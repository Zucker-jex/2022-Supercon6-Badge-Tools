
dist\default\production\Badge_firmware.production.elf:     file format elf32-pic30

Disassembly of section .ivt._ADC1Interrupt:

0000002e <.ivt._ADC1Interrupt>:
  2e:	b8 01 00    	nop       
Disassembly of section .ivt._AddressError:

00000006 <.ivt._AddressError>:
   6:	b8 01 00    	nop       
Disassembly of section .ivt._CCP1Interrupt:

00000092 <.ivt._CCP1Interrupt>:
  92:	b8 01 00    	nop       
Disassembly of section .ivt._CCP2Interrupt:

00000094 <.ivt._CCP2Interrupt>:
  94:	b8 01 00    	nop       
Disassembly of section .ivt._CCP3Interrupt:

000000d0 <__FSEC-0x2ae30>:
  d0:	b8 01 00    	nop       
Disassembly of section .ivt._CCP4Interrupt:

000000d2 <__FBSLIM-0x2ae3e>:
  d2:	b8 01 00    	nop       
Disassembly of section .ivt._CCT1Interrupt:

000000de <__FOSCSEL-0x2ae3a>:
  de:	b8 01 00    	nop       
Disassembly of section .ivt._CCT2Interrupt:

000000e0 <__FOSC-0x2ae3c>:
  e0:	b8 01 00    	nop       
Disassembly of section .ivt._CCT3Interrupt:

0000006a <__FWDT-0x2aeb6>:
  6a:	b8 01 00    	nop       
Disassembly of section .ivt._CCT4Interrupt:

0000006c <__FPOR-0x2aeb8>:
  6c:	b8 01 00    	nop       
Disassembly of section .ivt._CLC1Interrupt:

000000d4 <__FICD-0x2ae54>:
  d4:	b8 01 00    	nop       
Disassembly of section .ivt._CLC2Interrupt:

000000d6 <__FDEVOPT1-0x2ae56>:
  d6:	b8 01 00    	nop       
Disassembly of section .ivt._CRCInterrupt:

0000009a <.ivt._CRCInterrupt>:
  9a:	b8 01 00    	nop       
Disassembly of section .ivt._CTMUInterrupt:

000000ae <.ivt._CTMUInterrupt>:
  ae:	b8 01 00    	nop       
Disassembly of section .ivt._CompInterrupt:

00000038 <.ivt._CompInterrupt>:
  38:	b8 01 00    	nop       
Disassembly of section .ivt._DMA0Interrupt:

0000001c <.ivt._DMA0Interrupt>:
  1c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA1Interrupt:

00000030 <.ivt._DMA1Interrupt>:
  30:	b8 01 00    	nop       
Disassembly of section .ivt._DMA2Interrupt:

00000044 <.ivt._DMA2Interrupt>:
  44:	b8 01 00    	nop       
Disassembly of section .ivt._DMA3Interrupt:

0000005c <.ivt._DMA3Interrupt>:
  5c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA4Interrupt:

00000070 <.ivt._DMA4Interrupt>:
  70:	b8 01 00    	nop       
Disassembly of section .ivt._DMA5Interrupt:

0000008e <.ivt._DMA5Interrupt>:
  8e:	b8 01 00    	nop       
Disassembly of section .ivt._ECCInterrupt:

000000ec <.ivt._ECCInterrupt>:
  ec:	b8 01 00    	nop       
Disassembly of section .ivt._FSTInterrupt:

000000e8 <.ivt._FSTInterrupt>:
  e8:	b8 01 00    	nop       
Disassembly of section .ivt._GeneralError:

00000010 <.ivt._GeneralError>:
  10:	b8 01 00    	nop       
Disassembly of section .ivt._I2C1BCInterrupt:

000000bc <.ivt._I2C1BCInterrupt>:
  bc:	b8 01 00    	nop       
Disassembly of section .ivt._I2C2BCInterrupt:

000000be <.ivt._I2C2BCInterrupt>:
  be:	b8 01 00    	nop       
Disassembly of section .ivt._I2C3BCInterrupt:

000000ee <.ivt._I2C3BCInterrupt>:
  ee:	b8 01 00    	nop       
Disassembly of section .ivt._IC1Interrupt:

00000016 <.ivt._IC1Interrupt>:
  16:	b8 01 00    	nop       
Disassembly of section .ivt._IC2Interrupt:

0000001e <.ivt._IC2Interrupt>:
  1e:	b8 01 00    	nop       
Disassembly of section .ivt._IC3Interrupt:

0000005e <.ivt._IC3Interrupt>:
  5e:	b8 01 00    	nop       
Disassembly of section .ivt._INT0Interrupt:

00000014 <.ivt._INT0Interrupt>:
  14:	b8 01 00    	nop       
Disassembly of section .ivt._INT1Interrupt:

0000003c <.ivt._INT1Interrupt>:
  3c:	b8 01 00    	nop       
Disassembly of section .ivt._INT2Interrupt:

0000004e <.ivt._INT2Interrupt>:
  4e:	b8 01 00    	nop       
Disassembly of section .ivt._INT3Interrupt:

0000007e <.ivt._INT3Interrupt>:
  7e:	b8 01 00    	nop       
Disassembly of section .ivt._INT4Interrupt:

00000080 <.ivt._INT4Interrupt>:
  80:	b8 01 00    	nop       
Disassembly of section .ivt._IOCInterrupt:

0000003a <.ivt._IOCInterrupt>:
  3a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt100:

000000dc <.ivt._Interrupt100>:
  dc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt103:

000000e2 <.ivt._Interrupt103>:
  e2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt104:

000000e4 <.ivt._Interrupt104>:
  e4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt105:

000000e6 <.ivt._Interrupt105>:
  e6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt107:

000000ea <.ivt._Interrupt107>:
  ea:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt111:

000000f2 <.ivt._Interrupt111>:
  f2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt112:

000000f4 <.ivt._Interrupt112>:
  f4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt113:

000000f6 <.ivt._Interrupt113>:
  f6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt114:

000000f8 <.ivt._Interrupt114>:
  f8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt115:

000000fa <.ivt._Interrupt115>:
  fa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt116:

000000fc <.ivt._Interrupt116>:
  fc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt21:

0000003e <.ivt._Interrupt21>:
  3e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt22:

00000040 <.ivt._Interrupt22>:
  40:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt23:

00000042 <.ivt._Interrupt23>:
  42:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt26:

00000048 <.ivt._Interrupt26>:
  48:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt27:

0000004a <.ivt._Interrupt27>:
  4a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt28:

0000004c <.ivt._Interrupt28>:
  4c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt34:

00000058 <.ivt._Interrupt34>:
  58:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt35:

0000005a <.ivt._Interrupt35>:
  5a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt38:

00000060 <.ivt._Interrupt38>:
  60:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt39:

00000062 <.ivt._Interrupt39>:
  62:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt40:

00000064 <.ivt._Interrupt40>:
  64:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt47:

00000072 <.ivt._Interrupt47>:
  72:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt48:

00000074 <.ivt._Interrupt48>:
  74:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt51:

0000007a <.ivt._Interrupt51>:
  7a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt52:

0000007c <.ivt._Interrupt52>:
  7c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt55:

00000082 <.ivt._Interrupt55>:
  82:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt56:

00000084 <.ivt._Interrupt56>:
  84:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt57:

00000086 <.ivt._Interrupt57>:
  86:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt68:

0000009c <.ivt._Interrupt68>:
  9c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt69:

0000009e <.ivt._Interrupt69>:
  9e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt70:

000000a0 <.ivt._Interrupt70>:
  a0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt71:

000000a2 <.ivt._Interrupt71>:
  a2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt73:

000000a6 <.ivt._Interrupt73>:
  a6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt74:

000000a8 <.ivt._Interrupt74>:
  a8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt75:

000000aa <.ivt._Interrupt75>:
  aa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt76:

000000ac <.ivt._Interrupt76>:
  ac:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt78:

000000b0 <.ivt._Interrupt78>:
  b0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt79:

000000b2 <.ivt._Interrupt79>:
  b2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt80:

000000b4 <.ivt._Interrupt80>:
  b4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt81:

000000b6 <.ivt._Interrupt81>:
  b6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt82:

000000b8 <.ivt._Interrupt82>:
  b8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt83:

000000ba <.ivt._Interrupt83>:
  ba:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt86:

000000c0 <.ivt._Interrupt86>:
  c0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt87:

000000c2 <.ivt._Interrupt87>:
  c2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt88:

000000c4 <.ivt._Interrupt88>:
  c4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt89:

000000c6 <.ivt._Interrupt89>:
  c6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt92:

000000cc <.ivt._Interrupt92>:
  cc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt93:

000000ce <.ivt._Interrupt93>:
  ce:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt98:

000000d8 <.ivt._Interrupt98>:
  d8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt99:

000000da <.ivt._Interrupt99>:
  da:	b8 01 00    	nop       
Disassembly of section .ivt._JTAGInterrupt:

000000fe <.ivt._JTAGInterrupt>:
  fe:	b8 01 00    	nop       
Disassembly of section .ivt._LVDInterrupt:

000000a4 <.ivt._LVDInterrupt>:
  a4:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C1Interrupt:

00000036 <.ivt._MI2C1Interrupt>:
  36:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C2Interrupt:

00000078 <.ivt._MI2C2Interrupt>:
  78:	b8 01 00    	nop       
Disassembly of section .ivt._MathError:

0000000c <.ivt._MathError>:
   c:	b8 01 00    	nop       
Disassembly of section .ivt._NVMError:

00000008 <.ivt._NVMError>:
   8:	b8 01 00    	nop       
Disassembly of section .ivt._NVMInterrupt:

00000032 <.ivt._NVMInterrupt>:
  32:	b8 01 00    	nop       
Disassembly of section .ivt._OC1Interrupt:

00000018 <.ivt._OC1Interrupt>:
  18:	b8 01 00    	nop       
Disassembly of section .ivt._OC2Interrupt:

00000020 <.ivt._OC2Interrupt>:
  20:	b8 01 00    	nop       
Disassembly of section .ivt._OC3Interrupt:

00000046 <.ivt._OC3Interrupt>:
  46:	b8 01 00    	nop       
Disassembly of section .ivt._OC5Interrupt:

00000066 <.ivt._OC5Interrupt>:
  66:	b8 01 00    	nop       
Disassembly of section .ivt._OC6Interrupt:

00000068 <.ivt._OC6Interrupt>:
  68:	b8 01 00    	nop       
Disassembly of section .ivt._OscillatorFail:

00000004 <.ivt._OscillatorFail>:
   4:	b8 01 00    	nop       
Disassembly of section .ivt._PMPInterrupt:

0000006e <.ivt._PMPInterrupt>:
  6e:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCInterrupt:

00000090 <.ivt._RTCCInterrupt>:
  90:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCTSInterrupt:

000000f0 <.ivt._RTCCTSInterrupt>:
  f0:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap5:

0000000e <.ivt._ReservedTrap5>:
   e:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap7:

00000012 <.ivt._ReservedTrap7>:
  12:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C1Interrupt:

00000034 <.ivt._SI2C1Interrupt>:
  34:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C2Interrupt:

00000076 <.ivt._SI2C2Interrupt>:
  76:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1Interrupt:

00000026 <.ivt._SPI1Interrupt>:
  26:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1RXInterrupt:

00000088 <.ivt._SPI1RXInterrupt>:
  88:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1TXInterrupt:

00000028 <.ivt._SPI1TXInterrupt>:
  28:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2Interrupt:

00000054 <.ivt._SPI2Interrupt>:
  54:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2RXInterrupt:

0000008a <.ivt._SPI2RXInterrupt>:
  8a:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2TXInterrupt:

00000056 <.ivt._SPI2TXInterrupt>:
  56:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3Interrupt:

000000c8 <.ivt._SPI3Interrupt>:
  c8:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3RXInterrupt:

0000008c <.ivt._SPI3RXInterrupt>:
  8c:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3TXInterrupt:

000000ca <.ivt._SPI3TXInterrupt>:
  ca:	b8 01 00    	nop       
Disassembly of section .ivt._StackError:

0000000a <.ivt._StackError>:
   a:	b8 01 00    	nop       
Disassembly of section .ivt._T2Interrupt:

00000022 <.ivt._T2Interrupt>:
  22:	b8 01 00    	nop       
Disassembly of section .ivt._U1TXInterrupt:

0000002c <.ivt._U1TXInterrupt>:
  2c:	b8 01 00    	nop       
Disassembly of section .ivt._U2TXInterrupt:

00000052 <.ivt._U2TXInterrupt>:
  52:	b8 01 00    	nop       
Disassembly of section .reset:

00000000 <.reset>:
   0:	04 02 04    	goto      0x204 <__reset>
   2:	00 00 00 
Disassembly of section .text:

00000100 <__long_indirect_call>:
 100:	8a 1f 78    	mov.w     w10, [w15++]
 102:	8b 1f 78    	mov.w     w11, [w15++]
 104:	00 00 06    	return    

00000106 <__data_init>:
 106:	a1 02 88    	mov.w     w1, 0x54
 108:	80 04 78    	mov.w     w0, w9
 10a:	00 00 eb    	clr.w     w0
 10c:	1f 00 37    	bra       0x14c <L41>

0000010e <L11>:
 10e:	e2 84 44    	add.w     w9, #0x2, w9
 110:	54 a0 b4    	addc.w    0x54
 112:	99 05 ba    	tblrdl.w  [w9], w11
 114:	e2 84 44    	add.w     w9, #0x2, w9
 116:	54 a0 b4    	addc.w    0x54
 118:	99 06 ba    	tblrdl.w  [w9], w13
 11a:	e2 84 44    	add.w     w9, #0x2, w9
 11c:	54 a0 b4    	addc.w    0x54
 11e:	00 06 eb    	clr.w     w12
 120:	47 6f de    	lsr.w     w13, #0x7, w14
 122:	fd 07 b2    	and.w     #0x7f, w13
 124:	ae 01 88    	mov.w     w14, 0x34
 126:	63 6c e1    	cp.b      w13, #0x3
 128:	03 00 3a    	bra       NZ, 0x130 <L21>
 12a:	ea ff 07    	rcall     0x100 <__long_indirect_call>
 12c:	00 00 eb    	clr.w     w0
 12e:	0e 00 37    	bra       0x14c <L41>

00000130 <L21>:
 130:	60 6c e1    	cp.b      w13, #0x0
 132:	08 00 3a    	bra       NZ, 0x144 <L22>

00000134 <L91>:
 134:	00 4d eb    	clr.b     [w10]
 136:	0a 05 e8    	inc.w     w10, w10
 138:	02 00 39    	bra       NC, 0x13e <L81>
 13a:	34 20 ec    	inc.w     0x34
 13c:	0a f0 a0    	bset.w    w10, #0xf

0000013e <L81>:
 13e:	8b 05 e9    	dec.w     w11, w11
 140:	f9 ff 3e    	bra       GTU, 0x134 <L91>
 142:	04 00 37    	bra       0x14c <L41>

00000144 <L22>:
 144:	61 68 e1    	cp.w      w13, #0x1
 146:	01 00 32    	bra       Z, 0x14a <L31>
 148:	00 86 eb    	setm.w    w12

0000014a <L31>:
 14a:	0b 00 07    	rcall     0x162 <L13> <__memcpyd3extended>

0000014c <L41>:
 14c:	19 c7 ba    	tblrdh.b  [w9], w14
 14e:	19 05 ba    	tblrdl.w  [w9], w10
 150:	0e 04 e0    	cp0.b     w14
 152:	03 00 3a    	bra       NZ, 0x15a <L12>
 154:	0a 00 e0    	cp0.w     w10
 156:	db ff 3a    	bra       NZ, 0x10e <L11>
 158:	00 00 06    	return    

0000015a <L12>:
 15a:	fe 07 b2    	and.w     #0x7f, w14
 15c:	ae 02 88    	mov.w     w14, 0x54
 15e:	8a 04 78    	mov.w     w10, w9
 160:	f5 ff 37    	bra       0x14c <L41>

00000162 <L13>:
 162:	0c d0 a3    	btst.c    w12, #0xd
 164:	e2 0f 4d    	addc.w    w10, #0x2, [w15]
 166:	1c 00 39    	bra       NC, 0x1a0 <L23>
 168:	89 02 78    	mov.w     w9, w5
 16a:	35 4d ba    	tblrdl.b  [w5++], [w10]
 16c:	0a 05 e8    	inc.w     w10, w10
 16e:	02 00 39    	bra       NC, 0x174 <L32>
 170:	34 20 ec    	inc.w     0x34
 172:	0a f0 a0    	bset.w    w10, #0xf

00000174 <L32>:
 174:	8b 05 e9    	dec.w     w11, w11
 176:	0f 00 32    	bra       Z, 0x196 <L42>
 178:	25 4d ba    	tblrdl.b  [w5--], [w10]
 17a:	0a 05 e8    	inc.w     w10, w10
 17c:	02 00 39    	bra       NC, 0x182 <L33>
 17e:	34 20 ec    	inc.w     0x34
 180:	0a f0 a0    	bset.w    w10, #0xf

00000182 <L33>:
 182:	8b 05 e9    	dec.w     w11, w11
 184:	08 00 32    	bra       Z, 0x196 <L42>
 186:	0c 00 e0    	cp0.w     w12
 188:	06 00 32    	bra       Z, 0x196 <L42>
 18a:	15 cd ba    	tblrdh.b  [w5], [w10]
 18c:	0a 05 e8    	inc.w     w10, w10
 18e:	02 00 39    	bra       NC, 0x194 <L34>
 190:	34 20 ec    	inc.w     0x34
 192:	0a f0 a0    	bset.w    w10, #0xf

00000194 <L34>:
 194:	8b 05 e9    	dec.w     w11, w11

00000196 <L42>:
 196:	89 84 e8    	inc2.w    w9, w9
 198:	54 a0 b4    	addc.w    0x54
 19a:	0b 00 e0    	cp0.w     w11
 19c:	e2 ff 3a    	bra       NZ, 0x162 <L13> <__memcpyd3extended>
 19e:	00 00 06    	return    

000001a0 <L23>:
 1a0:	99 02 ba    	tblrdl.w  [w9], w5
 1a2:	05 5d 78    	mov.b     w5, [w10++]
 1a4:	8b 05 e9    	dec.w     w11, w11
 1a6:	f7 ff 32    	bra       Z, 0x196 <L42>
 1a8:	c8 2a de    	lsr.w     w5, #0x8, w5
 1aa:	05 5d 78    	mov.b     w5, [w10++]
 1ac:	8b 05 e9    	dec.w     w11, w11
 1ae:	f3 ff 32    	bra       Z, 0x196 <L42>
 1b0:	0c 00 e0    	cp0.w     w12
 1b2:	f1 ff 32    	bra       Z, 0x196 <L42>
 1b4:	19 dd ba    	tblrdh.b  [w9], [w10++]
 1b6:	ee ff 37    	bra       0x194 <L34>

000001b8 <__DefaultInterrupt>:
 1b8:	00 40 da    	break     
 1ba:	00 00 fe    	reset     

000001bc <__crt_start_mode>:
 1bc:	00 00 05    	retlw.w   #0x0, w0
Disassembly of section __FSEC:

0002af00 <__FSEC>:
   2af00:	f6 fe 00    	nop       
Disassembly of section __FBSLIM:

0002af10 <__FBSLIM>:
   2af10:	fd ff 00    	nop       
Disassembly of section __FOSCSEL:

0002af18 <__FOSCSEL>:
   2af18:	89 ff 00    	nop       
Disassembly of section __FOSC:

0002af1c <__FOSC>:
   2af1c:	e3 ff 00    	nop       
Disassembly of section __FWDT:

0002af20 <__FWDT>:
   2af20:	9f b7 00    	nop       
Disassembly of section __FPOR:

0002af24 <__FPOR>:
   2af24:	fc ff 00    	nop       
Disassembly of section __FICD:

0002af28 <__FICD>:
   2af28:	df ff 00    	nop       
Disassembly of section __FDEVOPT1:

0002af2c <__FDEVOPT1>:
   2af2c:	e7 ff 00    	nop       
Disassembly of section .ivt._T1Interrupt:

0000001a <.ivt._T1Interrupt>:
  1a:	10 10 00    	nop       
Disassembly of section .ivt._T3Interrupt:

00000024 <.ivt._T3Interrupt>:
  24:	14 10 00    	nop       
Disassembly of section .ivt._U1RXInterrupt:

0000002a <.ivt._U1RXInterrupt>:
  2a:	20 10 00    	nop       
Disassembly of section .ivt._U1ErrInterrupt:

00000096 <.ivt._U1ErrInterrupt>:
  96:	24 10 00    	nop       
Disassembly of section .ivt._U2RXInterrupt:

00000050 <.ivt._U2RXInterrupt>:
  50:	28 10 00    	nop       
Disassembly of section .ivt._U2ErrInterrupt:

00000098 <.ivt._U2ErrInterrupt>:
  98:	2c 10 00    	nop       
Disassembly of section .text:

000001be <.L0>:
     1be:	ff ff 00    	nop       
     1c0:	ff ff 00    	nop       
     1c2:	ff ff 00    	nop       
     1c4:	ff ff 00    	nop       
     1c6:	ff ff 00    	nop       
     1c8:	ff ff 00    	nop       
     1ca:	ff ff 00    	nop       
     1cc:	ff ff 00    	nop       
     1ce:	ff ff 00    	nop       
     1d0:	ff ff 00    	nop       
     1d2:	ff ff 00    	nop       
     1d4:	ff ff 00    	nop       
     1d6:	ff ff 00    	nop       
     1d8:	ff ff 00    	nop       
     1da:	ff ff 00    	nop       
     1dc:	ff ff 00    	nop       
     1de:	ff ff 00    	nop       
     1e0:	ff ff 00    	nop       
     1e2:	ff ff 00    	nop       
     1e4:	ff ff 00    	nop       
     1e6:	ff ff 00    	nop       
     1e8:	ff ff 00    	nop       
     1ea:	ff ff 00    	nop       
     1ec:	ff ff 00    	nop       
     1ee:	ff ff 00    	nop       
     1f0:	ff ff 00    	nop       
     1f2:	ff ff 00    	nop       
     1f4:	ff ff 00    	nop       
     1f6:	ff ff 00    	nop       
     1f8:	ff ff 00    	nop       
     1fa:	ff ff 00    	nop       
     1fc:	ff ff 00    	nop       
     1fe:	ff ff 00    	nop       
     200:	42 4f 00    	nop       
     202:	4f 54 00    	nop       

00000204 <__reset>:
; boot segment
	.ascii	"BOOT"		; boot segment start
.global __reset
__reset:
	mov	#STACK_START,w15
     204:	0f 70 24    	mov.w     #0x4700, w15
	mov	#STACK_END,w0
     206:	e0 7f 24    	mov.w     #0x47fe, w0
	mov	w0,SPLIM 		; Stack Pointer Limit
     208:	00 01 88    	mov.w     w0, 0x20
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	call	initialize
     20a:	3c 02 02    	call      0x23c <initialize>
     20c:	00 00 00 
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
;------------------------------------------ clear RAM
	mov	#0x800,w0
     20e:	00 80 20    	mov.w     #0x800, w0
	repeat	#0x400-1
     210:	ff 03 09    	repeat    #0x3ff
	xor	w2,[w0++],w2
     212:	30 01 69    	xor.w     w2, [w0++], w2
	mov	w2,w3
     214:	82 01 78    	mov.w     w2, w3
	repeat	#0x1C00-1
     216:	ff 1b 09    	repeat    #0x1bff
	xor	w3,[w0++],w3
     218:	b0 81 69    	xor.w     w3, [w0++], w3
	mov	#0x800,w1
     21a:	01 80 20    	mov.w     #0x800, w1
	repeat 	#0x2000-1	;total 0x4000=16K bytes
     21c:	ff 1f 09    	repeat    #0x1fff
	clr	[w1++]
     21e:	80 18 eb    	clr.w     [w1++]
	mov	w2,Rndlo	; initialize Rnd Seed
     220:	22 4e 88    	mov.w     w2, 0x9c4
	and	w2,#0x0F,w0
     222:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	Wreg,Ram+0xFF	; Write Rnd value
     224:	ff e8 b7    	mov.b     WREG, 0x8ff
	mov	w3,Rndhi	; initialize Rnd Seed
     226:	33 4e 88    	mov.w     w3, 0x9c6
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
; ini AutoOff
	mov	#2,w0		; 2×10 min autooff at hard reset
     228:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
     22a:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
     22c:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
     22e:	b0 4d 88    	mov.w     w0, 0x9b6
; ini dimmer
	mov	#15,w0
     230:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Dimmer
     232:	fe e8 b7    	mov.b     WREG, 0x8fe
; check if button ALT depressed (self check button)
	btsc	PORTA,#2	; PORTA,#2 = ALT key
     234:	64 46 af    	btsc.b    0x664, #0x2
	bra	selfcheck_back	; if ALT not pressed
     236:	fc 06 37    	bra       0x1030 <selfcheck_back>
	bra	boot_start
     238:	00 00 37    	bra       0x23a <boot_start>

0000023a <boot_start>:
;------------------------------------------------------------------------------------
;  NOTE: FIRMWARE IN THIS PAGE IS IN PROTECTED BOOT SEGMENT, AND CAN NOT BE MODIFIED 
;------------------------------------------------------------------------------------

boot_start:		bra	go_boot_start
     23a:	0e 00 37    	bra       0x258 <go_boot_start>

0000023c <initialize>:
initialize:		bra	boot_initialize
     23c:	91 01 37    	bra       0x560 <boot_initialize>

0000023e <set_decoder_to_w1>:
set_decoder_to_w1:	bra	boot_set_decoder_to_w1
     23e:	c4 01 37    	bra       0x5c8 <boot_set_decoder_to_w1>

00000240 <w0ms2>:
w0ms2:			bra	boot_w0ms2
     240:	e3 01 37    	bra       0x608 <boot_w0ms2>

00000242 <eecalc_addr_w0>:
eecalc_addr_w0:		bra	boot_eecalc_addr_w0
     242:	e7 01 37    	bra       0x612 <boot_eecalc_addr_w0>

00000244 <eesavew0>:
eesavew0:		bra	boot_eesavew0
     244:	f6 01 37    	bra       0x632 <boot_eesavew0>

00000246 <eeload>:
eeload:			bra	boot_eeload
     246:	25 02 37    	bra       0x692 <boot_eeload>

00000248 <eemeasure>:
eemeasure:		bra	boot_eemeasure
     248:	4e 02 37    	bra       0x6e6 <boot_eemeasure>

0000024a <eeburn_128>:
eeburn_128:		bra	boot_eeburn_128
     24a:	6b 02 37    	bra       0x722 <boot_eeburn_128>

0000024c <eeerase_1K>:
eeerase_1K:		bra	boot_eeerase_1K
     24c:	62 02 37    	bra       0x712 <boot_eeerase_1K>

0000024e <burn1k>:
burn1k:			bra	boot_burn1k
     24e:	98 02 37    	bra       0x780 <boot_burn1k>

00000250 <selfcheck>:
selfcheck:		bra	boot_selfcheck
     250:	24 00 37    	bra       0x29a <boot_selfcheck>

00000252 <bootload>:
bootload:		bra	boot_bootload
     252:	dd 00 37    	bra       0x40e <boot_bootload>

00000254 <key_save>:
key_save:		bra	boot_key_save
     254:	12 01 37    	bra       0x47a <boot_key_save>

00000256 <key_load>:
key_load:		bra	boot_key_load
     256:	37 01 37    	bra       0x4c6 <boot_key_load>

00000258 <go_boot_start>:

;------------------------------------------------------------------------
;--------------------     BOOT  START     -------------------------------
;------------------------------------------------------------------------

go_boot_start:
; **********************************************************************************	
; Note:											
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These	
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons,	
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and	
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every	
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second	
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.	
; **********************************************************************************	
; ALT pressed, initialize small debouncig area
	bclr	INTCON2,#GIE	; global interrupt disable
     258:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     25a:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     25c:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     25e:	84 e9 ef    	setm.b    0x984
; Check if some other key excl. Save and Load pressed (if so, don't allow spec mode)
	mov	#7,w1		; 7 = here are keys OperY1 and DataIn
     260:	71 00 20    	mov.w     #0x7, w1
	  call	  set_decoder_to_w1
     262:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     264:	00 00 00 
	btss	PORTA,#3
     266:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if OperY 1 pressed
     268:	e3 06 37    	bra       0x1030 <selfcheck_back>
	btss	PORTA,#4
     26a:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if DataIn pressed
     26c:	e1 06 37    	bra       0x1030 <selfcheck_back>
	  call	  set_decoder_to_w1
     26e:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     270:	00 00 00 
	btss	PORTA,#3
     272:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Mode pressed
     274:	dd 06 37    	bra       0x1030 <selfcheck_back>
	btss	PORTA,#4
     276:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Carry pressed
     278:	db 06 37    	bra       0x1030 <selfcheck_back>
	  call	  set_decoder_to_w1
     27a:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     27c:	00 00 00 
	btss	PORTA,#3
     27e:	64 66 ae    	btss.b    0x664, #0x3
	bra	key_save	; if Save pressed -----------> SAVE
     280:	e9 ff 37    	bra       0x254 <key_save>
	btss	PORTA,#4
     282:	64 86 ae    	btss.b    0x664, #0x4
	bra	key_load	; if Load pressed -----------> LOAD
     284:	e8 ff 37    	bra       0x256 <key_load>

	mov	#6,w2		; w2 loop count
     286:	62 00 20    	mov.w     #0x6, w2

00000288 <L61>:
6:			; \
	  call	  set_decoder_to_w1
     288:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     28a:	00 00 00 
	btss	PORTA,#3
     28c:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Clock, Opcode4, etc... pressed
     28e:	d0 06 37    	bra       0x1030 <selfcheck_back>
	btss	PORTA,#4
     290:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Opcode8, Opcode2, etc... pressed
     292:	ce 06 37    	bra       0x1030 <selfcheck_back>
	dec	w2,w2
     294:	02 01 e9    	dec.w     w2, w2
	bra	nz,6b	; /
     296:	f8 ff 3a    	bra       NZ, 0x288 <L61>
	bra	selfcheck	; if ALT only pressed
     298:	db ff 37    	bra       0x250 <selfcheck>

0000029a <boot_selfcheck>:

; ----------------------------------------------------------------------
; -----------------------  S E L F   C H E C K  ------------------------
; ----------------------------------------------------------------------
boot_selfcheck:
	mov	#5,w0
     29a:	50 00 20    	mov.w     #0x5, w0
	mov	w0,Mode
     29c:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#3		; #3 self-check mode
     29e:	dc 69 a8    	bset.b    0x9dc, #0x3

	clr	TMR1
     2a0:	90 21 ef    	clr.w     0x190
	bset	T1CON,#TON	; LED multiplex timer on
     2a2:	95 e1 a8    	bset.b    0x195, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
     2a4:	98 60 a8    	bset.b    0x98, #0x3
	bset	INTCON2,#GIE	; global int enable
     2a6:	83 e0 a8    	bset.b    0x83, #0x7
; initialize pixels for self check
	mov	#0b0100100100100100,w0
     2a8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Column1
     2aa:	40 4e 88    	mov.w     w0, 0x9c8
	mov	#0b0010010010010010,w0
     2ac:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Column2
     2ae:	50 4e 88    	mov.w     w0, 0x9ca
	mov	#0b1001001001001001,w0
     2b0:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Column3
     2b2:	60 4e 88    	mov.w     w0, 0x9cc
	mov	#0b0010010010010010,w0
     2b4:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row3
     2b6:	70 4e 88    	mov.w     w0, 0x9ce
	mov	#0b0100100100100100,w0
     2b8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row4
     2ba:	80 4e 88    	mov.w     w0, 0x9d0
	mov	#0b0010010010010010,w0
     2bc:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row5
     2be:	90 4e 88    	mov.w     w0, 0x9d2
	mov	#0b0100100100100100,w0
     2c0:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row6
     2c2:	a0 4e 88    	mov.w     w0, 0x9d4
	mov	#0b1001001001001001,w0
     2c4:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Row7
     2c6:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b1001001001001001,w0
     2c8:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,A16
     2ca:	70 4d 88    	mov.w     w0, 0x9ae

	mov	#0b010000001001,w0
     2cc:	90 40 20    	mov.w     #0x409, w0
	mov	w0,Ram+0
     2ce:	00 40 88    	mov.w     w0, 0x800
	mov	w0,Ram+6
     2d0:	30 40 88    	mov.w     w0, 0x806
	mov	w0,Ram+12
     2d2:	60 40 88    	mov.w     w0, 0x80c
	mov	w0,Ram+18
     2d4:	90 40 88    	mov.w     w0, 0x812
	mov	w0,Ram+24
     2d6:	c0 40 88    	mov.w     w0, 0x818
	mov	w0,Ram+30
     2d8:	f0 40 88    	mov.w     w0, 0x81e
	mov	#0b100100000010,w0
     2da:	20 90 20    	mov.w     #0x902, w0
	mov	w0,Ram+2
     2dc:	10 40 88    	mov.w     w0, 0x802
	mov	w0,Ram+8
     2de:	40 40 88    	mov.w     w0, 0x808
	mov	w0,Ram+14
     2e0:	70 40 88    	mov.w     w0, 0x80e
	mov	w0,Ram+20
     2e2:	a0 40 88    	mov.w     w0, 0x814
	mov	w0,Ram+26
     2e4:	d0 40 88    	mov.w     w0, 0x81a
	mov	#0b001000000100,w0
     2e6:	40 20 20    	mov.w     #0x204, w0
	mov	w0,Ram+4
     2e8:	20 40 88    	mov.w     w0, 0x804
	mov	w0,Ram+10
     2ea:	50 40 88    	mov.w     w0, 0x80a
	mov	w0,Ram+16
     2ec:	80 40 88    	mov.w     w0, 0x810
	mov	w0,Ram+22
     2ee:	b0 40 88    	mov.w     w0, 0x816
	mov	w0,Ram+28
     2f0:	e0 40 88    	mov.w     w0, 0x81c

000002f2 <self_check_loop>:
self_check_loop:
; STEP 1: WAIT ---------
	mov	BlinkCount,w0
     2f2:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x03FF,w0
     2f4:	f0 3f b2    	and.w     #0x3ff, w0
	bra	nz,self_check_loop
     2f6:	fd ff 3a    	bra       NZ, 0x2f2 <self_check_loop>

; STEP 2: SHIFT --------
.macro	rotate	variab,if,then
	lsr	\variab
	btsc	\variab,#\if
	bset	\variab,#\then
.endm
	rotate	Column1,0,15
     2f8:	c8 29 d5    	lsr.w     0x9c8
     2fa:	c8 09 af    	btsc.b    0x9c8, #0x0
     2fc:	c9 e9 a8    	bset.b    0x9c9, #0x7
	rotate	Column2,0,15
     2fe:	ca 29 d5    	lsr.w     0x9ca
     300:	ca 09 af    	btsc.b    0x9ca, #0x0
     302:	cb e9 a8    	bset.b    0x9cb, #0x7
	rotate	Column3,0,15
     304:	cc 29 d5    	lsr.w     0x9cc
     306:	cc 09 af    	btsc.b    0x9cc, #0x0
     308:	cd e9 a8    	bset.b    0x9cd, #0x7
	rotate	Row3,0,15
     30a:	ce 29 d5    	lsr.w     0x9ce
     30c:	ce 09 af    	btsc.b    0x9ce, #0x0
     30e:	cf e9 a8    	bset.b    0x9cf, #0x7
	rotate	Row4,0,15
     310:	d0 29 d5    	lsr.w     0x9d0
     312:	d0 09 af    	btsc.b    0x9d0, #0x0
     314:	d1 e9 a8    	bset.b    0x9d1, #0x7
	rotate	Row5,0,15
     316:	d2 29 d5    	lsr.w     0x9d2
     318:	d2 09 af    	btsc.b    0x9d2, #0x0
     31a:	d3 e9 a8    	bset.b    0x9d3, #0x7
	rotate	Row6,0,15
     31c:	d4 29 d5    	lsr.w     0x9d4
     31e:	d4 09 af    	btsc.b    0x9d4, #0x0
     320:	d5 e9 a8    	bset.b    0x9d5, #0x7
	rotate	Row7,0,15
     322:	d6 29 d5    	lsr.w     0x9d6
     324:	d6 09 af    	btsc.b    0x9d6, #0x0
     326:	d7 e9 a8    	bset.b    0x9d7, #0x7
	rotate	A16,6,15
     328:	ae 29 d5    	lsr.w     0x9ae
     32a:	ae c9 af    	btsc.b    0x9ae, #0x6
     32c:	af e9 a8    	bset.b    0x9af, #0x7
	bclr	A16,#2
     32e:	ae 49 a9    	bclr.b    0x9ae, #0x2
	btsc	A16,#12
     330:	af 89 af    	btsc.b    0x9af, #0x4
	bset	A16,#2
     332:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	rotate_ram
     334:	d4 05 02    	call      0x5d4 <rotate_ram>
     336:	00 00 00 

; any key pressed?
	btss	Flag,#1		; #1 handshaking flag for buttons
     338:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	self_check_loop	; no, loop ------------------------->
     33a:	db ff 37    	bra       0x2f2 <self_check_loop>

	setm	Column1
     33c:	c8 a9 ef    	setm.w    0x9c8
	setm	Column2
     33e:	ca a9 ef    	setm.w    0x9ca
	setm	Column3
     340:	cc a9 ef    	setm.w    0x9cc
	setm	Row3
     342:	ce a9 ef    	setm.w    0x9ce
	setm	Row4
     344:	d0 a9 ef    	setm.w    0x9d0
	setm	Row5
     346:	d2 a9 ef    	setm.w    0x9d2
	setm	Row6
     348:	d4 a9 ef    	setm.w    0x9d4
	mov	#0b1111000000000000,w0
     34a:	00 00 2f    	mov.w     #0xf000, w0
	mov	w0,Row7
     34c:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b0000000001111011,w0
     34e:	b0 07 20    	mov.w     #0x7b, w0
	mov	w0,A16
     350:	70 4d 88    	mov.w     w0, 0x9ae

00000352 <wait_still>:
wait_still:
; test if ASCII "BL"
	mov	Row7,w0
     352:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     354:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     356:	01 00 60    	and.w     w0, w1, w0
	mov	#0x024C,w1	; ASCII BL = 0x424C
     358:	c1 24 20    	mov.w     #0x24c, w1
	cp	w0,w1
     35a:	01 00 e1    	cp.w      w0, w1
	bra	nz,not_BL
     35c:	1a 00 3a    	bra       NZ, 0x392 <L11> <not_BL>
	btsc	A16,#b_carry	; carry   = bit 7 (should be 0)
     35e:	af 89 af    	btsc.b    0x9af, #0x4
	bra	not_BL
     360:	18 00 37    	bra       0x392 <L11> <not_BL>
	btss	A16,#b_save	; save    = bit 6 (should be 1)
     362:	af a9 ae    	btss.b    0x9af, #0x5
	bra	not_BL
     364:	16 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_load	; load    = bit 5 (should be 0)
     366:	af c9 af    	btsc.b    0x9af, #0x6
	bra	not_BL
     368:	14 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_clk_key	; clk_key = bit 4 (should be 0)
     36a:	ae 49 af    	btsc.b    0x9ae, #0x2
	bra	not_BL
     36c:	12 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_alu	; Mode field LEDs off?
     36e:	af 69 af    	btsc.b    0x9af, #0x3
	bra	not_BL
     370:	10 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_bin	; Data_In field LEDs off?
     372:	af e9 af    	btsc.b    0x9af, #0x7
	bra	not_BL
     374:	0e 00 37    	bra       0x392 <L11> <not_BL>

	clr	Column1
     376:	c8 29 ef    	clr.w     0x9c8
	clr	Column2
     378:	ca 29 ef    	clr.w     0x9ca
	clr	Column3
     37a:	cc 29 ef    	clr.w     0x9cc
	clr	Row3
     37c:	ce 29 ef    	clr.w     0x9ce
	clr	Row4
     37e:	d0 29 ef    	clr.w     0x9d0
	clr	Row5
     380:	d2 29 ef    	clr.w     0x9d2
	clr	Row6
     382:	d4 29 ef    	clr.w     0x9d4
	clr	Row7
     384:	d6 29 ef    	clr.w     0x9d6
	mov	#Ram,w0		; clr_ram
     386:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clr_ram (clear all exept SFR)
     388:	77 00 09    	repeat    #0x77
	clr	[w0++]		; clr_ram
     38a:	00 18 eb    	clr.w     [w0++]
	mov	#0b0110000000000000,w0	; only SAVE and LOAD are ON
     38c:	00 00 26    	mov.w     #0x6000, w0
	mov	w0,A16
     38e:	70 4d 88    	mov.w     w0, 0x9ae
	bra	bootload	; BOOTLOAD ------------------->
     390:	60 ff 37    	bra       0x252 <bootload>

00000392 <L11>:
not_BL:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
     392:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b		; no, loop ------------------------->
     394:	fe ff 37    	bra       0x392 <L11> <not_BL>
	bclr	Flag,#1		; #1 handshaking flag for buttons
     396:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	rotate_ram
     398:	d4 05 02    	call      0x5d4 <rotate_ram>
     39a:	00 00 00 
.macro		ct1	valct1
		mov	#0b\valct1,w0
		bra	cont_test1
.endm
.macro		ct2	valct2
		mov	#0b\valct2,w0
		bra	cont_test2
.endm
	mov	Just,w0
     39c:	30 4d 80    	mov.w     0x9a6, w0
	sl	w0,w0		; ×2
     39e:	00 00 d0    	sl.w      w0, w0
	bra	w0
     3a0:	00 60 01    	bra       w0
; ...
	ct1	0000111100000000	 ; mode
     3a2:	00 f0 20    	mov.w     #0xf00, w0
     3a4:	22 00 37    	bra       0x3ea <cont_test1>
	ct1	0001000000000000	 ; carry
     3a6:	00 00 21    	mov.w     #0x1000, w0
     3a8:	20 00 37    	bra       0x3ea <cont_test1>
	ct1	0010000000000000	 ; save
     3aa:	00 00 22    	mov.w     #0x2000, w0
     3ac:	1e 00 37    	bra       0x3ea <cont_test1>
	ct1	0100000000000000	 ; load
     3ae:	00 00 24    	mov.w     #0x4000, w0
     3b0:	1c 00 37    	bra       0x3ea <cont_test1>
	ct1	0000000000000100	 ; clock
     3b2:	40 00 20    	mov.w     #0x4, w0
     3b4:	1a 00 37    	bra       0x3ea <cont_test1>
	ct2	0000100000000000	 ; opcode 8
     3b6:	00 80 20    	mov.w     #0x800, w0
     3b8:	1a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000010000000000	 ; opcode 4
     3ba:	00 40 20    	mov.w     #0x400, w0
     3bc:	18 00 37    	bra       0x3ee <cont_test2>
	ct2	0000001000000000	 ; opcode 2
     3be:	00 20 20    	mov.w     #0x200, w0
     3c0:	16 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000100000000	 ; opcode 1
     3c2:	00 10 20    	mov.w     #0x100, w0
     3c4:	14 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000010000000	 ; oper X 8
     3c6:	00 08 20    	mov.w     #0x80, w0
     3c8:	12 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000001000000	 ; oper X 4
     3ca:	00 04 20    	mov.w     #0x40, w0
     3cc:	10 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000100000	 ; oper X 2
     3ce:	00 02 20    	mov.w     #0x20, w0
     3d0:	0e 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000010000	 ; oper X 1
     3d2:	00 01 20    	mov.w     #0x10, w0
     3d4:	0c 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000001000	 ; oper Y 8
     3d6:	80 00 20    	mov.w     #0x8, w0
     3d8:	0a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000100	 ; oper Y 4
     3da:	40 00 20    	mov.w     #0x4, w0
     3dc:	08 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000010	 ; oper Y 2
     3de:	20 00 20    	mov.w     #0x2, w0
     3e0:	06 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000001	 ; oper Y 1
     3e2:	10 00 20    	mov.w     #0x1, w0
     3e4:	04 00 37    	bra       0x3ee <cont_test2>
	ct1	1000000010000000	 ; DataIn 
     3e6:	00 08 28    	mov.w     #0x8080, w0
     3e8:	00 00 37    	bra       0x3ea <cont_test1>

000003ea <cont_test1>:
cont_test1:
	xor	A16
     3ea:	ae a9 b6    	xor.w     0x9ae
	bra	ctx
     3ec:	01 00 37    	bra       0x3f0 <ctx>

000003ee <cont_test2>:
cont_test2:
	xor	Row7
     3ee:	d6 a9 b6    	xor.w     0x9d6

000003f0 <ctx>:
ctx:
	mov	Row7,w0
     3f0:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     3f2:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     3f4:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     3f6:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     3f8:	ac ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	A16,w0
     3fa:	70 4d 80    	mov.w     0x9ae, w0
	mov	#0b1111111110000100,w1
     3fc:	41 f8 2f    	mov.w     #0xff84, w1
	and	w0,w1,w0
     3fe:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     400:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     402:	a7 ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	#-2000,w0	; count 2000 = 500 ms
     404:	00 83 2f    	mov.w     #0xf830, w0
	mov	w0,BlinkCount
     406:	e0 4b 88    	mov.w     w0, 0x97c

00000408 <wait_Xs>:
wait_Xs:
	cp0	BlinkCount
     408:	7c 09 e2    	cp0.w     0x97c
	bra	nz,wait_Xs
     40a:	fe ff 3a    	bra       NZ, 0x408 <wait_Xs>
	reset
     40c:	00 00 fe    	reset     

0000040e <boot_bootload>:

;-----------------------------------------------------------------------------
;------------------------- BOOTLOAD ------------------------------------------
;-----------------------------------------------------------------------------

boot_bootload:
	bclr	INTCON2,#GIE	; global interrupt disable
     40e:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     410:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     412:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     414:	84 e9 ef    	setm.b    0x984

00000416 <L12>:
1:
	clr.b	LATC		; all LEDS off
     416:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     418:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode driver off
     41a:	8f 06 a9    	bclr.b    0x68f, #0x0
; led SAVE on
	mov	#0b1111100001111111,w0
     41c:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     41e:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     420:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     422:	66 26 b7    	ior.w     0x666
	bset	LATC,#8		; anode 17 on
     424:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000		; ON time 0.5 ms
     426:	40 1f 09    	repeat    #0x1f40
	nop
     428:	00 00 00    	nop       
; led LOAD on
	mov	#0b1111100001111111,w0
     42a:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     42c:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     42e:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     430:	66 26 b7    	ior.w     0x666
	repeat	#8000		; ON time 0.5 ms
     432:	40 1f 09    	repeat    #0x1f40
	nop
     434:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     436:	8f 06 a9    	bclr.b    0x68f, #0x0
; set decoder output 0 and wait 2 ms
	mov	#0b1111100001111111,w0
     438:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     43a:	66 26 b6    	and.w     0x666
	mov	#0b0000010000000000,w0	; 8 = buttons MODE and CARRY
     43c:	00 40 20    	mov.w     #0x400, w0
	ior	LATA		; decoder state = 8 (there is key MODE)
     43e:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     440:	80 3e 09    	repeat    #0x3e80
	nop
     442:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     444:	80 3e 09    	repeat    #0x3e80
	nop
     446:	00 00 00    	nop       
; debounce and test key MODE
	sl.b	KeyRotors+0
     448:	7e 69 d4    	sl.b      0x97e
	btsc	PORTA,#3
     44a:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+0,#0
     44c:	7e 09 a8    	bset.b    0x97e, #0x0
	ifz
     44e:	42 20 af    	btsc.b    0x42, #0x1
	reset			; if MODE pressed then suicide
     450:	00 00 fe    	reset     
; set decoder output 1 and wait 2 ms
	mov	#0b1111100001111111,w0
     452:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     454:	66 26 b6    	and.w     0x666
	mov	#0b0000010010000000,w0	; 9 = buttons SAVE and LOAD
     456:	00 48 20    	mov.w     #0x480, w0
	ior	LATA		; decoder state = 9 (there are keys SAVE and LOAD)
     458:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     45a:	80 3e 09    	repeat    #0x3e80
	nop
     45c:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     45e:	80 3e 09    	repeat    #0x3e80
	nop
     460:	00 00 00    	nop       
; debounce and test key SAVE
	sl.b	KeyRotors+4
     462:	82 69 d4    	sl.b      0x982
	btsc	PORTA,#3
     464:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+4,#0
     466:	82 09 a8    	bset.b    0x982, #0x0
;	bra	z,key_save	; if SAVE pressed  (* THIS FUNCTION CANCELED *)
; debounce and test key LOAD
	sl.b	KeyRotors+6
     468:	84 69 d4    	sl.b      0x984
	btsc	PORTA,#4
     46a:	64 86 af    	btsc.b    0x664, #0x4
	bset.b	KeyRotors+6,#0
     46c:	84 09 a8    	bset.b    0x984, #0x0
	bra	z,key_load	; if LOAD pressed
     46e:	f3 fe 32    	bra       Z, 0x256 <key_load>
; wait 2 ms and loop 
	repeat	#16000		; 1 ms
     470:	80 3e 09    	repeat    #0x3e80
	nop
     472:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     474:	80 3e 09    	repeat    #0x3e80
	nop
     476:	00 00 00    	nop       
	bra	1b
     478:	ce ff 37    	bra       0x416 <L12>

0000047a <boot_key_save>:

;--------------------------------------------------------------
boot_key_save:



; debounce (DO NOTHING) RESET signal 2 sec first
	btsc	Flag2,#9	; #9 set = last command LOAD
     47a:	df 29 af    	btsc.b    0x9df, #0x1
	bra	6f		; no debouncer for LOAD
     47c:	0e 00 37    	bra       0x49a <L62>

	mov	#0b1111100001111111,w0
     47e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     480:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     482:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     484:	66 26 b7    	ior.w     0x666

	mov	#20,w1		; 2 sec debouncing (doing nothing, just blinking
     486:	41 01 20    	mov.w     #0x14, w1

00000488 <L13>:
1:
	bset	LATC,#8		; anode 17 on
     488:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000-1		; led SAVE ON time	
     48a:	3f 1f 09    	repeat    #0x1f3f
	nop
     48c:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     48e:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#80,w0		; led SAVE OFF timen 80 ms
     490:	00 05 20    	mov.w     #0x50, w0
	call	w0ms2
     492:	40 02 02    	call      0x240 <w0ms2>
     494:	00 00 00 

	dec	w1,w1
     496:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
     498:	f7 ff 3a    	bra       NZ, 0x488 <L13>

0000049a <L62>:
6:
; GO ON BOOT KEY_SAVE









	bset	Flag2,#6	; #6 EE pointers adjust to Boot
     49a:	de c9 a8    	bset.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load/save to/from the first half of Rom area
     49c:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
     49e:	df 29 a9    	bclr.b    0x9df, #0x1
	clr	w10		; w10 Flash Page, step 0x800
     4a0:	00 05 eb    	clr.w     w10

000004a2 <L91>:
9:			  ; \
	mov	w10,w0
     4a2:	0a 00 78    	mov.w     w10, w0
	call	eeload		; firmware 1 ---> Rom 1 (3K bytes + 1K dummy 0's)
     4a4:	46 02 02    	call      0x246 <eeload>
     4a6:	00 00 00 
	add	w10,#24,w0
     4a8:	78 00 45    	add.w     w10, #0x18, w0
	bset	Flag2,#7	; #7 EE load to second halve of Rom area
     4aa:	de e9 a8    	bset.b    0x9de, #0x7
	call	eeload		; firmware 2 ---> Rom 2 (3K bytes + 1K dummy 0's)
     4ac:	46 02 02    	call      0x246 <eeload>
     4ae:	00 00 00 

	mov	w10,w0
     4b0:	0a 00 78    	mov.w     w10, w0
	call	eesavew0	; Rom 2 ---> firmware 1 (3K bytes + 1K dummy 0's)
     4b2:	44 02 02    	call      0x244 <eesavew0>
     4b4:	00 00 00 
	add	w10,#24,w0
     4b6:	78 00 45    	add.w     w10, #0x18, w0
	bclr	Flag2,#7	; #7 EE save from first halve of Rom area
     4b8:	de e9 a9    	bclr.b    0x9de, #0x7
	call	eesavew0	; Rom 1 ---> firmware 2 (3K bytes + 1K dummy 0's)
     4ba:	44 02 02    	call      0x244 <eesavew0>
     4bc:	00 00 00 

	inc	w10,w10
     4be:	0a 05 e8    	inc.w     w10, w10
	cp	w10,#24
     4c0:	78 50 e1    	cp.w      w10, #0x18
	bra	nc,9b	  ;  /
     4c2:	ef ff 39    	bra       NC, 0x4a2 <L91>
	bra	bootload
     4c4:	c6 fe 37    	bra       0x252 <bootload>

000004c6 <boot_key_load>:

;--------------------------------------------------------------
boot_key_load:
	bset	Flag2,#6	; #6 EE subroutines adjust to Boot
     4c6:	de c9 a8    	bset.b    0x9de, #0x6
	bset	Flag2,#7	; #7 EE burn from 2nd halve of Rom area (start @ 0x3000)
     4c8:	de e9 a8    	bset.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
     4ca:	df 29 a8    	bset.b    0x9df, #0x1

; ------------------------------- DMA ------------------------------
; initialize DMA 0
	mov	#0b0000000000000000,w0	; Disabled, Fixed Priority
     4cc:	00 00 20    	mov.w     #0x0, w0
	mov	w0,DMACON		; Bit 15 = DMAEN (DMA Enable)
     4ce:	20 26 88    	mov.w     w0, 0x4c4
	mov	#0b0000001000010110,w0	; reload, SRC fixed, DST++, one-shot, byte mode
     4d0:	60 21 20    	mov.w     #0x216, w0
	mov	w0,DMACH0		; Bit 0: CHEN (Channel Enable)
     4d2:	60 26 88    	mov.w     w0, 0x4cc
	mov	#0b0100010100000000,w0	; Source is UART1 RX Interrupt
     4d4:	00 50 24    	mov.w     #0x4500, w0
	mov	w0,DMAINT0
     4d6:	70 26 88    	mov.w     w0, 0x4ce
	mov	#Rom,w0
     4d8:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMAL		; low limit
     4da:	40 26 88    	mov.w     w0, 0x4c8
	mov	#Rom+0x2000,w0
     4dc:	00 00 24    	mov.w     #0x4000, w0
	mov	w0,DMAH		; high limit
     4de:	50 26 88    	mov.w     w0, 0x4ca
	mov	#U1RXREG,w0
     4e0:	e0 39 20    	mov.w     #0x39e, w0
	mov	w0,DMASRC0	; Source address
     4e2:	80 26 88    	mov.w     w0, 0x4d0
	mov	#Rom,w0
     4e4:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMADST0	; Destination start address
     4e6:	90 26 88    	mov.w     w0, 0x4d2
	mov	#4096,w0
     4e8:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,DMACNT0	; RX block format (1024 instructions)
     4ea:	a0 26 88    	mov.w     w0, 0x4d4
	bset	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     4ec:	c5 e4 a8    	bset.b    0x4c5, #0x7
	bset	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     4ee:	cc 04 a8    	bset.b    0x4cc, #0x0
; initialize peripheral hardware and variables
	bclr	IEC0,#11	; disable RX1 interrupt
     4f0:	99 60 a9    	bclr.b    0x99, #0x3
	call	boot_rxtx_to_io2; RxTx directed to IO connector
     4f2:	ee 05 02    	call      0x5ee <boot_rxtx_to_io2>
     4f4:	00 00 00 
	mov	#0b1111100001111111,w0
     4f6:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     4f8:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     4fa:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     4fc:	66 26 b7    	ior.w     0x666
	clr	w8		; w8 = blink count (#4,#1) about 18 Hz (1 Hz, 8 Hz)
     4fe:	00 04 eb    	clr.w     w8
	mov	DMADST0,w14	; w14 = previous DMADST0
     500:	9e 26 80    	mov.w     0x4d2, w14
	mov	#50000,w13	; w13 = "DMADST changed" counter (0 when no RX data)
     502:	0d 35 2c    	mov.w     #0xc350, w13
	mov	#Rom,w0
     504:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1
     506:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve of Rom to 0xFFFF
     508:	00 98 eb    	setm.w    [w0++]
	mov	#0,w11		; Page burn pointer (×0x800)
     50a:	0b 00 20    	mov.w     #0x0, w11
; main BOOT loop
	mov	#23,w12		; max number of 4K packets (+1 non-complete at end)
     50c:	7c 01 20    	mov.w     #0x17, w12

0000050e <BootLoop>:
BootLoop:		 ; <------------------------------ bootload loop ~20t
	nop
     50e:	00 00 00    	nop       
; test if byte received (in that case set Flag2,#10 and initialize w13 counter)
	mov	DMADST0,w0	; Destination address
     510:	90 26 80    	mov.w     0x4d2, w0
	cp	w0,w14
     512:	0e 00 e1    	cp.w      w0, w14
	bra	z,equal_dst	; if byte not received in this cycle
     514:	03 00 32    	bra       Z, 0x51c <equal_dst>
; byte received, set Flag2,#10 and initialize w13 counter (patience meter)
	bset	Flag2,#10	; #8 set = 1st byte in Bootloader received
     516:	df 49 a8    	bset.b    0x9df, #0x2
	mov	w0,w14		; refresh previous DMADST0
     518:	00 07 78    	mov.w     w0, w14
	mov	#50000,w13
     51a:	0d 35 2c    	mov.w     #0xc350, w13

0000051c <equal_dst>:
equal_dst:
	btss	Flag2,#10	; #8 set = 1st byte in Bootloader received
     51c:	df 49 ae    	btss.b    0x9df, #0x2
	bra	noRXdata	; if no bytes received yet
     51e:	02 00 37    	bra       0x524 <noRXdata>
	dec	w13,w13		; patience counter
     520:	8d 06 e9    	dec.w     w13, w13
	bra	z,bl_lost_patience ; if end of reception (pause detected)
     522:	18 00 32    	bra       Z, 0x554 <bl_lost_patience>

00000524 <noRXdata>:
noRXdata:
	inc	w9,w9		; fast counter
     524:	89 04 e8    	inc.w     w9, w9
	ifz
     526:	42 20 af    	btsc.b    0x42, #0x1
	inc	w8,w8		; slow counter
     528:	08 04 e8    	inc.w     w8, w8
; fast or slow blinking
	mov	#0b0000000011110000,w0
     52a:	00 0f 20    	mov.w     #0xf0, w0
	and	w0,w9,w0
     52c:	09 00 60    	and.w     w0, w9, w0
	bra	nz,9f		; 15 of 16 cycles
     52e:	09 00 3a    	bra       NZ, 0x542 <L92>
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     530:	df 49 af    	btsc.b    0x9df, #0x2
	bra	2f		; if not 1st cycle (1st byte was received)
     532:	03 00 37    	bra       0x53a <L21>
	btss	w8,#3		; bit #4 (slow blinking)
     534:	08 30 a6    	btss.w    w8, #0x3
	bra	8f
     536:	03 00 37    	bra       0x53e <L81>
	bra	7f
     538:	05 00 37    	bra       0x544 <L71>

0000053a <L21>:
2:
	btss	w8,#0		; bit #1 (fast blinking)
     53a:	08 00 a6    	btss.w    w8, #0x0
	bra	9f
     53c:	02 00 37    	bra       0x542 <L92>

0000053e <L81>:
8:
	bset	LATC,#8		; LED LOAD on (1/16 duty cycle)
     53e:	8f 06 a8    	bset.b    0x68f, #0x0
	bra	7f
     540:	01 00 37    	bra       0x544 <L71>

00000542 <L92>:
9:
	bclr	LATC,#8		; LED LOAD off (15/16 duty cycle)
     542:	8f 06 a9    	bclr.b    0x68f, #0x0

00000544 <L71>:
7:
	btss	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     544:	ce a4 ae    	btss.b    0x4ce, #0x5
	bra	BootLoop ; ------------------------------> bootload loop
     546:	e3 ff 37    	bra       0x50e <BootLoop>
; Operation Completed, 1st halve of Rom received 4K bytes via UART
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     548:	ce a4 a9    	bclr.b    0x4ce, #0x5
	dec	w12,w12
     54a:	0c 06 e9    	dec.w     w12, w12
	bra	z,bl_lost_patience ; number of received bytes overflow
     54c:	03 00 32    	bra       Z, 0x554 <bl_lost_patience>
	call	burn1k		; burn 1 K block received
     54e:	4e 02 02    	call      0x24e <burn1k>
     550:	00 00 00 
	bra	BootLoop ; --------> bootload loop after one 1K instr segment written
     552:	dd ff 37    	bra       0x50e <BootLoop>

00000554 <bl_lost_patience>:
;------------------------
bl_lost_patience:
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     554:	ce a4 a9    	bclr.b    0x4ce, #0x5
	bclr	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     556:	c5 e4 a9    	bclr.b    0x4c5, #0x7
	bclr	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     558:	cc 04 a9    	bclr.b    0x4cc, #0x0
	call	burn1k		; burn last block received, even incomplete
     55a:	4e 02 02    	call      0x24e <burn1k>
     55c:	00 00 00 
	bra	bootload	; end of reception (pause detected)
     55e:	79 fe 37    	bra       0x252 <bootload>

00000560 <boot_initialize>:
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	

boot_initialize:
	bclr	INTCON2,#GIE		; global int disable
     560:	83 e0 a9    	bclr.b    0x83, #0x7

; -------------------------------------	; --- oscilator -----------------------
	mov	#0b0000000100000000,w0	; FRC with PLL, /1, PLL always active
     562:	00 10 20    	mov.w     #0x100, w0
	mov	w0,CLKDIV
     564:	10 08 88    	mov.w     w0, 0x102

; -------------------------------------	; --- REMAPABLE PINS ------------------
	mov	#25,w0			; RP25 PORT_C9...
     566:	90 01 20    	mov.w     #0x19, w0
	mov.b	WREG,RPINR0+1		; ...to Ext_Int_1
     568:	91 e7 b7    	mov.b     WREG, 0x791

	mov	#26,w0			; RP26 PORT  (A0)... (0x3f to disable RX input)
     56a:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18		; ...to U1_RX
     56c:	b4 e7 b7    	mov.b     WREG, 0x7b4
;	mov	#6,w0			; RP6  PORT  (B6)...  (0x3f to disable RX input)
;	mov.b	WREG,RPINR18		; ...to U1_RX
; both pins can be Tx (why not?)
	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
     56e:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR13+1		; ...to RP27 (A1)
     570:	ef e7 b7    	mov.b     WREG, 0x7ef
;	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
;	mov.b	WREG,RPOR3+1		; ...to RP7  (B7)

; -------------------------------------	; --- TIMERS --------------------------
	mov	#0b0010000000010000,w0	; stops in sleep mode, prescaler = 1:8
     572:	00 01 22    	mov.w     #0x2010, w0
	mov	w0,T1CON		; TIMER 1 = 3300 Hz (display matrix rfsh)
     574:	a0 0c 88    	mov.w     w0, 0x194
	mov	#514-40-1,w0		; heartbeat def period 16M/8/514=3888Hz, /16=243Hz
     576:	90 1d 20    	mov.w     #0x1d9, w0
	mov	w0,PR1
     578:	90 0c 88    	mov.w     w0, 0x192

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (CLOCK period)
     57a:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T2CON		; TIMER 2 = instruction clock (no interrupt, IFS0,#7 only!)
     57c:	00 0d 88    	mov.w     w0, 0x1a0
	mov	#10-1,w0		; instruction def period
     57e:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR2
     580:	e0 0c 88    	mov.w     w0, 0x19c

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (SYNC period)
     582:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T3CON		; TIMER 3 = user's sync (interrupt only sets RdFlags,#0)
     584:	10 0d 88    	mov.w     w0, 0x1a2
	mov	#10-1,w0		; sync def period
     586:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR3
     588:	f0 0c 88    	mov.w     w0, 0x19e

; -------------------------------------	; --- UART -----------------------------
	mov	#0b0010100000001000,w0	; BRGH=1, UART disabled, RTS/CTS disabled, BRGH set
     58a:	80 80 22    	mov.w     #0x2808, w0
	mov	w0,U1MODE		; UART1 je za infrared
     58c:	c0 1c 88    	mov.w     w0, 0x398
	mov	#0b0000000000000000,w0	; TX idle mode = high
     58e:	00 00 20    	mov.w     #0x0, w0
	mov	w0,U1STAL
     590:	d0 1c 88    	mov.w     w0, 0x39a
	mov	#417-1,w0		; 16 M / 4 / 417 = 9600 Baud
     592:	00 1a 20    	mov.w     #0x1a0, w0
	mov	w0,U1BRG
     594:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
     596:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#URXEN		; enable RX 1 (must be after UART enable)
     598:	9b 83 a8    	bset.b    0x39b, #0x4
	bset	U1STAL,#UTXEN		; enable TX 1 (must be after UART enable)
     59a:	9b 43 a8    	bset.b    0x39b, #0x2

; ------------------------------------- ; --- INTERRUPTS -----------------------
	bclr	RCON,#SWDTEN		; disable WDT
     59c:	10 a1 a9    	bclr.b    0x110, #0x5
	bset	INTCON1,#NSTDIS		; disable interrupt nesting
     59e:	81 e0 a8    	bset.b    0x81, #0x7

; -------------------------------------	; --- PORTS ----------------------------
	clr	ANSA
     5a0:	6a 26 ef    	clr.w     0x66a
	clr	ANSB
     5a2:	7e 26 ef    	clr.w     0x67e
	clr	ANSC
     5a4:	92 26 ef    	clr.w     0x692

	mov	#0b0000000000011100,w0	; pull-ups
     5a6:	c0 01 20    	mov.w     #0x1c, w0
	mov	w0,IOCPUA
     5a8:	90 33 88    	mov.w     w0, 0x672
	mov	#0b0000001000000000,w0	; pull-ups
     5aa:	00 20 20    	mov.w     #0x200, w0
	mov	w0,IOCPUC
     5ac:	d0 34 88    	mov.w     w0, 0x69a

	mov	#0b0000000000000110,w0
     5ae:	60 00 20    	mov.w     #0x6, w0
	mov	w0,LATA
     5b0:	30 33 88    	mov.w     w0, 0x666
	mov	#0b0000000011110000,w0
     5b2:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,LATB
     5b4:	d0 33 88    	mov.w     w0, 0x67a
	mov	#0b0000000000000000,w0
     5b6:	00 00 20    	mov.w     #0x0, w0
	mov	w0,LATC
     5b8:	70 34 88    	mov.w     w0, 0x68e
	mov	#0b0000000000011101,w0
     5ba:	d0 01 20    	mov.w     #0x1d, w0
	mov	w0,TRISA
     5bc:	10 33 88    	mov.w     w0, 0x662
	mov	#0b0000000011110000,w0
     5be:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,TRISB
     5c0:	b0 33 88    	mov.w     w0, 0x676
	mov	#0b0000001000000000,w0
     5c2:	00 20 20    	mov.w     #0x200, w0
	mov	w0,TRISC
     5c4:	50 34 88    	mov.w     w0, 0x68a
	return
     5c6:	00 00 06    	return    

000005c8 <boot_set_decoder_to_w1>:

;------------------------------------------------------------------------------------
;-----------------------------  S U B S  --------------------------------------------
;------------------------------------------------------------------------------------

boot_set_decoder_to_w1:
	mov	#0b1111100001111111,w0
     5c8:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     5ca:	66 26 b6    	and.w     0x666
	sl	w1,#7,w0
     5cc:	47 08 dd    	sl.w      w1, #0x7, w0
	ior	LATA		; decoder state is at LATA,#7...#10 control
     5ce:	66 26 b7    	ior.w     0x666
	inc	w1,w1
     5d0:	81 00 e8    	inc.w     w1, w1
	return
     5d2:	00 00 06    	return    

000005d4 <rotate_ram>:

rotate_ram:
	mov	#0x0F0F,w0
     5d4:	f0 f0 20    	mov.w     #0xf0f, w0
	mov	#Ram+0,w1
     5d6:	01 80 20    	mov.w     #0x800, w1
	mov	#16,w2
     5d8:	02 01 20    	mov.w     #0x10, w2

000005da <L22>:
2:
	lsr	[w1],[w1]	; (skips this line without NOP)
     5da:	91 08 d1    	lsr.w     [w1], [w1]
	btsc	[w1],#0
     5dc:	11 00 a7    	btsc.w    [w1], #0x0
	bset	[w1],#3
     5de:	11 30 a0    	bset.w    [w1], #0x3
	btsc	[w1],#8
     5e0:	11 80 a7    	btsc.w    [w1], #0x8
	bset	[w1],#11
     5e2:	11 b0 a0    	bset.w    [w1], #0xb
	and	w0,[w1],[w1++]
     5e4:	91 18 60    	and.w     w0, [w1], [w1++]
	nop			; * * *   MCU BUG FIX  ???   * * *
     5e6:	00 00 00    	nop       
	dec	w2,w2
     5e8:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b
     5ea:	f7 ff 3a    	bra       NZ, 0x5da <L22>
	return
     5ec:	00 00 06    	return    

000005ee <boot_rxtx_to_io2>:

;										
;-------
boot_rxtx_to_io2:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
     5ee:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
     5f0:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
     5f2:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
     5f4:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
     5f6:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
     5f8:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
     5fa:	de 69 a8    	bset.b    0x9de, #0x3
	bset	U1MODE,#15		; enable UART 1
     5fc:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
     5fe:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
     600:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
     602:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
     604:	f0 4d 88    	mov.w     w0, 0x9be
	return
     606:	00 00 06    	return    

00000608 <boot_w0ms2>:
;------------------------------------------------------------------------
boot_w0ms2:
	repeat	#16000-1
     608:	7f 3e 09    	repeat    #0x3e7f
	nop
     60a:	00 00 00    	nop       
	dec	w0,w0
     60c:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms2
     60e:	18 fe 3a    	bra       NZ, 0x240 <w0ms2>
	return
     610:	00 00 06    	return    

00000612 <boot_eecalc_addr_w0>:

;-----------------------------------------------------------------------------
;----------------------                              -------------------------
;----------------------        EE SUBROUTINES        -------------------------
;----------------------                              -------------------------
;-----------------------------------------------------------------------------

boot_eecalc_addr_w0:	; USER PROGRAM SAVE/LOAD (8K=0x2000 by blocks, 0x1A000...)
			; w0 × 0x1000 + 0x1A000 ----> w6:w7 (end must be < 2AFFE)
			; one record 0x1000 bytes, start 0x1A000, end 0x2A000
	btsc	Flag2,#6	; #6 EE subroutines adjust to Boot
     612:	de c9 af    	btsc.b    0x9de, #0x6
	bra	eecalc_page
     614:	07 00 37    	bra       0x624 <eecalc_page>
	mov	#0x1000,w1
     616:	01 00 21    	mov.w     #0x1000, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x1000
     618:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0xA000,w0
     61a:	00 00 2a    	mov.w     #0xa000, w0
	mov	#0x0001,w1	; w0:w1 = 0x0001:A000 start of 1st flash save block
     61c:	11 00 20    	mov.w     #0x1, w1
	add	w6,w0,w6
     61e:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     620:	81 83 4b    	addc.w    w7, w1, w7
	return
     622:	00 00 06    	return    

00000624 <eecalc_page>:
;-----------------------
eecalc_page:		; BOOTLOAD (4K=0x800 by blocks, 0x1000,0x1800...)
			; w0 × 0x800 + 0x1000 ---> w6:w7 (one record 0x800 = 2K by)
			; w0 = page, 0...23 (for Firmware Backup, w0 = 24...47)
	mov	#0x800,w1
     624:	01 80 20    	mov.w     #0x800, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x800
     626:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0x1000,w0
     628:	00 00 21    	mov.w     #0x1000, w0
	mov	#0x0000,w1	; w0:w1 = 0x0000:1000 start of 1st flash save block
     62a:	01 00 20    	mov.w     #0x0, w1
	add	w6,w0,w6
     62c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     62e:	81 83 4b    	addc.w    w7, w1, w7
	return
     630:	00 00 06    	return    

00000632 <boot_eesavew0>:
;----------------------------------------------------------------------------------
boot_eesavew0:		; data (@Rom) ----> flash w0
	call	eecalc_addr_w0
     632:	42 02 02    	call      0x242 <eecalc_addr_w0>
     634:	00 00 00 
	bclr	INTCON2,#GIE	; global int disable
     636:	83 e0 a9    	bclr.b    0x83, #0x7
	clr.b	LATC		; all LEDS off
     638:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     63a:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; anode 17 off
     63c:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#0b1111100001111111,w0
     63e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     640:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     642:	00 68 20    	mov.w     #0x680, w0
	btsc	Flag2,#9	; #9 set = last command LOAD
     644:	df 29 af    	btsc.b    0x9df, #0x1
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     646:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 13 or 14 (there is led SAVE or LOAD)
     648:	66 26 b7    	ior.w     0x666
	push.d	w6	   ; \    w6, w7
     64a:	86 9f be    	mov.d     w6, [w15++]
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     64c:	4c 02 02    	call      0x24c <eeerase_1K>
     64e:	00 00 00 
	btss	Flag2,#6	; only one page for BOOT !
     650:	de c9 ae    	btss.b    0x9de, #0x6
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     652:	4c 02 02    	call      0x24c <eeerase_1K>
     654:	00 00 00 
	pop.d	w6	   ; /    w6, w7
     656:	4f 03 be    	mov.d     [--w15], w6
	mov	#Rom,w2
     658:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE save from 2nd halve of Rom area (starting at 0x3000)
     65a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     65c:	02 00 23    	mov.w     #0x3000, w2
	mov	#16,w8		; 16× for User's Program Save (4K chunks)
     65e:	08 01 20    	mov.w     #0x10, w8
	btsc	Flag2,#6
     660:	de c9 af    	btsc.b    0x9de, #0x6
	mov	#8,w8		; only 8× for BOOT ! (2K chunks)
     662:	88 00 20    	mov.w     #0x8, w8

00000664 <L82>:
8:                        ; <----------
	call	eeburn_128	; burn
     664:	4a 02 02    	call      0x24a <eeburn_128>
     666:	00 00 00 
	btss	Flag2,#6	; #6 EE Boot
     668:	de c9 ae    	btss.b    0x9de, #0x6
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     66a:	df 49 af    	btsc.b    0x9df, #0x2
	bset	LATC,#8		; anode 17 on
     66c:	8f 06 a8    	bset.b    0x68f, #0x0

	inc	Dummy
     66e:	b0 29 ec    	inc.w     0x9b0
	mov	Dummy,w0
     670:	80 4d 80    	mov.w     0x9b0, w0
	and	#15,w0
     672:	f0 00 b2    	and.w     #0xf, w0
	bra	nz,7f
     674:	02 00 3a    	bra       NZ, 0x67a <L72>

	repeat	#8000-1		; led SAVE ON time	
     676:	3f 1f 09    	repeat    #0x1f3f
	nop
     678:	00 00 00    	nop       

0000067a <L72>:
7:
	bclr	LATC,#8		; anode 17 off
     67a:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#5,w0		; led SAVE OFF time	
     67c:	50 00 20    	mov.w     #0x5, w0
	call	w0ms2
     67e:	40 02 02    	call      0x240 <w0ms2>
     680:	00 00 00 
	dec.b	w8,w8
     682:	08 44 e9    	dec.b     w8, w8
	bra	nz,8b     ; ---------->
     684:	ef ff 3a    	bra       NZ, 0x664 <L82>
	clr	TBLPAG
     686:	54 20 ef    	clr.w     0x54
	btss	Flag2,#6	; #6 EE Boot mode
     688:	de c9 ae    	btss.b    0x9de, #0x6
	bset	INTCON2,#GIE	; global int enable
     68a:	83 e0 a8    	bset.b    0x83, #0x7
	mov	#0x1000,w0
     68c:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,NVMCON
     68e:	00 3b 88    	mov.w     w0, 0x760
	return
     690:	00 00 06    	return    

00000692 <boot_eeload>:

;---------------------------------------------------------------------------
boot_eeload:		; flash (w0×0x1000+0x1A000 or w0×0x800+0x1000) --> data (Rom or Rom+0x1000)
	call	eecalc_addr_w0
     692:	42 02 02    	call      0x242 <eecalc_addr_w0>
     694:	00 00 00 
	mov	w7,TBLPAG
     696:	a7 02 88    	mov.w     w7, 0x54
	mov	#Rom,w2
     698:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE load to second halve of Rom area (start at 0x3000)
     69a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     69c:	02 00 23    	mov.w     #0x3000, w2
	btsc	Flag2,#6
     69e:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_read_bootload
     6a0:	13 00 37    	bra       0x6c8 <case_read_bootload>
	mov	#0x800,w3	; 2048×24 bits for User's Program Load
     6a2:	03 80 20    	mov.w     #0x800, w3

000006a4 <L31>:
3:			;  <---- RD WR ----------------------------------
	tblrdh.b [w6],w1	; 8    w1 = high 2n xxxx xxxx BA98 ba98	
     6a4:	96 c0 ba    	tblrdh.b  [w6], w1
	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6a6:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6a8:	00 80 fd    	swap.w    w0
	mov.b	w1,w0		;      w0 = low by  7654 3210 BA98 ba98	
     6aa:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF ba98 (complemented data)
     6ac:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF ba98 7654 3210	
     6ae:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 1st program word		
     6b0:	00 19 78    	mov.w     w0, [w2++]

	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6b2:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6b4:	00 80 fd    	swap.w    w0
	swap.b	w1		;      w1 = high 2n xxxx xxxx ba98 BA98	
     6b6:	01 c0 fd    	swap.b    w1
	mov.b	w1,w0		;      w0 = low by  7654 3210 ba98 BA98	
     6b8:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF BA98 (complemented data)
     6ba:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF BA98 7654 3210	
     6bc:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 2nd program word		
     6be:	00 19 78    	mov.w     w0, [w2++]

	dec	w3,w3
     6c0:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; ---------------------------------------------->
     6c2:	f0 ff 3a    	bra       NZ, 0x6a4 <L31>
	clr	TBLPAG
     6c4:	54 20 ef    	clr.w     0x54
	return
     6c6:	00 00 06    	return    

000006c8 <case_read_bootload>:
;			
case_read_bootload:
	mov	#0x400,w3	; only 1024×24 bits for Boot !
     6c8:	03 40 20    	mov.w     #0x400, w3

000006ca <L32>:
3:			; \
	tblrdh.b [w6],w1	; read bits 16-23
     6ca:	96 c0 ba    	tblrdh.b  [w6], w1
	nop
     6cc:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 0-7
     6ce:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d0:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 8-15
     6d2:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d4:	00 00 00    	nop       
	mov.b	w1,[w2++]	; write bits 16-23
     6d6:	01 59 78    	mov.b     w1, [w2++]
	nop
     6d8:	00 00 00    	nop       
	clr.b	[w2++]		; skip 4th dummy byte
     6da:	00 59 eb    	clr.b     [w2++]
	nop
     6dc:	00 00 00    	nop       
	dec	w3,w3
     6de:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; /
     6e0:	f4 ff 3a    	bra       NZ, 0x6ca <L32>
	clr	TBLPAG
     6e2:	54 20 ef    	clr.w     0x54
	return
     6e4:	00 00 06    	return    

000006e6 <boot_eemeasure>:

;-------------------------------
boot_eemeasure:		; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
     6e6:	de c9 a9    	bclr.b    0x9de, #0x6
	call	eecalc_addr_w0	; w6:w7
     6e8:	42 02 02    	call      0x242 <eecalc_addr_w0>
     6ea:	00 00 00 
	mov	w7,TBLPAG
     6ec:	a7 02 88    	mov.w     w7, 0x54
	mov	#0x8,w3		; w3 loop counter, 8 steps, 0x200 words = 1 bit ea
     6ee:	83 00 20    	mov.w     #0x8, w3
	mov	#0,w2		; w2 measured occupance (8 bits)
     6f0:	02 00 20    	mov.w     #0x0, w2

000006f2 <L33>:
3:			   ; \
	mov	#0x100,w4	; w4 inner loop counter
     6f2:	04 10 20    	mov.w     #0x100, w4
	setm	w1
     6f4:	80 80 eb    	setm.w    w1

000006f6 <L41>:
4:			   ; \\
	tblrdh.b [w6],w0	; w1 = high 2n xxxx xxxx BA98 ba98
     6f6:	16 c0 ba    	tblrdh.b  [w6], w0
	and.b	w1,w0,w1
     6f8:	80 c0 60    	and.b     w1, w0, w1
	tblrdl [w6++],w0	; w0 = low by  7654 3210 7654 3210
     6fa:	36 00 ba    	tblrdl.w  [w6++], w0
	and	w1,w0,w1
     6fc:	80 80 60    	and.w     w1, w0, w1
	dec	w4,w4
     6fe:	04 02 e9    	dec.w     w4, w4
	bra	nz,4b	   ; //
     700:	fa ff 3a    	bra       NZ, 0x6f6 <L41>
	sl	w2,w2
     702:	02 01 d0    	sl.w      w2, w2
	inc	w1,w1
     704:	81 00 e8    	inc.w     w1, w1
	ifnz
     706:	42 20 ae    	btss.b    0x42, #0x1
	bset	w2,#0
     708:	02 00 a0    	bset.w    w2, #0x0
	dec	w3,w3
     70a:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	   ; /
     70c:	f2 ff 3a    	bra       NZ, 0x6f2 <L33>
	clr	TBLPAG
     70e:	54 20 ef    	clr.w     0x54
	return
     710:	00 00 06    	return    

00000712 <boot_eeerase_1K>:

; ------------------------------ PAGE ERASE -----------------------------
boot_eeerase_1K:	; erase block of 1K instructions (2K user pgm bytes + 1K high)
	mov	#0x5003,w0
     712:	30 00 25    	mov.w     #0x5003, w0
	mov	w0,NVMCON
     714:	00 3b 88    	mov.w     w0, 0x760
; Load the address of the page to be erased into the NVMADR register pair
	mov	w6,NVMADR
     716:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     718:	27 3b 88    	mov.w     w7, 0x764
	mov	#0x800,w0
     71a:	00 80 20    	mov.w     #0x800, w0
	add	w6,w0,w6
     71c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,#0,w7
     71e:	e0 83 4b    	addc.w    w7, #0x0, w7
; Set the WR bit
	bra	eeiniseq_128
     720:	17 00 37    	bra       0x750 <eeiniseq_128>

00000722 <boot_eeburn_128>:

; ------------------------------- ROW BURN ------------------------------
boot_eeburn_128:	; burn row of 128 instructions, source ptr w2, dest w6:w7
; Set NVMCON for 128 instruction words (256 user pgm words), rd ptr w2, wr ptr w6:w7
	mov	#0x5002,w0
     722:	20 00 25    	mov.w     #0x5002, w0
	mov	w0,NVMCON
     724:	00 3b 88    	mov.w     w0, 0x760
; Set the NVMADRU/NVMADR reg pair to starting address
	mov	w6,NVMADR
     726:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     728:	27 3b 88    	mov.w     w7, 0x764
	add	#256,w6		; prepare for the next row programming
     72a:	06 10 b0    	add.w     #0x100, w6
	addc	w7,#0,w7
     72c:	e0 83 4b    	addc.w    w7, #0x0, w7
; Initialize the TBLPAG register for writing to the latches
	mov	#0xfa,w0	; pgm latches are mapped at 0xFA0000-0xFA00FE
     72e:	a0 0f 20    	mov.w     #0xfa, w0
	mov	w0,TBLPAG
     730:	a0 02 88    	mov.w     w0, 0x54
	clr	w1		; low address
     732:	80 00 eb    	clr.w     w1
; Set up write data address pointer, W2 point to data in RAM
	mov	#128,w3		; loop counter
     734:	03 08 20    	mov.w     #0x80, w3
	btsc	Flag2,#6	; #6 EE Boot
     736:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_boot
     738:	18 00 37    	bra       0x76a <L42> <case_boot>

0000073a <L34>:
3:			; read 8+4+8+4 data bits, write 8+8+8 bits to latches
			;	 rd wr				
	tblwtl.b [w2++],[w1++]	; 8 8  [w1] = low by  7654 3210
     73a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	ze	[w2++],w4	; 4    w4 = 0000 0000 xxxx ba98
     73c:	32 82 fb    	ze        [w2++], w4
	and	#0x0F,w4	;      w4 = 0000 0000 0000 ba98
     73e:	f4 00 b2    	and.w     #0xf, w4
	tblwtl.b [w2++],[w1--]	; 8 8  [w1] = mid by  7654 3210
     740:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	ze	[w2++],w5	; 4    w5 = 0000 0000 xxxx BA98
     742:	b2 82 fb    	ze        [w2++], w5
	sl	w5,#4,w5	;      w4 = 0000 xxxx BA98 0000
     744:	c4 2a dd    	sl.w      w5, #0x4, w5
	ior	w4,w5,w4	;      w4 = 0000 xxxx BA98 ba98 (low word=low nib)
     746:	05 02 72    	ior.w     w4, w5, w4
	tblwth.b w4,[w1]	;   8  [w1] = high 2n BA98 ba98
     748:	84 c8 bb    	tblwth.b  w4, [w1]
	inc2	w1,w1
     74a:	81 80 e8    	inc2.w    w1, w1
	dec	w3,w3
     74c:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b
     74e:	f5 ff 3a    	bra       NZ, 0x73a <L34>

00000750 <eeiniseq_128>:
; Set the WR bit
eeiniseq_128:
	disi	#5		; DI for next 5 instructions
     750:	05 00 fc    	disi      #0x5
	mov.b	#0x55,w0
     752:	50 c5 b3    	mov.b     #0x55, w0
	mov	w0,NVMKEY	; Write the 1st key
     754:	30 3b 88    	mov.w     w0, 0x766
	mov.b	#0xAA,w0
     756:	a0 ca b3    	mov.b     #0xaa, w0
	mov	w0,NVMKEY	; Write the 2nd key
     758:	30 3b 88    	mov.w     w0, 0x766
	bset	NVMCON,#WR	; Start the programming sequence
     75a:	61 e7 a8    	bset.b    0x761, #0x7
	...
	nop			; Required delay
	nop			; Required delay
	nop			; Required delay
	btsc	NVMCON,#15	; and wait for it to be completed
     762:	61 e7 af    	btsc.b    0x761, #0x7

00000764 <L0>:
	bra	$-2
     764:	fe ff 37    	bra       0x762
	clr	TBLPAG
     766:	54 20 ef    	clr.w     0x54
	return
     768:	00 00 06    	return    

0000076a <L42>:
;	
case_boot:
4:			; read 8+8+8 data bits + skip, write 8+8+8 bits to latches
	tblwtl.b [w2++],[w1++]	; bits 0-7
     76a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	nop
     76c:	00 00 00    	nop       
	tblwtl.b [w2++],[w1--]	; bits 8-15
     76e:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	nop
     770:	00 00 00    	nop       
	tblwth.b [w2++],[w1]	; bits 16-23
     772:	b2 c8 bb    	tblwth.b  [w2++], [w1]
	nop
     774:	00 00 00    	nop       
	inc2	w1,w1		; write ptr +2
     776:	81 80 e8    	inc2.w    w1, w1
	inc	w2,w2		; skip 4th dummy byte
     778:	02 01 e8    	inc.w     w2, w2
	dec	w3,w3
     77a:	83 01 e9    	dec.w     w3, w3
	bra	nz,4b
     77c:	f6 ff 3a    	bra       NZ, 0x76a <L42> <case_boot>
; Set the WR bit
	bra	eeiniseq_128
     77e:	e8 ff 37    	bra       0x750 <eeiniseq_128>

00000780 <boot_burn1k>:
;------------------------------------------------------------------------
boot_burn1k:		; burn 1K instructions, 3K bytes + 1K dummy 0's
	mov	#Rom,w0
     780:	00 00 22    	mov.w     #0x2000, w0
	mov	#Rom+0x1000,w1
     782:	01 00 23    	mov.w     #0x3000, w1
	repeat	#0x800-1	; 2048 ×
     784:	ff 07 09    	repeat    #0x7ff
	mov	[w0++],[w1++]	; move 4K bytes from Rom 1st halve to 2nd halve
     786:	b0 18 78    	mov.w     [w0++], [w1++]
	mov	#Rom,w0
     788:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1	; 2048 ×
     78a:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve
     78c:	00 98 eb    	setm.w    [w0++]
	mov	w11,w0
     78e:	0b 00 78    	mov.w     w11, w0
	call	eesavew0	; burn 1024 instructions (×24 bits) from Rom 2nd halve
     790:	44 02 02    	call      0x244 <eesavew0>
     792:	00 00 00 
	inc	w11,w11
     794:	8b 05 e8    	inc.w     w11, w11
	return
     796:	00 00 06    	return    
     798:	ff ff 00    	nop       
     79a:	ff ff 00    	nop       
     79c:	ff ff 00    	nop       
     79e:	ff ff 00    	nop       
     7a0:	ff ff 00    	nop       
     7a2:	ff ff 00    	nop       
     7a4:	ff ff 00    	nop       
     7a6:	ff ff 00    	nop       
     7a8:	ff ff 00    	nop       
     7aa:	ff ff 00    	nop       
     7ac:	ff ff 00    	nop       
     7ae:	ff ff 00    	nop       
     7b0:	ff ff 00    	nop       
     7b2:	ff ff 00    	nop       
     7b4:	ff ff 00    	nop       
     7b6:	ff ff 00    	nop       
     7b8:	ff ff 00    	nop       
     7ba:	ff ff 00    	nop       
     7bc:	ff ff 00    	nop       
     7be:	ff ff 00    	nop       
     7c0:	ff ff 00    	nop       
     7c2:	ff ff 00    	nop       
     7c4:	ff ff 00    	nop       
     7c6:	ff ff 00    	nop       
     7c8:	ff ff 00    	nop       
     7ca:	ff ff 00    	nop       
     7cc:	ff ff 00    	nop       
     7ce:	ff ff 00    	nop       
     7d0:	ff ff 00    	nop       
     7d2:	ff ff 00    	nop       
     7d4:	ff ff 00    	nop       
     7d6:	ff ff 00    	nop       
     7d8:	ff ff 00    	nop       
     7da:	ff ff 00    	nop       
     7dc:	ff ff 00    	nop       
     7de:	ff ff 00    	nop       
     7e0:	ff ff 00    	nop       
     7e2:	ff ff 00    	nop       
     7e4:	ff ff 00    	nop       
     7e6:	ff ff 00    	nop       
     7e8:	ff ff 00    	nop       
     7ea:	ff ff 00    	nop       
     7ec:	ff ff 00    	nop       
     7ee:	ff ff 00    	nop       
     7f0:	ff ff 00    	nop       
     7f2:	ff ff 00    	nop       
     7f4:	ff ff 00    	nop       
     7f6:	ff ff 00    	nop       
     7f8:	ff ff 00    	nop       
     7fa:	ff ff 00    	nop       
     7fc:	ff ff 00    	nop       
     7fe:	ff ff 00    	nop       
     800:	ff ff 00    	nop       
     802:	ff ff 00    	nop       
     804:	ff ff 00    	nop       
     806:	ff ff 00    	nop       
     808:	ff ff 00    	nop       
     80a:	ff ff 00    	nop       
     80c:	ff ff 00    	nop       
     80e:	ff ff 00    	nop       
     810:	ff ff 00    	nop       
     812:	ff ff 00    	nop       
     814:	ff ff 00    	nop       
     816:	ff ff 00    	nop       
     818:	ff ff 00    	nop       
     81a:	ff ff 00    	nop       
     81c:	ff ff 00    	nop       
     81e:	ff ff 00    	nop       
     820:	ff ff 00    	nop       
     822:	ff ff 00    	nop       
     824:	ff ff 00    	nop       
     826:	ff ff 00    	nop       
     828:	ff ff 00    	nop       
     82a:	ff ff 00    	nop       
     82c:	ff ff 00    	nop       
     82e:	ff ff 00    	nop       
     830:	ff ff 00    	nop       
     832:	ff ff 00    	nop       
     834:	ff ff 00    	nop       
     836:	ff ff 00    	nop       
     838:	ff ff 00    	nop       
     83a:	ff ff 00    	nop       
     83c:	ff ff 00    	nop       
     83e:	ff ff 00    	nop       
     840:	ff ff 00    	nop       
     842:	ff ff 00    	nop       
     844:	ff ff 00    	nop       
     846:	ff ff 00    	nop       
     848:	ff ff 00    	nop       
     84a:	ff ff 00    	nop       
     84c:	ff ff 00    	nop       
     84e:	ff ff 00    	nop       
     850:	ff ff 00    	nop       
     852:	ff ff 00    	nop       
     854:	ff ff 00    	nop       
     856:	ff ff 00    	nop       
     858:	ff ff 00    	nop       
     85a:	ff ff 00    	nop       
     85c:	ff ff 00    	nop       
     85e:	ff ff 00    	nop       
     860:	ff ff 00    	nop       
     862:	ff ff 00    	nop       
     864:	ff ff 00    	nop       
     866:	ff ff 00    	nop       
     868:	ff ff 00    	nop       
     86a:	ff ff 00    	nop       
     86c:	ff ff 00    	nop       
     86e:	ff ff 00    	nop       
     870:	ff ff 00    	nop       
     872:	ff ff 00    	nop       
     874:	ff ff 00    	nop       
     876:	ff ff 00    	nop       
     878:	ff ff 00    	nop       
     87a:	ff ff 00    	nop       
     87c:	ff ff 00    	nop       
     87e:	ff ff 00    	nop       
     880:	ff ff 00    	nop       
     882:	ff ff 00    	nop       
     884:	ff ff 00    	nop       
     886:	ff ff 00    	nop       
     888:	ff ff 00    	nop       
     88a:	ff ff 00    	nop       
     88c:	ff ff 00    	nop       
     88e:	ff ff 00    	nop       
     890:	ff ff 00    	nop       
     892:	ff ff 00    	nop       
     894:	ff ff 00    	nop       
     896:	ff ff 00    	nop       
     898:	ff ff 00    	nop       
     89a:	ff ff 00    	nop       
     89c:	ff ff 00    	nop       
     89e:	ff ff 00    	nop       
     8a0:	ff ff 00    	nop       
     8a2:	ff ff 00    	nop       
     8a4:	ff ff 00    	nop       
     8a6:	ff ff 00    	nop       
     8a8:	ff ff 00    	nop       
     8aa:	ff ff 00    	nop       
     8ac:	ff ff 00    	nop       
     8ae:	ff ff 00    	nop       
     8b0:	ff ff 00    	nop       
     8b2:	ff ff 00    	nop       
     8b4:	ff ff 00    	nop       
     8b6:	ff ff 00    	nop       
     8b8:	ff ff 00    	nop       
     8ba:	ff ff 00    	nop       
     8bc:	ff ff 00    	nop       
     8be:	ff ff 00    	nop       
     8c0:	ff ff 00    	nop       
     8c2:	ff ff 00    	nop       
     8c4:	ff ff 00    	nop       
     8c6:	ff ff 00    	nop       
     8c8:	ff ff 00    	nop       
     8ca:	ff ff 00    	nop       
     8cc:	ff ff 00    	nop       
     8ce:	ff ff 00    	nop       
     8d0:	ff ff 00    	nop       
     8d2:	ff ff 00    	nop       
     8d4:	ff ff 00    	nop       
     8d6:	ff ff 00    	nop       
     8d8:	ff ff 00    	nop       
     8da:	ff ff 00    	nop       
     8dc:	ff ff 00    	nop       
     8de:	ff ff 00    	nop       
     8e0:	ff ff 00    	nop       
     8e2:	ff ff 00    	nop       
     8e4:	ff ff 00    	nop       
     8e6:	ff ff 00    	nop       
     8e8:	ff ff 00    	nop       
     8ea:	ff ff 00    	nop       
     8ec:	ff ff 00    	nop       
     8ee:	ff ff 00    	nop       
     8f0:	ff ff 00    	nop       
     8f2:	ff ff 00    	nop       
     8f4:	ff ff 00    	nop       
     8f6:	ff ff 00    	nop       
     8f8:	ff ff 00    	nop       
     8fa:	ff ff 00    	nop       
     8fc:	ff ff 00    	nop       
     8fe:	ff ff 00    	nop       
     900:	ff ff 00    	nop       
     902:	ff ff 00    	nop       
     904:	ff ff 00    	nop       
     906:	ff ff 00    	nop       
     908:	ff ff 00    	nop       
     90a:	ff ff 00    	nop       
     90c:	ff ff 00    	nop       
     90e:	ff ff 00    	nop       
     910:	ff ff 00    	nop       
     912:	ff ff 00    	nop       
     914:	ff ff 00    	nop       
     916:	ff ff 00    	nop       
     918:	ff ff 00    	nop       
     91a:	ff ff 00    	nop       
     91c:	ff ff 00    	nop       
     91e:	ff ff 00    	nop       
     920:	ff ff 00    	nop       
     922:	ff ff 00    	nop       
     924:	ff ff 00    	nop       
     926:	ff ff 00    	nop       
     928:	ff ff 00    	nop       
     92a:	ff ff 00    	nop       
     92c:	ff ff 00    	nop       
     92e:	ff ff 00    	nop       
     930:	ff ff 00    	nop       
     932:	ff ff 00    	nop       
     934:	ff ff 00    	nop       
     936:	ff ff 00    	nop       
     938:	ff ff 00    	nop       
     93a:	ff ff 00    	nop       
     93c:	ff ff 00    	nop       
     93e:	ff ff 00    	nop       
     940:	ff ff 00    	nop       
     942:	ff ff 00    	nop       
     944:	ff ff 00    	nop       
     946:	ff ff 00    	nop       
     948:	ff ff 00    	nop       
     94a:	ff ff 00    	nop       
     94c:	ff ff 00    	nop       
     94e:	ff ff 00    	nop       
     950:	ff ff 00    	nop       
     952:	ff ff 00    	nop       
     954:	ff ff 00    	nop       
     956:	ff ff 00    	nop       
     958:	ff ff 00    	nop       
     95a:	ff ff 00    	nop       
     95c:	ff ff 00    	nop       
     95e:	ff ff 00    	nop       
     960:	ff ff 00    	nop       
     962:	ff ff 00    	nop       
     964:	ff ff 00    	nop       
     966:	ff ff 00    	nop       
     968:	ff ff 00    	nop       
     96a:	ff ff 00    	nop       
     96c:	ff ff 00    	nop       
     96e:	ff ff 00    	nop       
     970:	ff ff 00    	nop       
     972:	ff ff 00    	nop       
     974:	ff ff 00    	nop       
     976:	ff ff 00    	nop       
     978:	ff ff 00    	nop       
     97a:	ff ff 00    	nop       
     97c:	ff ff 00    	nop       
     97e:	ff ff 00    	nop       
     980:	ff ff 00    	nop       
     982:	ff ff 00    	nop       
     984:	ff ff 00    	nop       
     986:	ff ff 00    	nop       
     988:	ff ff 00    	nop       
     98a:	ff ff 00    	nop       
     98c:	ff ff 00    	nop       
     98e:	ff ff 00    	nop       
     990:	ff ff 00    	nop       
     992:	ff ff 00    	nop       
     994:	ff ff 00    	nop       
     996:	ff ff 00    	nop       
     998:	ff ff 00    	nop       
     99a:	ff ff 00    	nop       
     99c:	ff ff 00    	nop       
     99e:	ff ff 00    	nop       
     9a0:	ff ff 00    	nop       
     9a2:	ff ff 00    	nop       
     9a4:	ff ff 00    	nop       
     9a6:	ff ff 00    	nop       
     9a8:	ff ff 00    	nop       
     9aa:	ff ff 00    	nop       
     9ac:	ff ff 00    	nop       
     9ae:	ff ff 00    	nop       
     9b0:	ff ff 00    	nop       
     9b2:	ff ff 00    	nop       
     9b4:	ff ff 00    	nop       
     9b6:	ff ff 00    	nop       
     9b8:	ff ff 00    	nop       
     9ba:	ff ff 00    	nop       
     9bc:	ff ff 00    	nop       
     9be:	ff ff 00    	nop       
     9c0:	ff ff 00    	nop       
     9c2:	ff ff 00    	nop       
     9c4:	ff ff 00    	nop       
     9c6:	ff ff 00    	nop       
     9c8:	ff ff 00    	nop       
     9ca:	ff ff 00    	nop       
     9cc:	ff ff 00    	nop       
     9ce:	ff ff 00    	nop       
     9d0:	ff ff 00    	nop       
     9d2:	ff ff 00    	nop       
     9d4:	ff ff 00    	nop       
     9d6:	ff ff 00    	nop       
     9d8:	ff ff 00    	nop       
     9da:	ff ff 00    	nop       
     9dc:	ff ff 00    	nop       
     9de:	ff ff 00    	nop       
     9e0:	ff ff 00    	nop       
     9e2:	ff ff 00    	nop       
     9e4:	ff ff 00    	nop       
     9e6:	ff ff 00    	nop       
     9e8:	ff ff 00    	nop       
     9ea:	ff ff 00    	nop       
     9ec:	ff ff 00    	nop       
     9ee:	ff ff 00    	nop       
     9f0:	ff ff 00    	nop       
     9f2:	ff ff 00    	nop       
     9f4:	ff ff 00    	nop       
     9f6:	ff ff 00    	nop       
     9f8:	ff ff 00    	nop       
     9fa:	ff ff 00    	nop       
     9fc:	ff ff 00    	nop       
     9fe:	ff ff 00    	nop       
     a00:	ff ff 00    	nop       
     a02:	ff ff 00    	nop       
     a04:	ff ff 00    	nop       
     a06:	ff ff 00    	nop       
     a08:	ff ff 00    	nop       
     a0a:	ff ff 00    	nop       
     a0c:	ff ff 00    	nop       
     a0e:	ff ff 00    	nop       
     a10:	ff ff 00    	nop       
     a12:	ff ff 00    	nop       
     a14:	ff ff 00    	nop       
     a16:	ff ff 00    	nop       
     a18:	ff ff 00    	nop       
     a1a:	ff ff 00    	nop       
     a1c:	ff ff 00    	nop       
     a1e:	ff ff 00    	nop       
     a20:	ff ff 00    	nop       
     a22:	ff ff 00    	nop       
     a24:	ff ff 00    	nop       
     a26:	ff ff 00    	nop       
     a28:	ff ff 00    	nop       
     a2a:	ff ff 00    	nop       
     a2c:	ff ff 00    	nop       
     a2e:	ff ff 00    	nop       
     a30:	ff ff 00    	nop       
     a32:	ff ff 00    	nop       
     a34:	ff ff 00    	nop       
     a36:	ff ff 00    	nop       
     a38:	ff ff 00    	nop       
     a3a:	ff ff 00    	nop       
     a3c:	ff ff 00    	nop       
     a3e:	ff ff 00    	nop       
     a40:	ff ff 00    	nop       
     a42:	ff ff 00    	nop       
     a44:	ff ff 00    	nop       
     a46:	ff ff 00    	nop       
     a48:	ff ff 00    	nop       
     a4a:	ff ff 00    	nop       
     a4c:	ff ff 00    	nop       
     a4e:	ff ff 00    	nop       
     a50:	ff ff 00    	nop       
     a52:	ff ff 00    	nop       
     a54:	ff ff 00    	nop       
     a56:	ff ff 00    	nop       
     a58:	ff ff 00    	nop       
     a5a:	ff ff 00    	nop       
     a5c:	ff ff 00    	nop       
     a5e:	ff ff 00    	nop       
     a60:	ff ff 00    	nop       
     a62:	ff ff 00    	nop       
     a64:	ff ff 00    	nop       
     a66:	ff ff 00    	nop       
     a68:	ff ff 00    	nop       
     a6a:	ff ff 00    	nop       
     a6c:	ff ff 00    	nop       
     a6e:	ff ff 00    	nop       
     a70:	ff ff 00    	nop       
     a72:	ff ff 00    	nop       
     a74:	ff ff 00    	nop       
     a76:	ff ff 00    	nop       
     a78:	ff ff 00    	nop       
     a7a:	ff ff 00    	nop       
     a7c:	ff ff 00    	nop       
     a7e:	ff ff 00    	nop       
     a80:	ff ff 00    	nop       
     a82:	ff ff 00    	nop       
     a84:	ff ff 00    	nop       
     a86:	ff ff 00    	nop       
     a88:	ff ff 00    	nop       
     a8a:	ff ff 00    	nop       
     a8c:	ff ff 00    	nop       
     a8e:	ff ff 00    	nop       
     a90:	ff ff 00    	nop       
     a92:	ff ff 00    	nop       
     a94:	ff ff 00    	nop       
     a96:	ff ff 00    	nop       
     a98:	ff ff 00    	nop       
     a9a:	ff ff 00    	nop       
     a9c:	ff ff 00    	nop       
     a9e:	ff ff 00    	nop       
     aa0:	ff ff 00    	nop       
     aa2:	ff ff 00    	nop       
     aa4:	ff ff 00    	nop       
     aa6:	ff ff 00    	nop       
     aa8:	ff ff 00    	nop       
     aaa:	ff ff 00    	nop       
     aac:	ff ff 00    	nop       
     aae:	ff ff 00    	nop       
     ab0:	ff ff 00    	nop       
     ab2:	ff ff 00    	nop       
     ab4:	ff ff 00    	nop       
     ab6:	ff ff 00    	nop       
     ab8:	ff ff 00    	nop       
     aba:	ff ff 00    	nop       
     abc:	ff ff 00    	nop       
     abe:	ff ff 00    	nop       
     ac0:	ff ff 00    	nop       
     ac2:	ff ff 00    	nop       
     ac4:	ff ff 00    	nop       
     ac6:	ff ff 00    	nop       
     ac8:	ff ff 00    	nop       
     aca:	ff ff 00    	nop       
     acc:	ff ff 00    	nop       
     ace:	ff ff 00    	nop       
     ad0:	ff ff 00    	nop       
     ad2:	ff ff 00    	nop       
     ad4:	ff ff 00    	nop       
     ad6:	ff ff 00    	nop       
     ad8:	ff ff 00    	nop       
     ada:	ff ff 00    	nop       
     adc:	ff ff 00    	nop       
     ade:	ff ff 00    	nop       
     ae0:	ff ff 00    	nop       
     ae2:	ff ff 00    	nop       
     ae4:	ff ff 00    	nop       
     ae6:	ff ff 00    	nop       
     ae8:	ff ff 00    	nop       
     aea:	ff ff 00    	nop       
     aec:	ff ff 00    	nop       
     aee:	ff ff 00    	nop       
     af0:	ff ff 00    	nop       
     af2:	ff ff 00    	nop       
     af4:	ff ff 00    	nop       
     af6:	ff ff 00    	nop       
     af8:	ff ff 00    	nop       
     afa:	ff ff 00    	nop       
     afc:	ff ff 00    	nop       
     afe:	ff ff 00    	nop       
     b00:	ff ff 00    	nop       
     b02:	ff ff 00    	nop       
     b04:	ff ff 00    	nop       
     b06:	ff ff 00    	nop       
     b08:	ff ff 00    	nop       
     b0a:	ff ff 00    	nop       
     b0c:	ff ff 00    	nop       
     b0e:	ff ff 00    	nop       
     b10:	ff ff 00    	nop       
     b12:	ff ff 00    	nop       
     b14:	ff ff 00    	nop       
     b16:	ff ff 00    	nop       
     b18:	ff ff 00    	nop       
     b1a:	ff ff 00    	nop       
     b1c:	ff ff 00    	nop       
     b1e:	ff ff 00    	nop       
     b20:	ff ff 00    	nop       
     b22:	ff ff 00    	nop       
     b24:	ff ff 00    	nop       
     b26:	ff ff 00    	nop       
     b28:	ff ff 00    	nop       
     b2a:	ff ff 00    	nop       
     b2c:	ff ff 00    	nop       
     b2e:	ff ff 00    	nop       
     b30:	ff ff 00    	nop       
     b32:	ff ff 00    	nop       
     b34:	ff ff 00    	nop       
     b36:	ff ff 00    	nop       
     b38:	ff ff 00    	nop       
     b3a:	ff ff 00    	nop       
     b3c:	ff ff 00    	nop       
     b3e:	ff ff 00    	nop       
     b40:	ff ff 00    	nop       
     b42:	ff ff 00    	nop       
     b44:	ff ff 00    	nop       
     b46:	ff ff 00    	nop       
     b48:	ff ff 00    	nop       
     b4a:	ff ff 00    	nop       
     b4c:	ff ff 00    	nop       
     b4e:	ff ff 00    	nop       
     b50:	ff ff 00    	nop       
     b52:	ff ff 00    	nop       
     b54:	ff ff 00    	nop       
     b56:	ff ff 00    	nop       
     b58:	ff ff 00    	nop       
     b5a:	ff ff 00    	nop       
     b5c:	ff ff 00    	nop       
     b5e:	ff ff 00    	nop       
     b60:	ff ff 00    	nop       
     b62:	ff ff 00    	nop       
     b64:	ff ff 00    	nop       
     b66:	ff ff 00    	nop       
     b68:	ff ff 00    	nop       
     b6a:	ff ff 00    	nop       
     b6c:	ff ff 00    	nop       
     b6e:	ff ff 00    	nop       
     b70:	ff ff 00    	nop       
     b72:	ff ff 00    	nop       
     b74:	ff ff 00    	nop       
     b76:	ff ff 00    	nop       
     b78:	ff ff 00    	nop       
     b7a:	ff ff 00    	nop       
     b7c:	ff ff 00    	nop       
     b7e:	ff ff 00    	nop       
     b80:	ff ff 00    	nop       
     b82:	ff ff 00    	nop       
     b84:	ff ff 00    	nop       
     b86:	ff ff 00    	nop       
     b88:	ff ff 00    	nop       
     b8a:	ff ff 00    	nop       
     b8c:	ff ff 00    	nop       
     b8e:	ff ff 00    	nop       
     b90:	ff ff 00    	nop       
     b92:	ff ff 00    	nop       
     b94:	ff ff 00    	nop       
     b96:	ff ff 00    	nop       
     b98:	ff ff 00    	nop       
     b9a:	ff ff 00    	nop       
     b9c:	ff ff 00    	nop       
     b9e:	ff ff 00    	nop       
     ba0:	ff ff 00    	nop       
     ba2:	ff ff 00    	nop       
     ba4:	ff ff 00    	nop       
     ba6:	ff ff 00    	nop       
     ba8:	ff ff 00    	nop       
     baa:	ff ff 00    	nop       
     bac:	ff ff 00    	nop       
     bae:	ff ff 00    	nop       
     bb0:	ff ff 00    	nop       
     bb2:	ff ff 00    	nop       
     bb4:	ff ff 00    	nop       
     bb6:	ff ff 00    	nop       
     bb8:	ff ff 00    	nop       
     bba:	ff ff 00    	nop       
     bbc:	ff ff 00    	nop       
     bbe:	ff ff 00    	nop       
     bc0:	ff ff 00    	nop       
     bc2:	ff ff 00    	nop       
     bc4:	ff ff 00    	nop       
     bc6:	ff ff 00    	nop       
     bc8:	ff ff 00    	nop       
     bca:	ff ff 00    	nop       
     bcc:	ff ff 00    	nop       
     bce:	ff ff 00    	nop       
     bd0:	ff ff 00    	nop       
     bd2:	ff ff 00    	nop       
     bd4:	ff ff 00    	nop       
     bd6:	ff ff 00    	nop       
     bd8:	ff ff 00    	nop       
     bda:	ff ff 00    	nop       
     bdc:	ff ff 00    	nop       
     bde:	ff ff 00    	nop       
     be0:	ff ff 00    	nop       
     be2:	ff ff 00    	nop       
     be4:	ff ff 00    	nop       
     be6:	ff ff 00    	nop       
     be8:	ff ff 00    	nop       
     bea:	ff ff 00    	nop       
     bec:	ff ff 00    	nop       
     bee:	ff ff 00    	nop       
     bf0:	ff ff 00    	nop       
     bf2:	ff ff 00    	nop       
     bf4:	ff ff 00    	nop       
     bf6:	ff ff 00    	nop       
     bf8:	ff ff 00    	nop       
     bfa:	ff ff 00    	nop       
     bfc:	ff ff 00    	nop       
     bfe:	ff ff 00    	nop       
     c00:	ff ff 00    	nop       
     c02:	ff ff 00    	nop       
     c04:	ff ff 00    	nop       
     c06:	ff ff 00    	nop       
     c08:	ff ff 00    	nop       
     c0a:	ff ff 00    	nop       
     c0c:	ff ff 00    	nop       
     c0e:	ff ff 00    	nop       
     c10:	ff ff 00    	nop       
     c12:	ff ff 00    	nop       
     c14:	ff ff 00    	nop       
     c16:	ff ff 00    	nop       
     c18:	ff ff 00    	nop       
     c1a:	ff ff 00    	nop       
     c1c:	ff ff 00    	nop       
     c1e:	ff ff 00    	nop       
     c20:	ff ff 00    	nop       
     c22:	ff ff 00    	nop       
     c24:	ff ff 00    	nop       
     c26:	ff ff 00    	nop       
     c28:	ff ff 00    	nop       
     c2a:	ff ff 00    	nop       
     c2c:	ff ff 00    	nop       
     c2e:	ff ff 00    	nop       
     c30:	ff ff 00    	nop       
     c32:	ff ff 00    	nop       
     c34:	ff ff 00    	nop       
     c36:	ff ff 00    	nop       
     c38:	ff ff 00    	nop       
     c3a:	ff ff 00    	nop       
     c3c:	ff ff 00    	nop       
     c3e:	ff ff 00    	nop       
     c40:	ff ff 00    	nop       
     c42:	ff ff 00    	nop       
     c44:	ff ff 00    	nop       
     c46:	ff ff 00    	nop       
     c48:	ff ff 00    	nop       
     c4a:	ff ff 00    	nop       
     c4c:	ff ff 00    	nop       
     c4e:	ff ff 00    	nop       
     c50:	ff ff 00    	nop       
     c52:	ff ff 00    	nop       
     c54:	ff ff 00    	nop       
     c56:	ff ff 00    	nop       
     c58:	ff ff 00    	nop       
     c5a:	ff ff 00    	nop       
     c5c:	ff ff 00    	nop       
     c5e:	ff ff 00    	nop       
     c60:	ff ff 00    	nop       
     c62:	ff ff 00    	nop       
     c64:	ff ff 00    	nop       
     c66:	ff ff 00    	nop       
     c68:	ff ff 00    	nop       
     c6a:	ff ff 00    	nop       
     c6c:	ff ff 00    	nop       
     c6e:	ff ff 00    	nop       
     c70:	ff ff 00    	nop       
     c72:	ff ff 00    	nop       
     c74:	ff ff 00    	nop       
     c76:	ff ff 00    	nop       
     c78:	ff ff 00    	nop       
     c7a:	ff ff 00    	nop       
     c7c:	ff ff 00    	nop       
     c7e:	ff ff 00    	nop       
     c80:	ff ff 00    	nop       
     c82:	ff ff 00    	nop       
     c84:	ff ff 00    	nop       
     c86:	ff ff 00    	nop       
     c88:	ff ff 00    	nop       
     c8a:	ff ff 00    	nop       
     c8c:	ff ff 00    	nop       
     c8e:	ff ff 00    	nop       
     c90:	ff ff 00    	nop       
     c92:	ff ff 00    	nop       
     c94:	ff ff 00    	nop       
     c96:	ff ff 00    	nop       
     c98:	ff ff 00    	nop       
     c9a:	ff ff 00    	nop       
     c9c:	ff ff 00    	nop       
     c9e:	ff ff 00    	nop       
     ca0:	ff ff 00    	nop       
     ca2:	ff ff 00    	nop       
     ca4:	ff ff 00    	nop       
     ca6:	ff ff 00    	nop       
     ca8:	ff ff 00    	nop       
     caa:	ff ff 00    	nop       
     cac:	ff ff 00    	nop       
     cae:	ff ff 00    	nop       
     cb0:	ff ff 00    	nop       
     cb2:	ff ff 00    	nop       
     cb4:	ff ff 00    	nop       
     cb6:	ff ff 00    	nop       
     cb8:	ff ff 00    	nop       
     cba:	ff ff 00    	nop       
     cbc:	ff ff 00    	nop       
     cbe:	ff ff 00    	nop       
     cc0:	ff ff 00    	nop       
     cc2:	ff ff 00    	nop       
     cc4:	ff ff 00    	nop       
     cc6:	ff ff 00    	nop       
     cc8:	ff ff 00    	nop       
     cca:	ff ff 00    	nop       
     ccc:	ff ff 00    	nop       
     cce:	ff ff 00    	nop       
     cd0:	ff ff 00    	nop       
     cd2:	ff ff 00    	nop       
     cd4:	ff ff 00    	nop       
     cd6:	ff ff 00    	nop       
     cd8:	ff ff 00    	nop       
     cda:	ff ff 00    	nop       
     cdc:	ff ff 00    	nop       
     cde:	ff ff 00    	nop       
     ce0:	ff ff 00    	nop       
     ce2:	ff ff 00    	nop       
     ce4:	ff ff 00    	nop       
     ce6:	ff ff 00    	nop       
     ce8:	ff ff 00    	nop       
     cea:	ff ff 00    	nop       
     cec:	ff ff 00    	nop       
     cee:	ff ff 00    	nop       
     cf0:	ff ff 00    	nop       
     cf2:	ff ff 00    	nop       
     cf4:	ff ff 00    	nop       
     cf6:	ff ff 00    	nop       
     cf8:	ff ff 00    	nop       
     cfa:	ff ff 00    	nop       
     cfc:	ff ff 00    	nop       
     cfe:	ff ff 00    	nop       
     d00:	ff ff 00    	nop       
     d02:	ff ff 00    	nop       
     d04:	ff ff 00    	nop       
     d06:	ff ff 00    	nop       
     d08:	ff ff 00    	nop       
     d0a:	ff ff 00    	nop       
     d0c:	ff ff 00    	nop       
     d0e:	ff ff 00    	nop       
     d10:	ff ff 00    	nop       
     d12:	ff ff 00    	nop       
     d14:	ff ff 00    	nop       
     d16:	ff ff 00    	nop       
     d18:	ff ff 00    	nop       
     d1a:	ff ff 00    	nop       
     d1c:	ff ff 00    	nop       
     d1e:	ff ff 00    	nop       
     d20:	ff ff 00    	nop       
     d22:	ff ff 00    	nop       
     d24:	ff ff 00    	nop       
     d26:	ff ff 00    	nop       
     d28:	ff ff 00    	nop       
     d2a:	ff ff 00    	nop       
     d2c:	ff ff 00    	nop       
     d2e:	ff ff 00    	nop       
     d30:	ff ff 00    	nop       
     d32:	ff ff 00    	nop       
     d34:	ff ff 00    	nop       
     d36:	ff ff 00    	nop       
     d38:	ff ff 00    	nop       
     d3a:	ff ff 00    	nop       
     d3c:	ff ff 00    	nop       
     d3e:	ff ff 00    	nop       
     d40:	ff ff 00    	nop       
     d42:	ff ff 00    	nop       
     d44:	ff ff 00    	nop       
     d46:	ff ff 00    	nop       
     d48:	ff ff 00    	nop       
     d4a:	ff ff 00    	nop       
     d4c:	ff ff 00    	nop       
     d4e:	ff ff 00    	nop       
     d50:	ff ff 00    	nop       
     d52:	ff ff 00    	nop       
     d54:	ff ff 00    	nop       
     d56:	ff ff 00    	nop       
     d58:	ff ff 00    	nop       
     d5a:	ff ff 00    	nop       
     d5c:	ff ff 00    	nop       
     d5e:	ff ff 00    	nop       
     d60:	ff ff 00    	nop       
     d62:	ff ff 00    	nop       
     d64:	ff ff 00    	nop       
     d66:	ff ff 00    	nop       
     d68:	ff ff 00    	nop       
     d6a:	ff ff 00    	nop       
     d6c:	ff ff 00    	nop       
     d6e:	ff ff 00    	nop       
     d70:	ff ff 00    	nop       
     d72:	ff ff 00    	nop       
     d74:	ff ff 00    	nop       
     d76:	ff ff 00    	nop       
     d78:	ff ff 00    	nop       
     d7a:	ff ff 00    	nop       
     d7c:	ff ff 00    	nop       
     d7e:	ff ff 00    	nop       
     d80:	ff ff 00    	nop       
     d82:	ff ff 00    	nop       
     d84:	ff ff 00    	nop       
     d86:	ff ff 00    	nop       
     d88:	ff ff 00    	nop       
     d8a:	ff ff 00    	nop       
     d8c:	ff ff 00    	nop       
     d8e:	ff ff 00    	nop       
     d90:	ff ff 00    	nop       
     d92:	ff ff 00    	nop       
     d94:	ff ff 00    	nop       
     d96:	ff ff 00    	nop       
     d98:	ff ff 00    	nop       
     d9a:	ff ff 00    	nop       
     d9c:	ff ff 00    	nop       
     d9e:	ff ff 00    	nop       
     da0:	ff ff 00    	nop       
     da2:	ff ff 00    	nop       
     da4:	ff ff 00    	nop       
     da6:	ff ff 00    	nop       
     da8:	ff ff 00    	nop       
     daa:	ff ff 00    	nop       
     dac:	ff ff 00    	nop       
     dae:	ff ff 00    	nop       
     db0:	ff ff 00    	nop       
     db2:	ff ff 00    	nop       
     db4:	ff ff 00    	nop       
     db6:	ff ff 00    	nop       
     db8:	ff ff 00    	nop       
     dba:	ff ff 00    	nop       
     dbc:	ff ff 00    	nop       
     dbe:	ff ff 00    	nop       
     dc0:	ff ff 00    	nop       
     dc2:	ff ff 00    	nop       
     dc4:	ff ff 00    	nop       
     dc6:	ff ff 00    	nop       
     dc8:	ff ff 00    	nop       
     dca:	ff ff 00    	nop       
     dcc:	ff ff 00    	nop       
     dce:	ff ff 00    	nop       
     dd0:	ff ff 00    	nop       
     dd2:	ff ff 00    	nop       
     dd4:	ff ff 00    	nop       
     dd6:	ff ff 00    	nop       
     dd8:	ff ff 00    	nop       
     dda:	ff ff 00    	nop       
     ddc:	ff ff 00    	nop       
     dde:	ff ff 00    	nop       
     de0:	ff ff 00    	nop       
     de2:	ff ff 00    	nop       
     de4:	ff ff 00    	nop       
     de6:	ff ff 00    	nop       
     de8:	ff ff 00    	nop       
     dea:	ff ff 00    	nop       
     dec:	ff ff 00    	nop       
     dee:	ff ff 00    	nop       
     df0:	ff ff 00    	nop       
     df2:	ff ff 00    	nop       
     df4:	ff ff 00    	nop       
     df6:	ff ff 00    	nop       
     df8:	ff ff 00    	nop       
     dfa:	ff ff 00    	nop       
     dfc:	ff ff 00    	nop       
     dfe:	ff ff 00    	nop       
     e00:	ff ff 00    	nop       
     e02:	ff ff 00    	nop       
     e04:	ff ff 00    	nop       
     e06:	ff ff 00    	nop       
     e08:	ff ff 00    	nop       
     e0a:	ff ff 00    	nop       
     e0c:	ff ff 00    	nop       
     e0e:	ff ff 00    	nop       
     e10:	ff ff 00    	nop       
     e12:	ff ff 00    	nop       
     e14:	ff ff 00    	nop       
     e16:	ff ff 00    	nop       
     e18:	ff ff 00    	nop       
     e1a:	ff ff 00    	nop       
     e1c:	ff ff 00    	nop       
     e1e:	ff ff 00    	nop       
     e20:	ff ff 00    	nop       
     e22:	ff ff 00    	nop       
     e24:	ff ff 00    	nop       
     e26:	ff ff 00    	nop       
     e28:	ff ff 00    	nop       
     e2a:	ff ff 00    	nop       
     e2c:	ff ff 00    	nop       
     e2e:	ff ff 00    	nop       
     e30:	ff ff 00    	nop       
     e32:	ff ff 00    	nop       
     e34:	ff ff 00    	nop       
     e36:	ff ff 00    	nop       
     e38:	ff ff 00    	nop       
     e3a:	ff ff 00    	nop       
     e3c:	ff ff 00    	nop       
     e3e:	ff ff 00    	nop       
     e40:	ff ff 00    	nop       
     e42:	ff ff 00    	nop       
     e44:	ff ff 00    	nop       
     e46:	ff ff 00    	nop       
     e48:	ff ff 00    	nop       
     e4a:	ff ff 00    	nop       
     e4c:	ff ff 00    	nop       
     e4e:	ff ff 00    	nop       
     e50:	ff ff 00    	nop       
     e52:	ff ff 00    	nop       
     e54:	ff ff 00    	nop       
     e56:	ff ff 00    	nop       
     e58:	ff ff 00    	nop       
     e5a:	ff ff 00    	nop       
     e5c:	ff ff 00    	nop       
     e5e:	ff ff 00    	nop       
     e60:	ff ff 00    	nop       
     e62:	ff ff 00    	nop       
     e64:	ff ff 00    	nop       
     e66:	ff ff 00    	nop       
     e68:	ff ff 00    	nop       
     e6a:	ff ff 00    	nop       
     e6c:	ff ff 00    	nop       
     e6e:	ff ff 00    	nop       
     e70:	ff ff 00    	nop       
     e72:	ff ff 00    	nop       
     e74:	ff ff 00    	nop       
     e76:	ff ff 00    	nop       
     e78:	ff ff 00    	nop       
     e7a:	ff ff 00    	nop       
     e7c:	ff ff 00    	nop       
     e7e:	ff ff 00    	nop       
     e80:	ff ff 00    	nop       
     e82:	ff ff 00    	nop       
     e84:	ff ff 00    	nop       
     e86:	ff ff 00    	nop       
     e88:	ff ff 00    	nop       
     e8a:	ff ff 00    	nop       
     e8c:	ff ff 00    	nop       
     e8e:	ff ff 00    	nop       
     e90:	ff ff 00    	nop       
     e92:	ff ff 00    	nop       
     e94:	ff ff 00    	nop       
     e96:	ff ff 00    	nop       
     e98:	ff ff 00    	nop       
     e9a:	ff ff 00    	nop       
     e9c:	ff ff 00    	nop       
     e9e:	ff ff 00    	nop       
     ea0:	ff ff 00    	nop       
     ea2:	ff ff 00    	nop       
     ea4:	ff ff 00    	nop       
     ea6:	ff ff 00    	nop       
     ea8:	ff ff 00    	nop       
     eaa:	ff ff 00    	nop       
     eac:	ff ff 00    	nop       
     eae:	ff ff 00    	nop       
     eb0:	ff ff 00    	nop       
     eb2:	ff ff 00    	nop       
     eb4:	ff ff 00    	nop       
     eb6:	ff ff 00    	nop       
     eb8:	ff ff 00    	nop       
     eba:	ff ff 00    	nop       
     ebc:	ff ff 00    	nop       
     ebe:	ff ff 00    	nop       
     ec0:	ff ff 00    	nop       
     ec2:	ff ff 00    	nop       
     ec4:	ff ff 00    	nop       
     ec6:	ff ff 00    	nop       
     ec8:	ff ff 00    	nop       
     eca:	ff ff 00    	nop       
     ecc:	ff ff 00    	nop       
     ece:	ff ff 00    	nop       
     ed0:	ff ff 00    	nop       
     ed2:	ff ff 00    	nop       
     ed4:	ff ff 00    	nop       
     ed6:	ff ff 00    	nop       
     ed8:	ff ff 00    	nop       
     eda:	ff ff 00    	nop       
     edc:	ff ff 00    	nop       
     ede:	ff ff 00    	nop       
     ee0:	ff ff 00    	nop       
     ee2:	ff ff 00    	nop       
     ee4:	ff ff 00    	nop       
     ee6:	ff ff 00    	nop       
     ee8:	ff ff 00    	nop       
     eea:	ff ff 00    	nop       
     eec:	ff ff 00    	nop       
     eee:	ff ff 00    	nop       
     ef0:	ff ff 00    	nop       
     ef2:	ff ff 00    	nop       
     ef4:	ff ff 00    	nop       
     ef6:	ff ff 00    	nop       
     ef8:	ff ff 00    	nop       
     efa:	ff ff 00    	nop       
     efc:	ff ff 00    	nop       
     efe:	ff ff 00    	nop       
     f00:	ff ff 00    	nop       
     f02:	ff ff 00    	nop       
     f04:	ff ff 00    	nop       
     f06:	ff ff 00    	nop       
     f08:	ff ff 00    	nop       
     f0a:	ff ff 00    	nop       
     f0c:	ff ff 00    	nop       
     f0e:	ff ff 00    	nop       
     f10:	ff ff 00    	nop       
     f12:	ff ff 00    	nop       
     f14:	ff ff 00    	nop       
     f16:	ff ff 00    	nop       
     f18:	ff ff 00    	nop       
     f1a:	ff ff 00    	nop       
     f1c:	ff ff 00    	nop       
     f1e:	ff ff 00    	nop       
     f20:	ff ff 00    	nop       
     f22:	ff ff 00    	nop       
     f24:	ff ff 00    	nop       
     f26:	ff ff 00    	nop       
     f28:	ff ff 00    	nop       
     f2a:	ff ff 00    	nop       
     f2c:	ff ff 00    	nop       
     f2e:	ff ff 00    	nop       
     f30:	ff ff 00    	nop       
     f32:	ff ff 00    	nop       
     f34:	ff ff 00    	nop       
     f36:	ff ff 00    	nop       
     f38:	ff ff 00    	nop       
     f3a:	ff ff 00    	nop       
     f3c:	ff ff 00    	nop       
     f3e:	ff ff 00    	nop       
     f40:	ff ff 00    	nop       
     f42:	ff ff 00    	nop       
     f44:	ff ff 00    	nop       
     f46:	ff ff 00    	nop       
     f48:	ff ff 00    	nop       
     f4a:	ff ff 00    	nop       
     f4c:	ff ff 00    	nop       
     f4e:	ff ff 00    	nop       
     f50:	ff ff 00    	nop       
     f52:	ff ff 00    	nop       
     f54:	ff ff 00    	nop       
     f56:	ff ff 00    	nop       
     f58:	ff ff 00    	nop       
     f5a:	ff ff 00    	nop       
     f5c:	ff ff 00    	nop       
     f5e:	ff ff 00    	nop       
     f60:	ff ff 00    	nop       
     f62:	ff ff 00    	nop       
     f64:	ff ff 00    	nop       
     f66:	ff ff 00    	nop       
     f68:	ff ff 00    	nop       
     f6a:	ff ff 00    	nop       
     f6c:	ff ff 00    	nop       
     f6e:	ff ff 00    	nop       
     f70:	ff ff 00    	nop       
     f72:	ff ff 00    	nop       
     f74:	ff ff 00    	nop       
     f76:	ff ff 00    	nop       
     f78:	ff ff 00    	nop       
     f7a:	ff ff 00    	nop       
     f7c:	ff ff 00    	nop       
     f7e:	ff ff 00    	nop       
     f80:	ff ff 00    	nop       
     f82:	ff ff 00    	nop       
     f84:	ff ff 00    	nop       
     f86:	ff ff 00    	nop       
     f88:	ff ff 00    	nop       
     f8a:	ff ff 00    	nop       
     f8c:	ff ff 00    	nop       
     f8e:	ff ff 00    	nop       
     f90:	ff ff 00    	nop       
     f92:	ff ff 00    	nop       
     f94:	ff ff 00    	nop       
     f96:	ff ff 00    	nop       
     f98:	ff ff 00    	nop       
     f9a:	ff ff 00    	nop       
     f9c:	ff ff 00    	nop       
     f9e:	ff ff 00    	nop       
     fa0:	ff ff 00    	nop       
     fa2:	ff ff 00    	nop       
     fa4:	ff ff 00    	nop       
     fa6:	ff ff 00    	nop       
     fa8:	ff ff 00    	nop       
     faa:	ff ff 00    	nop       
     fac:	ff ff 00    	nop       
     fae:	ff ff 00    	nop       
     fb0:	ff ff 00    	nop       
     fb2:	ff ff 00    	nop       
     fb4:	ff ff 00    	nop       
     fb6:	ff ff 00    	nop       
     fb8:	ff ff 00    	nop       
     fba:	ff ff 00    	nop       
     fbc:	ff ff 00    	nop       
     fbe:	ff ff 00    	nop       
     fc0:	ff ff 00    	nop       
     fc2:	ff ff 00    	nop       
     fc4:	ff ff 00    	nop       
     fc6:	ff ff 00    	nop       
     fc8:	ff ff 00    	nop       
     fca:	ff ff 00    	nop       
     fcc:	ff ff 00    	nop       
     fce:	ff ff 00    	nop       
     fd0:	ff ff 00    	nop       
     fd2:	ff ff 00    	nop       
     fd4:	ff ff 00    	nop       
     fd6:	ff ff 00    	nop       
     fd8:	ff ff 00    	nop       
     fda:	ff ff 00    	nop       
     fdc:	ff ff 00    	nop       
     fde:	ff ff 00    	nop       
     fe0:	ff ff 00    	nop       
     fe2:	ff ff 00    	nop       
     fe4:	ff ff 00    	nop       
     fe6:	ff ff 00    	nop       
     fe8:	ff ff 00    	nop       
     fea:	ff ff 00    	nop       
     fec:	ff ff 00    	nop       
     fee:	ff ff 00    	nop       
     ff0:	ff ff 00    	nop       
     ff2:	ff ff 00    	nop       
     ff4:	ff ff 00    	nop       
     ff6:	ff ff 00    	nop       
     ff8:	ff ff 00    	nop       
     ffa:	ff ff 00    	nop       
     ffc:	ff ff 00    	nop       
     ffe:	ff ff 00    	nop       
    1000:	47 45 00    	nop       
    1002:	4e 53 00    	nop       

00001004 <ver_data>:
    1004:	03 00 00    	nop       
    1006:	02 00 00    	nop       
    1008:	18 00 00    	nop       
    100a:	0a 00 00    	nop       
    100c:	01 00 00    	nop       
    100e:	20 00 00    	nop       

00001010 <__T1Interrupt>:
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	.include	"Boot.inc"
	.include	"flash.inc"

;											
;				0 x 1 0 0 0    (physical)				
;_______________________________________________________________________________________
	.org	0x1000-0x1BE, 0xFF	;   * * *   0x1000 (fill 0xFF's)
; general segment
	.ascii	"GENS"		; general segment start
; Ver/Rev/Year/Month/Day/Maker
ver_data:
	.word	Ver
	.word	Rev
	.word	Year
	.word	Month
	.word	Day
	.word	Maker
; IVT 
.global __T1Interrupt		; must be @ 0x1000
__T1Interrupt:
	goto	T1Int
    1010:	8c 29 04    	goto      0x298c <T1Int>
    1012:	00 00 00 

00001014 <__T3Interrupt>:
.global __T3Interrupt		; must be @ 0x1004
__T3Interrupt:
	goto	T3Int
    1014:	ce 31 04    	goto      0x31ce <T3Int>
    1016:	00 00 00 

00001018 <_INT1Interrupt>:
.global	_INT1Interrupt		; must be @ 0x1008
_INT1Interrupt:
	goto	INT1Int
    1018:	32 32 04    	goto      0x3232 <INT1Int>
    101a:	00 00 00 

0000101c <_INT2Interrupt>:
.global	_INT2Interrupt		; must be @ 0x100C
_INT2Interrupt:
	goto	INT2Int
    101c:	26 32 04    	goto      0x3226 <INT2Int>
    101e:	00 00 00 

00001020 <__U1RXInterrupt>:
.global __U1RXInterrupt		; must be @ 0x1010
__U1RXInterrupt:
	goto	U1RXInt
    1020:	d6 31 04    	goto      0x31d6 <U1RXInt>
    1022:	00 00 00 

00001024 <__U1ErrInterrupt>:
.global __U1ErrInterrupt	; must be @ 0x1014
__U1ErrInterrupt:
	goto	U1ErrInt
    1024:	1a 32 04    	goto      0x321a <U1ErrInt>
    1026:	00 00 00 

00001028 <__U2RXInterrupt>:
.global __U2RXInterrupt		; must be @ 0x1018
__U2RXInterrupt:
	goto	U2RXInt
    1028:	22 32 04    	goto      0x3222 <U2RXInt>
    102a:	00 00 00 

0000102c <__U2ErrInterrupt>:
.global __U2ErrInterrupt	; must be @ 0x101C
__U2ErrInterrupt:
	goto	U2ErrInt
    102c:	2a 32 04    	goto      0x322a <U2ErrInt>
    102e:	00 00 00 

00001030 <selfcheck_back>:

; **********************************************************************

selfcheck_back:
; ini Mode specific params
	mov	#Ram+11,w8
    1030:	b8 80 20    	mov.w     #0x80b, w8
	mov	#Rom,w9
    1032:	09 00 22    	mov.w     #0x2000, w9
	mov	w9,SSTempPMAddr
    1034:	29 4a 88    	mov.w     w9, 0x944
	mov	w9,RunTempPMAddr
    1036:	a9 4a 88    	mov.w     w9, 0x954
	mov	#Ram,w10
    1038:	0a 80 20    	mov.w     #0x800, w10
	clr	w11
    103a:	80 05 eb    	clr.w     w11
	clr	w12
    103c:	00 06 eb    	clr.w     w12
	clr	w13
    103e:	80 06 eb    	clr.w     w13
	clr	w14
    1040:	00 07 eb    	clr.w     w14
	mov	w9,History_w9
    1042:	19 48 88    	mov.w     w9, 0x902
; ini Rx FIFO
	mov	#RX_buf,w0
    1044:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1046:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1048:	f0 4d 88    	mov.w     w0, 0x9be
; ini function LEDs on Cathode 17
	mov	#0b0000100010001000,w0	; ALU def (Set ALU, SEL, -CLK)
    104a:	80 88 20    	mov.w     #0x888, w0
	mov	w0,A16
    104c:	70 4d 88    	mov.w     w0, 0x9ae
; ini SFR
	mov	#3,w0
    104e:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,SerCtrl
    1050:	f5 e8 b7    	mov.b     WREG, 0x8f5
	call	def_U1BRG
    1052:	c6 27 02    	call      0x27c6 <def_U1BRG>
    1054:	00 00 00 
	call	rxtx_to_rxtxpos
    1056:	fe 27 02    	call      0x27fe <rxtx_to_rxtxpos>
    1058:	00 00 00 
	call	show_vrymd
    105a:	b6 10 02    	call      0x10b6 <show_vrymd>
    105c:	00 00 00 
; show CHS in the middle of matrix
	mov	#0,w1
    105e:	01 00 20    	mov.w     #0x0, w1
	mov	#0x1000/2,w2
    1060:	02 80 20    	mov.w     #0x800, w2
	mov	#CHS1,w4	; point w4 to CHS1
    1062:	84 9d 20    	mov.w     #0x9d8, w4
	call	get_chs
    1064:	a0 10 02    	call      0x10a0 <get_chs>
    1066:	00 00 00 
; show CHS in the bottom of matrix
	mov	#0x1000,w1
    1068:	01 00 21    	mov.w     #0x1000, w1
	mov	#tbloffset(pgm_end)-0x1000,w2
    106a:	02 8f 22    	mov.w     #0x28f0, w2
	lsr	w2,w2		; /2
    106c:	02 01 d1    	lsr.w     w2, w2
	mov	#CHS2,w4	; point w4 to CHS2
    106e:	a4 9d 20    	mov.w     #0x9da, w4
	call	get_chs
    1070:	a0 10 02    	call      0x10a0 <get_chs>
    1072:	00 00 00 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	bset	Flag2,#4	; #4 set when initialized
    1074:	de 89 a8    	bset.b    0x9de, #0x4
	call	peek_flash	; record flash occupance  (37 ms)
    1076:	46 17 02    	call      0x1746 <peek_flash>
    1078:	00 00 00 
; -----------------------------
; ini perif
	clr	TMR1
    107a:	90 21 ef    	clr.w     0x190
	clr	TMR2
    107c:	96 21 ef    	clr.w     0x196
	clr	TMR3
    107e:	9a 21 ef    	clr.w     0x19a
	bset	T1CON,#TON	; LED multiplex timer on
    1080:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON
    1082:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON
    1084:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    1086:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    1088:	99 00 a8    	bset.b    0x99, #0x0
	bset	IEC0,#11	; enable RX1 interrupt
    108a:	99 60 a8    	bset.b    0x99, #0x3
	bset	IEC4,#1		; enable RX1 Error Interrupt
    108c:	a0 20 a8    	bset.b    0xa0, #0x1
	bset	INTCON2,#GIE	; global interrupt enable
    108e:	83 e0 a8    	bset.b    0x83, #0x7

00001090 <main_farm>:

;------------------------------------------------------------------------
;------------------------------------------------------------------------
;---------------------------   F A R M   --------------------------------
;------------------------------------------------------------------------
;------------------------------------------------------------------------

main_farm:
	bra	alu_ept
    1090:	2e 00 37    	bra       0x10ee <alu_ept>

00001092 <txword>:

;											
txword:				; TX w0_low, w0_high
	call	txbyte
    1092:	98 10 02    	call      0x1098 <txbyte>
    1094:	00 00 00 
	swap	w0
    1096:	00 80 fd    	swap.w    w0

00001098 <txbyte>:
txbyte:				; TX w0
	btsc	U1STA,#UTXBF
    1098:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	txbyte
    109a:	fe ff 37    	bra       0x1098 <txbyte>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    109c:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    109e:	00 00 06    	return    

000010a0 <get_chs>:

;											
get_chs:		; pointer w1, length (in words) w2, CHS in w3 on exit, wr ptr w4
	clr	w3
    10a0:	80 01 eb    	clr.w     w3

000010a2 <chs_loop>:
chs_loop:
	tblrdh.b [w1],w0
    10a2:	11 c0 ba    	tblrdh.b  [w1], w0
	ze	w0,w0
    10a4:	00 80 fb    	ze        w0, w0
	add	w0,w3,w3
    10a6:	83 01 40    	add.w     w0, w3, w3
	tblrdl	[w1++],w0
    10a8:	31 00 ba    	tblrdl.w  [w1++], w0
	add	w0,w3,w3
    10aa:	83 01 40    	add.w     w0, w3, w3
	dec	w2,w2
    10ac:	02 01 e9    	dec.w     w2, w2
	bra	nz,chs_loop
    10ae:	f9 ff 3a    	bra       NZ, 0x10a2 <chs_loop>
; CHS is in w3
	swap	w3	; because display routine shows in little endian, should be big
    10b0:	03 80 fd    	swap.w    w3
	mov	w3,[w4]
    10b2:	03 0a 78    	mov.w     w3, [w4]
	return
    10b4:	00 00 06    	return    

000010b6 <show_vrymd>:

;-----------------------
show_vrymd:	; show Ver/Rev/Year/Month/Day/Maker
	mov	#Ram+0,w1
    10b6:	01 80 20    	mov.w     #0x800, w1
	mov	#tbloffset(ver_data),w3
    10b8:	43 00 21    	mov.w     #0x1004, w3
	call	vrymd
    10ba:	ce 10 02    	call      0x10ce <vrymd>
    10bc:	00 00 00 
	call	vrymd
    10be:	ce 10 02    	call      0x10ce <vrymd>
    10c0:	00 00 00 
	call	vrymd
    10c2:	ce 10 02    	call      0x10ce <vrymd>
    10c4:	00 00 00 
	call	vrymd
    10c6:	ce 10 02    	call      0x10ce <vrymd>
    10c8:	00 00 00 
	call	vrymd
    10ca:	ce 10 02    	call      0x10ce <vrymd>
    10cc:	00 00 00 

000010ce <vrymd>:
vrymd:			; Ver/Rev/Year/Month/Day/Maker
	tblrdl	[w3++],w2
    10ce:	33 01 ba    	tblrdl.w  [w3++], w2
	and	w2,#0xF,w0
    10d0:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	w0,[w1]
    10d2:	80 48 78    	mov.b     w0, [w1]
	lsr	w2,#4,w0
    10d4:	44 10 de    	lsr.w     w2, #0x4, w0
	mov.b	w0,[w1+16]
    10d6:	80 50 98    	mov.b     w0, [w1+16]
	inc	w1,w1
    10d8:	81 00 e8    	inc.w     w1, w1
	return
    10da:	00 00 06    	return    

000010dc <clr_ram>:
;-----------------------
clr_ram:
	mov	#Ram,w0
    10dc:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clear all exept SFR
    10de:	77 00 09    	repeat    #0x77
	clr	[w0++]
    10e0:	00 18 eb    	clr.w     [w0++]
	return
    10e2:	00 00 06    	return    

000010e4 <w0ms>:
;------------------------------------------------------------------------
w0ms:
	repeat	#16000-1
    10e4:	7f 3e 09    	repeat    #0x3e7f
	nop
    10e6:	00 00 00    	nop       
	dec	w0,w0
    10e8:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms
    10ea:	fc ff 3a    	bra       NZ, 0x10e4 <w0ms>
	return
    10ec:	00 00 06    	return    

000010ee <alu_ept>:

alu_ept:	; <-------------------------------------------
; prepare A16 (set ALU and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    10ee:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    10f0:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000100000001000,w0	; set ALU and -CLK
    10f2:	80 80 20    	mov.w     #0x808, w0
	ior	A16
    10f4:	ae 29 b7    	ior.w     0x9ae
; restore ALU params
	mov	AluTempOpcode,w0
    10f6:	90 49 80    	mov.w     0x932, w0
	mov	w0,Opcode	; Opcode
    10f8:	10 49 88    	mov.w     w0, 0x922
	mov	AluTempOperX,w0
    10fa:	a0 49 80    	mov.w     0x934, w0
	mov	w0,OperX	; OperX
    10fc:	20 49 88    	mov.w     w0, 0x924
	mov	AluTempOperY,w0
    10fe:	b0 49 80    	mov.w     0x936, w0
	mov	w0,OperY	; OperY
    1100:	30 49 88    	mov.w     w0, 0x926
	mov	AluTempAtemp,w0
    1102:	c0 49 80    	mov.w     0x938, w0
	mov	w0,Atemp	; Accu temp
    1104:	40 49 88    	mov.w     w0, 0x928
	mov	AluTempw14,w14	; Accu Out
    1106:	ee 49 80    	mov.w     0x93c, w14
	mov	AluTempw13,w13	; Accu In
    1108:	dd 49 80    	mov.w     0x93a, w13
; repair all blinking (non-existing) combinations
	mov	#8,w1
    110a:	81 00 20    	mov.w     #0x8, w1
	mov	Opcode,WREG	; affects Z flag
    110c:	22 89 bf    	mov.w     0x922, WREG
	bra	z,eight_bit_opc	; if eight bit opcode
    110e:	04 00 32    	bra       Z, 0x1118 <eight_bit_opc>
	cp	w0,#9
    1110:	69 00 e1    	cp.w      w0, #0x9
	ifc			; if Opcode >= 9...
    1112:	42 00 af    	btsc.b    0x42, #0x0
	mov	w1,Opcode	; ...then fix it to 8
    1114:	11 49 88    	mov.w     w1, 0x922
	bra	fixed
    1116:	09 00 37    	bra       0x112a <fixed>

00001118 <eight_bit_opc>:
eight_bit_opc:
	mov	#2,w1
    1118:	21 00 20    	mov.w     #0x2, w1
	mov	OperX,w0
    111a:	20 49 80    	mov.w     0x924, w0
	cp	w0,#2		; 2 = INC RY, legal instruction
    111c:	62 00 e1    	cp.w      w0, #0x2
	bra	z,fixed
    111e:	05 00 32    	bra       Z, 0x112a <fixed>
	cp	w0,#3		; 3 = DEC RY, legal instruction
    1120:	63 00 e1    	cp.w      w0, #0x3
	bra	z,fixed
    1122:	03 00 32    	bra       Z, 0x112a <fixed>
	cp	w0,#13		; 13 = RRC RY, legal instruction
    1124:	6d 00 e1    	cp.w      w0, #0xd
	ifnz
    1126:	42 20 ae    	btss.b    0x42, #0x1
	mov	w1,OperX	; if unlegal, fix it to 2
    1128:	21 49 88    	mov.w     w1, 0x924

0000112a <fixed>:
fixed:
; restore ALU flags
	mov	AluTempVflag,w0
    112a:	f0 49 80    	mov.w     0x93e, w0
	mov	w0,Vflag
    112c:	80 49 88    	mov.w     w0, 0x930
	mov	AluTempZflag,w0
    112e:	00 4a 80    	mov.w     0x940, w0
	mov	w0,Zflag
    1130:	70 49 88    	mov.w     w0, 0x92e
	mov	AluTempCflag,w0
    1132:	10 4a 80    	mov.w     0x942, w0
	mov	w0,Cflag
    1134:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    1136:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    1138:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    113a:	af 89 a8    	bset.b    0x9af, #0x4
; initialize ALU
	clr	Mode			; 0 = ALU
    113c:	76 29 ef    	clr.w     0x976
	clr	BlinkFlag
    113e:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    1140:	54 20 ef    	clr.w     0x54
	mov	w9,PgmTempPMAddr
    1142:	29 4b 88    	mov.w     w9, 0x964
	clr.b	Page
    1144:	f0 68 ef    	clr.b     0x8f0
	clr	Stack
    1146:	2a 29 ef    	clr.w     0x92a
	clr	w9
    1148:	80 04 eb    	clr.w     w9
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    114a:	dc 49 a8    	bset.b    0x9dc, #0x2
	mov	#1,w0
    114c:	10 00 20    	mov.w     #0x1, w0
	cp0.b	Speed
    114e:	f1 48 e2    	cp0.b     0x8f1
	ifz
    1150:	42 20 af    	btsc.b    0x42, #0x1
	mov.b	WREG,Speed
    1152:	f1 e8 b7    	mov.b     WREG, 0x8f1
	mov	#0b011100000,w0	; autorpt for Opcode, OperX, OperY
    1154:	00 0e 20    	mov.w     #0xe0, w0
	mov	w0,AutorptFlag
    1156:	60 4d 88    	mov.w     w0, 0x9ac

00001158 <alu_farm>:
;------------------------------
alu_farm:			; <------------
	bset	IEC0,#11	; enable RX1 interrupt
    1158:	99 60 a8    	bset.b    0x99, #0x3
; IN register service
	mov	#PORTB,w0
    115a:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    115c:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    115e:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    1160:	0b e8 b7    	mov.b     WREG, 0x80b
; read instruction opcode
	mov	Opcode,w0	; read instruction opcode here...
    1162:	10 49 80    	mov.w     0x922, w0
	mov	OperX,w11	; ...or here
    1164:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12
    1166:	3c 49 80    	mov.w     0x926, w12
	cp0	w0		; w0 = Opcode
    1168:	00 00 e0    	cp0.w     w0
	bra	z,jpt_8alu	; if it's 8-bit opcode
    116a:	12 00 32    	bra       Z, 0x1190 <jpt_8alu>
	mov	#OperX,w7	; default result write address
    116c:	47 92 20    	mov.w     #0x924, w7
; w0 = table pos
	bra	w0
    116e:	00 60 01    	bra       w0
;jp table
	bra	alu_cmd	   ; impossible instruction
    1170:	27 00 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>
	bra	alu_A1	   ; ADD  RX,RY
    1172:	af 02 37    	bra       0x16d2 <alu_A1>
	bra	alu_A2	   ; ADC  RX,RY
    1174:	b3 02 37    	bra       0x16dc <alu_A2>
	bra	alu_A3	   ; SUB  RX,RY
    1176:	b7 02 37    	bra       0x16e6 <alu_A3>
	bra	alu_A4	   ; SBB  RX,RY
    1178:	bb 02 37    	bra       0x16f0 <alu_A4>
	bra	alu_A5	   ; OR   RX,RY
    117a:	bf 02 37    	bra       0x16fa <alu_A5>
	bra	alu_A6	   ; AND  RX,RY
    117c:	c3 02 37    	bra       0x1704 <alu_A6>
	bra	alu_A7	   ; XOR  RX,RY
    117e:	c7 02 37    	bra       0x170e <alu_A7>
	bra	alu_A8	   ; MOV  RX,RY
    1180:	cb 02 37    	bra       0x1718 <alu_A8>
	bra	alu_blink1 ; MOV  RX,RY   (non-existing in ALU mode)
    1182:	18 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; MOV  RX,N    (non-existing in ALU mode)
    1184:	17 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; MOV  [XY],R0 (non-existing in ALU mode)
    1186:	16 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[XY] (non-existing in ALU mode)
    1188:	15 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; MOV  [NN],R0 (non-existing in ALU mode)
    118a:	14 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[NN] (non-existing in ALU mode)
    118c:	13 00 37    	bra       0x11b4 <alu_blink1>
	bra	alu_blink1 ; JR   NN      (non-existing in ALU mode)
    118e:	12 00 37    	bra       0x11b4 <alu_blink1>

00001190 <jpt_8alu>:

jpt_8alu:
	mov	#Dummy,w7	; default result write address (R0 = Accu in)
    1190:	07 9b 20    	mov.w     #0x9b0, w7
; w0 = table pos
	bra	w11
    1192:	0b 60 01    	bra       w11
;jp table
	bra	alu_blink2   ; CP   R0,N    (uses R0)
    1194:	12 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; ADD  R0,N    (uses R0)
    1196:	11 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_G2	     ; INC  RY
    1198:	c4 02 37    	bra       0x1722 <alu_G2>
	bra	alu_G3	     ; DEC  RY
    119a:	c9 02 37    	bra       0x172e <alu_G3>
	bra	alu_blink2   ; DSZ  RY      (non-existing in ALU mode)
    119c:	0e 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; OR   R0,N    (uses R0)
    119e:	0d 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; AND  R0,N    (uses R0)
    11a0:	0c 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; XOR  R0,N    (uses R0)
    11a2:	0b 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; EXR  N       (non-existing in ALU mode)
    11a4:	0a 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; BIT  RG,M    (uses R0)
    11a6:	09 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; BSET RG,M    (uses R0)
    11a8:	08 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; BCLR RG,M    (uses R0)
    11aa:	07 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; BTG  RG,M    (uses R0)
    11ac:	06 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_G13	     ; RRC  RY
    11ae:	c5 02 37    	bra       0x173a <alu_G13>
	bra	alu_blink2   ; RET  RY,N    (non-existing in ALU mode)
    11b0:	04 00 37    	bra       0x11ba <alu_blink2>
	bra	alu_blink2   ; SKIP F,M     (non-existing in ALU mode)
    11b2:	03 00 37    	bra       0x11ba <alu_blink2>

000011b4 <alu_blink1>:
;...
; --------------------------------------------------------------------

alu_blink1:			; if non-existent, instruction column 1 should blink
	bset	BlinkFlag,#0
    11b4:	e0 09 a8    	bset.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    11b6:	e0 29 a9    	bclr.b    0x9e0, #0x1
	bra	alu_wait_key
    11b8:	03 00 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000011ba <alu_blink2>:
alu_blink2:			; if non-existent, instruction column 2 should blink
	bclr	BlinkFlag,#0
    11ba:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bset	BlinkFlag,#1
    11bc:	e0 29 a8    	bset.b    0x9e0, #0x1
	bra	alu_wait_key
    11be:	00 00 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000011c0 <alu_cmd>:

;-------------------------------
alu_cmd:			; w11 = Transfer Flag
alu_wait_key:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    11c0:	dc c9 af    	btsc.b    0x9dc, #0x6
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11c2:	df 09 a8    	bset.b    0x9df, #0x0
	mov	#PORTB,w0
    11c4:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    11c6:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    11c8:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    11ca:	0b e8 b7    	mov.b     WREG, 0x80b

	btss	Flag,#1		; #1 handshaking flag for buttons
    11cc:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	alu_wait_key
    11ce:	f8 ff 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>
	bclr	Flag,#1
    11d0:	dc 29 a9    	bclr.b    0x9dc, #0x1
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11d2:	df 09 af    	btsc.b    0x9df, #0x0
	bra	not_first
    11d4:	08 00 37    	bra       0x11e6 <not_first>
; first keypress, clear Ver/Rev
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11d6:	df 09 a8    	bset.b    0x9df, #0x0
	clr	Ram+0x00
    11d8:	00 28 ef    	clr.w     0x800
	clr	Ram+0x02
    11da:	02 28 ef    	clr.w     0x802
	clr	Ram+0x04
    11dc:	04 28 ef    	clr.w     0x804
	clr	Ram+0x10
    11de:	10 28 ef    	clr.w     0x810
	clr	Ram+0x12
    11e0:	12 28 ef    	clr.w     0x812
	clr	Ram+0x14
    11e2:	14 28 ef    	clr.w     0x814
	bra	alu_wait_key
    11e4:	ed ff 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000011e6 <not_first>:
not_first:
	bclr	BlinkFlag,#5	; switch off "SAVE blink" flag
    11e6:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bclr	BlinkFlag,#7	; switch off "LOAD blink" flag
    11e8:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	mov	Just,w0
    11ea:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    11ec:	65 00 e1    	cp.w      w0, #0x5
	ifc
    11ee:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    11f0:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    11f2:	00 60 01    	bra       w0
; jump table FOR BUTTONS
	bra	leave_alu_ept	; -------> next mode (Single Step)
    11f4:	b2 02 37    	bra       0x175a <leave_alu_ept>
	bra	button_CARRY
    11f6:	04 00 37    	bra       0x1200 <button_CARRY>
	bra	button_SAVE
    11f8:	05 00 37    	bra       0x1204 <button_SAVE>
	bra	button_LOAD
    11fa:	6a 00 37    	bra       0x12d0 <button_LOAD>
	bra	button_CLOCK
    11fc:	f3 00 37    	bra       0x13e4 <button_CLOCK>
	bra	general_alu_5
    11fe:	05 01 37    	bra       0x140a <general_alu_5>

00001200 <button_CARRY>:

; button entry points
; -----------------------------------------------------------------
button_CARRY:
	btg	A16,#b_carry
    1200:	af 89 aa    	btg.b     0x9af, #0x4
	bra	alu_farm
    1202:	aa ff 37    	bra       0x1158 <alu_farm>

00001204 <button_SAVE>:

; -----------------------------------------------------------------
; TX format:
; Header 00 FF 00 FF A5 C3
; file length (word count, 16-bit length, low byte first)
; message body (words, low byte first)
; checksum (16-bit sum of FILE LENGTH WORD plus MESSAGE BODY words, low byte first)

button_SAVE:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    1204:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    1206:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
    1208:	df 29 a9    	bclr.b    0x9df, #0x1
	bset	A16,#b_save	; led SAVE on
    120a:	af a9 a8    	bset.b    0x9af, #0x5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    120c:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	save2tx		; ALT not pressed: save to serial port
    120e:	05 00 37    	bra       0x121a <save2tx>
; ALT pressed: save to Flash
	mov	FlashAddr,w0
    1210:	00 4e 80    	mov.w     0x9c0, w0
	cp	w0,#15
    1212:	6f 00 e1    	cp.w      w0, #0xf
	bra	nc,save2flash	; save to flash, loc 0...14
    1214:	3e 00 39    	bra       NC, 0x1292 <save2flash>
	bclr	A16,#b_save	; led SAVE off
    1216:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	alu_farm
    1218:	9f ff 37    	bra       0x1158 <alu_farm>

0000121a <save2tx>:
save2tx:		; save to serial port
; save to serial port TX
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    121a:	14 28 02    	call      0x2814 <rxtx_to_io>
    121c:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    121e:	c6 27 02    	call      0x27c6 <def_U1BRG>
    1220:	00 00 00 
; measure the file length first
	mov	#0x1000,w5	; file length countdown (in words)
    1222:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom+0x1FFE,w3	; pointer backwards from the last program memory word
    1224:	e3 ff 23    	mov.w     #0x3ffe, w3

00001226 <L51>:
5:
	cp0	[w3--]		; test if word contains data
    1226:	23 00 e0    	cp0.w     [w3--]
	bra	nz,6f		; if found meaningful content >0000
    1228:	0a 00 3a    	bra       NZ, 0x123e <L63>
	dec	w5,w5
    122a:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    122c:	fc ff 3a    	bra       NZ, 0x1226 <L51>
	bset	A16,#b_save	; LED SAVE on
    122e:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    1230:	e0 a9 a8    	bset.b    0x9e0, #0x5

00001232 <waitany1>:
waitany1:
	btss	Flag,#1		; #1 = "key pressed" flag
    1232:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany1
    1234:	fe ff 37    	bra       0x1232 <waitany1>
	bclr	Flag,#1		; #1 = "key pressed" flag
    1236:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    1238:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    123a:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    123c:	40 00 37    	bra       0x12be <saveload_exit>

0000123e <L63>:
6:				; found >0000
; send header 00 FF 00 FF A5 C3 
	mov	#0xFF00,w0
    123e:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    1240:	92 10 02    	call      0x1092 <txword>
    1242:	00 00 00 
	mov	#0xFF00,w0
    1244:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    1246:	92 10 02    	call      0x1092 <txword>
    1248:	00 00 00 
	mov	#0xC3A5,w0
    124a:	50 3a 2c    	mov.w     #0xc3a5, w0
	call	txword		; ----> TX header A5 C3
    124c:	92 10 02    	call      0x1092 <txword>
    124e:	00 00 00 
; send file length w5 (in words)
	bset	A16,#b_save	; "SAVE" LED on
    1250:	af a9 a8    	bset.b    0x9af, #0x5
	mov	w5,w4		; w4 CHS
    1252:	05 02 78    	mov.w     w5, w4
	lsr	w5,#2,w2	; w2 file length/4, will be used in taskbar calculation
    1254:	42 29 de    	lsr.w     w5, #0x2, w2
	ifz
    1256:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    1258:	12 00 20    	mov.w     #0x1, w2
	mov	w5,w0
    125a:	05 00 78    	mov.w     w5, w0
	call	txword		; ----> TX record length in words 16-bit (little endian)
    125c:	92 10 02    	call      0x1092 <txword>
    125e:	00 00 00 
	mov	#Rom,w3		; program memory pointer from the beginning
    1260:	03 00 22    	mov.w     #0x2000, w3

00001262 <L52>:
; send message body (pointer w3, length w5)
5:			  ; \
	mov	[w3++],w0	; read word from program memory
    1262:	33 00 78    	mov.w     [w3++], w0
	add	w4,w0,w4	; update CHS
    1264:	00 02 42    	add.w     w4, w0, w4
	call	txword		; ----> TX data 16-bit (little endian, hi byte 0000xxxx)
    1266:	92 10 02    	call      0x1092 <txword>
    1268:	00 00 00 
; taskbar ------
	sl	w5,#3,w6	; w6 = w5 × 8
    126a:	43 2b dd    	sl.w      w5, #0x3, w6
	repeat	#17
    126c:	11 00 09    	repeat    #0x11
	div.u	w6,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    126e:	02 83 d8    	div.uw    w6, w2
	cp	w0,#31
    1270:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    1272:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    1274:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    1276:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    1278:	f1 ff 2f    	mov.w     #0xffff, w1
	sl	w1,w0,w1
    127a:	80 08 dd    	sl.w      w1, w0, w1
	mov	w1,Taskbar
    127c:	c1 4d 88    	mov.w     w1, 0x9b8

	dec	w5,w5
    127e:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b	  ; /
    1280:	f0 ff 3a    	bra       NZ, 0x1262 <L52>
; send checksum
	mov	w4,w0
    1282:	04 00 78    	mov.w     w4, w0
	call	txword		; ----> TX CHS 16-bit (little endian)
    1284:	92 10 02    	call      0x1092 <txword>
    1286:	00 00 00 
	mov	#140,w0
    1288:	c0 08 20    	mov.w     #0x8c, w0
	call	w0ms		; give some time to send the whole queue
    128a:	e4 10 02    	call      0x10e4 <w0ms>
    128c:	00 00 00 
; finale
	bclr	A16,#b_save	; "SAVE" LED off
    128e:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	saveload_exit
    1290:	16 00 37    	bra       0x12be <saveload_exit>

00001292 <save2flash>:

save2flash:		; save to flash
	mov	#0x1000,w5	; file length countdown (in words)
    1292:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom,w3		; pointer
    1294:	03 00 22    	mov.w     #0x2000, w3

00001296 <L53>:
5:
	cp0	[w3++]		; test if word contains data
    1296:	33 00 e0    	cp0.w     [w3++]
	bra	nz,6f		; if found meaningful content >0000
    1298:	0a 00 3a    	bra       NZ, 0x12ae <L64>
	dec	w5,w5
    129a:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    129c:	fc ff 3a    	bra       NZ, 0x1296 <L53>
	bset	A16,#b_save	; LED SAVE on
    129e:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    12a0:	e0 a9 a8    	bset.b    0x9e0, #0x5

000012a2 <waitany2>:
waitany2:
	btss	Flag,#1		; #1 = "key pressed" flag
    12a2:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany2
    12a4:	fe ff 37    	bra       0x12a2 <waitany2>
	bclr	Flag,#1		; #1 = "key pressed" flag
    12a6:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    12a8:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    12aa:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    12ac:	08 00 37    	bra       0x12be <saveload_exit>

000012ae <L64>:
6:			; found meaningful content >0000
	call	com_rom
    12ae:	fe 13 02    	call      0x13fe <com_rom>
    12b0:	00 00 00 
	mov	FlashAddr,w0
    12b2:	00 4e 80    	mov.w     0x9c0, w0
	call	eesavew0	; EEsave
    12b4:	44 02 02    	call      0x244 <eesavew0>
    12b6:	00 00 00 
	call	com_rom
    12b8:	fe 13 02    	call      0x13fe <com_rom>
    12ba:	00 00 00 
	bclr	A16,#b_save
    12bc:	af a9 a9    	bclr.b    0x9af, #0x5

000012be <saveload_exit>:
saveload_exit:
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxPos
    12be:	fe 27 02    	call      0x27fe <rxtx_to_rxtxpos>
    12c0:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    12c2:	ca 27 02    	call      0x27ca <set_U1BRG>
    12c4:	00 00 00 
	clr	Taskbar
    12c6:	b8 29 ef    	clr.w     0x9b8
	bclr	Flag,#1		; reset handshaking flag for buttons (ignore it during save!)
    12c8:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	peek_flash	; record flash occupance  (37 ms)
    12ca:	46 17 02    	call      0x1746 <peek_flash>
    12cc:	00 00 00 
	bra	alu_farm
    12ce:	44 ff 37    	bra       0x1158 <alu_farm>

000012d0 <button_LOAD>:

; ---------------------------------------------------------------------------------------

button_LOAD:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    12d0:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    12d2:	de e9 a9    	bclr.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
    12d4:	df 29 a8    	bset.b    0x9df, #0x1
	bset	A16,#b_load	; LED on
    12d6:	af c9 a8    	bset.b    0x9af, #0x6
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    12d8:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	nc,ALTload	; if ALT pressed: load from Flash
    12da:	56 00 39    	bra       NC, 0x1388 <ALTload>

000012dc <LoadFromRx>:
LoadFromRx:		; load from serial port
	bclr	IEC0,#11	; disable RX1 interrupt
    12dc:	99 60 a9    	bclr.b    0x99, #0x3
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    12de:	14 28 02    	call      0x2814 <rxtx_to_io>
    12e0:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    12e2:	c6 27 02    	call      0x27c6 <def_U1BRG>
    12e4:	00 00 00 

000012e6 <L65>:
; synchronize to header A5 C3
6:
	call	rxbyte_20s	; <---------- first RX attempt (timeout 20 sec)
    12e6:	b2 13 02    	call      0x13b2 <rxbyte_20s>
    12e8:	00 00 00 
	bra	c,rx_patience_1	; if patience lost or keypress
    12ea:	49 00 31    	bra       C, 0x137e <rx_patience_1>
	mov	#16,w5		; 16 attempts before giving up
    12ec:	05 01 20    	mov.w     #0x10, w5

000012ee <L54>:
5:
	call	rxbyte_4s	; <---------- attempt to RX header 1 (A5) (timeout 4 sec)
    12ee:	b6 13 02    	call      0x13b6 <rxbyte_4s>
    12f0:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    12f2:	5b 00 31    	bra       C, 0x13aa <rx_patience>
	sub	#0xA5,w0
    12f4:	50 0a b1    	sub.w     #0xa5, w0
	bra	z,found_header_a5
    12f6:	04 00 32    	bra       Z, 0x1300 <found_header_a5>
	dec	w5,w5
    12f8:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    12fa:	f9 ff 3a    	bra       NZ, 0x12ee <L54>
	mov	#0,w0
    12fc:	00 00 20    	mov.w     #0x0, w0
	bra	rx_patience	; giving up after 16 attempts to recognize header
    12fe:	55 00 37    	bra       0x13aa <rx_patience>

00001300 <found_header_a5>:
found_header_a5:
	call	rxbyte_500ms	; <---------- RX header 2 (C3)
    1300:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    1302:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1304:	52 00 31    	bra       C, 0x13aa <rx_patience>
	sub	#0xC3,w0
    1306:	30 0c b1    	sub.w     #0xc3, w0
	bra	nz,6b		; one more chance
    1308:	ee ff 3a    	bra       NZ, 0x12e6 <L65>
; header A5 C3 recognized, now get file length (low byte first)
	call	rxbyte_500ms	; <---------- RX file length low
    130a:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    130c:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    130e:	4d 00 31    	bra       C, 0x13aa <rx_patience>
	ze	w0,w3		; w3 first low byte (file length low)
    1310:	80 81 fb    	ze        w0, w3
	call	rxbyte_500ms	; <---------- RX file length high
    1312:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    1314:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    1316:	49 00 31    	bra       C, 0x13aa <rx_patience>
	sl	w0,#8,w0	; high byte go high
    1318:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w3,w3	; w3 file length (in words)
    131a:	83 01 70    	ior.w     w0, w3, w3
	mov	w3,w5		; w5 = CHS
    131c:	83 02 78    	mov.w     w3, w5
	lsr	w3,#2,w2	; w2 file length/4, will be used in taskbar calculation
    131e:	42 19 de    	lsr.w     w3, #0x2, w2
	ifz
    1320:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    1322:	12 00 20    	mov.w     #0x1, w2
	bra	z,only_timeout	; zero length - file too short (LOAD blinks)
    1324:	44 00 32    	bra       Z, 0x13ae <only_timeout>
	mov	#0x1001,w1	; max length+1 (number of words!)
    1326:	11 00 21    	mov.w     #0x1001, w1
	cp	w3,w1
    1328:	01 18 e1    	cp.w      w3, w1
	bra	c,only_timeout	; file too long (LOAD blinks)
    132a:	41 00 31    	bra       C, 0x13ae <only_timeout>
; receive message body
	mov	#Rom,w6		; write pointer
    132c:	06 00 22    	mov.w     #0x2000, w6

0000132e <L35>:
3:			; <-------- RX loop
	call	rxbyte_500ms	; <---------- RX message body low
    132e:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    1330:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1332:	3b 00 31    	bra       C, 0x13aa <rx_patience>
	ze	w0,w4
    1334:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX message body high
    1336:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    1338:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    133a:	37 00 31    	bra       C, 0x13aa <rx_patience>
	sl	w0,#8,w0	; high byte go high
    133c:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w4,w0
    133e:	04 00 70    	ior.w     w0, w4, w0
	mov	w0,[w6++]	; WRITE RECEIVED WORD
    1340:	00 1b 78    	mov.w     w0, [w6++]
	add	w0,w5,w5	; update CHS
    1342:	85 02 40    	add.w     w0, w5, w5

; taskbar ------
	sl	w3,#3,w1	; w1 = w5 × 8
    1344:	c3 18 dd    	sl.w      w3, #0x3, w1
	repeat	#17
    1346:	11 00 09    	repeat    #0x11
	div.u	w1,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    1348:	82 80 d8    	div.uw    w1, w2
	cp	w0,#31
    134a:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    134c:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    134e:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    1350:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    1352:	f1 ff 2f    	mov.w     #0xffff, w1
	lsr	w1,w0,w1	; taskbar progress  UP ---> DOWN
    1354:	80 08 de    	lsr.w     w1, w0, w1
	mov	w1,Taskbar
    1356:	c1 4d 88    	mov.w     w1, 0x9b8
	dec	w3,w3
    1358:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b		; loop
    135a:	e9 ff 3a    	bra       NZ, 0x132e <L35>
; receive checksum
	call	rxbyte_500ms	; <---------- RX CHS low
    135c:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    135e:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1360:	24 00 31    	bra       C, 0x13aa <rx_patience>
	ze	w0,w4
    1362:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX CHS high
    1364:	ba 13 02    	call      0x13ba <rxbyte_500ms>
    1366:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1368:	20 00 31    	bra       C, 0x13aa <rx_patience>
	swap	w0
    136a:	00 80 fd    	swap.w    w0
	ior	w0,w4,w0
    136c:	04 00 70    	ior.w     w0, w4, w0
	cp	w0,w5		; received CHS - calculated CHS
    136e:	05 00 e1    	cp.w      w0, w5
	bra	nz,rx_patience	; CHS does not match!
    1370:	1c 00 3a    	bra       NZ, 0x13aa <rx_patience>

00001372 <fill00>:
; RX finished, fill 00s to the end (pointer w6)
fill00:
	btsc	w6,#14		; #14 will be set when w6 reaches 0x4000
    1372:	06 e0 a7    	btsc.w    w6, #0xe
	bra	filled
    1374:	02 00 37    	bra       0x137a <filled>
	clr.b	[w6++]
    1376:	00 5b eb    	clr.b     [w6++]
	bra	fill00
    1378:	fc ff 37    	bra       0x1372 <fill00>

0000137a <filled>:
filled:
	bclr	A16,#b_load
    137a:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit	; -----> RX LOAD FINISHED
    137c:	a0 ff 37    	bra       0x12be <saveload_exit>

0000137e <rx_patience_1>:

;								
rx_patience_1:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0
    137e:	00 00 e0    	cp0.w     w0
	bra	z,only_timeout	; if no key pressed or gave up after 16 attempts to recognize header
    1380:	16 00 32    	bra       Z, 0x13ae <only_timeout>
	bclr	A16,#b_load	; LED LOAD off
    1382:	af c9 a9    	bclr.b    0x9af, #0x6
	bclr	BlinkFlag,#7	; no blinking
    1384:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	bra	saveload_exit	; key pressed, just exit
    1386:	9b ff 37    	bra       0x12be <saveload_exit>

00001388 <ALTload>:

;			
ALTload:		; ALT pressed, load from Flash
	bset	A16,#b_load
    1388:	af c9 a8    	bset.b    0x9af, #0x6
	call	com_rom
    138a:	fe 13 02    	call      0x13fe <com_rom>
    138c:	00 00 00 
	mov	#15,w0
    138e:	f0 00 20    	mov.w     #0xf, w0
	cp.b	FlashAddr
    1390:	c0 49 e3    	cp.b      0x9c0
	ifnz
    1392:	42 20 ae    	btss.b    0x42, #0x1
	call	eesavew0	; just in case, saved on record 15
    1394:	44 02 02    	call      0x244 <eesavew0>
    1396:	00 00 00 
	call	com_rom
    1398:	fe 13 02    	call      0x13fe <com_rom>
    139a:	00 00 00 

	mov	FlashAddr,w0
    139c:	00 4e 80    	mov.w     0x9c0, w0
	call	eeload
    139e:	46 02 02    	call      0x246 <eeload>
    13a0:	00 00 00 
	call	com_rom
    13a2:	fe 13 02    	call      0x13fe <com_rom>
    13a4:	00 00 00 
	bclr	A16,#b_load
    13a6:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit
    13a8:	8a ff 37    	bra       0x12be <saveload_exit>

000013aa <rx_patience>:
;			
rx_patience:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0		; w0=0 if no key pressed
    13aa:	00 00 e0    	cp0.w     w0
	ifnz			; if key pressed, then LED LOAD blinks = TIMEOUT
    13ac:	42 20 ae    	btss.b    0x42, #0x1

000013ae <only_timeout>:
only_timeout:
	bset	BlinkFlag,#7	; LED LOAD blinks = TIMEOUT
    13ae:	e0 e9 a8    	bset.b    0x9e0, #0x7
	bra	saveload_exit	; regular exit
    13b0:	86 ff 37    	bra       0x12be <saveload_exit>

000013b2 <rxbyte_20s>:

;											
rxbyte_20s:		; RX byte ---> w0 (NC), patience 20s (C set if pat lost)
	mov	#20000,w1	; patience 20 s
    13b2:	01 e2 24    	mov.w     #0x4e20, w1
	bra	1f
    13b4:	03 00 37    	bra       0x13bc <L14>

000013b6 <rxbyte_4s>:
rxbyte_4s:		; RX byte ---> w0 (NC), patience 4s (C set if pat lost)
	mov	#4000,w1	; patience 4 s
    13b6:	01 fa 20    	mov.w     #0xfa0, w1
	bra	1f
    13b8:	01 00 37    	bra       0x13bc <L14>

000013ba <rxbyte_500ms>:
rxbyte_500ms:		; RX byte ---> w0 (NC), patience 500 ms (C set if pat lost)
	mov	#500,w1		; patience 500 ms
    13ba:	41 1f 20    	mov.w     #0x1f4, w1

000013bc <L14>:
1:
	mov	#2240,w0	; inner loop 1 ms
    13bc:	00 8c 20    	mov.w     #0x8c0, w0

000013be <L23>:
2:
	btsc	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    13be:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	button_press_rx	; if button pressed
    13c0:	0d 00 37    	bra       0x13dc <button_press_rx>
	btsc	U1STAL,#URXDA	; bit set if RX data available
    13c2:	9a 03 af    	btsc.b    0x39a, #0x0
	bra	rx_arrived_2
    13c4:	07 00 37    	bra       0x13d4 <rx_arrived_2>
	dec	w0,w0
    13c6:	00 00 e9    	dec.w     w0, w0
	bra	nz,2b		; loop 7t × 2240 = 15680t = 1 ms (INT time estimated)
    13c8:	fa ff 3a    	bra       NZ, 0x13be <L23>
	dec	w1,w1
    13ca:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b		; loop 1 ms × 500 = 500 ms
    13cc:	f7 ff 3a    	bra       NZ, 0x13bc <L14>
;patience_lost
	mov	#0,w0		; flag no keys pressed (only timeout)
    13ce:	00 00 20    	mov.w     #0x0, w0
	setc			; Carry set = NOT OK
    13d0:	42 00 a8    	bset.b    0x42, #0x0
	return
    13d2:	00 00 06    	return    

000013d4 <rx_arrived_2>:
;				
rx_arrived_2:
	mov.b	U1RXREG,WREG	; <---- get received byte (this resets U1STAL,#URXDA)
    13d4:	9e c3 bf    	mov.b     0x39e, WREG
	ze	w0,w0
    13d6:	00 80 fb    	ze        w0, w0
	clrc
    13d8:	42 00 a9    	bclr.b    0x42, #0x0
	return
    13da:	00 00 06    	return    

000013dc <button_press_rx>:
;				
button_press_rx:
	bclr	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    13dc:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	#1,w0		; flag key pressed (not timeout)
    13de:	10 00 20    	mov.w     #0x1, w0
	setc			; Carry set = NOT OK
    13e0:	42 00 a8    	bset.b    0x42, #0x0
	return
    13e2:	00 00 06    	return    

000013e4 <button_CLOCK>:
; -----------------------------------------------------------------
button_CLOCK:
	mov	#3,w0
    13e4:	30 00 20    	mov.w     #0x3, w0
	and	BlinkFlag,WREG
    13e6:	e0 09 b6    	and.w     0x9e0, WREG
	bra	nz,alu_farm	; no execution if the instruction is illegal
    13e8:	b7 fe 3a    	bra       NZ, 0x1158 <alu_farm>

	bset	A16,#b_clk_key	; set CLK key
    13ea:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w11 bits to decide flag transfer
    13ec:	b6 14 02    	call      0x14b6 <transfer1>
    13ee:	00 00 00 

000013f0 <L15>:
1:
	inc	KeyRotors+8,WREG
    13f0:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,1b		; if not yet 0x11111111
    13f2:	fe ff 3a    	bra       NZ, 0x13f0 <L15>
	bclr	A16,#b_clk_key
    13f4:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w11 bits to decide flag transfer
    13f6:	9a 15 02    	call      0x159a <transfer2>
    13f8:	00 00 00 

	mov.b	w13,[w7]	; write result to destination
    13fa:	8d 4b 78    	mov.b     w13, [w7]
	bra	alu_farm
    13fc:	ad fe 37    	bra       0x1158 <alu_farm>

000013fe <com_rom>:

; **********************************************************************************************
com_rom:		; complement Rom 0x1800 bytes
	mov	#Rom,w2
    13fe:	02 00 22    	mov.w     #0x2000, w2
	mov	#0x1000,w1
    1400:	01 00 21    	mov.w     #0x1000, w1

00001402 <L16>:
1:
	com	[w2],[w2++]
    1402:	12 99 ea    	com.w     [w2], [w2++]
	dec	w1,w1
    1404:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    1406:	fd ff 3a    	bra       NZ, 0x1402 <L16>
	return
    1408:	00 00 06    	return    

0000140a <general_alu_5>:

; --------------------------------------------------------------------------------------
; buttons Opcode - OperX - OperY - DataIn						
; --------------------------------------------------------------------------------------

general_alu_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	alu_key_3
    140a:	10 14 02    	call      0x1410 <alu_key_3>
    140c:	00 00 00 
	bra	alu_farm
    140e:	a4 fe 37    	bra       0x1158 <alu_farm>

00001410 <alu_key_3>:
; ------------------------------
alu_key_3:		; Opcode-OperX-OperY --- Dim-Dummy-FlashAddr
	mov	#Opcode,w3
    1410:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    1412:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    1414:	65 92 20    	mov.w     #0x926, w5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1416:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    1418:	1b 00 37    	bra       0x1450 <general>
	mov	#Dimmer,w3
    141a:	e3 8f 20    	mov.w     #0x8fe, w3
	mov	#SerCtrl,w4
    141c:	54 8f 20    	mov.w     #0x8f5, w4
	bclr.b	[w4],#3		; spec case: Buad Rate can't be greater than 7
    141e:	14 34 a1    	bclr.b    [w4], #0x3
	mov	#FlashAddr,w5
    1420:	05 9c 20    	mov.w     #0x9c0, w5
	call	general
    1422:	50 14 02    	call      0x1450 <general>
    1424:	00 00 00 
	bclr.b	SerCtrl,#3	; spec case: Buad Rate can't be greater than 7
    1426:	f5 68 a9    	bclr.b    0x8f5, #0x3
	mov.b	SerCtrl,WREG
    1428:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    142a:	70 00 b2    	and.w     #0x7, w0
	call	set_U1BRG_from_w0	; set new Baud Rate
    142c:	ce 27 02    	call      0x27ce <set_U1BRG_from_w0>
    142e:	00 00 00 
	return
    1430:	00 00 06    	return    

00001432 <limited_key_3>:
limited_key_3:		; can't affect pgm data, only Dim Clock Page
	mov	#Dummy,w3
    1432:	03 9b 20    	mov.w     #0x9b0, w3
	mov	#Dummy,w4
    1434:	04 9b 20    	mov.w     #0x9b0, w4
	mov	#Dummy,w5
    1436:	05 9b 20    	mov.w     #0x9b0, w5
	bra	uni_key
    1438:	03 00 37    	bra       0x1440 <uni_key>

0000143a <general_key_3O>:
general_key_3O:
	mov	#Opcode,w3
    143a:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    143c:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    143e:	65 92 20    	mov.w     #0x926, w5

00001440 <uni_key>:
uni_key:
	mov	Mode,w0		; *** if PGM mode (disable 12 keys)
    1440:	b0 4b 80    	mov.w     0x976, w0
	cp.b	w0,#3		; *** if PGM mode (disable 12 keys)
    1442:	63 04 e1    	cp.b      w0, #0x3
	bra	z,general	; *** if PGM mode (disable 12 keys)
    1444:	05 00 32    	bra       Z, 0x1450 <general>

	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1446:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    1448:	03 00 37    	bra       0x1450 <general>
	mov	#Sync,w3
    144a:	23 8f 20    	mov.w     #0x8f2, w3
	mov	#Speed,w4
    144c:	14 8f 20    	mov.w     #0x8f1, w4
	mov	#Page,w5
    144e:	05 8f 20    	mov.w     #0x8f0, w5

00001450 <general>:
general:
; is it key 5...8?
	mov	Just,w0
    1450:	30 4d 80    	mov.w     0x9a6, w0
	sub	#5,w0
    1452:	50 00 b1    	sub.w     #0x5, w0
	cp	w0,#4
    1454:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    1456:	0d 00 39    	bra       NC, 0x1472 <key0_3>
; is it key 9...12?
	mov	w4,w3
    1458:	84 01 78    	mov.w     w4, w3
	sub	#4,w0
    145a:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    145c:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    145e:	09 00 39    	bra       NC, 0x1472 <key0_3>
; is it key 13...16?
	mov	w5,w3
    1460:	85 01 78    	mov.w     w5, w3
	sub	#4,w0
    1462:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    1464:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    1466:	05 00 39    	bra       NC, 0x1472 <key0_3>
; then it must be key 17 = Data In
	btg	A16,#b_bin
    1468:	af e9 aa    	btg.b     0x9af, #0x7
	bclr	A16,#b_sel
    146a:	ae e9 a9    	bclr.b    0x9ae, #0x7
	btss	A16,#b_bin
    146c:	af e9 ae    	btss.b    0x9af, #0x7
	bset	A16,#b_sel
    146e:	ae e9 a8    	bset.b    0x9ae, #0x7
	return
    1470:	00 00 06    	return    

00001472 <key0_3>:
; -------- 
key0_3:
	btss	A16,#b_bin
    1472:	af e9 ae    	btss.b    0x9af, #0x7
	bra	its_sel
    1474:	0d 00 37    	bra       0x1490 <its_sel>
; it's binary mode here
	cp0	w0
    1476:	00 00 e0    	cp0.w     w0
	ifz
    1478:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#3		; key 8 in binary mode
    147a:	13 34 a2    	btg.b     [w3], #0x3
	cp	w0,#1
    147c:	61 00 e1    	cp.w      w0, #0x1
	ifz
    147e:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#2		; key 4 in binary mode
    1480:	13 24 a2    	btg.b     [w3], #0x2
	cp	w0,#2
    1482:	62 00 e1    	cp.w      w0, #0x2
	ifz
    1484:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#1		; key 2 in binary mode
    1486:	13 14 a2    	btg.b     [w3], #0x1
	cp	w0,#3
    1488:	63 00 e1    	cp.w      w0, #0x3
	ifz
    148a:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#0		; key 1 in binary mode
    148c:	13 04 a2    	btg.b     [w3], #0x0
	return
    148e:	00 00 06    	return    

00001490 <its_sel>:
its_sel:
	ze	[w3],w4
    1490:	13 82 fb    	ze        [w3], w4
	cp0	w0
    1492:	00 00 e0    	cp0.w     w0
	ifz
    1494:	42 20 af    	btsc.b    0x42, #0x1
	sub	#4,w4		; key ---- in select mode
    1496:	44 00 b1    	sub.w     #0x4, w4
	cp	w0,#1
    1498:	61 00 e1    	cp.w      w0, #0x1
	ifz
    149a:	42 20 af    	btsc.b    0x42, #0x1
	dec	w4,w4		; key - in select mode
    149c:	04 02 e9    	dec.w     w4, w4
	cp	w0,#2
    149e:	62 00 e1    	cp.w      w0, #0x2
	ifz
    14a0:	42 20 af    	btsc.b    0x42, #0x1
	inc	w4,w4		; key + in select mode
    14a2:	04 02 e8    	inc.w     w4, w4
	cp	w0,#3
    14a4:	63 00 e1    	cp.w      w0, #0x3
	ifz
    14a6:	42 20 af    	btsc.b    0x42, #0x1
	add	#4,w4		; key ++++ in select mode
    14a8:	44 00 b0    	add.w     #0x4, w4
; clip w3 to 0...15
	btsc	w4,#15		; if w4<0...
    14aa:	04 f0 a7    	btsc.w    w4, #0xf
	clr	w4		; ...then w4=0
    14ac:	00 02 eb    	clr.w     w4
	btsc	w4,#4		; if w4>15...
    14ae:	04 40 a7    	btsc.w    w4, #0x4
	mov	#15,w4		; ...then w4=15
    14b0:	f4 00 20    	mov.w     #0xf, w4
	mov.b	w4,[w3]
    14b2:	84 49 78    	mov.b     w4, [w3]
	return
    14b4:	00 00 06    	return    

000014b6 <transfer1>:

; --------------------------------------------------------------------------------------
; Transfers through Accu and Flags  In - Temp - Out					
; --------------------------------------------------------------------------------------
transfer1:		; in the first clock semiphase or when STEP is depressed
	bclr	A16,#b_noclk_sch
    14b6:	ae 69 a9    	bclr.b    0x9ae, #0x3
	bset	A16,#b_clk_sch	; set CLK schematic
    14b8:	ae 09 a8    	bset.b    0x9ae, #0x0
	bra	w6
    14ba:	06 60 01    	bra       w6
;...
	return			; no transfers if w6=0000
    14bc:	00 00 06    	return    
	bra	n0001
    14be:	0e 00 37    	bra       0x14dc <n0001>
	bra	n0010
    14c0:	0f 00 37    	bra       0x14e0 <n0010>
	bra	n0011
    14c2:	12 00 37    	bra       0x14e8 <n0011>
	bra	n0100
    14c4:	16 00 37    	bra       0x14f2 <n0100>
	bra	n0101
    14c6:	19 00 37    	bra       0x14fa <n0101>
	bra	n0110
    14c8:	1d 00 37    	bra       0x1504 <n0110>
	bra	n0111
    14ca:	23 00 37    	bra       0x1512 <n0111>
	bra	n1000
    14cc:	2a 00 37    	bra       0x1522 <n1000>
	bra	n1001
    14ce:	2d 00 37    	bra       0x152a <n1001>
	bra	n1010
    14d0:	31 00 37    	bra       0x1534 <n1010>
	bra	n1011
    14d2:	37 00 37    	bra       0x1542 <n1011>
	bra	n1100
    14d4:	3e 00 37    	bra       0x1552 <n1100>
	bra	n1101
    14d6:	44 00 37    	bra       0x1560 <n1101>
	bra	n1110
    14d8:	4b 00 37    	bra       0x1570 <n1110>
	bra	n1111
    14da:	54 00 37    	bra       0x1584 <n1111>

000014dc <n0001>:
; -------------------
n0001:
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    14dc:	4d 49 88    	mov.w     w13, 0x928
	return
    14de:	00 00 06    	return    

000014e0 <n0010>:
n0010:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    14e0:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    14e2:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    14e4:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    14e6:	00 00 06    	return    

000014e8 <n0011>:
n0011:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    14e8:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    14ea:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    14ec:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    14ee:	4d 49 88    	mov.w     w13, 0x928
	return
    14f0:	00 00 06    	return    

000014f2 <n0100>:
n0100:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    14f2:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    14f4:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    14f6:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    14f8:	00 00 06    	return    

000014fa <n0101>:
n0101:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    14fa:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    14fc:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    14fe:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1500:	4d 49 88    	mov.w     w13, 0x928
	return
    1502:	00 00 06    	return    

00001504 <n0110>:
n0110:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1504:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1506:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1508:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    150a:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    150c:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    150e:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    1510:	00 00 06    	return    

00001512 <n0111>:
n0111:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1512:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1514:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1516:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1518:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    151a:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    151c:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    151e:	4d 49 88    	mov.w     w13, 0x928
	return
    1520:	00 00 06    	return    

00001522 <n1000>:
n1000:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1522:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1524:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1526:	30 29 a8    	bset.b    0x930, #0x1
	return
    1528:	00 00 06    	return    

0000152a <n1001>:
n1001:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    152a:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    152c:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    152e:	30 29 a8    	bset.b    0x930, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1530:	4d 49 88    	mov.w     w13, 0x928
	return
    1532:	00 00 06    	return    

00001534 <n1010>:
n1010:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1534:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1536:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1538:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    153a:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    153c:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    153e:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    1540:	00 00 06    	return    

00001542 <n1011>:
n1011:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1542:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1544:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1546:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1548:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    154a:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    154c:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    154e:	4d 49 88    	mov.w     w13, 0x928
	return
    1550:	00 00 06    	return    

00001552 <n1100>:

n1100:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1552:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1554:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1556:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1558:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    155a:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    155c:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    155e:	00 00 06    	return    

00001560 <n1101>:
n1101:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1560:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1562:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1564:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1566:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1568:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    156a:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    156c:	4d 49 88    	mov.w     w13, 0x928
	return
    156e:	00 00 06    	return    

00001570 <n1110>:
n1110:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1570:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1572:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1574:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1576:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1578:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    157a:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    157c:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    157e:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1580:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    1582:	00 00 06    	return    

00001584 <n1111>:
n1111:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1584:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1586:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1588:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    158a:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    158c:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    158e:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1590:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1592:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1594:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1596:	4d 49 88    	mov.w     w13, 0x928
	return
    1598:	00 00 06    	return    

0000159a <transfer2>:
;-----------------------------------------------------------------------------------

transfer2:		; in the second clack semiphase or when STEP is released
	bclr	A16,#b_clk_sch
    159a:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch ; set NOCLK schematic
    159c:	ae 69 a8    	bset.b    0x9ae, #0x3
	bra	w6
    159e:	06 60 01    	bra       w6
;...
	return
    15a0:	00 00 06    	return    
	bra	z0001
    15a2:	0e 00 37    	bra       0x15c0 <z0001>
	bra	z0010
    15a4:	0f 00 37    	bra       0x15c4 <z0010>
	bra	z0011
    15a6:	15 00 37    	bra       0x15d2 <z0011>
	bra	z0100
    15a8:	1c 00 37    	bra       0x15e2 <z0100>
	bra	z0101
    15aa:	1f 00 37    	bra       0x15ea <z0101>
	bra	z0110
    15ac:	23 00 37    	bra       0x15f4 <z0110>
	bra	z0111
    15ae:	2c 00 37    	bra       0x1608 <z0111>
	bra	z1000
    15b0:	36 00 37    	bra       0x161e <z1000>
	bra	z1001
    15b2:	3c 00 37    	bra       0x162c <z1001>
	bra	z1010
    15b4:	43 00 37    	bra       0x163c <z1010>
	bra	z1011
    15b6:	49 00 37    	bra       0x164a <z1011>
	bra	z1100
    15b8:	56 00 37    	bra       0x1666 <z1100>
	bra	z1101
    15ba:	5f 00 37    	bra       0x167a <z1101>
	bra	z1110
    15bc:	69 00 37    	bra       0x1690 <z1110>
	bra	z1111
    15be:	78 00 37    	bra       0x16b0 <z1111>

000015c0 <z0001>:
; -------------------
z0001:
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15c0:	4e 49 80    	mov.w     0x928, w14
	return
    15c2:	00 00 06    	return    

000015c4 <z0010>:
z0010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15c4:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15c6:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15c8:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    15ca:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    15cc:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    15ce:	af 89 a8    	bset.b    0x9af, #0x4
	return
    15d0:	00 00 06    	return    

000015d2 <z0011>:
z0011:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15d2:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15d4:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15d6:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    15d8:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    15da:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    15dc:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15de:	4e 49 80    	mov.w     0x928, w14
	return
    15e0:	00 00 06    	return    

000015e2 <z0100>:
z0100:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15e2:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15e4:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15e6:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    15e8:	00 00 06    	return    

000015ea <z0101>:
z0101:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15ea:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15ec:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15ee:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15f0:	4e 49 80    	mov.w     0x928, w14
	return
    15f2:	00 00 06    	return    

000015f4 <z0110>:
z0110:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15f4:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15f6:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15f8:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15fa:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15fc:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15fe:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1600:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1602:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1604:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1606:	00 00 06    	return    

00001608 <z0111>:
z0111:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1608:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    160a:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    160c:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    160e:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1610:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1612:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1614:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1616:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1618:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    161a:	4e 49 80    	mov.w     0x928, w14
	return
    161c:	00 00 06    	return    

0000161e <z1000>:
z1000:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    161e:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1620:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1622:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1624:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1626:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1628:	f4 28 a8    	bset.b    0x8f4, #0x1
	return
    162a:	00 00 06    	return    

0000162c <z1001>:
z1001:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    162c:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    162e:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1630:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1632:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1634:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1636:	f4 28 a8    	bset.b    0x8f4, #0x1
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1638:	4e 49 80    	mov.w     0x928, w14
	return
    163a:	00 00 06    	return    

0000163c <z1010>:
z1010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    163c:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    163e:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1640:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1642:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1644:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1646:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1648:	00 00 06    	return    

0000164a <z1011>:
z1011:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    164a:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    164c:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    164e:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1650:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1652:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1654:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1656:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1658:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    165a:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    165c:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    165e:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1660:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1662:	4e 49 80    	mov.w     0x928, w14
	return
    1664:	00 00 06    	return    

00001666 <z1100>:
z1100:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1666:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1668:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    166a:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    166c:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    166e:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1670:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1672:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1674:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1676:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    1678:	00 00 06    	return    

0000167a <z1101>:
z1101:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    167a:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    167c:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    167e:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1680:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1682:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1684:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1686:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1688:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    168a:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    168c:	4e 49 80    	mov.w     0x928, w14
	return
    168e:	00 00 06    	return    

00001690 <z1110>:
z1110:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1690:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1692:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1694:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1696:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1698:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    169a:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    169c:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    169e:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    16a0:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    16a2:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    16a4:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16a6:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16a8:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16aa:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16ac:	af 89 a8    	bset.b    0x9af, #0x4
	return
    16ae:	00 00 06    	return    

000016b0 <z1111>:
z1111:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16b0:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16b2:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16b4:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16b6:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16b8:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16ba:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    16bc:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    16be:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    16c0:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    16c2:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    16c4:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16c6:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16c8:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16ca:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16cc:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    16ce:	4e 49 80    	mov.w     0x928, w14
	return
    16d0:	00 00 06    	return    

000016d2 <alu_A1>:

; ----------------------------------------------------------   INSTRUCTIONS  -----

alu_A1:			; ADD  RX,RY
	bclr	BlinkFlag,#0
    16d2:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16d4:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_1
    16d6:	1a 1e 02    	call      0x1e1a <dir_4_1>
    16d8:	00 00 00 
	bra	alu_cmd
    16da:	72 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000016dc <alu_A2>:
alu_A2:			; ADC  RX,RY
	bclr	BlinkFlag,#0
    16dc:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16de:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_2
    16e0:	82 1e 02    	call      0x1e82 <dir_4_2>
    16e2:	00 00 00 
	bra	alu_cmd
    16e4:	6d fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000016e6 <alu_A3>:
alu_A3:			; SUB  RX,RY
	bclr	BlinkFlag,#0
    16e6:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16e8:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_3
    16ea:	e0 1e 02    	call      0x1ee0 <dir_4_3>
    16ec:	00 00 00 
	bra	alu_cmd
    16ee:	68 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000016f0 <alu_A4>:
alu_A4:			; SBB  RX,RY
	bclr	BlinkFlag,#0
    16f0:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16f2:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_4
    16f4:	36 1f 02    	call      0x1f36 <dir_4_4>
    16f6:	00 00 00 
	bra	alu_cmd
    16f8:	63 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

000016fa <alu_A5>:
alu_A5:			; OR   RX,RY
	bclr	BlinkFlag,#0
    16fa:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16fc:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_5
    16fe:	9a 1f 02    	call      0x1f9a <dir_4_5>
    1700:	00 00 00 
	bra	alu_cmd
    1702:	5e fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

00001704 <alu_A6>:
alu_A6:			; AND  RX,RY
	bclr	BlinkFlag,#0
    1704:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1706:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_6
    1708:	d6 1f 02    	call      0x1fd6 <dir_4_6>
    170a:	00 00 00 
	bra	alu_cmd
    170c:	59 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

0000170e <alu_A7>:
alu_A7:			; XOR  RX,RY
	bclr	BlinkFlag,#0
    170e:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1710:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_7
    1712:	08 20 02    	call      0x2008 <dir_4_7>
    1714:	00 00 00 
	bra	alu_cmd
    1716:	54 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

00001718 <alu_A8>:
alu_A8:			; MOV  RX,RY
	bclr	BlinkFlag,#0
    1718:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    171a:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_8
    171c:	3a 20 02    	call      0x203a <dir_4_8>
    171e:	00 00 00 
	bra	alu_cmd
    1720:	4f fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

00001722 <alu_G2>:
;-----------------------
;alu_G0:			; CP    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_0
;	bra	alu_cmd
;alu_G1:			; ADD   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_1
;	bra	alu_cmd
alu_G2:			; INC   RY
	bclr	BlinkFlag,#0
    1722:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1724:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    1726:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_2
    1728:	4a 22 02    	call      0x224a <dir_8_2>
    172a:	00 00 00 
	bra	alu_cmd
    172c:	49 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

0000172e <alu_G3>:
alu_G3:			; DEC   RY
	bclr	BlinkFlag,#0
    172e:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1730:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    1732:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_3
    1734:	ca 22 02    	call      0x22ca <dir_8_3>
    1736:	00 00 00 
	bra	alu_cmd
    1738:	43 fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

0000173a <alu_G13>:
;alu_G5:			; OR    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_5
;	bra	alu_cmd
;alu_G6:			; AND   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_6
;	bra	alu_cmd
;alu_G7:			; XOR   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_7
;	bra	alu_cmd
;alu_G9:			; BIT   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+11,w7	; register read address = IN port
;	call	dir_8_9
;	bra	alu_cmd
;alu_G10:		; BSET  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_10
;	bra	alu_cmd
;alu_G11:		; BCLR  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_11
;	bra	alu_cmd
;alu_G12:		; BTG   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_12
;	bra	alu_cmd
alu_G13:		; RRC   RY
	bclr	BlinkFlag,#0
    173a:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    173c:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    173e:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_13
    1740:	60 25 02    	call      0x2560 <dir_8_13>
    1742:	00 00 00 
	bra	alu_cmd
    1744:	3d fd 37    	bra       0x11c0 <alu_cmd> <alu_wait_key>

00001746 <peek_flash>:

; --------------------------------------------------------------------

peek_flash:		; measure all 16 Flash occupancies, write to Files (16×1 by) 37 ms
	mov	#Files,w5	; wr ptr
    1746:	65 96 20    	mov.w     #0x966, w5
	mov	#0,w8		; loop count and record count
    1748:	08 00 20    	mov.w     #0x0, w8

0000174a <L83>:
8:
	mov	w8,w0
    174a:	08 00 78    	mov.w     w8, w0
	call	eemeasure	; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
    174c:	48 02 02    	call      0x248 <eemeasure>
    174e:	00 00 00 
	mov.b	w2,[w5++]
    1750:	82 5a 78    	mov.b     w2, [w5++]
	inc	w8,w8
    1752:	08 04 e8    	inc.w     w8, w8
	btss	w8,#4
    1754:	08 40 a6    	btss.w    w8, #0x4
	bra	8b
    1756:	f9 ff 37    	bra       0x174a <L83>
	return
    1758:	00 00 06    	return    

0000175a <leave_alu_ept>:

; --------------------------------------------------------------------
; --------------------------------------------------------------------
; --------------------------------------------------------------------

leave_alu_ept:
; save ALU variables to ALU Temp
	mov	Opcode,w0
    175a:	10 49 80    	mov.w     0x922, w0
	mov	w0,AluTempOpcode ; Opcode
    175c:	90 49 88    	mov.w     w0, 0x932
	mov	OperX,w0
    175e:	20 49 80    	mov.w     0x924, w0
	mov	w0,AluTempOperX	; OperX
    1760:	a0 49 88    	mov.w     w0, 0x934
	mov	OperY,w0
    1762:	30 49 80    	mov.w     0x926, w0
	mov	w0,AluTempOperY	; OperY
    1764:	b0 49 88    	mov.w     w0, 0x936
	mov	Atemp,w0
    1766:	40 49 80    	mov.w     0x928, w0
	mov	w0,AluTempAtemp	; Accu temp
    1768:	c0 49 88    	mov.w     w0, 0x938
	mov	w14,AluTempw14	; Accu out
    176a:	ee 49 88    	mov.w     w14, 0x93c
	mov	w13,AluTempw13	; Accu in
    176c:	dd 49 88    	mov.w     w13, 0x93a
; save Alu flags
	mov	Vflag,w0
    176e:	80 49 80    	mov.w     0x930, w0
	mov	w0,AluTempVflag
    1770:	f0 49 88    	mov.w     w0, 0x93e
	mov	Zflag,w0
    1772:	70 49 80    	mov.w     0x92e, w0
	mov	w0,AluTempZflag
    1774:	00 4a 88    	mov.w     w0, 0x940
	mov	Cflag,w0
    1776:	60 49 80    	mov.w     0x92c, w0
	mov	w0,AluTempCflag
    1778:	10 4a 88    	mov.w     w0, 0x942
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    177a:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_ept
    177c:	01 00 37    	bra       0x1780 <ss_ept>
	bra	pgm_ept
    177e:	67 08 37    	bra       0x284e <pgm_ept>

00001780 <ss_ept>:

ss_ept:
	btss	Flag2,#12
    1780:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    1782:	dc 10 02    	call      0x10dc <clr_ram>
    1784:	00 00 00 
	bset	Flag2,#12
    1786:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload SS variables from RUN Temp
	mov	SSTempPage,w0
    1788:	30 4a 80    	mov.w     0x946, w0
	mov.b	WREG,Page	; Page
    178a:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	SSTempStack,w0
    178c:	40 4a 80    	mov.w     0x948, w0
	mov	w0,Stack	; Stack
    178e:	50 49 88    	mov.w     w0, 0x92a
	mov	SSTempPMAddr,w9	; PC
    1790:	29 4a 80    	mov.w     0x944, w9
	mov	SSTempw14,w14
    1792:	9e 4a 80    	mov.w     0x952, w14
	mov	SSTempw13,w13
    1794:	8d 4a 80    	mov.w     0x950, w13
; restore SS flags
	mov	SSTempVflag,w0
    1796:	50 4a 80    	mov.w     0x94a, w0
	mov	w0,Vflag
    1798:	80 49 88    	mov.w     w0, 0x930
	mov	SSTempZflag,w0
    179a:	60 4a 80    	mov.w     0x94c, w0
	mov	w0,Zflag
    179c:	70 49 88    	mov.w     w0, 0x92e
	mov	SSTempCflag,w0
    179e:	70 4a 80    	mov.w     0x94e, w0
	mov	w0,Cflag
    17a0:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    17a2:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    17a4:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    17a6:	af 89 a8    	bset.b    0x9af, #0x4
; SS initialize
	mov	#1,w0		; 1 = SS
    17a8:	10 00 20    	mov.w     #0x1, w0
	mov	w0,Mode		; Mode
    17aa:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    17ac:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    17ae:	54 20 ef    	clr.w     0x54
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    17b0:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    17b2:	df 69 a8    	bset.b    0x9df, #0x3
	mov	SSTempPMAddr,w9 ; const
    17b4:	29 4a 80    	mov.w     0x944, w9
	mov	#Ram,w10	; const
    17b6:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    17b8:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    17ba:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    17bc:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b011111100,w0	; autorpt allow flag: #0-4=keys1-5, #5=keys6-9,
    17be:	c0 0f 20    	mov.w     #0xfc, w0
	mov	w0,AutorptFlag	; #6=keys10-13, #7=keys14-17, #8=key18
    17c0:	60 4d 88    	mov.w     w0, 0x9ac
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    17c2:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    17c4:	00 07 eb    	clr.w     w14
	bclr	Flag2,#5	; #5 Fatal Stack Error
    17c6:	de a9 a9    	bclr.b    0x9de, #0x5
; prepare A16 (set SS and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    17c8:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    17ca:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000010000001000,w0	; set SS and -CLK
    17cc:	80 40 20    	mov.w     #0x408, w0
	ior	A16
    17ce:	ae 29 b7    	ior.w     0x9ae
;	
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    17d0:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    17d2:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    17d4:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    17d6:	9b 83 a8    	bset.b    0x39b, #0x4
	bclr	Flag,#9		; possible write to SFR area
    17d8:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10	; possible read from SFR area
    17da:	dd 49 a9    	bclr.b    0x9dd, #0x2

000017dc <ss_farm>:
; ------------------------------
ss_farm:
	bclr	Flag,#5		; #5 set: in HISTORY mode
    17dc:	dc a9 a9    	bclr.b    0x9dc, #0x5
	bclr	BlinkFlag,#3	; #3 set: LED SS blinks
    17de:	e0 69 a9    	bclr.b    0x9e0, #0x3
	call	read12
    17e0:	72 29 02    	call      0x2972 <read12>
    17e2:	00 00 00 
; check if Stack Error occured
	btss	Flag2,#5	; #5 Fatal Stack Error
    17e4:	de a9 ae    	btss.b    0x9de, #0x5
	bra	no_SS_StackErr
    17e6:	09 00 37    	bra       0x17fa <no_SS_StackErr> <ss_noread>
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    17e8:	e0 c9 a8    	bset.b    0x9e0, #0x6

000017ea <L17>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    17ea:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    17ec:	02 00 37    	bra       0x17f2 <L24>
	btss	Flag,#1		; #1 handshaking flag for buttons
    17ee:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    17f0:	fc ff 37    	bra       0x17ea <L17>

000017f2 <L24>:
2:
	bclr	Flag,#1
    17f2:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    17f4:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    17f6:	2a 29 ef    	clr.w     0x92a
	bclr	Flag2,#5	; #5 Fatal Stack Error
    17f8:	de a9 a9    	bclr.b    0x9de, #0x5

000017fa <no_SS_StackErr>:
;	call	clr_ram
no_SS_StackErr:
ss_noread:
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    17fa:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    17fc:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    17fe:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    1800:	7a e6 b7    	mov.b     WREG, 0x67a

	bclr	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    1802:	dc 89 a9    	bclr.b    0x9dc, #0x4
	mov	OperX,w11	; w11 = OperX
    1804:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12	; w12 = OperY
    1806:	3c 49 80    	mov.w     0x926, w12
	mov	Opcode,w0	; w0 = Opcode
    1808:	10 49 80    	mov.w     0x922, w0
	and	#0x0F,w0
    180a:	f0 00 b2    	and.w     #0xf, w0
	bra	z,group8runb	; ---------> 8-bit opcode
    180c:	32 00 32    	bra       Z, 0x1872 <group8runb>
; w0 = instruction
	mul.uu	w0,#3,w0
    180e:	63 00 b8    	mul.uu    w0, #0x3, w0
	bra	w0
    1810:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0		; non-existing instruction
	callSS	ind_4_1		; ADD  RX,RY
    1818:	0c 1e 02    	call      0x1e0c <ind_4_1>
    181a:	00 00 00 
    181c:	5c 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_2		; ADC  RX,RY
    181e:	74 1e 02    	call      0x1e74 <ind_4_2>
    1820:	00 00 00 
    1822:	59 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_3		; SUB  RX,RY
    1824:	d2 1e 02    	call      0x1ed2 <ind_4_3>
    1826:	00 00 00 
    1828:	56 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_4		; SBB  RX,RY
    182a:	28 1f 02    	call      0x1f28 <ind_4_4>
    182c:	00 00 00 
    182e:	53 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_5		; OR   RX,RY
    1830:	8c 1f 02    	call      0x1f8c <ind_4_5>
    1832:	00 00 00 
    1834:	50 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_6		; AND  RX,RY
    1836:	c8 1f 02    	call      0x1fc8 <ind_4_6>
    1838:	00 00 00 
    183a:	4d 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_7		; XOR  RX,RY
    183c:	fa 1f 02    	call      0x1ffa <ind_4_7>
    183e:	00 00 00 
    1840:	4a 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_8		; MOV  RX,RY
    1842:	2c 20 02    	call      0x202c <ind_4_8>
    1844:	00 00 00 
    1846:	47 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_9		; MOV  RX,N (TEST PCL)
    1848:	66 20 02    	call      0x2066 <ind_4_9>
    184a:	00 00 00 
    184c:	44 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_10	; MOV  [XY],R0
    184e:	9a 20 02    	call      0x209a <ind_4_10>
    1850:	00 00 00 
    1852:	41 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_11	; MOV  R0,[XY]
    1854:	d0 20 02    	call      0x20d0 <ind_4_11>
    1856:	00 00 00 
    1858:	3e 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_12	; MOV  [NN],R0
    185a:	08 21 02    	call      0x2108 <ind_4_12>
    185c:	00 00 00 
    185e:	3b 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_13	; MOV  R0,[NN]
    1860:	3a 21 02    	call      0x213a <ind_4_13>
    1862:	00 00 00 
    1864:	38 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_14	; MOV  PC,NN
    1866:	6e 21 02    	call      0x216e <ind_4_14>
    1868:	00 00 00 
    186a:	35 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_4_15	; JR   NN
    186c:	8e 21 02    	call      0x218e <ind_4_15>
    186e:	00 00 00 
    1870:	32 00 37    	bra       0x18d6 <L18> <ss_cont>

00001872 <group8runb>:
;...
group8runb:
; w0 = instruction
	mul.uu	w11,#3,w0
    1872:	63 58 b8    	mul.uu    w11, #0x3, w0
	bra	w0
    1874:	00 60 01    	bra       w0
;jp table
	callSS	ind_8_0		; CP   R0,N
    1876:	aa 21 02    	call      0x21aa <ind_8_0>
    1878:	00 00 00 
    187a:	2d 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_1		; ADD  R0,N
    187c:	f6 21 02    	call      0x21f6 <ind_8_1>
    187e:	00 00 00 
    1880:	2a 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_2		; INC  RY (TEST PCL)
    1882:	46 22 02    	call      0x2246 <ind_8_2>
    1884:	00 00 00 
    1886:	27 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_3		; DEC  RY (TEST PCL)
    1888:	c6 22 02    	call      0x22c6 <ind_8_3>
    188a:	00 00 00 
    188c:	24 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_4		; DSZ  RY
    188e:	44 23 02    	call      0x2344 <ind_8_4>
    1890:	00 00 00 
    1892:	21 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_5		; OR   R0,N
    1894:	80 23 02    	call      0x2380 <ind_8_5>
    1896:	00 00 00 
    1898:	1e 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_6		; AND  R0,N
    189a:	ca 23 02    	call      0x23ca <ind_8_6>
    189c:	00 00 00 
    189e:	1b 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_7		; XOR  R0,N
    18a0:	04 24 02    	call      0x2404 <ind_8_7>
    18a2:	00 00 00 
    18a4:	18 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_8		; EXR  N
    18a6:	4a 24 02    	call      0x244a <ind_8_8>
    18a8:	00 00 00 
    18aa:	15 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_9		; BIT  RG,M
    18ac:	80 24 02    	call      0x2480 <ind_8_9>
    18ae:	00 00 00 
    18b0:	12 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_10	; BSET RG,M
    18b2:	c2 24 02    	call      0x24c2 <ind_8_10>
    18b4:	00 00 00 
    18b6:	0f 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_11	; BCLR RG,M
    18b8:	f2 24 02    	call      0x24f2 <ind_8_11>
    18ba:	00 00 00 
    18bc:	0c 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_12	; BTG  RG,M
    18be:	24 25 02    	call      0x2524 <ind_8_12>
    18c0:	00 00 00 
    18c2:	09 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_13	; RRC  RY
    18c4:	54 25 02    	call      0x2554 <ind_8_13>
    18c6:	00 00 00 
    18c8:	06 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_14	; RET  R0,N
    18ca:	96 25 02    	call      0x2596 <ind_8_14>
    18cc:	00 00 00 
    18ce:	03 00 37    	bra       0x18d6 <L18> <ss_cont>
	callSS	ind_8_15	; SKIP F,M
    18d0:	c2 25 02    	call      0x25c2 <ind_8_15>
    18d2:	00 00 00 
    18d4:	00 00 37    	bra       0x18d6 <L18> <ss_cont>

000018d6 <L18>:
;..............................................
ss_cont:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    18d6:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    18d8:	fe ff 37    	bra       0x18d6 <L18> <ss_cont>
	bclr	Flag,#1
    18da:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    18dc:	30 4d 80    	mov.w     0x9a6, w0
; test if Rnd has to be invoked
	cp.b	w0,#17		; Data In
    18de:	71 04 e1    	cp.b      w0, #0x11
	bra	nz,9f		; if not key Data In
    18e0:	06 00 3a    	bra       NZ, 0x18ee <L93>
	mov	Page,w0
    18e2:	80 47 80    	mov.w     0x8f0, w0
	cp.b	w0,#0x0F
    18e4:	6f 04 e1    	cp.b      w0, #0xf
	ifz			; if Page=15
    18e6:	42 20 af    	btsc.b    0x42, #0x1
	call	new_rnd
    18e8:	be 27 02    	call      0x27be <new_rnd>
    18ea:	00 00 00 
	mov	Just,w0
    18ec:	30 4d 80    	mov.w     0x9a6, w0

000018ee <L93>:
9:
; continue
	cp	w0,#5
    18ee:	65 00 e1    	cp.w      w0, #0x5
	ifc
    18f0:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    18f2:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    18f4:	00 60 01    	bra       w0
; ...
	bra	leave_ss_ept		; mode ++
    18f6:	47 00 37    	bra       0x1986 <leave_ss_ept>
	bra	button_ss_history	; ss_history
    18f8:	04 00 37    	bra       0x1902 <button_ss_history>
	bra	button_ss_addr_minus	; ss_addr_minus
    18fa:	0c 00 37    	bra       0x1914 <button_ss_addr_minus>
	bra	button_ss_addr_plus	; ss_addr_plus
    18fc:	11 00 37    	bra       0x1920 <button_ss_addr_plus>
	bra	button_ss_step		; ss_step
    18fe:	2b 00 37    	bra       0x1956 <button_ss_step>
	bra	button_ss_key5plus
    1900:	06 00 37    	bra       0x190e <button_ss_key5plus>

00001902 <button_ss_history>:
;				
button_ss_history:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1902:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_history		; ss_history ------>
    1904:	4c 0d 37    	bra       0x339e <ss_history>
	btg	A16,#b_carry
    1906:	af 89 aa    	btg.b     0x9af, #0x4
	call	read12
    1908:	72 29 02    	call      0x2972 <read12>
    190a:	00 00 00 
	bra	ss_noread
    190c:	76 ff 37    	bra       0x17fa <no_SS_StackErr> <ss_noread>

0000190e <button_ss_key5plus>:
;				
button_ss_key5plus:
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    190e:	3a 14 02    	call      0x143a <general_key_3O>
    1910:	00 00 00 
	bra	ss_noread
    1912:	73 ff 37    	bra       0x17fa <no_SS_StackErr> <ss_noread>

00001914 <button_ss_addr_minus>:
; --------------------------------------------------
button_ss_addr_minus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    1914:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adr000_ss	; if alt-ADR minus pressed
    1916:	0a 00 37    	bra       0x192c <adr000_ss>
	dec2	w9,w9		; decrement address
    1918:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    191a:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    191c:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	ss_farm
    191e:	5e ff 37    	bra       0x17dc <ss_farm>

00001920 <button_ss_addr_plus>:
; -----------
button_ss_addr_plus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    1920:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adrFFF_ss	; if alt-ADR plus pressed
    1922:	0c 00 37    	bra       0x193c <adrFFF_ss>

00001924 <ss_adr_plus>:
ss_adr_plus:
	inc2	w9,w9		; increment address
    1924:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    1926:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    1928:	09 00 22    	mov.w     #0x2000, w9
	bra	ss_farm
    192a:	58 ff 37    	bra       0x17dc <ss_farm>

0000192c <adr000_ss>:
;		
adr000_ss:
	clr	Stack
    192c:	2a 29 ef    	clr.w     0x92a
	clr.b	Page
    192e:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    1930:	09 00 22    	mov.w     #0x2000, w9
	call	clr_ram
    1932:	dc 10 02    	call      0x10dc <clr_ram>
    1934:	00 00 00 
	call	read12
    1936:	72 29 02    	call      0x2972 <read12>
    1938:	00 00 00 
	bra	ss_noread
    193a:	5f ff 37    	bra       0x17fa <no_SS_StackErr> <ss_noread>

0000193c <adrFFF_ss>:
;		
adrFFF_ss:
	call	find_last
    193c:	46 19 02    	call      0x1946 <find_last>
    193e:	00 00 00 
	call	read12
    1940:	72 29 02    	call      0x2972 <read12>
    1942:	00 00 00 
	bra	ss_noread
    1944:	5a ff 37    	bra       0x17fa <no_SS_StackErr> <ss_noread>

00001946 <find_last>:
;		
find_last:
	mov	#Rom+0x2000,w9	; pointer on top of pgm mem
    1946:	09 00 24    	mov.w     #0x4000, w9
	mov	#0x1000,w1	; loop count
    1948:	01 00 21    	mov.w     #0x1000, w1

0000194a <L19>:
1:
	cp0	[--w9]
    194a:	49 00 e0    	cp0.w     [--w9]
	ifnz
    194c:	42 20 ae    	btss.b    0x42, #0x1
	return
    194e:	00 00 06    	return    
	dec	w1,w1
    1950:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    1952:	fb ff 3a    	bra       NZ, 0x194a <L19>
	return
    1954:	00 00 06    	return    

00001956 <button_ss_step>:

; ------------------------------------------------
button_ss_step:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1956:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	final_ss_step	; if not ALT, then simple ss_step
    1958:	09 00 37    	bra       0x196c <final_ss_step>
; address set from Opc/OperX/OperY
	mov	Opcode,w0
    195a:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    195c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    195e:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    1960:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    1962:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    1964:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    1966:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    1968:	81 04 40    	add.w     w0, w1, w9
	bra	ss_farm
    196a:	38 ff 37    	bra       0x17dc <ss_farm>

0000196c <final_ss_step>:
;		
final_ss_step:
	call	insert		; shift buffer up, pack and insert new 32 by (used 28, spare 4)
    196c:	fa 33 02    	call      0x33fa <insert>
    196e:	00 00 00 
; w6 = flags to affect
	bset	A16,#b_clk_key	; set CLK key
    1970:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w6 bits to decide flag transfer
    1972:	b6 14 02    	call      0x14b6 <transfer1>
    1974:	00 00 00 

00001976 <L25>:
2:				; wait for key STEP released
	inc	KeyRotors+8,WREG
    1976:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,2b		; if not yet 0x1111111111111111
    1978:	fe ff 3a    	bra       NZ, 0x1976 <L25>
	bclr	A16,#b_clk_key
    197a:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w6 bits to decide flag transfer
    197c:	9a 15 02    	call      0x159a <transfer2>
    197e:	00 00 00 
	call	ins_part_2	; INSTRUCTION PART 2
    1980:	32 1d 02    	call      0x1d32 <ins_part_2>
    1982:	00 00 00 
	bra	ss_farm		; LOOP -------------------------------------->
    1984:	2b ff 37    	bra       0x17dc <ss_farm>

00001986 <leave_ss_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_ss_ept:
	clr	BlinkFlag
    1986:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    1988:	54 20 ef    	clr.w     0x54
; save SS variables to SS Temp
	mov.b	Page,WREG
    198a:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,SSTempPage	; Page
    198c:	46 e9 b7    	mov.b     WREG, 0x946
	mov	Stack,w0
    198e:	50 49 80    	mov.w     0x92a, w0
	mov	w0,SSTempStack	; Stack
    1990:	40 4a 88    	mov.w     w0, 0x948
	mov	w9,SSTempPMAddr	; PC
    1992:	29 4a 88    	mov.w     w9, 0x944
	mov	w14,SSTempw14
    1994:	9e 4a 88    	mov.w     w14, 0x952
	mov	w13,SSTempw13
    1996:	8d 4a 88    	mov.w     w13, 0x950
; save SS flags
	mov	Vflag,w0
    1998:	80 49 80    	mov.w     0x930, w0
	mov	w0,SSTempVflag
    199a:	50 4a 88    	mov.w     w0, 0x94a
	mov	Zflag,w0
    199c:	70 49 80    	mov.w     0x92e, w0
	mov	w0,SSTempZflag
    199e:	60 4a 88    	mov.w     w0, 0x94c
	mov	Cflag,w0
    19a0:	60 49 80    	mov.w     0x92c, w0
	mov	w0,SSTempCflag
    19a2:	70 4a 88    	mov.w     w0, 0x94e
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    19a4:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	run_ept
    19a6:	01 00 37    	bra       0x19aa <run_ept>
	bra	alu_ept
    19a8:	a2 fb 37    	bra       0x10ee <alu_ept>

000019aa <run_ept>:
; #2 set: Transfer Zero flag after this instruction
; #3 set: Transfer Overflow flag after this instruction

run_ept:
	btss	Flag2,#12
    19aa:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    19ac:	dc 10 02    	call      0x10dc <clr_ram>
    19ae:	00 00 00 
	bset	Flag2,#12
    19b0:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload RUN variables from RUN Temp
	mov	RunTempPMAddr,w9 ; PC
    19b2:	a9 4a 80    	mov.w     0x954, w9
	mov	RunTempStack,w0
    19b4:	b0 4a 80    	mov.w     0x956, w0
	mov	w0,Stack
    19b6:	50 49 88    	mov.w     w0, 0x92a
	mov	RunTempPage,w0
    19b8:	c0 4a 80    	mov.w     0x958, w0
	mov.b	WREG,Page	; restore Page
    19ba:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	RunTempw14,w14
    19bc:	1e 4b 80    	mov.w     0x962, w14
	mov	RunTempw13,w13
    19be:	0d 4b 80    	mov.w     0x960, w13
; restore RUN flags
	mov	RunTempVflag,w0
    19c0:	d0 4a 80    	mov.w     0x95a, w0
	mov	w0,Vflag
    19c2:	80 49 88    	mov.w     w0, 0x930
	mov	RunTempZflag,w0
    19c4:	e0 4a 80    	mov.w     0x95c, w0
	mov	w0,Zflag
    19c6:	70 49 88    	mov.w     w0, 0x92e
	mov	RunTempCflag,w0
    19c8:	f0 4a 80    	mov.w     0x95e, w0
	mov	w0,Cflag
    19ca:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    19cc:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    19ce:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    19d0:	af 89 a8    	bset.b    0x9af, #0x4
; RUN initialize
	mov	#2,w0		; 2 = RUN
    19d2:	20 00 20    	mov.w     #0x2, w0
	mov	w0,Mode
    19d4:	b0 4b 88    	mov.w     w0, 0x976
	mov	#0,w0		; default speed 0 (max)
    19d6:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    19d8:	0e 26 02    	call      0x260e <set_T2_from_w0>
    19da:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    19dc:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    19de:	40 26 02    	call      0x2640 <set_T3_from_w0>
    19e0:	00 00 00 
	mov	#Ram,w10	; const
    19e2:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    19e4:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    19e6:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    19e8:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    19ea:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    19ec:	60 4d 88    	mov.w     w0, 0x9ac
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    19ee:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#5		; #5 set in HISTORY mode
    19f0:	dc a9 a9    	bclr.b    0x9dc, #0x5
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    19f2:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    19f4:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    19f6:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    19f8:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000001000001000,w0	; set RUN and -CLK
    19fa:	80 20 20    	mov.w     #0x208, w0
	ior	A16
    19fc:	ae 29 b7    	ior.w     0x9ae

	bclr	Flag,#9
    19fe:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10
    1a00:	dd 49 a9    	bclr.b    0x9dd, #0x2

00001a02 <run_wait_key>:
run_wait_key:		; outside pgm execution
	bclr	Flag2,#1	; #1 program Runs 
    1a02:	de 29 a9    	bclr.b    0x9de, #0x1
	bclr	A16,#b_clk_key	; LED RUN off
    1a04:	ae 49 a9    	bclr.b    0x9ae, #0x2

00001a06 <L110>:
1:
	bclr	Flag,#3		; #3 set = no RAM matrix display
    1a06:	dc 69 a9    	bclr.b    0x9dc, #0x3
	btss	Flag,#1		; #1 handshaking flag for buttons
    1a08:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1a0a:	fd ff 37    	bra       0x1a06 <L110>
	bclr	Flag,#1
    1a0c:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1a0e:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1a10:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1a12:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1a14:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1a16:	00 60 01    	bra       w0
; ...
	bra	leave_run_ept	; mode ++
    1a18:	0a 07 37    	bra       0x282e <leave_run_ept>
	bra	run_wait_key	; run_fast
    1a1a:	f3 ff 37    	bra       0x1a02 <run_wait_key>
	bra	run_wait_key	; run_pause
    1a1c:	f2 ff 37    	bra       0x1a02 <run_wait_key>
	bra	run_wait_key	; run_break
    1a1e:	f1 ff 37    	bra       0x1a02 <run_wait_key>
	bra	run_run
    1a20:	08 00 37    	bra       0x1a32 <run_run>
	bra	run_keys_5
    1a22:	00 00 37    	bra       0x1a24 <run_keys_5>

00001a24 <run_keys_5>:
;				
run_keys_5:
; 13 buttons OPCODE 8... DATA IN
	call	limited_key_3	; can't affect pgm data, only Sync Clock Page
    1a24:	32 14 02    	call      0x1432 <limited_key_3>
    1a26:	00 00 00 
	call	set_T2_from_Speed
    1a28:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    1a2a:	00 00 00 
	call	set_T3_from_Sync
    1a2c:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    1a2e:	00 00 00 
	bra	run_wait_key
    1a30:	e8 ff 37    	bra       0x1a02 <run_wait_key>

00001a32 <run_run>:

; ------------------------------------------------
run_run:
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    1a32:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    1a34:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    1a36:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    1a38:	9b 83 a8    	bset.b    0x39b, #0x4

	bclr	BlinkFlag,#2	; 2 set = LED Run blinks
    1a3a:	e0 49 a9    	bclr.b    0x9e0, #0x2
	mov	#RX_buf,w0
    1a3c:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1a3e:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1a40:	f0 4d 88    	mov.w     w0, 0x9be
	bset	Flag2,#1	; #1 program Runs 
    1a42:	de 29 a8    	bset.b    0x9de, #0x1
	mov	#0b000000000,w0	; no autorpt in runtime
    1a44:	00 00 20    	mov.w     #0x0, w0
	mov	w0,AutorptFlag
    1a46:	60 4d 88    	mov.w     w0, 0x9ac
	bset	A16,#b_clk_key	 ; LED RUN on
    1a48:	ae 49 a8    	bset.b    0x9ae, #0x2
	bclr	A16,#b_carry
    1a4a:	af 89 a9    	bclr.b    0x9af, #0x4
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1a4c:	de a9 a9    	bclr.b    0x9de, #0x5
	mov	#Rom,w9
    1a4e:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1a50:	72 29 02    	call      0x2972 <read12>
    1a52:	00 00 00 
	call	clr_ram
    1a54:	dc 10 02    	call      0x10dc <clr_ram>
    1a56:	00 00 00 
	clr	Stack
    1a58:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    1a5a:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    1a5c:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    1a5e:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1a60:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1a62:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1a64:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1a66:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1a68:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1a6a:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1a6c:	fe 27 02    	call      0x27fe <rxtx_to_rxtxpos>
    1a6e:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1a70:	ca 27 02    	call      0x27ca <set_U1BRG>
    1a72:	00 00 00 
	call	read12		; READ 12
    1a74:	72 29 02    	call      0x2972 <read12>
    1a76:	00 00 00 

00001a78 <run_farm>:
run_farm:
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    1a78:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    1a7a:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    1a7c:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    1a7e:	7a e6 b7    	mov.b     WREG, 0x67a
; check if Stack Error occured
	btsc	Flag2,#5	; #5 Fatal Stack Error
    1a80:	de a9 af    	btsc.b    0x9de, #0x5
	bra	Run_StackErr
    1a82:	18 01 37    	bra       0x1cb4 <Run_StackErr>
; check if runtime key pressed
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1a84:	dc 89 a9    	bclr.b    0x9dc, #0x4
	btsc	Flag,#1		; #1 handshaking flag for buttons
    1a86:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	runtime_key_0	; key pressed during pgm execution
    1a88:	d0 00 37    	bra       0x1c2a <runtime_key_0>

00001a8a <runtime_back_0>:
runtime_back_0:
	bclr	Flag2,#11	; #11 = previous Flag,#2
    1a8a:	df 69 a9    	bclr.b    0x9df, #0x3
	btsc	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    1a8c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    1a8e:	df 69 a8    	bset.b    0x9df, #0x3
; [PC] ---> w12,OperY, w11,OperX, w0,Opcode
	mov	[w9],w0		; read instruction
    1a90:	19 00 78    	mov.w     [w9], w0
	and	w0,#0x0F,w12
    1a92:	6f 06 60    	and.w     w0, #0xf, w12
	mov	w12,OperY	; w12 = OperY
    1a94:	3c 49 88    	mov.w     w12, 0x926
	lsr	w0,#4,w11
    1a96:	c4 05 de    	lsr.w     w0, #0x4, w11
	and	w11,#0x0F,w11
    1a98:	ef 85 65    	and.w     w11, #0xf, w11
	mov	w11,OperX	; w11 = OperX
    1a9a:	2b 49 88    	mov.w     w11, 0x924
	lsr	w0,#8,w0
    1a9c:	48 00 de    	lsr.w     w0, #0x8, w0
	mov	w0,Opcode	; w0 = Opcode
    1a9e:	10 49 88    	mov.w     w0, 0x922
	bra	z,group8run	; ---------> 8-bit opcode
    1aa0:	62 00 32    	bra       Z, 0x1b66 <group8run>
; table jump, w0 = instruction
	mul.uu	w0,#6,w0
    1aa2:	66 00 b8    	mul.uu    w0, #0x6, w0
	bra	w0		; execution step 1 (4-bit opcode)
    1aa4:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0,0,0,0	; non-existing instruction
	callRUN	ind_4_1		; ADD  RX,RY
    1ab2:	0c 1e 02    	call      0x1e0c <ind_4_1>
    1ab4:	00 00 00 
    1ab6:	df 69 af    	btsc.b    0x9df, #0x3
    1ab8:	12 1d 02    	call      0x1d12 <run_cont>
    1aba:	00 00 00 
    1abc:	dd ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_2		; ADC  RX,RY
    1abe:	74 1e 02    	call      0x1e74 <ind_4_2>
    1ac0:	00 00 00 
    1ac2:	df 69 af    	btsc.b    0x9df, #0x3
    1ac4:	12 1d 02    	call      0x1d12 <run_cont>
    1ac6:	00 00 00 
    1ac8:	d7 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_3		; SUB  RX,RY
    1aca:	d2 1e 02    	call      0x1ed2 <ind_4_3>
    1acc:	00 00 00 
    1ace:	df 69 af    	btsc.b    0x9df, #0x3
    1ad0:	12 1d 02    	call      0x1d12 <run_cont>
    1ad2:	00 00 00 
    1ad4:	d1 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_4		; SBB  RX,RY
    1ad6:	28 1f 02    	call      0x1f28 <ind_4_4>
    1ad8:	00 00 00 
    1ada:	df 69 af    	btsc.b    0x9df, #0x3
    1adc:	12 1d 02    	call      0x1d12 <run_cont>
    1ade:	00 00 00 
    1ae0:	cb ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_5		; OR   RX,RY
    1ae2:	8c 1f 02    	call      0x1f8c <ind_4_5>
    1ae4:	00 00 00 
    1ae6:	df 69 af    	btsc.b    0x9df, #0x3
    1ae8:	12 1d 02    	call      0x1d12 <run_cont>
    1aea:	00 00 00 
    1aec:	c5 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_6		; AND  RX,RY
    1aee:	c8 1f 02    	call      0x1fc8 <ind_4_6>
    1af0:	00 00 00 
    1af2:	df 69 af    	btsc.b    0x9df, #0x3
    1af4:	12 1d 02    	call      0x1d12 <run_cont>
    1af6:	00 00 00 
    1af8:	bf ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_7		; XOR  RX,RY
    1afa:	fa 1f 02    	call      0x1ffa <ind_4_7>
    1afc:	00 00 00 
    1afe:	df 69 af    	btsc.b    0x9df, #0x3
    1b00:	12 1d 02    	call      0x1d12 <run_cont>
    1b02:	00 00 00 
    1b04:	b9 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_8		; MOV  RX,RY (TEST PCL)
    1b06:	2c 20 02    	call      0x202c <ind_4_8>
    1b08:	00 00 00 
    1b0a:	df 69 af    	btsc.b    0x9df, #0x3
    1b0c:	12 1d 02    	call      0x1d12 <run_cont>
    1b0e:	00 00 00 
    1b10:	b3 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_9		; MOV  RX,N (TEST PCL)
    1b12:	66 20 02    	call      0x2066 <ind_4_9>
    1b14:	00 00 00 
    1b16:	df 69 af    	btsc.b    0x9df, #0x3
    1b18:	12 1d 02    	call      0x1d12 <run_cont>
    1b1a:	00 00 00 
    1b1c:	ad ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_10	; MOV  [XY],R0
    1b1e:	9a 20 02    	call      0x209a <ind_4_10>
    1b20:	00 00 00 
    1b22:	df 69 af    	btsc.b    0x9df, #0x3
    1b24:	12 1d 02    	call      0x1d12 <run_cont>
    1b26:	00 00 00 
    1b28:	a7 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_11	; MOV  R0,[XY]
    1b2a:	d0 20 02    	call      0x20d0 <ind_4_11>
    1b2c:	00 00 00 
    1b2e:	df 69 af    	btsc.b    0x9df, #0x3
    1b30:	12 1d 02    	call      0x1d12 <run_cont>
    1b32:	00 00 00 
    1b34:	a1 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_12	; MOV  [NN],R0
    1b36:	08 21 02    	call      0x2108 <ind_4_12>
    1b38:	00 00 00 
    1b3a:	df 69 af    	btsc.b    0x9df, #0x3
    1b3c:	12 1d 02    	call      0x1d12 <run_cont>
    1b3e:	00 00 00 
    1b40:	9b ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_13	; MOV  R0,[NN]
    1b42:	3a 21 02    	call      0x213a <ind_4_13>
    1b44:	00 00 00 
    1b46:	df 69 af    	btsc.b    0x9df, #0x3
    1b48:	12 1d 02    	call      0x1d12 <run_cont>
    1b4a:	00 00 00 
    1b4c:	95 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_14	; MOV  PC,NN
    1b4e:	6e 21 02    	call      0x216e <ind_4_14>
    1b50:	00 00 00 
    1b52:	df 69 af    	btsc.b    0x9df, #0x3
    1b54:	12 1d 02    	call      0x1d12 <run_cont>
    1b56:	00 00 00 
    1b58:	8f ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_4_15	; JR   NN
    1b5a:	8e 21 02    	call      0x218e <ind_4_15>
    1b5c:	00 00 00 
    1b5e:	df 69 af    	btsc.b    0x9df, #0x3
    1b60:	12 1d 02    	call      0x1d12 <run_cont>
    1b62:	00 00 00 
    1b64:	89 ff 37    	bra       0x1a78 <run_farm>

00001b66 <group8run>:
;...
group8run:
; table jump, w0 = instruction
	mul.uu	w11,#6,w0
    1b66:	66 58 b8    	mul.uu    w11, #0x6, w0
	bra	w0		; execution step 1 (8-bit opcode)
    1b68:	00 60 01    	bra       w0
;jp table
	callRUN	ind_8_0		; CP   R0,N
    1b6a:	aa 21 02    	call      0x21aa <ind_8_0>
    1b6c:	00 00 00 
    1b6e:	df 69 af    	btsc.b    0x9df, #0x3
    1b70:	12 1d 02    	call      0x1d12 <run_cont>
    1b72:	00 00 00 
    1b74:	81 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_1		; ADD  R0,N
    1b76:	f6 21 02    	call      0x21f6 <ind_8_1>
    1b78:	00 00 00 
    1b7a:	df 69 af    	btsc.b    0x9df, #0x3
    1b7c:	12 1d 02    	call      0x1d12 <run_cont>
    1b7e:	00 00 00 
    1b80:	7b ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_2		; INC  RY (TEST PCL)
    1b82:	46 22 02    	call      0x2246 <ind_8_2>
    1b84:	00 00 00 
    1b86:	df 69 af    	btsc.b    0x9df, #0x3
    1b88:	12 1d 02    	call      0x1d12 <run_cont>
    1b8a:	00 00 00 
    1b8c:	75 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_3		; DEC  RY (TEST PCL)
    1b8e:	c6 22 02    	call      0x22c6 <ind_8_3>
    1b90:	00 00 00 
    1b92:	df 69 af    	btsc.b    0x9df, #0x3
    1b94:	12 1d 02    	call      0x1d12 <run_cont>
    1b96:	00 00 00 
    1b98:	6f ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_4		; DSZ  RY
    1b9a:	44 23 02    	call      0x2344 <ind_8_4>
    1b9c:	00 00 00 
    1b9e:	df 69 af    	btsc.b    0x9df, #0x3
    1ba0:	12 1d 02    	call      0x1d12 <run_cont>
    1ba2:	00 00 00 
    1ba4:	69 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_5		; OR   R0,N
    1ba6:	80 23 02    	call      0x2380 <ind_8_5>
    1ba8:	00 00 00 
    1baa:	df 69 af    	btsc.b    0x9df, #0x3
    1bac:	12 1d 02    	call      0x1d12 <run_cont>
    1bae:	00 00 00 
    1bb0:	63 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_6		; AND  R0,N
    1bb2:	ca 23 02    	call      0x23ca <ind_8_6>
    1bb4:	00 00 00 
    1bb6:	df 69 af    	btsc.b    0x9df, #0x3
    1bb8:	12 1d 02    	call      0x1d12 <run_cont>
    1bba:	00 00 00 
    1bbc:	5d ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_7		; XOR  R0,N
    1bbe:	04 24 02    	call      0x2404 <ind_8_7>
    1bc0:	00 00 00 
    1bc2:	df 69 af    	btsc.b    0x9df, #0x3
    1bc4:	12 1d 02    	call      0x1d12 <run_cont>
    1bc6:	00 00 00 
    1bc8:	57 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_8		; EXR  N
    1bca:	4a 24 02    	call      0x244a <ind_8_8>
    1bcc:	00 00 00 
    1bce:	df 69 af    	btsc.b    0x9df, #0x3
    1bd0:	12 1d 02    	call      0x1d12 <run_cont>
    1bd2:	00 00 00 
    1bd4:	51 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_9		; BIT  RG,M
    1bd6:	80 24 02    	call      0x2480 <ind_8_9>
    1bd8:	00 00 00 
    1bda:	df 69 af    	btsc.b    0x9df, #0x3
    1bdc:	12 1d 02    	call      0x1d12 <run_cont>
    1bde:	00 00 00 
    1be0:	4b ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_10	; BSET RG,M
    1be2:	c2 24 02    	call      0x24c2 <ind_8_10>
    1be4:	00 00 00 
    1be6:	df 69 af    	btsc.b    0x9df, #0x3
    1be8:	12 1d 02    	call      0x1d12 <run_cont>
    1bea:	00 00 00 
    1bec:	45 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_11	; BCLR RG,M
    1bee:	f2 24 02    	call      0x24f2 <ind_8_11>
    1bf0:	00 00 00 
    1bf2:	df 69 af    	btsc.b    0x9df, #0x3
    1bf4:	12 1d 02    	call      0x1d12 <run_cont>
    1bf6:	00 00 00 
    1bf8:	3f ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_12	; BTG  RG,M
    1bfa:	24 25 02    	call      0x2524 <ind_8_12>
    1bfc:	00 00 00 
    1bfe:	df 69 af    	btsc.b    0x9df, #0x3
    1c00:	12 1d 02    	call      0x1d12 <run_cont>
    1c02:	00 00 00 
    1c04:	39 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_13	; RRC  RY
    1c06:	54 25 02    	call      0x2554 <ind_8_13>
    1c08:	00 00 00 
    1c0a:	df 69 af    	btsc.b    0x9df, #0x3
    1c0c:	12 1d 02    	call      0x1d12 <run_cont>
    1c0e:	00 00 00 
    1c10:	33 ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_14	; RET  R0,N
    1c12:	96 25 02    	call      0x2596 <ind_8_14>
    1c14:	00 00 00 
    1c16:	df 69 af    	btsc.b    0x9df, #0x3
    1c18:	12 1d 02    	call      0x1d12 <run_cont>
    1c1a:	00 00 00 
    1c1c:	2d ff 37    	bra       0x1a78 <run_farm>
	callRUN	ind_8_15	; SKIP F,M
    1c1e:	c2 25 02    	call      0x25c2 <ind_8_15>
    1c20:	00 00 00 
    1c22:	df 69 af    	btsc.b    0x9df, #0x3
    1c24:	12 1d 02    	call      0x1d12 <run_cont>
    1c26:	00 00 00 
    1c28:	27 ff 37    	bra       0x1a78 <run_farm>

00001c2a <runtime_key_0>:
;...
; #######################################################################################

runtime_key_0:
	mov	#0,w0
    1c2a:	00 00 20    	mov.w     #0x0, w0

00001c2c <runtime_key>:
runtime_key:			; key pressed during pgm execution (don't trash w5-w15!)
	mov	w0,BackIndex
    1c2c:	a0 4d 88    	mov.w     w0, 0x9b4
	bclr	Flag,#1
    1c2e:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1c30:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1c32:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1c34:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1c36:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1c38:	00 60 01    	bra       w0
; ...
	bra	runtime_back_X	; runtime mode (just ignore)
    1c3a:	0b 00 37    	bra       0x1c52 <runtime_back_X>
	bra	runtime_fast 	; runtime fast 
    1c3c:	04 00 37    	bra       0x1c46 <runtime_fast>
	bra	runtime_pause	; runtime pause
    1c3e:	18 00 37    	bra       0x1c70 <runtime_pause>
	bra	runtime_break	; runtime break
    1c40:	41 00 37    	bra       0x1cc4 <runtime_break>
	bra	runtime_back_X	; runtime run (just ignore)
    1c42:	07 00 37    	bra       0x1c52 <runtime_back_X>
	bra	runtime_keys_5
    1c44:	0c 00 37    	bra       0x1c5e <runtime_keys_5>

00001c46 <runtime_fast>:
;...............................
runtime_fast:			; runtime FAST
	btg	Flag2,#0	; #0 Run Fast toggler (1=fast)
    1c46:	de 09 aa    	btg.b     0x9de, #0x0
	btg	BlinkFlag,#2	; 2 set = LED Run blinks
    1c48:	e0 49 aa    	btg.b     0x9e0, #0x2
	call	set_T2_from_Speed
    1c4a:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    1c4c:	00 00 00 
	call	set_T3_from_Sync
    1c4e:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    1c50:	00 00 00 

00001c52 <runtime_back_X>:
;...
runtime_back_X:		; uses BackIndex to return exactly where it came from
	mov	BackIndex,w0
    1c52:	a0 4d 80    	mov.w     0x9b4, w0
	cp0	w0
    1c54:	00 00 e0    	cp0.w     w0
	bra	z,runtime_back_0 ; if [BackIndex] = 0
    1c56:	19 ff 32    	bra       Z, 0x1a8a <runtime_back_0>
	dec	w0,w0
    1c58:	00 00 e9    	dec.w     w0, w0
	bra	z,runtime_back_1 ; if [BackIndex] = 1
    1c5a:	5e 00 32    	bra       Z, 0x1d18 <runtime_back_1>
	bra	runtime_back_2	 ; if [BackIndex] = 2
    1c5c:	65 00 37    	bra       0x1d28 <runtime_back_2>

00001c5e <runtime_keys_5>:
;				
runtime_keys_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1c5e:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1c60:	32 14 02    	call      0x1432 <limited_key_3>
    1c62:	00 00 00 
	call	set_T2_from_Speed
    1c64:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    1c66:	00 00 00 
	call	set_T3_from_Sync
    1c68:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    1c6a:	00 00 00 
	pop	w5	; /
    1c6c:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_back_X
    1c6e:	f1 ff 37    	bra       0x1c52 <runtime_back_X>

00001c70 <runtime_pause>:
;-----------------------------------------------
runtime_pause:			; runtime PAUSE
	bclr	Flag2,#1	; #1 program Runs 
    1c70:	de 29 a9    	bclr.b    0x9de, #0x1
	bset	A16,#b_noclk_sch
    1c72:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1c74:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_save
    1c76:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1c78:	e0 a9 a8    	bset.b    0x9e0, #0x5
	bclr	A16,#b_clk_sch
    1c7a:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1c7c:	ae 69 a8    	bset.b    0x9ae, #0x3

00001c7e <L111>:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    1c7e:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1c80:	fe ff 37    	bra       0x1c7e <L111>
	bclr	Flag,#1
    1c82:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1c84:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1c86:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1c88:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1c8a:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1c8c:	00 60 01    	bra       w0
; ...
	bra	runtime_pause	; pause mode (just ignore)
    1c8e:	f0 ff 37    	bra       0x1c70 <runtime_pause>
	bra	pause_exit 	; pause fast (exit from pause)
    1c90:	0d 00 37    	bra       0x1cac <pause_exit>
	bra	pause_exit	; pause pause (exit from pause)
    1c92:	0c 00 37    	bra       0x1cac <pause_exit>
	bra	runtime_break	; pause break (break pgm execution)
    1c94:	17 00 37    	bra       0x1cc4 <runtime_break>
	bra	pause_exit	; pause run (exit from pause)
    1c96:	0a 00 37    	bra       0x1cac <pause_exit>
	bra	general_pause_5	; keys 6...18
    1c98:	00 00 37    	bra       0x1c9a <general_pause_5>

00001c9a <general_pause_5>:
;................................
general_pause_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1c9a:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1c9c:	32 14 02    	call      0x1432 <limited_key_3>
    1c9e:	00 00 00 
	call	set_T2_from_Speed
    1ca0:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    1ca2:	00 00 00 
	call	set_T3_from_Sync
    1ca4:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    1ca6:	00 00 00 
	pop	w5	; /
    1ca8:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_pause
    1caa:	e2 ff 37    	bra       0x1c70 <runtime_pause>

00001cac <pause_exit>:
; ------------------------------
pause_exit:
	bset	Flag2,#1	; #1 program Runs 
    1cac:	de 29 a8    	bset.b    0x9de, #0x1
	bclr	A16,#b_save
    1cae:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1cb0:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	runtime_back_X	; continue execution
    1cb2:	cf ff 37    	bra       0x1c52 <runtime_back_X>

00001cb4 <Run_StackErr>:
;------------------------------------------------
Run_StackErr:		; Stack Error occured
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    1cb4:	e0 c9 a8    	bset.b    0x9e0, #0x6

00001cb6 <L112>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    1cb6:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    1cb8:	02 00 37    	bra       0x1cbe <L26>
	btss	Flag,#1		; #1 handshaking flag for buttons
    1cba:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1cbc:	fc ff 37    	bra       0x1cb6 <L112>

00001cbe <L26>:
2:
	bclr	Flag,#1
    1cbe:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    1cc0:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    1cc2:	2a 29 ef    	clr.w     0x92a

00001cc4 <runtime_break>:
runtime_break:			; runtime BREAK
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1cc4:	de a9 a9    	bclr.b    0x9de, #0x5
	bclr	A16,#b_clk_sch
    1cc6:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1cc8:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_key
    1cca:	ae 49 a9    	bclr.b    0x9ae, #0x2
	bset	A16,#b_noclk_sch
    1ccc:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1cce:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bclr	A16,#b_save
    1cd0:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1cd2:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    1cd4:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    1cd6:	60 4d 88    	mov.w     w0, 0x9ac
; clear SFR and spec registers
	bclr	A16,#b_carry
    1cd8:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#Rom,w9
    1cda:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1cdc:	72 29 02    	call      0x2972 <read12>
    1cde:	00 00 00 
;	call	clr_ram
;	clr	Stack
;	clr.b	Page		; default page 0
;	clr.b	Speed		; default Clock max
;	clr.b	Sync		; default Sync max
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1ce0:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1ce2:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1ce4:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1ce6:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1ce8:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1cea:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1cec:	fe 27 02    	call      0x27fe <rxtx_to_rxtxpos>
    1cee:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1cf0:	ca 27 02    	call      0x27ca <set_U1BRG>
    1cf2:	00 00 00 
; clear Fast parameters
	  bclr	  BlinkFlag,#2		; 2 set = LED Run blinks
    1cf4:	e0 49 a9    	bclr.b    0x9e0, #0x2
	  btss	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1cf6:	de 09 ae    	btss.b    0x9de, #0x0
	  bra	  not_running_fast
    1cf8:	05 00 37    	bra       0x1d04 <not_running_fast>
	  bclr	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1cfa:	de 09 a9    	bclr.b    0x9de, #0x0
	  call	  set_T2_from_Speed
    1cfc:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    1cfe:	00 00 00 
	  call	  set_T3_from_Sync
    1d00:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    1d02:	00 00 00 

00001d04 <not_running_fast>:
not_running_fast:
	mov	#0,w0		; default speed 0 (max)
    1d04:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    1d06:	0e 26 02    	call      0x260e <set_T2_from_w0>
    1d08:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    1d0a:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    1d0c:	40 26 02    	call      0x2640 <set_T3_from_w0>
    1d0e:	00 00 00 
	bra	run_wait_key
    1d10:	78 fe 37    	bra       0x1a02 <run_wait_key>

00001d12 <run_cont>:

; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

run_cont:			; phases (ONLY IF SPEED>0)
wait_phase_1:
	  mov	  #1,w0
    1d12:	10 00 20    	mov.w     #0x1, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1d14:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1d16:	8a ff 37    	bra       0x1c2c <runtime_key>

00001d18 <runtime_back_1>:
runtime_back_1:
	  btss	  IFS0,#7	; test int flag
    1d18:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_1
    1d1a:	fb ff 37    	bra       0x1d12 <run_cont> <wait_phase_1>
	  bclr	  IFS0,#7	; clr int flag
    1d1c:	88 e0 a9    	bclr.b    0x88, #0x7
;	
	  call	  transfer1	; uses w6 bits to decide flag transfer
    1d1e:	b6 14 02    	call      0x14b6 <transfer1>
    1d20:	00 00 00 

00001d22 <wait_phase_2>:
wait_phase_2:
	  mov	  #2,w0
    1d22:	20 00 20    	mov.w     #0x2, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1d24:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1d26:	82 ff 37    	bra       0x1c2c <runtime_key>

00001d28 <runtime_back_2>:
runtime_back_2:
	  btss	  IFS0,#7	; test int flag
    1d28:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_2
    1d2a:	fb ff 37    	bra       0x1d22 <wait_phase_2>
	  bclr	  IFS0,#7	; clr int flag
    1d2c:	88 e0 a9    	bclr.b    0x88, #0x7
	  call	  transfer2	; uses w6 bits to decide flag transfer
    1d2e:	9a 15 02    	call      0x159a <transfer2>
    1d30:	00 00 00 

00001d32 <ins_part_2>:
; ------
ins_part_2:			; called from SS mode
	incpc			; increment address     * * * * * * * * * * * * * * * * *
    1d32:	89 84 e8    	inc2.w    w9, w9
    1d34:	09 e0 a7    	btsc.w    w9, #0xe
    1d36:	09 00 22    	mov.w     #0x2000, w9
; check if w7 < 8, if so perform special instruction
	cp	w7,#8		; flag for special instructions (if w7 < 8)
    1d38:	68 38 e1    	cp.w      w7, #0x8
	bra	nc,spec_ins
    1d3a:	14 00 39    	bra       NC, 0x1d64 <spec_ins>
	mov.b	w13,[w7]	;  W R I T E   R E S U L T   T O   D E S T I N A T I O N
    1d3c:	8d 4b 78    	mov.b     w13, [w7]
; check if destination was JSR or PCL, if so, then perform CALL or JUMP
	btss	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1d3e:	dc 89 ae    	btss.b    0x9dc, #0x4
	bra	chk_sfr
    1d40:	0a 00 37    	bra       0x1d56 <chk_sfr>
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1d42:	dc 89 a9    	bclr.b    0x9dc, #0x4
; check and perform if there is PCM, PCH 12-bit extension
	  mov	  PcmPch,w0
    1d44:	90 4d 80    	mov.w     0x9b2, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    1d46:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    1d48:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    1d4a:	dc e9 a9    	bclr.b    0x9dc, #0x7
	mov	#Ram+12,w0	; Ram+12=JSR
    1d4c:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    1d4e:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    1d50:	3c 00 32    	bra       Z, 0x1dca <run_call>
	dec	w1,w1		; Ram+13=JUMP
    1d52:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    1d54:	4e 00 32    	bra       Z, 0x1df2 <run_jump>

00001d56 <chk_sfr>:
; check if source or dest was in SFR area, if so perform perpheral service
chk_sfr:
	  btsc	  Flag,#9		; #9 set if instruction is writing to SFR area
    1d56:	dd 29 af    	btsc.b    0x9dd, #0x1
	  call	  perform_SFR_write
    1d58:	94 26 02    	call      0x2694 <perform_SFR_write>
    1d5a:	00 00 00 
	  btsc	  Flag,#10		; #10 set if instruction is reading from SFR area
    1d5c:	dd 49 af    	btsc.b    0x9dd, #0x2
	  call	  perform_SFR_read
    1d5e:	34 27 02    	call      0x2734 <perform_SFR_read>
    1d60:	00 00 00 
	return
    1d62:	00 00 06    	return    

00001d64 <spec_ins>:
;------------------------
spec_ins:			; <------ executed both from SS and RUN
	bra	w7
    1d64:	07 60 01    	bra       w7
;...
	bra	spec0	; dummy
    1d66:	07 00 37    	bra       0x1d76 <spec0>
	bra	spec1	; JR   N
    1d68:	07 00 37    	bra       0x1d78 <spec1>
	bra	spec2	; DSZ  RY
    1d6a:	0f 00 37    	bra       0x1d8a <spec2>
	bra	spec3	; EXR  N
    1d6c:	16 00 37    	bra       0x1d9a <spec3>
	bra	spec4	; RET R0,N
    1d6e:	18 00 37    	bra       0x1da0 <spec4>
	bra	spec5	; LPC  NN
    1d70:	1d 00 37    	bra       0x1dac <spec5>
	bra	spec6	; SKIP F,M
    1d72:	22 00 37    	bra       0x1db8 <spec6>
	bra	spec7	; reserved
    1d74:	23 00 37    	bra       0x1dbc <spec7>

00001d76 <spec0>:
; --------------------
spec0:			; flag 00 = dummy instruction
	return
    1d76:	00 00 06    	return    

00001d78 <spec1>:
;		
spec1:			; flag 01 = special instruction: JR NN
	btsc	w5,#8		; displacement is signed 9-bit number
    1d78:	05 80 a7    	btsc.w    w5, #0x8
	sub	#0x200,w5	; if displacement is negative
    1d7a:	05 20 b1    	sub.w     #0x200, w5
	add	w9,w5,w9	; new PC value
    1d7c:	85 84 44    	add.w     w9, w5, w9

00001d7e <w9range>:
w9range:
	mov	#0x2000,w0
    1d7e:	00 00 22    	mov.w     #0x2000, w0
	btsc	w9,#14
    1d80:	09 e0 a7    	btsc.w    w9, #0xe
	sub	w9,w0,w9	; fit w9 < end of program memory
    1d82:	80 84 54    	sub.w     w9, w0, w9
	btss	w9,#13
    1d84:	09 d0 a6    	btss.w    w9, #0xd
	add	w9,w0,w9	; fit w9 > start-1 of program memory
    1d86:	80 84 44    	add.w     w9, w0, w9
	return
    1d88:	00 00 06    	return    

00001d8a <spec2>:
;		
spec2:			; flag 02 = special instruction: DSZ RY
	mov.b	w13,[w5]	; w13 = RY after decrement, w5 = RY address
    1d8a:	8d 4a 78    	mov.b     w13, [w5]
	cp0	w13
    1d8c:	0d 00 e0    	cp0.w     w13
	ifnz
    1d8e:	42 20 ae    	btss.b    0x42, #0x1
	return
    1d90:	00 00 06    	return    
	inc2	w9,w9		; skip (inrement PC)
    1d92:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    1d94:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    1d96:	09 00 22    	mov.w     #0x2000, w9
	return
    1d98:	00 00 06    	return    

00001d9a <spec3>:
;		
spec3:			; flag 03 = special instruction: EXR N
	btg	A16,#b_exr
    1d9a:	ae 29 aa    	btg.b     0x9ae, #0x1
	goto	swapper
    1d9c:	62 24 04    	goto      0x2462 <swapper>
    1d9e:	00 00 00 

00001da0 <spec4>:
;		
spec4:			; flag 04 = special instruction: RET R0,N
	cp0	Stack
    1da0:	2a 09 e2    	cp0.w     0x92a
	bra	z,stackerr7	; stack underflow
    1da2:	0f 00 32    	bra       Z, 0x1dc2 <stackerr7>
	mov.b	w12,[w10]	; store #N to R0
    1da4:	0c 4d 78    	mov.b     w12, [w10]
	mov	w5,w9		; store ret address to PC
    1da6:	85 04 78    	mov.w     w5, w9
	dec	Stack		; new Stack
    1da8:	2a 29 ed    	dec.w     0x92a
	return
    1daa:	00 00 06    	return    

00001dac <spec5>:
;		
spec5:			; flag 05 = special instruction: MOV PC,NN
	mov.b	w5,[w10+15]	; write hi nibble to PCH (irregular, but possible use of w5)
    1dac:	75 4d 98    	mov.b     w5, [w10+15]
	mov.b	w8,[w10+14]	; write low nibble to PCL (irregular, but possible use of w8)
    1dae:	68 4d 98    	mov.b     w8, [w10+14]
	mov	#Ram+0x0B,w8	; restore w8
    1db0:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    1db2:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; restore w8
    1db4:	b8 8f 20    	mov.w     #0x8fb, w8
	return
    1db6:	00 00 06    	return    

00001db8 <spec6>:
;		
spec6:			; flag 06 = special instruction: SKIP F,M
	mov	w5,w9		; store new address to PC
    1db8:	85 04 78    	mov.w     w5, w9
	return
    1dba:	00 00 06    	return    

00001dbc <spec7>:
;		
spec7:			; flag 07 is reserved
	return
    1dbc:	00 00 06    	return    

00001dbe <stackerr6>:
;------------------------------------------
stackerr6:			; Fatal Error, Stack overflow
	mov	#6,w0		; Stack=6: Overflow (5+1)
    1dbe:	60 00 20    	mov.w     #0x6, w0
	bra	skrerr
    1dc0:	01 00 37    	bra       0x1dc4 <skrerr>

00001dc2 <stackerr7>:
stackerr7:			; Fatal Error, Stack underflow
	mov	#7,w0		; Stack=7: Underflow (0-1)
    1dc2:	70 00 20    	mov.w     #0x7, w0

00001dc4 <skrerr>:
skrerr:
	mov	w0,Stack
    1dc4:	50 49 88    	mov.w     w0, 0x92a
	bset	Flag2,#5	; #5 Fatal Stack Error
    1dc6:	de a9 a8    	bset.b    0x9de, #0x5
	return
    1dc8:	00 00 06    	return    

00001dca <run_call>:

;#################################################################################
run_call:			; - - - - - - - - - - - - - - - - -  RUN CALL   <----
	mov	Stack,w0
    1dca:	50 49 80    	mov.w     0x92a, w0
	cp	w0,#5
    1dcc:	65 00 e1    	cp.w      w0, #0x5
	bra	c,stackerr6	; stack overflow
    1dce:	f7 ff 31    	bra       C, 0x1dbe <stackerr6>
	mul.uu	w0,#3,w0	; w0:w1
    1dd0:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16,w0		; stack starts at Ram+16
    1dd2:	00 01 b0    	add.w     #0x10, w0
	add	w0,w10,w1	; w1 = current stack
    1dd4:	8a 00 40    	add.w     w0, w10, w1
; push ret addr on stack
	mov	#Rom,w0
    1dd6:	00 00 22    	mov.w     #0x2000, w0
	sub	w9,w0,w9
    1dd8:	80 84 54    	sub.w     w9, w0, w9
	lsr	w9,w9
    1dda:	89 04 d1    	lsr.w     w9, w9
	and	w9,#0x0F,w0
    1ddc:	6f 80 64    	and.w     w9, #0xf, w0
	mov.b	w0,[w1++]	; push low ret addr on stack
    1dde:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#4,w0
    1de0:	44 48 de    	lsr.w     w9, #0x4, w0
	and	w0,#0x0F,w0
    1de2:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push med ret addr on stack
    1de4:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#8,w0
    1de6:	48 48 de    	lsr.w     w9, #0x8, w0
	and	w0,#0x0F,w0
    1de8:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push hi ret addr on stack
    1dea:	80 58 78    	mov.b     w0, [w1++]
	inc	Stack
    1dec:	2a 29 ec    	inc.w     0x92a
; load new ProgMemAddr from registers RC RE RF
	mov.b	Ram+12,WREG
    1dee:	0c c8 bf    	mov.b     0x80c, WREG
	bra	skr_run
    1df0:	01 00 37    	bra       0x1df4 <skr_run>

00001df2 <run_jump>:
run_jump:			; - - - - - - - - - - - - - - - - -  RUN JUMP   <----
	mov.b	Ram+13,WREG
    1df2:	0d c8 bf    	mov.b     0x80d, WREG

00001df4 <skr_run>:
skr_run:
	ze	w0,w1
    1df4:	80 80 fb    	ze        w0, w1
	mov.b	Ram+15,WREG
    1df6:	0f c8 bf    	mov.b     0x80f, WREG
	sl	w0,#4,w0
    1df8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Ram+14,WREG
    1dfa:	0e 48 b7    	ior.b     0x80e, WREG
	ze	w0,w0
    1dfc:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0
    1dfe:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w1,w0
    1e00:	01 40 70    	ior.b     w0, w1, w0
	mov	w0,w9		; correction, as SS farm increments Prog Mem Addr
    1e02:	80 04 78    	mov.w     w0, w9
	sl	w9,w9		; ×2
    1e04:	89 04 d0    	sl.w      w9, w9
	mov	#Rom,w0
    1e06:	00 00 22    	mov.w     #0x2000, w0
	add	w9,w0,w9
    1e08:	80 84 44    	add.w     w9, w0, w9
	return
    1e0a:	00 00 06    	return    

00001e0c <ind_4_1>:

; ----------------------------------------------------------------------------------- 
; ------------------------     I N S T R U C T I O N S     -------------------------- 
; ----------------------------------------------------------------------------------- 
; Label Name Rules:								      
; IND subroutines: with INDirectly addressed operands (SS and RUN modes)              
; DIR subroutines: with DIRectly addressed operands (ALU mode)                        
; First digit: _4 means 4-bit operand						      
; First digit: _8 means 8-bit operand						      
; Second digit _0..._15 is Opcode (or Opcode extension) digit			      

ind_4_1:   ; ------------------------------------------------------   1   ADD RX,RY (49T)
; IN register service
	mov	PORTB,w0
    1e0c:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1e0e:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1e10:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1e12:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1e14:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1e16:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1e18:	6a 46 7e    	mov.b     [w10+w12], w12

00001e1a <dir_4_1>:
dir_4_1:
	mov	w11,Atemp	; pre-load Accu temp
    1e1a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1e1c:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds		; uses w0
    1e1e:	f0 f8 2f    	mov.w     #0xff8f, w0
    1e20:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1e22:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1e24:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1e26:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1e28:	02 4f 23    	mov.w     #0x34f0, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1e2a:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1e2c:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1e2e:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1e30:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1e32:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1e34:	14 00 37    	bra       0x1e5e <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1e36:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1e38:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1e3a:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1e3c:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1e3e:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1e40:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1e42:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1e44:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1e46:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1e48:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1e4a:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1e4c:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1e4e:	89 84 e8    	inc2.w    w9, w9
    1e50:	09 e0 a7    	btsc.w    w9, #0xe
    1e52:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1e54:	00 40 a6    	btss.w    w0, #0x4
	return
    1e56:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1e58:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1e5a:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1e5c:	00 00 06    	return    

00001e5e <slow3flags1111>:

slow3flags1111:
	mov	#0b1111,w6	; move VZCA
    1e5e:	f6 00 20    	mov.w     #0xf, w6

00001e60 <slow3flags_keepw6>:
slow3flags_keepw6:
	bclr	Vflag,#0
    1e60:	30 09 a9    	bclr.b    0x930, #0x0
	bclr	Zflag,#0
    1e62:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    1e64:	2c 09 a9    	bclr.b    0x92c, #0x0
	btsc	w0,#6
    1e66:	00 60 a7    	btsc.w    w0, #0x6
	bset	Vflag,#0
    1e68:	30 09 a8    	bset.b    0x930, #0x0
	btsc	w0,#5
    1e6a:	00 50 a7    	btsc.w    w0, #0x5
	bset	Zflag,#0
    1e6c:	2e 09 a8    	bset.b    0x92e, #0x0
	btsc	w0,#4
    1e6e:	00 40 a7    	btsc.w    w0, #0x4
	bset	Cflag,#0
    1e70:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    1e72:	00 00 06    	return    

00001e74 <ind_4_2>:

ind_4_2:   ; ------------------------------------------------------   2   ADC RX,RY (52T)
; IN register service
	mov	PORTB,w0
    1e74:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1e76:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1e78:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1e7a:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1e7c:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1e7e:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1e80:	6a 46 7e    	mov.b     [w10+w12], w12

00001e82 <dir_4_2>:
dir_4_2:
	mov	w11,Atemp	; pre-load Accu temp
    1e82:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1e84:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	bclr	A16,#b_data_inv
    1e86:	ae 89 a9    	bclr.b    0x9ae, #0x4
	bset	A16,#b_cena
    1e88:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1e8a:	e0 9a 20    	mov.w     #0x9ae, w0
	btst.c	[w0],#b_carry	; A16,#b_carry ---> C
    1e8c:	10 c0 a3    	btst.c    [w0], #0xc
	mov	#b_cin,w3
    1e8e:	53 00 20    	mov.w     #0x5, w3
	bsw.c	[w0],w3		; C ---> A16,#b_cin
    1e90:	10 18 ad    	bsw.c     [w0], w3
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1e92:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1e94:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1e96:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1e98:	02 4f 23    	mov.w     #0x34f0, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1e9a:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1e9c:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1e9e:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1ea0:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1ea2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1ea4:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1ea6:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1ea8:	da ff 37    	bra       0x1e5e <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1eaa:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1eac:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1eae:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1eb0:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1eb2:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1eb4:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1eb6:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1eb8:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1eba:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1ebc:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1ebe:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1ec0:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1ec2:	89 84 e8    	inc2.w    w9, w9
    1ec4:	09 e0 a7    	btsc.w    w9, #0xe
    1ec6:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1ec8:	00 40 a6    	btss.w    w0, #0x4
	return
    1eca:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1ecc:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1ece:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1ed0:	00 00 06    	return    

00001ed2 <ind_4_3>:

ind_4_3:   ; ------------------------------------------------------   3   SUB RX,RY (50T)
; IN register service
	mov	PORTB,w0
    1ed2:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1ed4:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1ed6:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1ed8:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1eda:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1edc:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1ede:	6a 46 7e    	mov.b     [w10+w12], w12

00001ee0 <dir_4_3>:
dir_4_3:
	mov	w11,Atemp	; pre-load Accu temp
    1ee0:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1ee2:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1ee4:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1ee6:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    1ee8:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    1eea:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1eec:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1eee:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1ef0:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    1ef2:	22 4f 23    	mov.w     #0x34f2, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1ef4:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1ef6:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1ef8:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1efa:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1efc:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1efe:	af ff 37    	bra       0x1e5e <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1f00:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1f02:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1f04:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f06:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f08:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f0a:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f0c:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f0e:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f10:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f12:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f14:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1f16:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1f18:	89 84 e8    	inc2.w    w9, w9
    1f1a:	09 e0 a7    	btsc.w    w9, #0xe
    1f1c:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1f1e:	00 40 a6    	btss.w    w0, #0x4
	return
    1f20:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1f22:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1f24:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1f26:	00 00 06    	return    

00001f28 <ind_4_4>:

ind_4_4:   ; ------------------------------------------------------   4   SBB RX,RY (54T)
; IN register service
	mov	PORTB,w0
    1f28:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f2a:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f2c:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f2e:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f30:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1f32:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1f34:	6a 46 7e    	mov.b     [w10+w12], w12

00001f36 <dir_4_4>:
dir_4_4:
	mov	w11,Atemp	; pre-load Accu temp
    1f36:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f38:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1f3a:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1f3c:	ae 89 a8    	bset.b    0x9ae, #0x4
	bset	A16,#b_cena
    1f3e:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1f40:	e0 9a 20    	mov.w     #0x9ae, w0
	btst	[w0],#b_carry	; A16,#b_carry ---> C
    1f42:	10 c8 a3    	btst.z    [w0], #0xc
	ccf
    1f44:	42 00 aa    	btg.b     0x42, #0x0
	mov	#b_cin,w3
    1f46:	53 00 20    	mov.w     #0x5, w3
	bsw	[w0],w3		; C ---> A16,#b_cin
    1f48:	10 98 ad    	bsw.z     [w0], w3
	ccf
    1f4a:	42 00 aa    	btg.b     0x42, #0x0
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1f4c:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1f4e:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1f50:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1f52:	02 4f 23    	mov.w     #0x34f0, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1f54:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1f56:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1f58:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1f5a:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1f5c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1f5e:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1f60:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1f62:	7d ff 37    	bra       0x1e5e <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1f64:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1f66:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1f68:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f6a:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f6c:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f6e:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f70:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f72:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f74:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f76:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f78:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1f7a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1f7c:	89 84 e8    	inc2.w    w9, w9
    1f7e:	09 e0 a7    	btsc.w    w9, #0xe
    1f80:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1f82:	00 40 a6    	btss.w    w0, #0x4
	return
    1f84:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1f86:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1f88:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1f8a:	00 00 06    	return    

00001f8c <ind_4_5>:

ind_4_5:   ; ------------------------------------------------------   5   OR RX,RY (T)
; IN register service
	mov	PORTB,w0
    1f8c:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f8e:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f90:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f92:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f94:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    1f96:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    1f98:	6a 46 7e    	mov.b     [w10+w12], w12

00001f9a <dir_4_5>:
dir_4_5:
	mov	w11,Atemp	; pre-load Accu temp
    1f9a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f9c:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    1f9e:	f0 f8 2f    	mov.w     #0xff8f, w0
    1fa0:	ae 29 b6    	and.w     0x9ae
; exec
	ior	w11,w12,w13	; exec
    1fa2:	8c 86 75    	ior.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1fa4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    1fa6:	0b 00 37    	bra       0x1fbe <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1fa8:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    1faa:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    1fac:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    1fae:	2e 29 ef    	clr.w     0x92e
	ifz
    1fb0:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    1fb2:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1fb4:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1fb6:	89 84 e8    	inc2.w    w9, w9
    1fb8:	09 e0 a7    	btsc.w    w9, #0xe
    1fba:	09 00 22    	mov.w     #0x2000, w9

	return
    1fbc:	00 00 06    	return    

00001fbe <slowZflag0101>:
slowZflag0101:
	mov	#0b0101,w6	; move VZCA
    1fbe:	56 00 20    	mov.w     #0x5, w6
	bclr	Zflag,#0
    1fc0:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    1fc2:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    1fc4:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    1fc6:	00 00 06    	return    

00001fc8 <ind_4_6>:

ind_4_6:   ; ------------------------------------------------------   6   AND RX,RY (T)
; IN register service
	mov	PORTB,w0
    1fc8:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1fca:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1fcc:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1fce:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1fd0:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    1fd2:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    1fd4:	6a 46 7e    	mov.b     [w10+w12], w12

00001fd6 <dir_4_6>:
dir_4_6:
	mov	w11,Atemp	; pre-load Accu temp
    1fd6:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1fd8:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    1fda:	f0 f8 2f    	mov.w     #0xff8f, w0
    1fdc:	ae 29 b6    	and.w     0x9ae
; exec
	and	w11,w12,w13	; exec
    1fde:	8c 86 65    	and.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1fe0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    1fe2:	ed ff 37    	bra       0x1fbe <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1fe4:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    1fe6:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    1fe8:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    1fea:	2e 29 ef    	clr.w     0x92e
	ifz
    1fec:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    1fee:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1ff0:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1ff2:	89 84 e8    	inc2.w    w9, w9
    1ff4:	09 e0 a7    	btsc.w    w9, #0xe
    1ff6:	09 00 22    	mov.w     #0x2000, w9

	return
    1ff8:	00 00 06    	return    

00001ffa <ind_4_7>:

ind_4_7:   ; ------------------------------------------------------   7   XOR RX,RY (T)
; IN register service
	mov	PORTB,w0
    1ffa:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1ffc:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1ffe:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2000:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    2002:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    2004:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2006:	6a 46 7e    	mov.b     [w10+w12], w12

00002008 <dir_4_7>:
dir_4_7:
	mov	w11,Atemp	; pre-load Accu temp
    2008:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    200a:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    200c:	f0 f8 2f    	mov.w     #0xff8f, w0
    200e:	ae 29 b6    	and.w     0x9ae
; exec
	xor	w11,w12,w13	; exec
    2010:	8c 86 6d    	xor.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2012:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    2014:	d4 ff 37    	bra       0x1fbe <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2016:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2018:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    201a:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    201c:	2e 29 ef    	clr.w     0x92e
	ifz
    201e:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    2020:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    2022:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2024:	89 84 e8    	inc2.w    w9, w9
    2026:	09 e0 a7    	btsc.w    w9, #0xe
    2028:	09 00 22    	mov.w     #0x2000, w9

	return
    202a:	00 00 06    	return    

0000202c <ind_4_8>:

ind_4_8:   ; ------------------------------------------------------   8   MOV RX,RY (T)
; IN register service
	mov	PORTB,w0
    202c:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    202e:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2030:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2032:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    2034:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    2036:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    2038:	6a 46 7e    	mov.b     [w10+w12], w12

0000203a <dir_4_8>:
dir_4_8:
	mov	w11,Atemp	; pre-load Accu temp
    203a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    203c:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    203e:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    2040:	f0 f8 2f    	mov.w     #0xff8f, w0
    2042:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    2044:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2046:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2048:	0c 00 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    204a:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    204c:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    204e:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2050:	89 84 e8    	inc2.w    w9, w9
    2052:	09 e0 a7    	btsc.w    w9, #0xe
    2054:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    2056:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    2058:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    205a:	b7 fe 32    	bra       Z, 0x1dca <run_call>
	dec	w1,w1		; Ram+13=JUMP
    205c:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    205e:	c9 fe 32    	bra       Z, 0x1df2 <run_jump>
	return
    2060:	00 00 06    	return    

00002062 <slowAccu0001>:
slowAccu0001:
	mov	#0b0001,w6	; move VZCA
    2062:	16 00 20    	mov.w     #0x1, w6
	return
    2064:	00 00 06    	return    

00002066 <ind_4_9>:

ind_4_9:   ; ------------------------------------------------------   9   MOV RX,N (T)
; IN register service
	mov	PORTB,w0
    2066:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2068:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    206a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    206c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    206e:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    2070:	ea c5 7d    	mov.b     [w10+w11], w11
	mov	w11,Atemp	; pre-load Accu temp
    2072:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2074:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    2076:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    2078:	f0 f8 2f    	mov.w     #0xff8f, w0
    207a:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    207c:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    207e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2080:	f0 ff 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2082:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2084:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2086:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2088:	89 84 e8    	inc2.w    w9, w9
    208a:	09 e0 a7    	btsc.w    w9, #0xe
    208c:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    208e:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    2090:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    2092:	9b fe 32    	bra       Z, 0x1dca <run_call>
	dec	w1,w1		; Ram+13=JUMP
    2094:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    2096:	ad fe 32    	bra       Z, 0x1df2 <run_jump>
	return
    2098:	00 00 06    	return    

0000209a <ind_4_10>:

ind_4_10:   ; -----------------------------------------------------   10  MOV [XY],R0 (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    209a:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    209c:	6a 46 7e    	mov.b     [w10+w12], w12
	sl	w11,#4,w7	; 16 × X
    209e:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    20a0:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    20a2:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    20a4:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    20a6:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    20a8:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    20aa:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    20ac:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    20ae:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    20b0:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    20b2:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    20b4:	f0 f8 2f    	mov.w     #0xff8f, w0
    20b6:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    20b8:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    20ba:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    20bc:	d2 ff 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    20be:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20c0:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    20c2:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20c4:	89 84 e8    	inc2.w    w9, w9
    20c6:	09 e0 a7    	btsc.w    w9, #0xe
    20c8:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    20ca:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    20cc:	00 00 06    	return    
	bra	perform_SFR_write
    20ce:	e2 02 37    	bra       0x2694 <perform_SFR_write>

000020d0 <ind_4_11>:

ind_4_11:   ; -----------------------------------------------------   11  MOV R0,[XY] (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    20d0:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    20d2:	6a 46 7e    	mov.b     [w10+w12], w12
	mov	w10,w7		; dst addr to w7 (just for convention)
    20d4:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    20d6:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    20d8:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    20da:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    20dc:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    20de:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    20e0:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr1
    20e2:	02 00 3a    	bra       NZ, 0x20e8 <nosfr1>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    20e4:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    20e6:	8c 02 78    	mov.w     w12, w5

000020e8 <nosfr1>:
nosfr1:
	clr	w11		; clear 1st operand displayed
    20e8:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    20ea:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    20ec:	f0 f8 2f    	mov.w     #0xff8f, w0
    20ee:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    20f0:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    20f2:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    20f4:	b6 ff 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    20f6:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20f8:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    20fa:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20fc:	89 84 e8    	inc2.w    w9, w9
    20fe:	09 e0 a7    	btsc.w    w9, #0xe
    2100:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    2102:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    2104:	00 00 06    	return    
	bra	perform_SFR_read
    2106:	16 03 37    	bra       0x2734 <perform_SFR_read>

00002108 <ind_4_12>:

ind_4_12:   ; -----------------------------------------------------   12  MOV [NN],R0 (T)
	sl	w11,#4,w7	; 16 × X
    2108:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    210a:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    210c:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    210e:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    2110:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    2112:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    2114:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    2116:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    2118:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    211a:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    211c:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    211e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2120:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    2122:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2124:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2126:	9d ff 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2128:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    212a:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    212c:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    212e:	89 84 e8    	inc2.w    w9, w9
    2130:	09 e0 a7    	btsc.w    w9, #0xe
    2132:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    2134:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    2136:	00 00 06    	return    
	bra	perform_SFR_write
    2138:	ad 02 37    	bra       0x2694 <perform_SFR_write>

0000213a <ind_4_13>:


ind_4_13:   ; -----------------------------------------------------   13  MOV R0,[NN] (T)
	mov	w10,w7		; dst addr to w7 (just for convention)
    213a:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    213c:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    213e:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    2140:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    2142:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    2144:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    2146:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr2
    2148:	02 00 3a    	bra       NZ, 0x214e <nosfr2>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    214a:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    214c:	8c 02 78    	mov.w     w12, w5

0000214e <nosfr2>:
nosfr2:
	clr	w11		; clear 1st operand displayed
    214e:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    2150:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    2152:	f0 f8 2f    	mov.w     #0xff8f, w0
    2154:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    2156:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2158:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    215a:	83 ff 37    	bra       0x2062 <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    215c:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    215e:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2160:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2162:	89 84 e8    	inc2.w    w9, w9
    2164:	09 e0 a7    	btsc.w    w9, #0xe
    2166:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    2168:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    216a:	00 00 06    	return    
	bra	perform_SFR_read
    216c:	e3 02 37    	bra       0x2734 <perform_SFR_read>

0000216e <ind_4_14>:

ind_4_14:   ; -----------------------------------------------------   14  MOV PC,NN (T)
; maintain logic diagram
	clr3leds
    216e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2170:	ae 29 b6    	and.w     0x9ae

	mov	w11,w5
    2172:	8b 02 78    	mov.w     w11, w5
	mov	w12,w8
    2174:	0c 04 78    	mov.w     w12, w8
	clr	w11		; clear 1st operand displayed
    2176:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    2178:	00 06 eb    	clr.w     w12

	mov	#0x05,w7	; flag "MOV PC,NN" instead of "MOV W13,[W7]"
    217a:	57 00 20    	mov.w     #0x5, w7
	mov	w14,w13
    217c:	8e 06 78    	mov.w     w14, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    217e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2180:	04 00 37    	bra       0x218a <phases_0>

	incpc			; w9++
    2182:	89 84 e8    	inc2.w    w9, w9
    2184:	09 e0 a7    	btsc.w    w9, #0xe
    2186:	09 00 22    	mov.w     #0x2000, w9

	bra	spec5
    2188:	11 fe 37    	bra       0x1dac <spec5>

0000218a <phases_0>:
phases_0:
	mov	#0b0000,w6	; move VZCA
    218a:	06 00 20    	mov.w     #0x0, w6
	return
    218c:	00 00 06    	return    

0000218e <ind_4_15>:

ind_4_15:   ; -----------------------------------------------------   15  JR NN (T)
; maintain logic diagram
	clr3leds
    218e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2190:	ae 29 b6    	and.w     0x9ae
; exec
	sl	w11,#4,w5	; 16 × X
    2192:	c4 5a dd    	sl.w      w11, #0x4, w5
	add	w5,w12,w5	; 16 × X + Y (8-bit displacement addr)
    2194:	8c 82 42    	add.w     w5, w12, w5
	sl	w5,w5		; ×2, now in 9-bit range 0...0x1FE (signed -0x100...0xFF)
    2196:	85 02 d0    	sl.w      w5, w5
	clr	w11		; clear 1st operand displayed
    2198:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    219a:	00 06 eb    	clr.w     w12

	mov	#0x01,w7	; flag "JR NN" instead of "MOV W13,[W7]"
    219c:	17 00 20    	mov.w     #0x1, w7
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    219e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    21a0:	f4 ff 37    	bra       0x218a <phases_0>
				; fast simplified exit (no flags)
	incpc			; w9++
    21a2:	89 84 e8    	inc2.w    w9, w9
    21a4:	09 e0 a7    	btsc.w    w9, #0xe
    21a6:	09 00 22    	mov.w     #0x2000, w9

	bra	spec1
    21a8:	e7 fd 37    	bra       0x1d78 <spec1>

000021aa <ind_8_0>:

; ###################################################################################

ind_8_0:   ; -----------------------------------------------------    00  CP R0,N (T)
; IN register service
	mov	PORTB,w0
    21aa:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    21ac:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    21ae:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    21b0:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    21b2:	9a 85 fb    	ze        [w10], w11

000021b4 <dir_8_0>:
dir_8_0:
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    21b4:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    21b6:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    21b8:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    21ba:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    21bc:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    21be:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    21c0:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    21c2:	22 4f 23    	mov.w     #0x34f2, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    21c4:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    21c6:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    21c8:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; result to Accu IN
    21ca:	ef 06 60    	and.w     w0, #0xf, w13
	mov	#Dummy,w7
    21cc:	07 9b 20    	mov.w     #0x9b0, w7
; get flags
	mov	#0b1110,w6	; move VZCA
    21ce:	e6 00 20    	mov.w     #0xe, w6
	btsc	Flag,#2		; #2 set if Speed>0
    21d0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags_keepw6
    21d2:	46 fe 37    	bra       0x1e60 <slow3flags_keepw6>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	clr	Vflag
    21d4:	30 29 ef    	clr.w     0x930
	clr	Zflag
    21d6:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    21d8:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    21da:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    21dc:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    21de:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    21e0:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    21e2:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    21e4:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    21e6:	89 84 e8    	inc2.w    w9, w9
    21e8:	09 e0 a7    	btsc.w    w9, #0xe
    21ea:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    21ec:	00 40 a6    	btss.w    w0, #0x4
	return
    21ee:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    21f0:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    21f2:	af 89 a8    	bset.b    0x9af, #0x4
	return
    21f4:	00 00 06    	return    

000021f6 <ind_8_1>:

ind_8_1:   ; -----------------------------------------------------    01  ADD R0,N (T)
; IN register service
	mov	PORTB,w0
    21f6:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    21f8:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    21fa:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    21fc:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    21fe:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    2200:	8a 03 78    	mov.w     w10, w7

00002202 <dir_8_1>:
dir_8_1:
	mov	w11,Atemp	; pre-load Accu temp
    2202:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2204:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2206:	f0 f8 2f    	mov.w     #0xff8f, w0
    2208:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    220a:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    220c:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    220e:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    2210:	02 4f 23    	mov.w     #0x34f0, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    2212:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    2214:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    2216:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2218:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    221a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    221c:	20 fe 37    	bra       0x1e5e <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    221e:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2220:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    2222:	30 29 ef    	clr.w     0x930
	clr	Zflag
    2224:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2226:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2228:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    222a:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    222c:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    222e:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    2230:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    2232:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    2234:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2236:	89 84 e8    	inc2.w    w9, w9
    2238:	09 e0 a7    	btsc.w    w9, #0xe
    223a:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    223c:	00 40 a6    	btss.w    w0, #0x4
	return
    223e:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    2240:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    2242:	af 89 a8    	bset.b    0x9af, #0x4
	return
    2244:	00 00 06    	return    

00002246 <ind_8_2>:

ind_8_2:   ; -----------------------------------------------------    02  INC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    2246:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    2248:	6a 46 7e    	mov.b     [w10+w12], w12

0000224a <dir_8_2>:
dir_8_2:
	mov	w12,Atemp	; pre-load Accu temp
    224a:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    224c:	0c 07 78    	mov.w     w12, w14
	mov	#1,w11		; "add 1" = "inc" (will be displayed)
    224e:	1b 00 20    	mov.w     #0x1, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    2250:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    2252:	f0 f8 2f    	mov.w     #0xff8f, w0
    2254:	ae 29 b6    	and.w     0x9ae
; exec 
	inc	w12,w0		; exec
    2256:	0c 00 e8    	inc.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2258:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    225a:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    225c:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 13)
    225e:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    2260:	0f 00 3a    	bra       NZ, 0x2280 <L43>
	cp0	Mode
    2262:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    2264:	0d 00 32    	bra       Z, 0x2280 <L43>
; extension to PCM and PCH
	cp0	w13
    2266:	0d 00 e0    	cp0.w     w13
	bra	nz,4f		; if no overflow from nibble 1
    2268:	0b 00 3a    	bra       NZ, 0x2280 <L43>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    226a:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    226c:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    226e:	90 4d 88    	mov.w     w0, 0x9b2
	  inc.b	  PcmPch+0	; inc PCM
    2270:	b2 69 ec    	inc.b     0x9b2
	  btss.b  PcmPch+0,#4	; PCM overflow?
    2272:	b2 89 ae    	btss.b    0x9b2, #0x4
	  bra	  4f		; if no overflow
    2274:	05 00 37    	bra       0x2280 <L43>
	  bclr.b  PcmPch+0,#4	; keep PCM in 4-bit range
    2276:	b2 89 a9    	bclr.b    0x9b2, #0x4
	  cp0.b	  PcmPch+0	; is there overflow from PCM nibble?
    2278:	b2 49 e2    	cp0.b     0x9b2
	  ifz			; if overflow from PCM nibble...
    227a:	42 20 af    	btsc.b    0x42, #0x1
	  inc.b	  PcmPch+1	; ...then inc PCH...
    227c:	b3 69 ec    	inc.b     0x9b3
	  bclr.b  PcmPch+1,#4	; ...and keep it in 4-bit range
    227e:	b3 89 a9    	bclr.b    0x9b3, #0x4

00002280 <L43>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2280:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow0111
    2282:	19 00 37    	bra       0x22b6 <slow0111>

	incpc			; w9++
    2284:	89 84 e8    	inc2.w    w9, w9
    2286:	09 e0 a7    	btsc.w    w9, #0xe
    2288:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    228a:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    228c:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    228e:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    2290:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    2292:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    2294:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    2296:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    2298:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    229a:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    229c:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    229e:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    22a0:	0d 00 e0    	cp0.w     w13
	bra	nz,no_write_02
    22a2:	03 00 3a    	bra       NZ, 0x22aa <no_write_02>
	mov	w2,Zflag	; if result zero, Z flag set
    22a4:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; if overflow, C flag set
    22a6:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    22a8:	af 89 a8    	bset.b    0x9af, #0x4

000022aa <no_write_02>:
no_write_02:
; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    22aa:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    22ac:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    22ae:	8d fd 32    	bra       Z, 0x1dca <run_call>
	dec	w1,w1		; Ram+13=JUMP
    22b0:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    22b2:	9f fd 32    	bra       Z, 0x1df2 <run_jump>
	return
    22b4:	00 00 06    	return    

000022b6 <slow0111>:
slow0111:
	mov	#0b0111,w6	; move VZCA
    22b6:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    22b8:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    22ba:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    22bc:	0d 00 e0    	cp0.w     w13
	bra	nz,goback
    22be:	02 00 3a    	bra       NZ, 0x22c4 <goback>
	bset	Zflag,#0	; if result zero, Z flag set
    22c0:	2e 09 a8    	bset.b    0x92e, #0x0
	bset	Cflag,#0	; if overflow, C flag set
    22c2:	2c 09 a8    	bset.b    0x92c, #0x0

000022c4 <goback>:
goback:
	return
    22c4:	00 00 06    	return    

000022c6 <ind_8_3>:

ind_8_3:   ; -----------------------------------------------------    03  DEC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    22c6:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    22c8:	6a 46 7e    	mov.b     [w10+w12], w12

000022ca <dir_8_3>:
dir_8_3:
	mov	w12,Atemp	; pre-load Accu temp
    22ca:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    22cc:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    22ce:	fb 00 20    	mov.w     #0xf, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    22d0:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    22d2:	f0 f8 2f    	mov.w     #0xff8f, w0
    22d4:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w0		; exec
    22d6:	0c 00 e9    	dec.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    22d8:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    22da:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    22dc:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 12)
    22de:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    22e0:	0e 00 3a    	bra       NZ, 0x22fe <L44>
	cp0	Mode
    22e2:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    22e4:	0c 00 32    	bra       Z, 0x22fe <L44>
; extension to PCM and PCH
	cp0	w12
    22e6:	0c 00 e0    	cp0.w     w12
	bra	nz,4f		; if PCL or JSR was not 0 before dec
    22e8:	0a 00 3a    	bra       NZ, 0x22fe <L44>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    22ea:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    22ec:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    22ee:	90 4d 88    	mov.w     w0, 0x9b2
	  dec.b	  PcmPch+0	; dec PCM
    22f0:	b2 69 ed    	dec.b     0x9b2
	  btss.b  PcmPch+0,#7	; PCM underflow?
    22f2:	b2 e9 ae    	btss.b    0x9b2, #0x7
	  bra	  4f		; if no underflow
    22f4:	04 00 37    	bra       0x22fe <L44>
	mov	#0x0F,w0
    22f6:	f0 00 20    	mov.w     #0xf, w0
	and.b	PcmPch+0	; mask low nibble bits of PCM
    22f8:	b2 69 b6    	and.b     0x9b2
	dec.b	PcmPch+1	; dec PCH
    22fa:	b3 69 ed    	dec.b     0x9b3
	and.b	PcmPch+1	; mask low nibble bits of PCH
    22fc:	b3 69 b6    	and.b     0x9b3

000022fe <L44>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    22fe:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow03
    2300:	17 00 37    	bra       0x2330 <slow03>

	incpc			; w9++
    2302:	89 84 e8    	inc2.w    w9, w9
    2304:	09 e0 a7    	btsc.w    w9, #0xe
    2306:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2308:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    230a:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    230c:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    230e:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    2310:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    2312:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    2314:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    2316:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2318:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    231a:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    231c:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    231e:	0d 00 e0    	cp0.w     w13
	ifz
    2320:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if zero, Z flag set
    2322:	72 49 88    	mov.w     w2, 0x92e
	cp	w13,#0x0F
    2324:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    2326:	42 20 ae    	btss.b    0x42, #0x1
	return
    2328:	00 00 06    	return    
	mov	w2,Cflag	; if "dec" did not cause result 0x1111
    232a:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    232c:	af 89 a8    	bset.b    0x9af, #0x4
	return
    232e:	00 00 06    	return    

00002330 <slow03>:
slow03:
	mov	#0b0111,w6	; move VZCA
    2330:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    2332:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    2334:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    2336:	0d 00 e0    	cp0.w     w13
	ifz
    2338:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0	; if zero, Z flag set
    233a:	2e 09 a8    	bset.b    0x92e, #0x0
	cp	w13,#0x0F
    233c:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    233e:	42 20 ae    	btss.b    0x42, #0x1
	bset	Cflag,#0	; if "dec" did not cause result 0x1111
    2340:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    2342:	00 00 06    	return    

00002344 <ind_8_4>:

ind_8_4:   ; -----------------------------------------------------    04  DSZ RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    2344:	8c 03 45    	add.w     w10, w12, w7
	ze	[w7],w12	; Y value
    2346:	17 86 fb    	ze        [w7], w12

00002348 <dir_8_4>:
dir_8_4:
	mov	w12,Atemp	; pre-load Accu temp
    2348:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    234a:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    234c:	fb 00 20    	mov.w     #0xf, w11
; maintain logic diagram
	clr3leds
    234e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2350:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w2		; exec
    2352:	0c 01 e9    	dec.w     w12, w2
	and	w2,#0x0F,w13	; w13 = new Accu value
    2354:	ef 06 61    	and.w     w2, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2356:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow04
    2358:	0d 00 37    	bra       0x2374 <slow04>

	incpc			; w9++
    235a:	89 84 e8    	inc2.w    w9, w9
    235c:	09 e0 a7    	btsc.w    w9, #0xe
    235e:	09 00 22    	mov.w     #0x2000, w9
				; fast simplified execution (no flags)
	mov.b	w13,[w7]	; write result to destination
    2360:	8d 4b 78    	mov.b     w13, [w7]
	mov	w13,w14
    2362:	0d 07 78    	mov.w     w13, w14
	mov	w13,Atemp
    2364:	4d 49 88    	mov.w     w13, 0x928
	cp0	w13
    2366:	0d 00 e0    	cp0.w     w13
	ifnz
    2368:	42 20 ae    	btss.b    0x42, #0x1
	return
    236a:	00 00 06    	return    

	incpc			; w9++
    236c:	89 84 e8    	inc2.w    w9, w9
    236e:	09 e0 a7    	btsc.w    w9, #0xe
    2370:	09 00 22    	mov.w     #0x2000, w9

	return
    2372:	00 00 06    	return    

00002374 <slow04>:
slow04:
	mov	w12,Atemp	; pre-load Accu temp
    2374:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2376:	0c 07 78    	mov.w     w12, w14
	mov	w7,w5		; new destination address (not w7)!
    2378:	87 02 78    	mov.w     w7, w5
	mov	#0x02,w7	; flag "DSZ RY" instead of "MOV W13,[W7]"
    237a:	27 00 20    	mov.w     #0x2, w7
	mov	#0b0000,w6	; move VZCA
    237c:	06 00 20    	mov.w     #0x0, w6
	return
    237e:	00 00 06    	return    

00002380 <ind_8_5>:

ind_8_5:   ; -----------------------------------------------------    05  OR R0,N (T)
; IN register service
	mov	PORTB,w0
    2380:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2382:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2384:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2386:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2388:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    238a:	8a 03 78    	mov.w     w10, w7

0000238c <dir_8_5>:
dir_8_5:
	mov	w11,Atemp	; pre-load Accu temp
    238c:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    238e:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2390:	f0 f8 2f    	mov.w     #0xff8f, w0
    2392:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w11,w12,w0
    2394:	0c 80 75    	ior.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2396:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	setc			; SET C unconditionally
    2398:	42 00 a8    	bset.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    239a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    239c:	0e 00 37    	bra       0x23ba <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    239e:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    23a0:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    23a2:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    23a4:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    23a6:	0d 00 e0    	cp0.w     w13
	ifz
    23a8:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    23aa:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; SET C unconditionally
    23ac:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED unconditionally
    23ae:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    23b0:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    23b2:	89 84 e8    	inc2.w    w9, w9
    23b4:	09 e0 a7    	btsc.w    w9, #0xe
    23b6:	09 00 22    	mov.w     #0x2000, w9

	return
    23b8:	00 00 06    	return    

000023ba <slowZCAflag0111>:

slowZCAflag0111:
	mov	#0b0111,w6	; move VZCA
    23ba:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    23bc:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    23be:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    23c0:	2e 09 a8    	bset.b    0x92e, #0x0
	bclr	Cflag,#0
    23c2:	2c 09 a9    	bclr.b    0x92c, #0x0
	ifc
    23c4:	42 00 af    	btsc.b    0x42, #0x0
	bset	Cflag,#0
    23c6:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    23c8:	00 00 06    	return    

000023ca <ind_8_6>:

ind_8_6:   ; -----------------------------------------------------    06  AND R0,N (T)
; IN register service
	mov	PORTB,w0
    23ca:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    23cc:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    23ce:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    23d0:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    23d2:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    23d4:	8a 03 78    	mov.w     w10, w7

000023d6 <dir_8_6>:
dir_8_6:
	mov	w11,Atemp	; pre-load Accu temp
    23d6:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    23d8:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    23da:	f0 f8 2f    	mov.w     #0xff8f, w0
    23dc:	ae 29 b6    	and.w     0x9ae
; exec 
	and	w11,w12,w0
    23de:	0c 80 65    	and.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    23e0:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	clrc			; CLR C unconditionally
    23e2:	42 00 a9    	bclr.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    23e4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    23e6:	e9 ff 37    	bra       0x23ba <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    23e8:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    23ea:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    23ec:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    23ee:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    23f0:	0d 00 e0    	cp0.w     w13
	ifz
    23f2:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    23f4:	72 49 88    	mov.w     w2, 0x92e
	clr	Cflag		; clr C unconditionally
    23f6:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED unconditionally
    23f8:	af 89 a9    	bclr.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    23fa:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    23fc:	89 84 e8    	inc2.w    w9, w9
    23fe:	09 e0 a7    	btsc.w    w9, #0xe
    2400:	09 00 22    	mov.w     #0x2000, w9

	return
    2402:	00 00 06    	return    

00002404 <ind_8_7>:

ind_8_7:   ; -----------------------------------------------------    07  XOR R0,N (T)
; IN register service
	mov	PORTB,w0
    2404:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2406:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2408:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    240a:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    240c:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    240e:	8a 03 78    	mov.w     w10, w7

00002410 <dir_8_7>:
dir_8_7:
	mov	w11,Atemp	; pre-load Accu temp
    2410:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2412:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2414:	f0 f8 2f    	mov.w     #0xff8f, w0
    2416:	ae 29 b6    	and.w     0x9ae
; exec 
	clrc
    2418:	42 00 a9    	bclr.b    0x42, #0x0
	btss	A16,#b_carry
    241a:	af 89 ae    	btss.b    0x9af, #0x4
	setc			; CPL C unconditionally
    241c:	42 00 a8    	bset.b    0x42, #0x0
	xor	w11,w12,w0
    241e:	0c 80 6d    	xor.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2420:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2422:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    2424:	ca ff 37    	bra       0x23ba <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2426:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2428:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    242a:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    242c:	2e 29 ef    	clr.w     0x92e
	bclr	A16,#b_carry	; Carry button LED
    242e:	af 89 a9    	bclr.b    0x9af, #0x4
	cp0	w13
    2430:	0d 00 e0    	cp0.w     w13
	ifz
    2432:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; Z flag
    2434:	72 49 88    	mov.w     w2, 0x92e

	btsc	Cflag,#2
    2436:	2c 49 af    	btsc.b    0x92c, #0x2
	clr	w2		; w2,#2,1,0 = complement Cflag,#2
    2438:	00 01 eb    	clr.w     w2
	mov	w2,Cflag	; cpl C unconditionally (bits 2,1,0)
    243a:	62 49 88    	mov.w     w2, 0x92c
	
	btsc	w2,#0
    243c:	02 00 a7    	btsc.w    w2, #0x0
	bset	A16,#b_carry	; Carry button LED
    243e:	af 89 a8    	bset.b    0x9af, #0x4

	mov.b	w13,[w7]	; write result to destination
    2440:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2442:	89 84 e8    	inc2.w    w9, w9
    2444:	09 e0 a7    	btsc.w    w9, #0xe
    2446:	09 00 22    	mov.w     #0x2000, w9

	return
    2448:	00 00 06    	return    

0000244a <ind_8_8>:

ind_8_8:   ; -----------------------------------------------------    08  EXR N (T)
; IN register service
	mov	PORTB,w0
    244a:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    244c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    244e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2450:	00 4c 78    	mov.b     w0, [w8]

	clr	w11		; 1st operand = 0 (what else?)
    2452:	80 05 eb    	clr.w     w11
; maintain logic diagram
	clr3leds
    2454:	f0 f8 2f    	mov.w     #0xff8f, w0
    2456:	ae 29 b6    	and.w     0x9ae
	btsc	Flag,#2		; #2 set if Speed>0
    2458:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow08
    245a:	0f 00 37    	bra       0x247a <slow08>

	incpc			; w9++
    245c:	89 84 e8    	inc2.w    w9, w9
    245e:	09 e0 a7    	btsc.w    w9, #0xe
    2460:	09 00 22    	mov.w     #0x2000, w9

00002462 <swapper>:
; exec 
swapper:
	mov	w12,w2
    2462:	0c 01 78    	mov.w     w12, w2
	cp0	w2
    2464:	02 00 e0    	cp0.w     w2
	ifz
    2466:	42 20 af    	btsc.b    0x42, #0x1
	mov	#16,w2		; 0 members ---> 16 members
    2468:	02 01 20    	mov.w     #0x10, w2
	mov	#Ram,w3
    246a:	03 80 20    	mov.w     #0x800, w3
	mov	#Ram+(14*16),w4	; page 14
    246c:	04 8e 20    	mov.w     #0x8e0, w4

0000246e <L27>:
2:
	ze	[w4],w0		; [page 14] ---> w0
    246e:	14 80 fb    	ze        [w4], w0
	mov.b	[w3],[w4++]	;  [page 0] ---> [page 14]
    2470:	13 5a 78    	mov.b     [w3], [w4++]
	mov.b	w0,[w3++]	;        w0 ---> [page 0]
    2472:	80 59 78    	mov.b     w0, [w3++]
	dec	w2,w2
    2474:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b		; swap loop -------->
    2476:	fb ff 3a    	bra       NZ, 0x246e <L27>
	return
    2478:	00 00 06    	return    

0000247a <slow08>:
slow08:
	mov	#0x03,w7	; flag "EXR N" instead of "MOV W13,[W7]"
    247a:	37 00 20    	mov.w     #0x3, w7
	mov	#0b0000,w6	; move VZCA
    247c:	06 00 20    	mov.w     #0x0, w6
	return
    247e:	00 00 06    	return    

00002480 <ind_8_9>:

ind_8_9:   ; -----------------------------------------------------    09  BIT RG,M (T)
; IN register service
	mov	PORTB,w0
    2480:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2482:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2484:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2486:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    2488:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    248a:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    248c:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if reading from reg 0, 1, 2
    248e:	03 00 3a    	bra       NZ, 0x2496 <L113>
; if reading from reg 3 (IN port)
	mov	#0x0B,w0	; R0A (IN A)
    2490:	b0 00 20    	mov.w     #0xb, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    2492:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFB,w0	; RFA (IN B)
    2494:	b0 0f 20    	mov.w     #0xfb, w0

00002496 <L113>:
1:
	add	w10,w0,w7	; result write address
    2496:	80 03 45    	add.w     w10, w0, w7

00002498 <dir_8_9>:
dir_8_9:
	ze	[w7],w11	; value of addressed nibble
    2498:	97 85 fb    	ze        [w7], w11
	ze	[w7],w13	; this cancels later writing to [w7] (in routine "phases")
    249a:	97 86 fb    	ze        [w7], w13
	and	w12,#3,w2	; w2 = M isolated
    249c:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    249e:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    24a0:	02 06 dd    	sl.w      w0, w2, w12
; exec 
	and	w12,w11,w0	; only flag Z is the result
    24a2:	0b 00 66    	and.w     w12, w11, w0
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    24a4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0100
    24a6:	08 00 37    	bra       0x24b8 <slowZflag0100>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	#7,w2		; constant to write to in/temp/out flag
    24a8:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    24aa:	2e 29 ef    	clr.w     0x92e
	ifz
    24ac:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    24ae:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    24b0:	89 84 e8    	inc2.w    w9, w9
    24b2:	09 e0 a7    	btsc.w    w9, #0xe
    24b4:	09 00 22    	mov.w     #0x2000, w9

	return
    24b6:	00 00 06    	return    

000024b8 <slowZflag0100>:
slowZflag0100:
	mov	#0b0100,w6	; move VZCA
    24b8:	46 00 20    	mov.w     #0x4, w6
	bclr	Zflag,#0
    24ba:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    24bc:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    24be:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    24c0:	00 00 06    	return    

000024c2 <ind_8_10>:

ind_8_10:   ; -----------------------------------------------------    0A  BSET RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    24c2:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    24c4:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    24c6:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    24c8:	03 00 3a    	bra       NZ, 0x24d0 <L114>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    24ca:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    24cc:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    24ce:	a0 0f 20    	mov.w     #0xfa, w0

000024d0 <L114>:
1:
	add	w10,w0,w7	; result write address
    24d0:	80 03 45    	add.w     w10, w0, w7

000024d2 <dir_8_10>:
dir_8_10:
	ze	[w7],w11	; value of addressed nibble
    24d2:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    24d4:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    24d6:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    24d8:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    24da:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    24dc:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    24de:	f0 f8 2f    	mov.w     #0xff8f, w0
    24e0:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w12,w11,w13	; w11 with bit set to Accu in
    24e2:	8b 06 76    	ior.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    24e4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    24e6:	51 fe 37    	bra       0x218a <phases_0>
	mov.b	w13,[w7]	; write result to destination
    24e8:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    24ea:	89 84 e8    	inc2.w    w9, w9
    24ec:	09 e0 a7    	btsc.w    w9, #0xe
    24ee:	09 00 22    	mov.w     #0x2000, w9

	return
    24f0:	00 00 06    	return    

000024f2 <ind_8_11>:

ind_8_11:   ; -----------------------------------------------------    0B  BCLR RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    24f2:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    24f4:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    24f6:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    24f8:	03 00 3a    	bra       NZ, 0x2500 <L115>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    24fa:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    24fc:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    24fe:	a0 0f 20    	mov.w     #0xfa, w0

00002500 <L115>:
1:
	add	w10,w0,w7	; result write address
    2500:	80 03 45    	add.w     w10, w0, w7

00002502 <dir_8_11>:
dir_8_11:
	ze	[w7],w11	; value of addressed nibble
    2502:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    2504:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2506:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    2508:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    250a:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    250c:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    250e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2510:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,#0x0F,w0
    2512:	6f 00 6e    	xor.w     w12, #0xf, w0
	and	w0,w11,w13	; w11 with bit reset to Accu in
    2514:	8b 06 60    	and.w     w0, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2516:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2518:	38 fe 37    	bra       0x218a <phases_0>
	mov.b	w13,[w7]	; write result to destination
    251a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    251c:	89 84 e8    	inc2.w    w9, w9
    251e:	09 e0 a7    	btsc.w    w9, #0xe
    2520:	09 00 22    	mov.w     #0x2000, w9

	return
    2522:	00 00 06    	return    

00002524 <ind_8_12>:

ind_8_12:   ; -----------------------------------------------------    0C  BTG RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    2524:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    2526:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2528:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    252a:	03 00 3a    	bra       NZ, 0x2532 <L116>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    252c:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    252e:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    2530:	a0 0f 20    	mov.w     #0xfa, w0

00002532 <L116>:
1:
	add	w10,w0,w7	; result write address
    2532:	80 03 45    	add.w     w10, w0, w7

00002534 <dir_8_12>:
dir_8_12:
	ze	[w7],w11	; value of addressed nibble
    2534:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    2536:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2538:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    253a:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    253c:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    253e:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    2540:	f0 f8 2f    	mov.w     #0xff8f, w0
    2542:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,w11,w13	; w11 with bit flipped to Accu in
    2544:	8b 06 6e    	xor.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2546:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2548:	20 fe 37    	bra       0x218a <phases_0>
	mov.b	w13,[w7]	; write result to destination
    254a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    254c:	89 84 e8    	inc2.w    w9, w9
    254e:	09 e0 a7    	btsc.w    w9, #0xe
    2550:	09 00 22    	mov.w     #0x2000, w9

	return
    2552:	00 00 06    	return    

00002554 <ind_8_13>:

ind_8_13:   ; -----------------------------------------------------    0D  RRC RY (T)
; IN register service
	mov	PORTB,w0
    2554:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2556:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2558:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    255a:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from OperY
	add	w10,w12,w7	; result write address
    255c:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    255e:	6a 46 7e    	mov.b     [w10+w12], w12

00002560 <dir_8_13>:
dir_8_13:
	clr	w11		; clr oper 1 (will be displayed)
    2560:	80 05 eb    	clr.w     w11
	mov	w12,Atemp	; pre-load Accu temp
    2562:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2564:	0c 07 78    	mov.w     w12, w14
; maintain logic diagram
	clr3leds
    2566:	f0 f8 2f    	mov.w     #0xff8f, w0
    2568:	ae 29 b6    	and.w     0x9ae
; exec 
	btsc	A16,#b_carry
    256a:	af 89 af    	btsc.b    0x9af, #0x4
	bset	w12,#4		; Carry flag for 4-bit operand
    256c:	0c 40 a0    	bset.w    w12, #0x4
	lsr	w12,w13		; write result straight to Accu in
    256e:	8c 06 d1    	lsr.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2570:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    2572:	23 ff 37    	bra       0x23ba <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2574:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2576:	0d 07 78    	mov.w     w13, w14
	clr	Zflag
    2578:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    257a:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    257c:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    257e:	72 00 20    	mov.w     #0x7, w2
	ifz
    2580:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    2582:	72 49 88    	mov.w     w2, 0x92e
	ifc
    2584:	42 00 af    	btsc.b    0x42, #0x0
	mov	w2,Cflag	; if C flag set
    2586:	62 49 88    	mov.w     w2, 0x92c
	ifc
    2588:	42 00 af    	btsc.b    0x42, #0x0
	bset	A16,#b_carry	; Carry button LED
    258a:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    258c:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    258e:	89 84 e8    	inc2.w    w9, w9
    2590:	09 e0 a7    	btsc.w    w9, #0xe
    2592:	09 00 22    	mov.w     #0x2000, w9

	return
    2594:	00 00 06    	return    

00002596 <ind_8_14>:

ind_8_14:   ; -----------------------------------------------------    0E  RET R0,N (T)
	clr	w11		; will be displayed
    2596:	80 05 eb    	clr.w     w11
	mov.b	w12,w13		; preset #N to Acc in
    2598:	8c 46 78    	mov.b     w12, w13
	mov.b	[w10],w14	; preset previous R0 to Acc out
    259a:	1a 47 78    	mov.b     [w10], w14
	mov	w14,Atemp	; preset previous R0 to Acc temp
    259c:	4e 49 88    	mov.w     w14, 0x928
	mov	#0x04,w7	; flag "RET R0,N" instead of "MOV W13,[W7]"
    259e:	47 00 20    	mov.w     #0x4, w7
; maintain logic diagram
	clr3leds
    25a0:	f0 f8 2f    	mov.w     #0xff8f, w0
    25a2:	ae 29 b6    	and.w     0x9ae
; exec
	mov	Stack,w0
    25a4:	50 49 80    	mov.w     0x92a, w0
	mul.uu	w0,#3,w0	; w0:w1
    25a6:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16-1,w0	; stack starts at Ram+16
    25a8:	f0 00 b0    	add.w     #0xf, w0
	add	w0,w10,w1	; stack starts at Ram+16
    25aa:	8a 00 40    	add.w     w0, w10, w1
	ze	[w1--],w0	; high nibble of ret addr
    25ac:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0
    25ae:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1--],w0	; medium nibble of ret addr
    25b0:	21 40 70    	ior.b     w0, [w1--], w0
	sl	w0,#4,w0
    25b2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; low nibble of ret addr
    25b4:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,w0		; ×2
    25b6:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w5
    25b8:	05 00 22    	mov.w     #0x2000, w5
	add	w0,w5,w5	; ret address
    25ba:	85 02 40    	add.w     w0, w5, w5
	btss	Flag,#2		; #2 set if Speed>0
    25bc:	dc 49 ae    	btss.b    0x9dc, #0x2
	bra	spec4
    25be:	f0 fb 37    	bra       0x1da0 <spec4>
	bra	phases_0
    25c0:	e4 fd 37    	bra       0x218a <phases_0>

000025c2 <ind_8_15>:

ind_8_15:   ; -----------------------------------------------------    0F  SKIP F,M (T)
	clr	w11		; will be displayed
    25c2:	80 05 eb    	clr.w     w11
	mov	#0x06,w7	; flag "SKIP F,M" instead of "MOV W13,[W7]"
    25c4:	67 00 20    	mov.w     #0x6, w7
; maintain logic diagram
	clr3leds
    25c6:	f0 f8 2f    	mov.w     #0xff8f, w0
    25c8:	ae 29 b6    	and.w     0x9ae
; exec
	and	w12,#3,w0	; w0 skip format
    25ca:	63 00 66    	and.w     w12, #0x3, w0
	ifz
    25cc:	42 20 af    	btsc.b    0x42, #0x1
	mov	#4,w0		; skip 0 = skip 4
    25ce:	40 00 20    	mov.w     #0x4, w0
	sl	w0,w0		; ×2
    25d0:	00 00 d0    	sl.w      w0, w0
	lsr	w12,#2,w1	; w1 = condition
    25d2:	c2 60 de    	lsr.w     w12, #0x2, w1
	and	#3,w1
    25d4:	31 00 b2    	and.w     #0x3, w1
	bra	w1
    25d6:	01 60 01    	bra       w1
;.........................
	bra	skip_C
    25d8:	03 00 37    	bra       0x25e0 <skip_C>
	bra	skip_NC
    25da:	06 00 37    	bra       0x25e8 <skip_NC>
	bra	skip_Z
    25dc:	09 00 37    	bra       0x25f0 <skip_Z>
	bra	skip_NZ
    25de:	0c 00 37    	bra       0x25f8 <skip_NZ>

000025e0 <skip_C>:
skip_C:
	mov	w9,w5
    25e0:	89 02 78    	mov.w     w9, w5
	btsc	A16,#b_carry	; cc0: C
    25e2:	af 89 af    	btsc.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    25e4:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25e6:	0b 00 37    	bra       0x25fe <skr_skip>

000025e8 <skip_NC>:
skip_NC:
	mov	w9,w5
    25e8:	89 02 78    	mov.w     w9, w5
	btss	A16,#b_carry	; cc1: NC
    25ea:	af 89 ae    	btss.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    25ec:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25ee:	07 00 37    	bra       0x25fe <skr_skip>

000025f0 <skip_Z>:
skip_Z:
	mov	w9,w5
    25f0:	89 02 78    	mov.w     w9, w5
	btsc	Zflag,#2	; cc2: Z
    25f2:	2e 49 af    	btsc.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    25f4:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25f6:	03 00 37    	bra       0x25fe <skr_skip>

000025f8 <skip_NZ>:
skip_NZ:
	mov	w9,w5
    25f8:	89 02 78    	mov.w     w9, w5
	btss	Zflag,#2	; cc3: NZ
    25fa:	2e 49 ae    	btss.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    25fc:	80 82 42    	add.w     w5, w0, w5

000025fe <skr_skip>:
skr_skip:
	inc2	w5,w5		; because INC2 W5 will not be executed like INC2 W9
    25fe:	85 82 e8    	inc2.w    w5, w5
	btsc	w5,#14
    2600:	05 e0 a7    	btsc.w    w5, #0xe
	mov	#Rom,w5		; wrap to start of program memory
    2602:	05 00 22    	mov.w     #0x2000, w5

	btsc	Flag,#2		; #2 set if Speed>0
    2604:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2606:	c1 fd 37    	bra       0x218a <phases_0>

	mov	w5,w9
    2608:	85 04 78    	mov.w     w5, w9
	bra	w9range
    260a:	b9 fb 37    	bra       0x1d7e <w9range>

0000260c <set_T2_from_Speed>:

; ---------------------------------------------------------------------------
set_T2_from_Speed:
	mov.b	Speed,WREG
    260c:	f1 c8 bf    	mov.b     0x8f1, WREG

0000260e <set_T2_from_w0>:
set_T2_from_w0:
	and	#0x0F,w0
    260e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Speed	; Speed index, bit 3210
    2610:	f1 e8 b7    	mov.b     WREG, 0x8f1
	clr	TBLPAG
    2612:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(clk_table),w1
    2614:	e1 29 23    	mov.w     #0x329e, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    2616:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(clk_table_high),w1
    2618:	e1 2d 23    	mov.w     #0x32de, w1
	bclr	T2CON,#TON	; stop Timer 2
    261a:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	clr	TMR2		; clear timing counter
    261c:	96 21 ef    	clr.w     0x196
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    261e:	dc 49 a8    	bset.b    0x9dc, #0x2
	  cp0.b	  w0
    2620:	00 04 e0    	cp0.b     w0
	  ifz
    2622:	42 20 af    	btsc.b    0x42, #0x1
	  bclr	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    2624:	dc 49 a9    	bclr.b    0x9dc, #0x2
	bclr	IFS0,#7		; clr int flag
    2626:	88 e0 a9    	bclr.b    0x88, #0x7
	sl	w0,#2,w0	; × 4
    2628:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Speed × 4
    262a:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    262c:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR2		; update T2 divider value
    262e:	e1 0c 88    	mov.w     w1, 0x19c
	tblrdl	[w0++],w0
    2630:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T2CON	; update prescaler value (low byte only)
    2632:	a0 e1 b7    	mov.b     WREG, 0x1a0
	  dec2	  Mode,WREG
    2634:	76 89 ed    	dec2.w    0x976, WREG
	  ifnz
    2636:	42 20 ae    	btss.b    0x42, #0x1
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    2638:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	T2CON,#TON	; start Timer 2
    263a:	a1 e1 a8    	bset.b    0x1a1, #0x7
	return
    263c:	00 00 06    	return    

0000263e <set_T3_from_Sync>:

; ---------------------------------------------------------------------------
set_T3_from_Sync:
	mov.b	Sync,WREG
    263e:	f2 c8 bf    	mov.b     0x8f2, WREG

00002640 <set_T3_from_w0>:
set_T3_from_w0:
	and	#0x0F,w0
    2640:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Sync	; Sync index, bit 3210
    2642:	f2 e8 b7    	mov.b     WREG, 0x8f2
	clr	TBLPAG
    2644:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(sync_table),w1
    2646:	e1 31 23    	mov.w     #0x331e, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    2648:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(sync_table_high),w1
    264a:	e1 35 23    	mov.w     #0x335e, w1
	bclr	T3CON,#TON	; stop Timer 3
    264c:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	clr	TMR3		; clear timing counter
    264e:	9a 21 ef    	clr.w     0x19a
	bclr	IFS0,#8		; clr int flag
    2650:	89 00 a9    	bclr.b    0x89, #0x0
	bclr.b	RdFlags,#0	; clr Sync flag
    2652:	f4 08 a9    	bclr.b    0x8f4, #0x0
	sl	w0,#2,w0	; × 4
    2654:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Sync × 4
    2656:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    2658:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR3		; update T3 divider value
    265a:	f1 0c 88    	mov.w     w1, 0x19e
	tblrdl	[w0++],w0
    265c:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T3CON	; update prescaler value (low byte only)
    265e:	a2 e1 b7    	mov.b     WREG, 0x1a2
	bset	T3CON,#TON	; start Timer 3
    2660:	a3 e1 a8    	bset.b    0x1a3, #0x7
	return
    2662:	00 00 06    	return    

00002664 <rnd>:

; ------------------------------------------------------------------------------
rnd:				; RND to w0 bits 3-0
;           not needed       needed1          needed2
; AB * CD = (A*C << 32) + ((B*C + A*D) << 16) + B*D
; A=w5:B=w4 × C=w3=0x41c6:D=w2=4e6d + 0x6073 ---> w4:w5

	mov	Rndhi,w5	; existing hi
    2664:	35 4e 80    	mov.w     0x9c6, w5
	mov	Rndlo,w4	; existing lo
    2666:	24 4e 80    	mov.w     0x9c4, w4
	mov	#0x41c6,w3	; hi
    2668:	63 1c 24    	mov.w     #0x41c6, w3
	mov	#0x4e6d,w2	; lo
    266a:	d2 e6 24    	mov.w     #0x4e6d, w2

	mul.uu	w4,w3,w0	; B*C ---> w0(:w1)
    266c:	03 20 b8    	mul.uu    w4, w3, w0
	mov	w0,w6		; ---> w6
    266e:	00 03 78    	mov.w     w0, w6
	mul.uu	w5,w2,w0	; A*D ---> w0(:w1)
    2670:	02 28 b8    	mul.uu    w5, w2, w0
	add	w0,w6,w3	; w3 = needed1
    2672:	86 01 40    	add.w     w0, w6, w3

	mul.uu	w4,w2,w4	; B*D ---> w4:w5 = needed2 (w4 low word)
    2674:	02 22 b8    	mul.uu    w4, w2, w4
	add	w5,w3,w5	; w5 high word
    2676:	83 82 42    	add.w     w5, w3, w5

	mov	#0x6073,w3
    2678:	33 07 26    	mov.w     #0x6073, w3
	add	w4,w3,w4	; lo + 0x6073 --> lo
    267a:	03 02 42    	add.w     w4, w3, w4
	addc	w5,#0,w5	; hi + Carry ---> hi
    267c:	e0 82 4a    	addc.w    w5, #0x0, w5
    ; w4:w5 ---> rnd seed
	mov	w4,Rndlo	; new lo
    267e:	24 4e 88    	mov.w     w4, 0x9c4
	mov	w5,Rndhi	; new hi
    2680:	35 4e 88    	mov.w     w5, 0x9c6

00002682 <extract4bits>:
extract4bits:
	xor	w4,w5,w0	; [w5] 31-16  XOR  [w4] 15-00  --->  [w0] 15-0
    2682:	05 00 6a    	xor.w     w4, w5, w0
	add.b	_WREG0+1,WREG	; [w0] 15-08   +   [w0] 07-00  --->  [w0] 7-0
    2684:	01 40 b4    	add.b     0x1, WREG
	lsr	w0,#4,w2
    2686:	44 01 de    	lsr.w     w0, #0x4, w2
	xor	w0,w2,w0	; [w2] 07-04  XOR  [w0] 03-00  --->  [w0] 3-0
    2688:	02 00 68    	xor.w     w0, w2, w0
	and	w0,#0x0F,w0	; RND in w0 bits 3-0
    268a:	6f 00 60    	and.w     w0, #0xf, w0
	return
    268c:	00 00 06    	return    

0000268e <getrnd>:

getrnd:
	mov	Rndlo,w4	; existing lo
    268e:	24 4e 80    	mov.w     0x9c4, w4
	mov	Rndhi,w5	; existing hi
    2690:	35 4e 80    	mov.w     0x9c6, w5
	bra	extract4bits
    2692:	f7 ff 37    	bra       0x2682 <extract4bits>

00002694 <perform_SFR_write>:

; ------------------------------------------------------------------------------
perform_SFR_write:
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    2694:	dd 29 a9    	bclr.b    0x9dd, #0x1
	and	#0x0f,w5
    2696:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    2698:	05 60 01    	bra       w5
;...
	return
    269a:	00 00 06    	return    
	bra	SFR_write_1
    269c:	0e 00 37    	bra       0x26ba <SFR_write_1>
	bra	SFR_write_2
    269e:	10 00 37    	bra       0x26c0 <SFR_write_2>
	bra	SFR_write_3
    26a0:	12 00 37    	bra       0x26c6 <SFR_write_3>
	return
    26a2:	00 00 06    	return    
	bra	SFR_write_5
    26a4:	1d 00 37    	bra       0x26e0 <SFR_write_5>
	bra	SFR_write_6
    26a6:	1e 00 37    	bra       0x26e4 <SFR_write_6>
	return
    26a8:	00 00 06    	return    
	bra	SFR_write_8
    26aa:	23 00 37    	bra       0x26f2 <SFR_write_8>
	bra	SFR_write_9
    26ac:	29 00 37    	bra       0x2700 <SFR_write_9>
	return
    26ae:	00 00 06    	return    
	return
    26b0:	00 00 06    	return    
	return
    26b2:	00 00 06    	return    
	return
    26b4:	00 00 06    	return    
	return
    26b6:	00 00 06    	return    
	bra	SFR_write_15
    26b8:	26 00 37    	bra       0x2706 <SFR_write_15>

000026ba <SFR_write_1>:
;...
SFR_write_1:		; Speed
	call	set_T2_from_Speed
    26ba:	0c 26 02    	call      0x260c <set_T2_from_Speed>
    26bc:	00 00 00 
	return
    26be:	00 00 06    	return    

000026c0 <SFR_write_2>:
;	
SFR_write_2:		; Sync
	call	set_T3_from_Sync
    26c0:	3e 26 02    	call      0x263e <set_T3_from_Sync>
    26c2:	00 00 00 
	return
    26c4:	00 00 06    	return    

000026c6 <SFR_write_3>:
;	
SFR_write_3:		; WrFlags (PinPos); in: SerCtrl,#3=0...1,  out: RPINR, RPOR
	mov.b	SerCtrl,WREG
    26c6:	f5 c8 bf    	mov.b     0x8f5, WREG

000026c8 <sel_pinpos>:
sel_pinpos:
	btss.b	WrFlags,#0	; #0 RxTxPos
    26c8:	f3 08 ae    	btss.b    0x8f3, #0x0
	bra	RxTx0
    26ca:	05 00 37    	bra       0x26d6 <RxTx0>
; RxTxPos=1 (Rx and Tx are on I/O connector)
	btsc	Flag2,#3	; #3 Previous RxTxPos
    26cc:	de 69 af    	btsc.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    26ce:	07 00 37    	bra       0x26de <WrFlags_next>
	  call	  rxtx_to_io	; SWITCH RxTx to IO
    26d0:	14 28 02    	call      0x2814 <rxtx_to_io>
    26d2:	00 00 00 
	bra	WrFlags_next
    26d4:	04 00 37    	bra       0x26de <WrFlags_next>

000026d6 <RxTx0>:
RxTx0:
	btss	Flag2,#3	; #3 Previous RxTxPos
    26d6:	de 69 ae    	btss.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    26d8:	02 00 37    	bra       0x26de <WrFlags_next>
	  call	  rxtx_to_sao	; SWITCH RxTx to SAO
    26da:	02 28 02    	call      0x2802 <rxtx_to_sao>
    26dc:	00 00 00 

000026de <WrFlags_next>:
WrFlags_next:
	return
    26de:	00 00 06    	return    

000026e0 <SFR_write_5>:
;	
SFR_write_5:		; SerCtrl (SERVICE BaudRate)
	and	w13,#0x07,w0
    26e0:	67 80 66    	and.w     w13, #0x7, w0
	bra	set_U1BRG_from_w0
    26e2:	75 00 37    	bra       0x27ce <set_U1BRG_from_w0>

000026e4 <SFR_write_6>:
;	
SFR_write_6:		; SerLow (TX BYTE)
	mov.b	SerHigh,WREG
    26e4:	f7 c8 bf    	mov.b     0x8f7, WREG
	sl	w0,#4,w0
    26e6:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerLow,WREG
    26e8:	f6 48 b7    	ior.b     0x8f6, WREG

000026ea <waittx_2>:
waittx_2:
	btsc	U1STA,#UTXBF
    26ea:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	waittx_2
    26ec:	fe ff 37    	bra       0x26ea <waittx_2>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    26ee:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    26f0:	00 00 06    	return    

000026f2 <SFR_write_8>:
;	
SFR_write_8:		; Received
	cp0.b	Received
    26f2:	f8 48 e2    	cp0.b     0x8f8
	bra	nz,go_cont_8_2
    26f4:	03 00 3a    	bra       NZ, 0x26fc <go_cont_8_2>
	mov	#RX_buf,w0
    26f6:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    26f8:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    26fa:	f0 4d 88    	mov.w     w0, 0x9be

000026fc <go_cont_8_2>:
go_cont_8_2:
	ifnz
    26fc:	42 20 ae    	btss.b    0x42, #0x1
	return
    26fe:	00 00 06    	return    

00002700 <SFR_write_9>:
;	
SFR_write_9:		; AutoOff
; as the destination is AutoOff, AutoOff_Hi must be preloaded
	mov	#37500,w0
    2700:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    2702:	b0 4d 88    	mov.w     w0, 0x9b6
	return
    2704:	00 00 06    	return    

00002706 <SFR_write_15>:
;	
SFR_write_15:		; RND
	cp.b	w13,#15
    2706:	6f 6c e1    	cp.b      w13, #0xf
	bra	z,seed15
    2708:	09 00 32    	bra       Z, 0x271c <seed15>
	sl	w13,#4,w0
    270a:	44 68 dd    	sl.w      w13, #0x4, w0
	ior	w13,w0,w0	; 4 ---> 8 bits
    270c:	00 80 76    	ior.w     w13, w0, w0
	sl	w0,#8,w13
    270e:	c8 06 dd    	sl.w      w0, #0x8, w13
	ior	w13,w0,w0	; 8 ---> 16 bits
    2710:	00 80 76    	ior.w     w13, w0, w0
	mov	w0,Rndhi
    2712:	30 4e 88    	mov.w     w0, 0x9c6
	mov	w0,Rndlo
    2714:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    2716:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    2718:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    271a:	00 00 06    	return    

0000271c <seed15>:
seed15:			; if seed=15, then total RND
	mov	TMR2,w0
    271c:	b0 0c 80    	mov.w     0x196, w0
	sl	w0,#4,w0
    271e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	RowScan,WREG
    2720:	78 49 b7    	ior.b     0x978, WREG
	sl	w0,#4,w0
    2722:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	TMR1,WREG
    2724:	90 41 b7    	ior.b     0x190, WREG
	mov	w0,Rndhi
    2726:	30 4e 88    	mov.w     w0, 0x9c6
	mov	AutoOff_Hi,w1
    2728:	b1 4d 80    	mov.w     0x9b6, w1
	xor	w0,w1,w0
    272a:	01 00 68    	xor.w     w0, w1, w0
	mov	w0,Rndlo
    272c:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    272e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    2730:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    2732:	00 00 06    	return    

00002734 <perform_SFR_read>:

; ------------------------------------------------------------------------------

perform_SFR_read:
	bclr	Flag,#10	; #10 set if instruction is reading from SFR area
    2734:	dd 49 a9    	bclr.b    0x9dd, #0x2
	and	#0x0f,w5
    2736:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    2738:	05 60 01    	bra       w5
;...
	return
    273a:	00 00 06    	return    
	return
    273c:	00 00 06    	return    
	return
    273e:	00 00 06    	return    
	return
    2740:	00 00 06    	return    
	bra	SFR_read_4
    2742:	0b 00 37    	bra       0x275a <SFR_read_4>
	bra	SFR_read_5
    2744:	15 00 37    	bra       0x2770 <SFR_read_5>
	bra	SFR_read_6
    2746:	16 00 37    	bra       0x2774 <SFR_read_6>
	return
    2748:	00 00 06    	return    
	return
    274a:	00 00 06    	return    
	return
    274c:	00 00 06    	return    
	return	;bra	SFR_read_10
    274e:	00 00 06    	return    
	return
    2750:	00 00 06    	return    
	bra	SFR_read_12
    2752:	2d 00 37    	bra       0x27ae <SFR_read_12>
	return
    2754:	00 00 06    	return    
	return
    2756:	00 00 06    	return    
	bra	SFR_read_15
    2758:	2f 00 37    	bra       0x27b8 <SFR_read_15>

0000275a <SFR_read_4>:
;...
SFR_read_4:		; RdFlags
	bclr	IEC0,#8		; disable Timer 3 interrupt
    275a:	99 00 a9    	bclr.b    0x99, #0x0
	mov.b	RdFlags,WREG
    275c:	f4 c8 bf    	mov.b     0x8f4, WREG
	and.b	Ram+0,WREG
    275e:	00 48 b6    	and.b     0x800, WREG
	btss	w0,#0
    2760:	00 00 a6    	btss.w    w0, #0x0
	bra	1f
    2762:	04 00 37    	bra       0x276c <L117>
	mov.b	RdFlags,WREG
    2764:	f4 c8 bf    	mov.b     0x8f4, WREG
	mov.b	WREG,Ram+0	; write to R0 again, timing is critical!
    2766:	00 e8 b7    	mov.b     WREG, 0x800
	and	#0b1110,w0	; kill flag UserSync (#0)
    2768:	e0 00 b2    	and.w     #0xe, w0
	mov.b	WREG,RdFlags
    276a:	f4 e8 b7    	mov.b     WREG, 0x8f4

0000276c <L117>:
1:
	bset	IEC0,#8		; enable Timer 3 interrupt
    276c:	99 00 a8    	bset.b    0x99, #0x0
	return
    276e:	00 00 06    	return    

00002770 <SFR_read_5>:
;	
SFR_read_5:
	bclr	SerCtrl,#3
    2770:	f5 68 a9    	bclr.b    0x8f5, #0x3
	return
    2772:	00 00 06    	return    

00002774 <SFR_read_6>:
;	
SFR_read_6:		; SerLow
	cp0.b	Received
    2774:	f8 48 e2    	cp0.b     0x8f8
	ifz
    2776:	42 20 af    	btsc.b    0x42, #0x1
	return			; if zero received
    2778:	00 00 06    	return    
	bclr	IEC0,#11   ; \    disable RX1 interrupt
    277a:	99 60 a9    	bclr.b    0x99, #0x3
; move char from SerLow to r0
	mov.b	SerLow,WREG
    277c:	f6 c8 bf    	mov.b     0x8f6, WREG
	mov.b	w0,[w7]
    277e:	80 4b 78    	mov.b     w0, [w7]
	bclr	Flag2,#2	; clr handshaking flag (for FIFO ---> SerHigh:SerLow)
    2780:	de 49 a9    	bclr.b    0x9de, #0x2
; test if there is anything in FIFO...
	mov	RXRD,w0
    2782:	f0 4d 80    	mov.w     0x9be, w0
	cp.b	RXWR
    2784:	bc 49 e3    	cp.b      0x9bc
	bra	z,calc_rcvd	; if FIFO empty
    2786:	08 00 32    	bra       Z, 0x2798 <calc_rcvd>
; ...checked, FIFO > 0, move 1st char from FIFO to ser buf Ser L:H and inc RDPtr
	ze	[w0],w1		; w1 1st byte from FIFO
    2788:	90 80 fb    	ze        [w0], w1
	and	w1,#0x0F,w0	; low nibble
    278a:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    278c:	f6 e8 b7    	mov.b     WREG, 0x8f6
	lsr	w1,#4,w0	; hi nibble
    278e:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    2790:	f7 e8 b7    	mov.b     WREG, 0x8f7
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    2792:	de 49 a8    	bset.b    0x9de, #0x2
	inc.b	RXRD		; inc RD ptr (8-bit inc, to stay inside FIFO)
    2794:	be 69 ec    	inc.b     0x9be
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    2796:	de 49 a8    	bset.b    0x9de, #0x2

00002798 <calc_rcvd>:
calc_rcvd:
; calculate Received
	clr	w0		; to clear high byte
    2798:	00 00 eb    	clr.w     w0
	mov.b	RXWR,WREG
    279a:	bc c9 bf    	mov.b     0x9bc, WREG
	sub.b	RXRD,WREG	; RXRD-RXWR (byte mode, to stay in range 0000-00FF)
    279c:	be 49 b5    	sub.b     0x9be, WREG
	btsc	Flag2,#2	; handshaking flag (for FIFO ---> SerHigh:SerLow)
    279e:	de 49 af    	btsc.b    0x9de, #0x2
	inc	w0,w0		; plus char in Ser H:L (if any)
    27a0:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    27a2:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    27a4:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    27a6:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    27a8:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	IEC0,#11   ; /    enable RX1 interrupt
    27aa:	99 60 a8    	bset.b    0x99, #0x3
	return
    27ac:	00 00 06    	return    

000027ae <SFR_read_12>:
;	
;SFR_read_10:		; KeyStatus
;	disi	#4
;	mov.b	KeyStatus,WREG
;	mov.b	WREG,Ram+0	; write to R0
;	bclr	KeyStatus,#0
;	return
;	
SFR_read_12:		; KeyStatus
	disi	#4
    27ae:	04 00 fc    	disi      #0x4
	mov.b	KeyStatus,WREG
    27b0:	fc c8 bf    	mov.b     0x8fc, WREG
	mov.b	WREG,Ram+0	; write to R0
    27b2:	00 e8 b7    	mov.b     WREG, 0x800
	bclr	KeyStatus,#0
    27b4:	fc 08 a9    	bclr.b    0x8fc, #0x0
	return
    27b6:	00 00 06    	return    

000027b8 <SFR_read_15>:
;	
SFR_read_15:		; RND
	call	getrnd
    27b8:	8e 26 02    	call      0x268e <getrnd>
    27ba:	00 00 00 
	mov.b	WREG,Ram+0	; write to R0
    27bc:	00 e8 b7    	mov.b     WREG, 0x800

000027be <new_rnd>:
new_rnd:
	call	rnd
    27be:	64 26 02    	call      0x2664 <rnd>
    27c0:	00 00 00 
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    27c2:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    27c4:	00 00 06    	return    

000027c6 <def_U1BRG>:

; ---------------------------------------------------------------------------
def_U1BRG:		; set Baud Rate to 9600
	mov	#3,w0
    27c6:	30 00 20    	mov.w     #0x3, w0
	bra	set_U1BRG_from_w0
    27c8:	02 00 37    	bra       0x27ce <set_U1BRG_from_w0>

000027ca <set_U1BRG>:
set_U1BRG:		; restore the original Baud Rate
	mov.b	SerCtrl,WREG
    27ca:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    27cc:	70 00 b2    	and.w     #0x7, w0

000027ce <set_U1BRG_from_w0>:
set_U1BRG_from_w0:	; in: w0,  out: U1BRG
	bclr	U1MODE,#15		; disable UART 1
    27ce:	99 e3 a9    	bclr.b    0x399, #0x7
	clr	TBLPAG
    27d0:	54 20 ef    	clr.w     0x54
	sl	w0,w0		; ×2
    27d2:	00 00 d0    	sl.w      w0, w0
	mov	#tbloffset(baud_tab),w1
    27d4:	e1 7e 22    	mov.w     #0x27ee, w1
	add	w0,w1,w1
    27d6:	81 00 40    	add.w     w0, w1, w1
	tblrdl	[w1],w0
    27d8:	11 00 ba    	tblrdl.w  [w1], w0
	mov	w0,U1BRG
    27da:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
    27dc:	99 e3 a8    	bset.b    0x399, #0x7
	nop
    27de:	00 00 00    	nop       
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    27e0:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    27e2:	9b 83 a8    	bset.b    0x39b, #0x4
	clr.b	Received
    27e4:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    27e6:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    27e8:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    27ea:	f0 4d 88    	mov.w     w0, 0x9be
	return
    27ec:	00 00 06    	return    

000027ee <baud_tab>:
    27ee:	04 0d 00    	nop       
    27f0:	82 06 00    	nop       
    27f2:	40 03 00    	nop       
    27f4:	a0 01 00    	nop       
    27f6:	cf 00 00    	nop       
    27f8:	67 00 00    	nop       
    27fa:	44 00 00    	nop       
    27fc:	22 00 00    	nop       

000027fe <rxtx_to_rxtxpos>:
baud_tab:
	.word	3333-1	;  0.  1200
	.word	1667-1	;  1.  2400
	.word	833-1	;  2.  4800
	.word	417-1	;  3.  9600
	.word	208-1	;  4.  19200
	.word	104-1	;  5.  38400
	.word	69-1	;  6.  57600
	.word	35-1	;  7.  115200
; ---------------------------------------------------
rxtx_to_rxtxpos:
	btsc.b	WrFlags,#0	; WrFlags,#0: RxTxPos
    27fe:	f3 08 af    	btsc.b    0x8f3, #0x0
	bra	rxtx_to_io	; if RxTxPos=1
    2800:	09 00 37    	bra       0x2814 <rxtx_to_io>

00002802 <rxtx_to_sao>:
rxtx_to_sao:
; B7 input now (GP input)
	bclr	U1MODE,#15		; disable UART 1
    2802:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	TRISB,#7
    2804:	76 e6 a8    	bset.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to SAO connector
	mov	#26,w0		; RP26 PORT  (A0)... (0x3f to disable RX input)
    2806:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    2808:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    280a:	30 00 20    	mov.w     #0x3, w0
	mov.b	RPOR13+1	; ...to RP27 (A1)
    280c:	ef e7 bf    	mov.b     0x7ef
; disable old pin for Tx
	clr.b	RPOR3+1		; ...to RP7  (B7) (0x00 to return to default OUT port)
    280e:	db 67 ef    	clr.b     0x7db
	bclr	Flag2,#3	; #3 Previous RxTxPos
    2810:	de 69 a9    	bclr.b    0x9de, #0x3
	bra	skr_rxtx
    2812:	07 00 37    	bra       0x2822 <skr_rxtx>

00002814 <rxtx_to_io>:
;----------------------------------------------------
rxtx_to_io:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
    2814:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
    2816:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
    2818:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    281a:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    281c:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
    281e:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
    2820:	de 69 a8    	bset.b    0x9de, #0x3

00002822 <skr_rxtx>:
skr_rxtx:
	bset	U1MODE,#15		; enable UART 1
    2822:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
    2824:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    2826:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    2828:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    282a:	f0 4d 88    	mov.w     w0, 0x9be
	return
    282c:	00 00 06    	return    

0000282e <leave_run_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_run_ept:
; save RUN variables to RUN Temp
	mov	Stack,w0
    282e:	50 49 80    	mov.w     0x92a, w0
	mov	w0,RunTempStack	; Stack
    2830:	b0 4a 88    	mov.w     w0, 0x956
	mov	w9,RunTempPMAddr; PC
    2832:	a9 4a 88    	mov.w     w9, 0x954
	mov.b	Page,WREG
    2834:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,RunTempPage ; Page
    2836:	58 e9 b7    	mov.b     WREG, 0x958
; save Run flags
	mov	Vflag,w0
    2838:	80 49 80    	mov.w     0x930, w0
	mov	w0,RunTempVflag
    283a:	d0 4a 88    	mov.w     w0, 0x95a
	mov	Zflag,w0
    283c:	70 49 80    	mov.w     0x92e, w0
	mov	w0,RunTempZflag
    283e:	e0 4a 88    	mov.w     w0, 0x95c
	mov	Cflag,w0
    2840:	60 49 80    	mov.w     0x92c, w0
	mov	w0,RunTempCflag
    2842:	f0 4a 88    	mov.w     w0, 0x95e
	mov	w14,RunTempw14
    2844:	1e 4b 88    	mov.w     w14, 0x962
	mov	w13,RunTempw13
    2846:	0d 4b 88    	mov.w     w13, 0x960
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    2848:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	pgm_ept
    284a:	01 00 37    	bra       0x284e <pgm_ept>
	bra	ss_ept
    284c:	99 f7 37    	bra       0x1780 <ss_ept>

0000284e <pgm_ept>:

pgm_ept:
	btss	Flag2,#12
    284e:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    2850:	dc 10 02    	call      0x10dc <clr_ram>
    2852:	00 00 00 
	bset	Flag2,#12
    2854:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload PGM variables from PGM Temp
	clr	Stack		; Stack
    2856:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; Page 0
    2858:	f0 68 ef    	clr.b     0x8f0
	mov	PgmTempPMAddr,w9 ; PC
    285a:	29 4b 80    	mov.w     0x964, w9
	mov	#0b011101100,w0	; autorpt for Addr-, Addr+, Opcode, OperX, OperY
    285c:	c0 0e 20    	mov.w     #0xec, w0
	mov	w0,AutorptFlag
    285e:	60 4d 88    	mov.w     w0, 0x9ac
; PGM initialize
	mov	#3,w0
    2860:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode		; Mode
    2862:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    2864:	e0 29 ef    	clr.w     0x9e0
	clr	w11
    2866:	80 05 eb    	clr.w     w11
	clr	w12
    2868:	00 06 eb    	clr.w     w12
	clr	w13
    286a:	80 06 eb    	clr.w     w13
	clr	w14
    286c:	00 07 eb    	clr.w     w14
	clr	Vflag
    286e:	30 29 ef    	clr.w     0x930
	clr	Zflag
    2870:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2872:	2c 29 ef    	clr.w     0x92c
	mov	#3,w0			; 3 = PGM
    2874:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode
    2876:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    2878:	dc 49 a8    	bset.b    0x9dc, #0x2
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    287a:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    287c:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    287e:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    2880:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000000100000000,w0	; set RUN
    2882:	00 10 20    	mov.w     #0x100, w0
	ior	A16
    2884:	ae 29 b7    	ior.w     0x9ae

00002886 <pgm_farm>:

pgm_farm:
	call	read12		; read new pgm word
    2886:	72 29 02    	call      0x2972 <read12>
    2888:	00 00 00 

0000288a <pgm_noread>:
pgm_noread:
	btss	Flag,#1		; #1 handshaking flag for buttons
    288a:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	pgm_noread
    288c:	fe ff 37    	bra       0x288a <pgm_noread>
	bclr	Flag,#1
    288e:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    2890:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    2892:	65 00 e1    	cp.w      w0, #0x5
	ifc
    2894:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    2896:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    2898:	00 60 01    	bra       w0
; ...
	bra	leave_pgm_ept
    289a:	74 00 37    	bra       0x2984 <leave_pgm_ept>
	bra	button_addr_set
    289c:	04 00 37    	bra       0x28a6 <button_addr_set>
	bra	button_addr_minus_pgm
    289e:	18 00 37    	bra       0x28d0 <button_addr_minus_pgm>
	bra	button_addr_plus_pgm
    28a0:	1d 00 37    	bra       0x28dc <button_addr_plus_pgm>
	bra	button_dep
    28a2:	22 00 37    	bra       0x28e8 <button_dep>
	bra	general_pgm_5
    28a4:	63 00 37    	bra       0x296c <general_pgm_5>

000028a6 <button_addr_set>:
;					ept 0: addr_set (in PGM mode)
button_addr_set:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28a6:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_addr_set	; if ALT addr set pressed
    28a8:	09 00 37    	bra       0x28bc <alt_addr_set>
	mov	Opcode,w0
    28aa:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    28ac:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    28ae:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    28b0:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    28b2:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    28b4:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    28b6:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    28b8:	81 04 40    	add.w     w0, w1, w9
	bra	pgm_farm
    28ba:	e5 ff 37    	bra       0x2886 <pgm_farm>

000028bc <alt_addr_set>:
;					ept 0: addr_set (in PGM mode)
alt_addr_set:
	inc2	w9,w2
    28bc:	09 81 e8    	inc2.w    w9, w2
	mov	#Rom+0x2000,w1	; end of Program Memory + 2
    28be:	01 00 24    	mov.w     #0x4000, w1

000028c0 <train2>:
train2:
	cp	w2,w1		; w9=current program pointer (non-incremented)
    28c0:	01 10 e1    	cp.w      w2, w1
	bra	nz,1f
    28c2:	02 00 3a    	bra       NZ, 0x28c8 <L118>
	clr	[--w2]		; last word in program = 0x000
    28c4:	00 21 eb    	clr.w     [--w2]
	bra	adr_plus	; train finished
    28c6:	0c 00 37    	bra       0x28e0 <adr_plus>

000028c8 <L118>:
1:
	mov	[w2--],w0	; w0 = contents
    28c8:	22 00 78    	mov.w     [w2--], w0
	mov	w0,[w2]
    28ca:	00 09 78    	mov.w     w0, [w2]
	add	#4,w2
    28cc:	42 00 b0    	add.w     #0x4, w2
	bra	train2
    28ce:	f8 ff 37    	bra       0x28c0 <train2>

000028d0 <button_addr_minus_pgm>:
;					ept 1: addr_minus_pgm (in PGM mode)
button_addr_minus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28d0:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_minus_pgm	; if ALT addr minus pressed
    28d2:	27 00 37    	bra       0x2922 <alt_minus_pgm>
	dec2	w9,w9		; decrement address
    28d4:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    28d6:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    28d8:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	pgm_farm
    28da:	d5 ff 37    	bra       0x2886 <pgm_farm>

000028dc <button_addr_plus_pgm>:
;					ept 2: addr_plus_pgm (in PGM mode)
button_addr_plus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28dc:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_plus_pgm	; if ALT addr plus pressed
    28de:	1c 00 37    	bra       0x2918 <alt_plus_pgm>

000028e0 <adr_plus>:
adr_plus:
	inc2	w9,w9		; increment address
    28e0:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    28e2:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    28e4:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm	; test failed, some other key pressed
    28e6:	cf ff 37    	bra       0x2886 <pgm_farm>

000028e8 <button_dep>:
;					ept 3: dep (in PGM mode)
button_dep:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28e8:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_dep		; if ALT DEP pressed
    28ea:	03 00 37    	bra       0x28f2 <alt_dep>
	call	write12		; write new pgm word
    28ec:	0a 29 02    	call      0x290a <write12>
    28ee:	00 00 00 
	bra	adr_plus
    28f0:	f7 ff 37    	bra       0x28e0 <adr_plus>

000028f2 <alt_dep>:
;		
alt_dep:
	mov	[w9],w2		; old value
    28f2:	19 01 78    	mov.w     [w9], w2
	call	write12		; *** write new pgm word
    28f4:	0a 29 02    	call      0x290a <write12>
    28f6:	00 00 00 
	mov	#Rom+0x1FFC,w1	; end of Program Memory - 2
    28f8:	c1 ff 23    	mov.w     #0x3ffc, w1

000028fa <train1>:
train1:
	cp	w9,w1		; w9=current program pointer (non-incremented)
    28fa:	01 48 e1    	cp.w      w9, w1
	bra	nc,1f
    28fc:	02 00 39    	bra       NC, 0x2902 <L119>
	mov	w2,[++w1]
    28fe:	82 28 78    	mov.w     w2, [++w1]
	bra	adr_plus	; train finished
    2900:	ef ff 37    	bra       0x28e0 <adr_plus>

00002902 <L119>:
1:
	mov	[w1++],w0	; w0 = contents
    2902:	31 00 78    	mov.w     [w1++], w0
	mov	w0,[w1--]
    2904:	80 10 78    	mov.w     w0, [w1--]
	dec2	w1,w1
    2906:	81 80 e9    	dec2.w    w1, w1
	bra	train1
    2908:	f8 ff 37    	bra       0x28fa <train1>

0000290a <write12>:
;		
write12:
	mov	Opcode,w0
    290a:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    290c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    290e:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    2910:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    2912:	26 09 b7    	ior.w     0x926, WREG
	mov	w0,[w9]		; write program word
    2914:	80 0c 78    	mov.w     w0, [w9]
	return
    2916:	00 00 06    	return    

00002918 <alt_plus_pgm>:
;		
alt_plus_pgm:
	btss	KeyRotors+4,#0	; it's -ADDR debouncer
    2918:	82 09 ae    	btss.b    0x982, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    291a:	08 00 37    	bra       0x292c <alt_both_pgm>
	call	find_last
    291c:	46 19 02    	call      0x1946 <find_last>
    291e:	00 00 00 
	bra	pgm_farm
    2920:	b2 ff 37    	bra       0x2886 <pgm_farm>

00002922 <alt_minus_pgm>:
;		
alt_minus_pgm:
	btss	KeyRotors+6,#0	; it's ADDR+ debouncer
    2922:	84 09 ae    	btss.b    0x984, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    2924:	03 00 37    	bra       0x292c <alt_both_pgm>
	clr	Stack
    2926:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w9
    2928:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    292a:	ad ff 37    	bra       0x2886 <pgm_farm>

0000292c <alt_both_pgm>:
;				; "go addr 0" test	
alt_both_pgm:			; ALT both pressed
	mov	KeyRotors+0,w0
    292c:	f0 4b 80    	mov.w     0x97e, w0
	and	KeyRotors+2,WREG
    292e:	80 09 b6    	and.w     0x980, WREG
	mov	#KeyRotors+8,w1
    2930:	61 98 20    	mov.w     #0x986, w1
	mov	#14,w2
    2932:	e2 00 20    	mov.w     #0xe, w2

00002934 <L120>:
1:
	and	w0,[w1++],w0
    2934:	31 00 60    	and.w     w0, [w1++], w0
	dec	w2,w2
    2936:	02 01 e9    	dec.w     w2, w2
	bra	nz,1b
    2938:	fd ff 3a    	bra       NZ, 0x2934 <L120>
	btss	w0,#0
    293a:	00 00 a6    	btss.w    w0, #0x0
	bra	pgm_farm	; some other key is pressed, ignore command
    293c:	a4 ff 37    	bra       0x2886 <pgm_farm>
; erase all data memory
	call	clr_ram
    293e:	dc 10 02    	call      0x10dc <clr_ram>
    2940:	00 00 00 
	clr	Stack
    2942:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    2944:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    2946:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    2948:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    294a:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    294c:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    294e:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    2950:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    2952:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    2954:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    2956:	fe 27 02    	call      0x27fe <rxtx_to_rxtxpos>
    2958:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    295a:	ca 27 02    	call      0x27ca <set_U1BRG>
    295c:	00 00 00 
; erase all program memory
	clr	Stack
    295e:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w0
    2960:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x01000-1
    2962:	ff 0f 09    	repeat    #0xfff
	clr	[w0++]		; clr Rom
    2964:	00 18 eb    	clr.w     [w0++]
	clr.b	Page
    2966:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    2968:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    296a:	8d ff 37    	bra       0x2886 <pgm_farm>

0000296c <general_pgm_5>:

general_pgm_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    296c:	3a 14 02    	call      0x143a <general_key_3O>
    296e:	00 00 00 
	bra	pgm_noread
    2970:	8c ff 37    	bra       0x288a <pgm_noread>

00002972 <read12>:
; ------------------------------
read12:
	mov	[w9],w0
    2972:	19 00 78    	mov.w     [w9], w0
	lsr	w0,#8,w1
    2974:	c8 00 de    	lsr.w     w0, #0x8, w1
	mov	w1,Opcode
    2976:	11 49 88    	mov.w     w1, 0x922
	lsr	w0,#4,w2
    2978:	44 01 de    	lsr.w     w0, #0x4, w2
	and	w2,#0x0F,w2
    297a:	6f 01 61    	and.w     w2, #0xf, w2
	mov	w2,OperX
    297c:	22 49 88    	mov.w     w2, 0x924
	and	w0,#0x0F,w0
    297e:	6f 00 60    	and.w     w0, #0xf, w0
	mov	w0,OperY
    2980:	30 49 88    	mov.w     w0, 0x926
	return
    2982:	00 00 06    	return    

00002984 <leave_pgm_ept>:

; -------------------------------------------------------------------------------

leave_pgm_ept:
; save PGM params
	mov	w9,PgmTempPMAddr ; PC
    2984:	29 4b 88    	mov.w     w9, 0x964
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    2986:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	alu_ept
    2988:	b2 f3 37    	bra       0x10ee <alu_ept>
	bra	run_ept
    298a:	0f f8 37    	bra       0x19aa <run_ept>

0000298c <T1Int>:
;***********************************************************************************
;****************************       T1 INTERRUPT       *****************************
;***********************************************************************************
T1Int:				; TIMER1 int, display & kbd 3.2 KHz
	push.s			; \
    298c:	00 a0 fe    	push.s    
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    298e:	0a c8 bf    	mov.b     0x80a, WREG
	btsc	WrFlags,#1	; I/O port select
    2990:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    2992:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    2994:	7a e6 b7    	mov.b     WREG, 0x67a
; split interrupt Dimmer timing to two timings (to give a total of 514)
	mov.b	Dimmer,WREG
    2996:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w0
    2998:	00 80 fb    	ze        w0, w0
	btsc	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    299a:	dd a9 af    	btsc.b    0x9dd, #0x5
	bra	aux_int		; aux_int only turns off LEDs, for dimming
    299c:	0e 04 37    	bra       0x31ba <aux_int>
	bset	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    299e:	dd a9 a8    	bset.b    0x9dd, #0x5
; calculate exponential dimmer step
	mul.uu	w0,w0,w2	; w2 =   0,   1,   4,   9,  16...196, 225
    29a0:	00 01 b8    	mul.uu    w0, w0, w2
	cp0	w2
    29a2:	02 00 e0    	cp0.w     w2
	ifnz
    29a4:	42 20 ae    	btss.b    0x42, #0x1
	add	#5,w2		; w2 =   0,   6,   9,  14,  21...201, 230
    29a6:	52 00 b0    	add.w     #0x5, w2
	add	#5,w2		; w2 =   5,  11,  14,  19,  26...206, 235
    29a8:	52 00 b0    	add.w     #0x5, w2
	sl	w2,w2		; w2 =  10,  22,  28,  38,  52...412, 470
    29aa:	02 01 d0    	sl.w      w2, w2
; mov #300,w2 ;(samo za snimanje 60 fps)
	mov	w2,PR1
    29ac:	92 0c 88    	mov.w     w2, 0x192
	mov	w2,PR1copy
    29ae:	12 4e 88    	mov.w     w2, 0x9c2
; automatic Leds and Matrix off when ALT pressed
	  mov	  #0b0011,w0
    29b0:	30 00 20    	mov.w     #0x3, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    29b2:	dc c9 af    	btsc.b    0x9dc, #0x6
	  and.b	  WrFlags
    29b4:	f3 68 b6    	and.b     0x8f3
; if 10 minutes countdown=0 then go to sleep
	inc	BlinkCount	; +
    29b6:	7c 29 ec    	inc.w     0x97c
	  btsc	  Flag,#14	  ; dim down in progress?
    29b8:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  count625
    29ba:	0e 00 37    	bra       0x29d8 <count625>
	  btsc	  Flag,#15	  ; dim up in progress?
    29bc:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  count625
    29be:	0c 00 37    	bra       0x29d8 <count625>
	mov	BlinkCount,w0
    29c0:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x3F,w0	; 4 KHz / 0x03F = 62.5 Hz
    29c2:	f0 03 b2    	and.w     #0x3f, w0
	  ifz
    29c4:	42 20 af    	btsc.b    0x42, #0x1
	  dec	  AutoOff_Hi	  ; 62.5 Hz decrement
    29c6:	b6 29 ed    	dec.w     0x9b6
	  bra	  nz,count625
    29c8:	07 00 3a    	bra       NZ, 0x29d8 <count625>
; if AutoOff_Hi started from 37500, then 10 minutes here
	  mov	  #37500,w0
    29ca:	c0 27 29    	mov.w     #0x927c, w0
	  mov	  w0,AutoOff_Hi	  ; new 10 min cycle started
    29cc:	b0 4d 88    	mov.w     w0, 0x9b6
; decrement 10 minutes countdown, if=0 then go to sleep 
	  dec.b	  AutoOff
    29ce:	f9 68 ed    	dec.b     0x8f9
	  bra	  nz,count625
    29d0:	03 00 3a    	bra       NZ, 0x29d8 <count625>
	  mov.b	  Dimmer,WREG
    29d2:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    29d4:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down request (AutoOff patience counter expired)
    29d6:	dd c9 a8    	bset.b    0x9dd, #0x6

000029d8 <count625>:
count625:
; inc main multiplex pointer
	inc	RowScan,WREG	; +
    29d8:	78 09 ec    	inc.w     0x978, WREG
	and	#0x0F,w0
    29da:	f0 00 b2    	and.w     #0xf, w0
	mov	w0,RowScan	; RowScan = 0000...1111
    29dc:	c0 4b 88    	mov.w     w0, 0x978
; anode off
	clr.b	LATC		; LED anodes off
    29de:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; LED anodes off
    29e0:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode column
    29e2:	8f 06 a9    	bclr.b    0x68f, #0x0
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    29e4:	dd 89 a9    	bclr.b    0x9dd, #0x4
; decoder service
	sl	w0,#7,w1	; RowScan 3, 2, 1, 0 ---> A10, A9, A8, A7
    29e6:	c7 00 dd    	sl.w      w0, #0x7, w1
	btsc	LATA,#1		; LATA,#1 is output for SAO (if it's not Tx)...
    29e8:	66 26 af    	btsc.b    0x666, #0x1
	bset	w1,#1		; ...restore it
    29ea:	01 10 a0    	bset.w    w1, #0x1
	mov	w1,LATA		; set decoder 74HC138 inputs
    29ec:	31 33 88    	mov.w     w1, 0x666
; A16 History/standard mode select
	  mov	  History_A16,w3
    29ee:	63 48 80    	mov.w     0x90c, w3
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    29f0:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	A16,w3
    29f2:	73 4d 80    	mov.w     0x9ae, w3
; main branch
	bra	w0		; main branch (w0=0...15)
    29f4:	00 60 01    	bra       w0
;...
	bra	cathode0
    29f6:	0f 00 37    	bra       0x2a16 <cathode0>
	bra	cathode1
    29f8:	3e 00 37    	bra       0x2a76 <cathode1>
	bra	cathode2
    29fa:	60 00 37    	bra       0x2abc <cathode2>
	bra	cathode3
    29fc:	7d 00 37    	bra       0x2af8 <cathode3>
	bra	cathode4
    29fe:	a6 00 37    	bra       0x2b4c <cathode4>
	bra	cathode5
    2a00:	ca 00 37    	bra       0x2b96 <cathode5>
	bra	cathode6
    2a02:	ee 00 37    	bra       0x2be0 <cathode6>
	bra	cathode7
    2a04:	16 01 37    	bra       0x2c32 <cathode7>
	bra	cathode8
    2a06:	7d 01 37    	bra       0x2d02 <cathode8>
	bra	cathode9
    2a08:	b7 01 37    	bra       0x2d78 <cathode9>
	bra	cathode10
    2a0a:	f4 01 37    	bra       0x2df4 <cathode10>
	bra	cathode11
    2a0c:	31 02 37    	bra       0x2e70 <cathode11>
	bra	cathode12
    2a0e:	74 02 37    	bra       0x2ef8 <cathode12>
	bra	cathode13
    2a10:	b1 02 37    	bra       0x2f74 <cathode13>
	bra	cathode14
    2a12:	ee 02 37    	bra       0x2ff0 <cathode14>
	bra	cathode15
    2a14:	3e 03 37    	bra       0x3092 <cathode15>

00002a16 <cathode0>:

;------------------------------- MACRO -------------------------------
; Important Note for this Macro: 
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These 
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons, 
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and 
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every 
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second 
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.
.macro	keytest	keynum,AllowRpt1,AllowRpt2
; key connected to PORTA,#3 input
	btsc	BlinkCount,#4
	bra	6f		; if odd then skip
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2
	btsc	PORTA,#3
	bset	KeyRotors+\keynum*2,#0
	inc2	KeyRotors+\keynum*2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum,w0
	mov	w0,Just		; just pressed
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt1
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
6:
; key connected to PORTA,#4 input
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2+2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2+2
	btsc	PORTA,#4
	bset	KeyRotors+\keynum*2+2,#0
	inc2	KeyRotors+\keynum*2+2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum+1,w0
	mov	w0,Just		; code of "just pressed" key
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt2
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
7:
	and	Anypress	; bit 0 will be reset if any key still depressed
8:
.endm

;------------------------------- OPCODE BAR --------------------------- cathode 0
cathode0:
; spec test if any key pressed (needed for autorepeat)
	btsc	BlinkCount,#4
    2a16:	7c 89 af    	btsc.b    0x97c, #0x4
	bra	cont_cathode0	; test must be performed in every 2nd pass
    2a18:	0f 00 37    	bra       0x2a38 <cont_cathode0>
	btsts	Anypress,#0	; test AND SET bit 0 (will be Z if any key pressed)
    2a1a:	a8 09 ac    	btsts.b   0x9a8, #0x0
	bra	nz,NoAutoRpt	; if no key was pressed
    2a1c:	0c 00 3a    	bra       NZ, 0x2a36 <NoAutoRpt>
; at least 1 key was pressed
	btsc	AutorptCount,#15
    2a1e:	ab e9 af    	btsc.b    0x9ab, #0x7
	bra	cont_cathode0	; if it's not set for counting (it's negative)
    2a20:	0b 00 37    	bra       0x2a38 <cont_cathode0>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a22:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	cont_cathode0	; if ALT pressed
    2a24:	09 00 37    	bra       0x2a38 <cont_cathode0>
	dec	AutorptCount
    2a26:	aa 29 ed    	dec.w     0x9aa
	bra	nz,cont_cathode0 ; if not yet 0x0000
    2a28:	07 00 3a    	bra       NZ, 0x2a38 <cont_cathode0>
; AutorptCount just reached 0, reinitialize autorpt process
	mov	#KeyRotors,w0
    2a2a:	e0 97 20    	mov.w     #0x97e, w0
	repeat	#18-1
    2a2c:	11 00 09    	repeat    #0x11
	setm	[w0++]		; reenable "just" condition
    2a2e:	00 98 eb    	setm.w    [w0++]
	mov	#autorpt_next,w0
    2a30:	f0 00 20    	mov.w     #0xf, w0
	mov	w0,AutorptCount	; reinitialize autorpt process
    2a32:	50 4d 88    	mov.w     w0, 0x9aa
	bra	cont_cathode0
    2a34:	01 00 37    	bra       0x2a38 <cont_cathode0>

00002a36 <NoAutoRpt>:
NoAutoRpt:
	setm	AutorptCount	; forced -1 (only #autorpt_start allowed for writing)
    2a36:	aa a9 ef    	setm.w    0x9aa

00002a38 <cont_cathode0>:
cont_cathode0:
; extra anode 16
	btsc	w3,#b_clk_sch	; Extra bit 16: CLOCK (schematics) 
    2a38:	03 00 a7    	btsc.w    w3, #0x0
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2a3a:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2a3c:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2a3e:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2a40:	02 00 32    	bra       Z, 0x2a46 <L36>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a42:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt0		; IF ALT pressed
    2a44:	0e 00 37    	bra       0x2a62 <alt0>

00002a46 <L36>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2a46:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2a48:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#8,w1	  ; HISTORY mode
    2a4a:	c8 08 de    	lsr.w     w1, #0x8, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2a4c:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	Opcode,w1	; ***
    2a4e:	11 49 80    	mov.w     0x922, w1
	mov	#0,w0
    2a50:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2a52:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#0	; 0 set = column Opcode blinks
    2a54:	e0 09 ae    	btss.b    0x9e0, #0x0
	mov	#1,w0
    2a56:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a58:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2a5a:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2a5c:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2a5e:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0a
    2a60:	07 00 37    	bra       0x2a70 <go_disp0a>

00002a62 <alt0>:
alt0:				; IF ALU pressed
	mov.b	Sync,WREG	; if Mode > 0 (SS Run Pgm)
    2a62:	f2 c8 bf    	mov.b     0x8f2, WREG
	    cp0	    Mode
    2a64:	76 09 e2    	cp0.w     0x976
	    ifz
    2a66:	42 20 af    	btsc.b    0x42, #0x1
	    mov.b   Dimmer,WREG	; if Mode = 0 (ALU)
    2a68:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w1
    2a6a:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2a6c:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a6e:	01 00 dd    	sl.w      w0, w1, w0

00002a70 <go_disp0a>:
go_disp0a:
	btsc	Flag,#3		; #3 self-check mode
    2a70:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column1,w0
    2a72:	40 4e 80    	mov.w     0x9c8, w0
	bra	disp_w0_noblank
    2a74:	98 03 37    	bra       0x31a6 <disp_w0_noblank>

00002a76 <cathode1>:
;------------------------------- OPERAND X BAR ------------------------ cathode 1
cathode1:
; extra anode 16
	btsc	w3,#b_exr	; Extra bit 16: EXR (instruction set)
    2a76:	03 10 a7    	btsc.w    w3, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2a78:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2a7a:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2a7c:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2a7e:	02 00 32    	bra       Z, 0x2a84 <L37>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a80:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt1		; IF ALT pressed
    2a82:	0f 00 37    	bra       0x2aa2 <alt1>

00002a84 <L37>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2a84:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2a86:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#4,w1	  ; HISTORY mode
    2a88:	c4 08 de    	lsr.w     w1, #0x4, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2a8a:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperX,w1	; ***
    2a8c:	21 49 80    	mov.w     0x924, w1
	and	#0x0F,w1
    2a8e:	f1 00 b2    	and.w     #0xf, w1
	mov	#0,w0
    2a90:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2a92:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#1	; 1 set = column Oper X blinks
    2a94:	e0 29 ae    	btss.b    0x9e0, #0x1
	mov	#1,w0
    2a96:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a98:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2a9a:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2a9c:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2a9e:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0b
    2aa0:	0a 00 37    	bra       0x2ab6 <go_disp0b>

00002aa2 <alt1>:
alt1:			; IF ALT pressed
	mov.b	Speed,WREG
    2aa2:	f1 c8 bf    	mov.b     0x8f1, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2aa4:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Speed,WREG
    2aa6:	14 c9 bf    	mov.b     0x914, WREG
	    cp0	    Mode
    2aa8:	76 09 e2    	cp0.w     0x976
	    bra	    nz,1f
    2aaa:	02 00 3a    	bra       NZ, 0x2ab0 <L121>
	    mov.b   SerCtrl,WREG	; if Mode = 0 (ALU)
    2aac:	f5 c8 bf    	mov.b     0x8f5, WREG
	    bclr.b  w0,#3		; spec case: Buad Rate takes only 3 bits
    2aae:	00 34 a1    	bclr.b    w0, #0x3

00002ab0 <L121>:
1:
	ze	w0,w1
    2ab0:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2ab2:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2ab4:	01 00 dd    	sl.w      w0, w1, w0

00002ab6 <go_disp0b>:
go_disp0b:
	btsc	Flag,#3		; #3 self-check mode
    2ab6:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column2,w0
    2ab8:	50 4e 80    	mov.w     0x9ca, w0
	bra	disp_w0
    2aba:	73 03 37    	bra       0x31a2 <disp_w0>

00002abc <cathode2>:
;------------------------------- OPERAND Y BAR ------------------------ cathode 2
cathode2:
; extra anode 16
	btsc	w3,#b_clk_key	; Extra bit 16: CLOCK (schematic) 
    2abc:	03 20 a7    	btsc.w    w3, #0x2
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2abe:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2ac0:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2ac2:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2ac4:	02 00 32    	bra       Z, 0x2aca <L38>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2ac6:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt2pressed	; IF ALT pressed
    2ac8:	0b 00 37    	bra       0x2ae0 <alt2pressed>

00002aca <L38>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2aca:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2acc:	91 00 78    	mov.w     [w1], w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2ace:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperY,w1
    2ad0:	31 49 80    	mov.w     0x926, w1
	and	#0x0F,w1
    2ad2:	f1 00 b2    	and.w     #0xf, w1
	mov	#1,w0
    2ad4:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2ad6:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2ad8:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2ada:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2adc:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0c
    2ade:	09 00 37    	bra       0x2af2 <go_disp0c>

00002ae0 <alt2pressed>:
alt2pressed:		; IF DATA IN pressed
	mov.b	Page,WREG
    2ae0:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2ae2:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Page,WREG
    2ae4:	10 c9 bf    	mov.b     0x910, WREG
	    cp0	    Mode
    2ae6:	76 09 e2    	cp0.w     0x976
	    ifz
    2ae8:	42 20 af    	btsc.b    0x42, #0x1
	    mov	    FlashAddr,w0 ; Alt pressed in ALU mode: get FlashAddr instead of OperY
    2aea:	00 4e 80    	mov.w     0x9c0, w0
	ze	w0,w1
    2aec:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2aee:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2af0:	01 00 dd    	sl.w      w0, w1, w0

00002af2 <go_disp0c>:
go_disp0c:
	btsc	Flag,#3		; #3 self-check mode
    2af2:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column3,w0
    2af4:	60 4e 80    	mov.w     0x9cc, w0
	bra	disp_w0
    2af6:	55 03 37    	bra       0x31a2 <disp_w0>

00002af8 <cathode3>:
;---------------------- SOURCE, PROG MEM ADDR ------------------------ cathode 3
cathode3:
; ALT key debouncer
	sl	KeyRotors+38
    2af8:	a4 29 d4    	sl.w      0x9a4
	btsc	PORTA,#2
    2afa:	64 46 af    	btsc.b    0x664, #0x2
	bset	KeyRotors+38,#0
    2afc:	a4 09 a8    	bset.b    0x9a4, #0x0
	inc.b	KeyRotors+38,WREG ; test if keynum = 0bxxxxxxxx11111111
    2afe:	a4 49 ec    	inc.b     0x9a4, WREG
	ifz
    2b00:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#6		; #6 set if ALT pressed (debounced)
    2b02:	dc c9 a9    	bclr.b    0x9dc, #0x6
	ifz
    2b04:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b06:	fc 68 a9    	bclr.b    0x8fc, #0x3
	cp0.b	KeyRotors+38	; test if keynum = 0bxxxxxxxx00000000
    2b08:	a4 49 e2    	cp0.b     0x9a4
	ifz
    2b0a:	42 20 af    	btsc.b    0x42, #0x1
	bset	Flag,#6		; #6 set if ALT pressed (debounced)
    2b0c:	dc c9 a8    	bset.b    0x9dc, #0x6
	ifz
    2b0e:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b10:	fc 68 a9    	bclr.b    0x8fc, #0x3
	btsc	Flag,#3		; #3 self-check mode
    2b12:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in3		; no IN in self-check mode
    2b14:	07 00 37    	bra       0x2b24 <no_in3>
; IN register service
	mov.b	PORTB,WREG
    2b16:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2b18:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2b1a:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2b1c:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2b1e:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2b20:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2b22:	fb e8 b7    	mov.b     WREG, 0x8fb

00002b24 <no_in3>:
no_in3:
; extra anode 16
	btsc	w3,#b_noclk_sch ; Extra bit 16: INV CLOCK (schematic)
    2b24:	03 30 a7    	btsc.w    w3, #0x3
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b26:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Rom,w1
    2b28:	01 00 22    	mov.w     #0x2000, w1
	  mov	  History_w9,w0	  ; HISTORY mode
    2b2a:	10 48 80    	mov.w     0x902, w0
	  sub	  w0,w1,w0	  ; HISTORY mode
    2b2c:	01 00 50    	sub.w     w0, w1, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    2b2e:	dc c9 af    	btsc.b    0x9dc, #0x6
	  sl	  History_Ptr,WREG ; if ALT in History mode, then History_Ptr displayed
    2b30:	1e 09 d4    	sl.w      0x91e, WREG
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b32:	dc a9 ae    	btss.b    0x9dc, #0x5
	sub	w9,w1,w0
    2b34:	01 80 54    	sub.w     w9, w1, w0
	lsr	w0,w1		; w1 = PC actual value
    2b36:	80 00 d1    	lsr.w     w0, w1
	  mov	  History_w12,w0  ; HISTORY mode
    2b38:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#12,w0	  ; HISTORY mode
    2b3a:	4c 00 dd    	sl.w      w0, #0xc, w0
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b3c:	dc a9 ae    	btss.b    0x9dc, #0x5
	sl	w12,#12,w0	; w12 = SOURCE (OperY) contents
    2b3e:	4c 60 dd    	sl.w      w12, #0xc, w0
	    mov	    #0x0FFF,w3	    ; * * * * BUG FIX SEPT 21 2022
    2b40:	f3 ff 20    	mov.w     #0xfff, w3
	    and	    w3,w1,w1	    ; * * * * BUG FIX SEPT 21 2022
    2b42:	81 80 61    	and.w     w3, w1, w1
;	cp0	Mode
;	ifnz			; ProgMemAddr (w9) is not displayed in ALU mode
	ior	w1,w0,w0
    2b44:	00 80 70    	ior.w     w1, w0, w0
	btsc	Flag,#3		; #3 self-check mode
    2b46:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row3,w0
    2b48:	70 4e 80    	mov.w     0x9ce, w0
	bra	disp_w0_noblank
    2b4a:	2d 03 37    	bra       0x31a6 <disp_w0_noblank>

00002b4c <cathode4>:
;------------------------------- Vflag, ADDER, DEST ------------------- cathode 4
cathode4:
; extra anode 16
	btsc	w3,#b_data_inv	; Extra bit 16: DATA INVERSE (schematic) 
    2b4c:	03 40 a7    	btsc.w    w3, #0x4
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b4e:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b50:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat4	  ; if HISTORY mode
    2b52:	19 00 37    	bra       0x2b86 <History_cat4>
	mov	Vflag,w0
    2b54:	80 49 80    	mov.w     0x930, w0
	btss	Stack,#2
    2b56:	2a 49 ae    	btss.b    0x92a, #0x2
	bra	1f
    2b58:	03 00 37    	bra       0x2b60 <L122>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2b5a:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2b5c:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2b5e:	00 30 a0    	bset.w    w0, #0x3

00002b60 <L122>:
1:
	sl	w0,#8,w1	; 0000 SVVV 0000 0000
    2b60:	c8 00 dd    	sl.w      w0, #0x8, w1
; Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2b62:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2b64:	00 80 75    	ior.w     w11, w0, w0

00002b66 <skr_cat4>:
skr_cat4:
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    2b66:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    2b68:	02 4f 23    	mov.w     #0x34f0, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    2b6a:	02 00 40    	add.w     w0, w2, w0
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2b6c:	03 50 a7    	btsc.w    w3, #0x5
	inc2	w0,w0		; if Cin set
    2b6e:	00 80 e8    	inc2.w    w0, w0
	push	TBLPAG	   ; \\
    2b70:	54 00 f8    	push      0x54
	clr	TBLPAG
    2b72:	54 20 ef    	clr.w     0x54
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    2b74:	10 00 ba    	tblrdl.w  [w0], w0
	pop	TBLPAG	   ; //
    2b76:	54 00 f9    	pop       0x54
	and	#0x0FF,w0	; 0000 0000 AAAA CCCC
    2b78:	f0 0f b2    	and.w     #0xff, w0
	ior	w0,w1,w0	; 0000 SVVV AAAA CCCC
    2b7a:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SVVV AAAA CCCC 0000
    2b7c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w11,w0	; SVVV AAAA CCCC DDDD (w11 = dest contents)
    2b7e:	0b 00 70    	ior.w     w0, w11, w0
	btsc	Flag,#3		; #3 self-check mode
    2b80:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row4,w0
    2b82:	80 4e 80    	mov.w     0x9d0, w0
	bra	disp_w0
    2b84:	0e 03 37    	bra       0x31a2 <disp_w0>

00002b86 <History_cat4>:
History_cat4:			  ; HISTORY mode ............................
	  mov	  History_Vflag,w0
    2b86:	b0 48 80    	mov.w     0x916, w0
	  btsc	  History_Stack,#2
    2b88:	1c 49 af    	btsc.b    0x91c, #0x2
	  bset	  w0,#3		  ; Stack LED bit
    2b8a:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#8,w1	  ; 0000 SVVV 0000 0000
    2b8c:	c8 00 dd    	sl.w      w0, #0x8, w1
  ; Adder Sum & Carry
	  mov	  History_w12,w0
    2b8e:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#4,w0	  ; w0 = source × 16
    2b90:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w11,WREG ; w0 = source × 16 + dest
    2b92:	04 09 b7    	ior.w     0x904, WREG
	  bra	  skr_cat4
    2b94:	e8 ff 37    	bra       0x2b66 <skr_cat4>

00002b96 <cathode5>:
;-------------------------------- Zflag, OR, AND, XOR ----------------- cathode 5
cathode5:
; extra anode 16
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2b96:	03 50 a7    	btsc.w    w3, #0x5
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b98:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b9a:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat5
    2b9c:	12 00 37    	bra       0x2bc2 <History_cat5>
	mov	Zflag,w0	; 0000 0000 0000 0ZZZ
    2b9e:	70 49 80    	mov.w     0x92e, w0
	btss	Stack,#1
    2ba0:	2a 29 ae    	btss.b    0x92a, #0x1
	bra	1f
    2ba2:	03 00 37    	bra       0x2baa <L123>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2ba4:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2ba6:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; 0000 0000 0000 SZZZ
    2ba8:	00 30 a0    	bset.w    w0, #0x3

00002baa <L123>:
1:
	sl	w0,#4,w0	; 0000 0000 SZZZ 0000
    2baa:	44 00 dd    	sl.w      w0, #0x4, w0
; Logic OR, AND and XOR
	ior	w11,w12,w1
    2bac:	8c 80 75    	ior.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 0000 SZZZ OOOO
    2bae:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; 0000 SZZZ OOOO 0000
    2bb0:	44 00 dd    	sl.w      w0, #0x4, w0
	and	w11,w12,w1
    2bb2:	8c 80 65    	and.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 SZZZ OOOO AAAA
    2bb4:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SZZZ OOOO AAAA 0000
    2bb6:	44 00 dd    	sl.w      w0, #0x4, w0
	xor	w11,w12,w1
    2bb8:	8c 80 6d    	xor.w     w11, w12, w1
	ior	w0,w1,w0	; SZZZ OOOO AAAA XXXX
    2bba:	01 00 70    	ior.w     w0, w1, w0
	btsc	Flag,#3		; #3 self-check mode
    2bbc:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row5,w0
    2bbe:	90 4e 80    	mov.w     0x9d2, w0
	bra	disp_w0
    2bc0:	f0 02 37    	bra       0x31a2 <disp_w0>

00002bc2 <History_cat5>:
History_cat5:			  ; HISTORY mode ............................
	  mov	  History_Zflag,w0 ; 0000 0000 0000 0ZZZ
    2bc2:	c0 48 80    	mov.w     0x918, w0
	  btsc	  History_Stack,#1
    2bc4:	1c 29 af    	btsc.b    0x91c, #0x1
	  bset	  w0,#3		  ; 0000 0000 0000 SZZZ
    2bc6:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; 0000 0000 SZZZ 0000
    2bc8:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Logic OR, AND and XOR
	  mov	  History_w11,w2
    2bca:	22 48 80    	mov.w     0x904, w2
	  mov	  History_w12,w3
    2bcc:	33 48 80    	mov.w     0x906, w3
	  ior	  w2,w3,w1
    2bce:	83 00 71    	ior.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 0000 SZZZ OOOO
    2bd0:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; 0000 SZZZ OOOO 0000
    2bd2:	44 00 dd    	sl.w      w0, #0x4, w0
	  and	  w2,w3,w1
    2bd4:	83 00 61    	and.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 SZZZ OOOO AAAA
    2bd6:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; SZZZ OOOO AAAA 0000
    2bd8:	44 00 dd    	sl.w      w0, #0x4, w0
	  xor	  w2,w3,w1
    2bda:	83 00 69    	xor.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; SZZZ OOOO AAAA XXXX
    2bdc:	01 00 70    	ior.w     w0, w1, w0
	  bra	  disp_w0
    2bde:	e1 02 37    	bra       0x31a2 <disp_w0>

00002be0 <cathode6>:
;-------------------------------- Cflag, ACCU OUT/TEMP/IN ------------- cathode 6
cathode6:
; test ON-OFF key
	sl	KeyRotors+36
    2be0:	a2 29 d4    	sl.w      0x9a2
	btsc	PORTC,#9
    2be2:	8d 26 af    	btsc.b    0x68d, #0x1
	bset	KeyRotors+36,#0
    2be4:	a2 09 a8    	bset.b    0x9a2, #0x0
	inc2	KeyRotors+36,WREG ; test if keynum = 0bxxxxxxxx11111110
    2be6:	a2 89 ec    	inc2.w    0x9a2, WREG
	bra	nz,1f
    2be8:	07 00 3a    	bra       NZ, 0x2bf8 <L124>
; ON-OFF pressed
	  btsc	  Flag,#14	  ; dim down in progress?
    2bea:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  1f
    2bec:	05 00 37    	bra       0x2bf8 <L124>
	  btsc	  Flag,#15	  ; dim up in progress?
    2bee:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  1f
    2bf0:	03 00 37    	bra       0x2bf8 <L124>
	  mov.b	  Dimmer,WREG
    2bf2:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    2bf4:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down MAIN REQUEST (key ON/OFF pressed)
    2bf6:	dd c9 a8    	bset.b    0x9dd, #0x6

00002bf8 <L124>:
1:
; extra anode 16
	btsc	w3,#b_cena	; Extra bit 16: C ENABLE (schematic) 
    2bf8:	03 60 a7    	btsc.w    w3, #0x6
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2bfa:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2bfc:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat6
    2bfe:	0f 00 37    	bra       0x2c1e <History_cat6>
	mov	Cflag,w0
    2c00:	60 49 80    	mov.w     0x92c, w0
	btss	Stack,#0
    2c02:	2a 09 ae    	btss.b    0x92a, #0x0
	bra	1f
    2c04:	03 00 37    	bra       0x2c0c <L125>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2c06:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2c08:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2c0a:	00 30 a0    	bset.w    w0, #0x3

00002c0c <L125>:
1:
	sl	w0,#4,w0	; xxxx xxxx SCCC 0000
    2c0c:	44 00 dd    	sl.w      w0, #0x4, w0
; Accumulator OUT / TEMP / IN
	ior	w0,w14,w0	; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2c0e:	0e 00 70    	ior.w     w0, w14, w0
	sl	w0,#4,w0	; xxxx SCCC OOOO 0000
    2c10:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	Atemp,WREG	; xxxx SCCC OOOO TTTT
    2c12:	28 09 b7    	ior.w     0x928, WREG
	sl	w0,#4,w0	; SCCC OOOO TTTT 0000
    2c14:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w13,w0	; SCCC OOOO TTTT IIII (Accu In is w13)
    2c16:	0d 00 70    	ior.w     w0, w13, w0
	btsc	Flag,#3		; #3 self-check mode
    2c18:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row6,w0
    2c1a:	a0 4e 80    	mov.w     0x9d4, w0
	bra	disp_w0
    2c1c:	c2 02 37    	bra       0x31a2 <disp_w0>

00002c1e <History_cat6>:
History_cat6:			  ; HISTORY mode ............................
	  mov	  History_Cflag,w0
    2c1e:	d0 48 80    	mov.w     0x91a, w0
	  btsc	  History_Stack,#0
    2c20:	1c 09 af    	btsc.b    0x91c, #0x0
	  bset	  w0,#3		  ; Stack LED bit
    2c22:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; xxxx xxxx SCCC 0000
    2c24:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Accumulator OUT / TEMP / IN
	  ior	  History_w14,WREG ; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2c26:	0a 09 b7    	ior.w     0x90a, WREG
	  sl	  w0,#4,w0	  ; xxxx SCCC OOOO 0000
    2c28:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_Atemp,WREG ; xxxx SCCC OOOO TTTT
    2c2a:	0e 09 b7    	ior.w     0x90e, WREG
	  sl	  w0,#4,w0	  ; SCCC OOOO TTTT 0000
    2c2c:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w13,WREG ; SCCC OOOO TTTT IIII (Accu In is w13)
    2c2e:	08 09 b7    	ior.w     0x908, WREG
	  bra	  disp_w0
    2c30:	b8 02 37    	bra       0x31a2 <disp_w0>

00002c32 <cathode7>:
;-------------------------------- PAGE, OPCODE, OPERX, OPERY ---------- cathode 7
cathode7:
; test keys 16, 17
	keytest	16,7,8
    2c32:	7c 89 af    	btsc.b    0x97c, #0x4
    2c34:	1a 00 37    	bra       0x2c6a <L66>
    2c36:	9e 29 d4    	sl.w      0x99e
    2c38:	00 c0 2f    	mov.w     #0xfc00, w0
    2c3a:	9e 29 b7    	ior.w     0x99e
    2c3c:	64 66 af    	btsc.b    0x664, #0x3
    2c3e:	9e 09 a8    	bset.b    0x99e, #0x0
    2c40:	9e 89 ec    	inc2.w    0x99e, WREG
    2c42:	2d 00 3a    	bra       NZ, 0x2c9e <L73>
    2c44:	a8 29 b6    	and.w     0x9a8
    2c46:	00 01 20    	mov.w     #0x10, w0
    2c48:	30 4d 88    	mov.w     w0, 0x9a6
    2c4a:	40 00 b1    	sub.w     #0x4, w0
    2c4c:	42 00 ae    	btss.b    0x42, #0x0
    2c4e:	00 00 20    	mov.w     #0x0, w0
    2c50:	fd e8 b7    	mov.b     WREG, 0x8fd
    2c52:	dc 29 a8    	bset.b    0x9dc, #0x1
    2c54:	fc 08 a8    	bset.b    0x8fc, #0x0
    2c56:	f0 00 20    	mov.w     #0xf, w0
    2c58:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2c5a:	c0 27 29    	mov.w     #0x927c, w0
    2c5c:	b0 4d 88    	mov.w     w0, 0x9b6
    2c5e:	ac e9 ae    	btss.b    0x9ac, #0x7
    2c60:	1f 00 37    	bra       0x2ca0 <L84>
    2c62:	00 05 20    	mov.w     #0x50, w0
    2c64:	ab e9 af    	btsc.b    0x9ab, #0x7
    2c66:	50 4d 88    	mov.w     w0, 0x9aa
    2c68:	1b 00 37    	bra       0x2ca0 <L84>

00002c6a <L66>:
    2c6a:	a0 29 d4    	sl.w      0x9a0
    2c6c:	00 c0 2f    	mov.w     #0xfc00, w0
    2c6e:	a0 29 b7    	ior.w     0x9a0
    2c70:	64 86 af    	btsc.b    0x664, #0x4
    2c72:	a0 09 a8    	bset.b    0x9a0, #0x0
    2c74:	a0 89 ec    	inc2.w    0x9a0, WREG
    2c76:	13 00 3a    	bra       NZ, 0x2c9e <L73>
    2c78:	a8 29 b6    	and.w     0x9a8
    2c7a:	10 01 20    	mov.w     #0x11, w0
    2c7c:	30 4d 88    	mov.w     w0, 0x9a6
    2c7e:	40 00 b1    	sub.w     #0x4, w0
    2c80:	42 00 ae    	btss.b    0x42, #0x0
    2c82:	00 00 20    	mov.w     #0x0, w0
    2c84:	fd e8 b7    	mov.b     WREG, 0x8fd
    2c86:	dc 29 a8    	bset.b    0x9dc, #0x1
    2c88:	fc 08 a8    	bset.b    0x8fc, #0x0
    2c8a:	f0 00 20    	mov.w     #0xf, w0
    2c8c:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2c8e:	c0 27 29    	mov.w     #0x927c, w0
    2c90:	b0 4d 88    	mov.w     w0, 0x9b6
    2c92:	ad 09 ae    	btss.b    0x9ad, #0x0
    2c94:	05 00 37    	bra       0x2ca0 <L84>
    2c96:	00 05 20    	mov.w     #0x50, w0
    2c98:	ab e9 af    	btsc.b    0x9ab, #0x7
    2c9a:	50 4d 88    	mov.w     w0, 0x9aa
    2c9c:	01 00 37    	bra       0x2ca0 <L84>

00002c9e <L73>:
    2c9e:	a8 29 b6    	and.w     0x9a8

00002ca0 <L84>:
; extra anode 16
	btsc	w3,#b_sel	; Extra bit 16: SEL (bin/sel leds) 
    2ca0:	03 70 a7    	btsc.w    w3, #0x7
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ca2:	dd 89 a8    	bset.b    0x9dd, #0x4
	  btsc	  Flag,#5	; #5 set in HISTORY mode
    2ca4:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat7
    2ca6:	1e 00 37    	bra       0x2ce4 <History_cat7>
	mov.b	Page,WREG	; xxxx xxxx xxxx PPPP
    2ca8:	f0 c8 bf    	mov.b     0x8f0, WREG
	sl	w0,#4,w0	; xxxx xxxx PPPP 0000
    2caa:	44 00 dd    	sl.w      w0, #0x4, w0
	mov	Mode,w1
    2cac:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2cae:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2cb0:	02 00 32    	bra       Z, 0x2cb6 <L39>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2cb2:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	Alt7		; IF ALT pressed
    2cb4:	06 00 37    	bra       0x2cc2 <Alt7>

00002cb6 <L39>:
; anodes 0...15
3:
	ior	Opcode,WREG	; xxxx xxxx PPPP OOOO
    2cb6:	22 09 b7    	ior.w     0x922, WREG
	sl	w0,#4,w0	; xxxx PPPP OOOO 0000
    2cb8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG	; xxxx PPPP OOOO XXXX
    2cba:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0	; PPPP OOOO XXXX 0000
    2cbc:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; PPPP OOOO XXXX YYYY
    2cbe:	26 09 b7    	ior.w     0x926, WREG
	bra	go_disp0d
    2cc0:	07 00 37    	bra       0x2cd0 <go_disp0d>

00002cc2 <Alt7>:
Alt7:			; IF ALT pressed (not history) (Sync Clock Page)
	cp0	Mode
    2cc2:	76 09 e2    	cp0.w     0x976
	bra	z,alt7alu
    2cc4:	08 00 32    	bra       Z, 0x2cd6 <alt7alu>
	ior.b	Sync,WREG	; xxxx xxxx PPPP SSSS
    2cc6:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0	; xxxx PPPP SSSS 0000
    2cc8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG	; xxxx PPPP SSSS SSSS
    2cca:	f1 48 b7    	ior.b     0x8f1, WREG
	sl	w0,#4,w0	; PPPP SSSS SSSS 0000
    2ccc:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG	; PPPP SSSS SSSS PPPP
    2cce:	f0 48 b7    	ior.b     0x8f0, WREG

00002cd0 <go_disp0d>:
go_disp0d:
	btsc	Flag,#3		; #3 self-check mode
    2cd0:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row7,w0
    2cd2:	b0 4e 80    	mov.w     0x9d6, w0
	bra	disp_w0
    2cd4:	66 02 37    	bra       0x31a2 <disp_w0>

00002cd6 <alt7alu>:
alt7alu:		; if ALT pressed in ALU mode (Dim Baud Flash)
	ior.b	Dimmer,WREG	; xxxx xxxx PPPP DDDD
    2cd6:	fe 48 b7    	ior.b     0x8fe, WREG
	sl	w0,#4,w0	; xxxx PPPP DDDD 0000
    2cd8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerCtrl,WREG	; xxxx PPPP DDDD EBBB
    2cda:	f5 48 b7    	ior.b     0x8f5, WREG
	  bclr	  w0,#3		; spec case: Buad Rate takes only 3 bits
    2cdc:	00 30 a1    	bclr.w    w0, #0x3
	sl	w0,#4,w0	; PPPP DDDD 0BBB 0000
    2cde:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	FlashAddr,WREG	; PPPP DDDD 0BBB FFFF
    2ce0:	c0 49 b7    	ior.b     0x9c0, WREG
	bra	disp_w0
    2ce2:	5f 02 37    	bra       0x31a2 <disp_w0>

00002ce4 <History_cat7>:
History_cat7:			  ; HISTORY mode ............................
	  btsc	  Flag,#6		; #6 set if ALT pressed (debounced)
    2ce4:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  History_PageClockDim	; IF ALT pressed
    2ce6:	05 00 37    	bra       0x2cf2 <History_PageClockDim>
  ; anodes 0...15
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2ce8:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#12,w0		; PPPP 0000 0000 0000
    2cea:	4c 00 dd    	sl.w      w0, #0xc, w0
	  mov	  History_w9,w1		; Program Memory Address
    2cec:	11 48 80    	mov.w     0x902, w1
	  ior	  w0,[w1],w0		; PPPP CCCC XXXX YYYY
    2cee:	11 00 70    	ior.w     w0, [w1], w0
	  bra	  disp_w0
    2cf0:	58 02 37    	bra       0x31a2 <disp_w0>

00002cf2 <History_PageClockDim>:
History_PageClockDim:
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2cf2:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#4,w0		; xxxx xxxx PPPP 0000
    2cf4:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  Dimmer,WREG		; xxxx xxxx PPPP SSSS
    2cf6:	fe 48 b7    	ior.b     0x8fe, WREG
	  sl	  w0,#4,w0		; xxxx PPPP SSSS 0000
    2cf8:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Speed,WREG	; xxxx PPPP SSSS CCCC
    2cfa:	14 49 b7    	ior.b     0x914, WREG
	  sl	  w0,#4,w0		; PPPP SSSS CCCC 0000
    2cfc:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Page,WREG	; PPPP SSSS CCCC PPPP
    2cfe:	10 49 b7    	ior.b     0x910, WREG
	  bra	  disp_w0
    2d00:	50 02 37    	bra       0x31a2 <disp_w0>

00002d02 <cathode8>:
;-------------------------------- MATRIX 0,1 -------------------------- cathode 8
cathode8:
; test keys 0, 1
	keytest	0,0,1
    2d02:	7c 89 af    	btsc.b    0x97c, #0x4
    2d04:	1a 00 37    	bra       0x2d3a <L67>
    2d06:	7e 29 d4    	sl.w      0x97e
    2d08:	00 c0 2f    	mov.w     #0xfc00, w0
    2d0a:	7e 29 b7    	ior.w     0x97e
    2d0c:	64 66 af    	btsc.b    0x664, #0x3
    2d0e:	7e 09 a8    	bset.b    0x97e, #0x0
    2d10:	7e 89 ec    	inc2.w    0x97e, WREG
    2d12:	2d 00 3a    	bra       NZ, 0x2d6e <L74>
    2d14:	a8 29 b6    	and.w     0x9a8
    2d16:	00 00 20    	mov.w     #0x0, w0
    2d18:	30 4d 88    	mov.w     w0, 0x9a6
    2d1a:	40 00 b1    	sub.w     #0x4, w0
    2d1c:	42 00 ae    	btss.b    0x42, #0x0
    2d1e:	00 00 20    	mov.w     #0x0, w0
    2d20:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d22:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d24:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d26:	f0 00 20    	mov.w     #0xf, w0
    2d28:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d2a:	c0 27 29    	mov.w     #0x927c, w0
    2d2c:	b0 4d 88    	mov.w     w0, 0x9b6
    2d2e:	ac 09 ae    	btss.b    0x9ac, #0x0
    2d30:	1f 00 37    	bra       0x2d70 <L85>
    2d32:	00 05 20    	mov.w     #0x50, w0
    2d34:	ab e9 af    	btsc.b    0x9ab, #0x7
    2d36:	50 4d 88    	mov.w     w0, 0x9aa
    2d38:	1b 00 37    	bra       0x2d70 <L85>

00002d3a <L67>:
    2d3a:	80 29 d4    	sl.w      0x980
    2d3c:	00 c0 2f    	mov.w     #0xfc00, w0
    2d3e:	80 29 b7    	ior.w     0x980
    2d40:	64 86 af    	btsc.b    0x664, #0x4
    2d42:	80 09 a8    	bset.b    0x980, #0x0
    2d44:	80 89 ec    	inc2.w    0x980, WREG
    2d46:	13 00 3a    	bra       NZ, 0x2d6e <L74>
    2d48:	a8 29 b6    	and.w     0x9a8
    2d4a:	10 00 20    	mov.w     #0x1, w0
    2d4c:	30 4d 88    	mov.w     w0, 0x9a6
    2d4e:	40 00 b1    	sub.w     #0x4, w0
    2d50:	42 00 ae    	btss.b    0x42, #0x0
    2d52:	00 00 20    	mov.w     #0x0, w0
    2d54:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d56:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d58:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d5a:	f0 00 20    	mov.w     #0xf, w0
    2d5c:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d5e:	c0 27 29    	mov.w     #0x927c, w0
    2d60:	b0 4d 88    	mov.w     w0, 0x9b6
    2d62:	ac 29 ae    	btss.b    0x9ac, #0x1
    2d64:	05 00 37    	bra       0x2d70 <L85>
    2d66:	00 05 20    	mov.w     #0x50, w0
    2d68:	ab e9 af    	btsc.b    0x9ab, #0x7
    2d6a:	50 4d 88    	mov.w     w0, 0x9aa
    2d6c:	01 00 37    	bra       0x2d70 <L85>

00002d6e <L74>:
    2d6e:	a8 29 b6    	and.w     0x9a8

00002d70 <L85>:
; extra anode 16
	btsc	w3,#b_pgm	; Extra bit 16: PGM (led) 
    2d70:	03 80 a7    	btsc.w    w3, #0x8
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2d72:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+17,w1
    2d74:	11 81 20    	mov.w     #0x811, w1
	bra	disp_matrix
    2d76:	d8 01 37    	bra       0x3128 <disp_matrix>

00002d78 <cathode9>:
;-------------------------------- MATRIX 2,3 -------------------------- cathode 9
cathode9:
; test keys 2, 3
	keytest 2,2,3
    2d78:	7c 89 af    	btsc.b    0x97c, #0x4
    2d7a:	1a 00 37    	bra       0x2db0 <L68>
    2d7c:	82 29 d4    	sl.w      0x982
    2d7e:	00 c0 2f    	mov.w     #0xfc00, w0
    2d80:	82 29 b7    	ior.w     0x982
    2d82:	64 66 af    	btsc.b    0x664, #0x3
    2d84:	82 09 a8    	bset.b    0x982, #0x0
    2d86:	82 89 ec    	inc2.w    0x982, WREG
    2d88:	2d 00 3a    	bra       NZ, 0x2de4 <L75>
    2d8a:	a8 29 b6    	and.w     0x9a8
    2d8c:	20 00 20    	mov.w     #0x2, w0
    2d8e:	30 4d 88    	mov.w     w0, 0x9a6
    2d90:	40 00 b1    	sub.w     #0x4, w0
    2d92:	42 00 ae    	btss.b    0x42, #0x0
    2d94:	00 00 20    	mov.w     #0x0, w0
    2d96:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d98:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d9a:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d9c:	f0 00 20    	mov.w     #0xf, w0
    2d9e:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2da0:	c0 27 29    	mov.w     #0x927c, w0
    2da2:	b0 4d 88    	mov.w     w0, 0x9b6
    2da4:	ac 49 ae    	btss.b    0x9ac, #0x2
    2da6:	1f 00 37    	bra       0x2de6 <L86>
    2da8:	00 05 20    	mov.w     #0x50, w0
    2daa:	ab e9 af    	btsc.b    0x9ab, #0x7
    2dac:	50 4d 88    	mov.w     w0, 0x9aa
    2dae:	1b 00 37    	bra       0x2de6 <L86>

00002db0 <L68>:
    2db0:	84 29 d4    	sl.w      0x984
    2db2:	00 c0 2f    	mov.w     #0xfc00, w0
    2db4:	84 29 b7    	ior.w     0x984
    2db6:	64 86 af    	btsc.b    0x664, #0x4
    2db8:	84 09 a8    	bset.b    0x984, #0x0
    2dba:	84 89 ec    	inc2.w    0x984, WREG
    2dbc:	13 00 3a    	bra       NZ, 0x2de4 <L75>
    2dbe:	a8 29 b6    	and.w     0x9a8
    2dc0:	30 00 20    	mov.w     #0x3, w0
    2dc2:	30 4d 88    	mov.w     w0, 0x9a6
    2dc4:	40 00 b1    	sub.w     #0x4, w0
    2dc6:	42 00 ae    	btss.b    0x42, #0x0
    2dc8:	00 00 20    	mov.w     #0x0, w0
    2dca:	fd e8 b7    	mov.b     WREG, 0x8fd
    2dcc:	dc 29 a8    	bset.b    0x9dc, #0x1
    2dce:	fc 08 a8    	bset.b    0x8fc, #0x0
    2dd0:	f0 00 20    	mov.w     #0xf, w0
    2dd2:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2dd4:	c0 27 29    	mov.w     #0x927c, w0
    2dd6:	b0 4d 88    	mov.w     w0, 0x9b6
    2dd8:	ac 69 ae    	btss.b    0x9ac, #0x3
    2dda:	05 00 37    	bra       0x2de6 <L86>
    2ddc:	00 05 20    	mov.w     #0x50, w0
    2dde:	ab e9 af    	btsc.b    0x9ab, #0x7
    2de0:	50 4d 88    	mov.w     w0, 0x9aa
    2de2:	01 00 37    	bra       0x2de6 <L86>

00002de4 <L75>:
    2de4:	a8 29 b6    	and.w     0x9a8

00002de6 <L86>:
; extra anode 16
	btss	w3,#b_run	; Extra bit 16: RUN (led) 
    2de6:	03 90 a6    	btss.w    w3, #0x9
	bra	1f
    2de8:	03 00 37    	bra       0x2df0 <L126>
	btsc	BlinkFlag,#2	; 2 set = LED Run blinks
    2dea:	e0 49 af    	btsc.b    0x9e0, #0x2
	btss	BlinkCount,#9	; bit pos = blinking freq
    2dec:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2dee:	dd 89 a8    	bset.b    0x9dd, #0x4

00002df0 <L126>:
1:
; anodes 0...15
	mov	#Ram+19,w1
    2df0:	31 81 20    	mov.w     #0x813, w1
	bra	disp_matrix
    2df2:	9a 01 37    	bra       0x3128 <disp_matrix>

00002df4 <cathode10>:
;-------------------------------- MATRIX 4,5 -------------------------- cathode 10
cathode10:
; test keys 4, 5
	keytest 4,4,5
    2df4:	7c 89 af    	btsc.b    0x97c, #0x4
    2df6:	1a 00 37    	bra       0x2e2c <L69>
    2df8:	86 29 d4    	sl.w      0x986
    2dfa:	00 c0 2f    	mov.w     #0xfc00, w0
    2dfc:	86 29 b7    	ior.w     0x986
    2dfe:	64 66 af    	btsc.b    0x664, #0x3
    2e00:	86 09 a8    	bset.b    0x986, #0x0
    2e02:	86 89 ec    	inc2.w    0x986, WREG
    2e04:	2d 00 3a    	bra       NZ, 0x2e60 <L76>
    2e06:	a8 29 b6    	and.w     0x9a8
    2e08:	40 00 20    	mov.w     #0x4, w0
    2e0a:	30 4d 88    	mov.w     w0, 0x9a6
    2e0c:	40 00 b1    	sub.w     #0x4, w0
    2e0e:	42 00 ae    	btss.b    0x42, #0x0
    2e10:	00 00 20    	mov.w     #0x0, w0
    2e12:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e14:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e16:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e18:	f0 00 20    	mov.w     #0xf, w0
    2e1a:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e1c:	c0 27 29    	mov.w     #0x927c, w0
    2e1e:	b0 4d 88    	mov.w     w0, 0x9b6
    2e20:	ac 89 ae    	btss.b    0x9ac, #0x4
    2e22:	1f 00 37    	bra       0x2e62 <L87>
    2e24:	00 05 20    	mov.w     #0x50, w0
    2e26:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e28:	50 4d 88    	mov.w     w0, 0x9aa
    2e2a:	1b 00 37    	bra       0x2e62 <L87>

00002e2c <L69>:
    2e2c:	88 29 d4    	sl.w      0x988
    2e2e:	00 c0 2f    	mov.w     #0xfc00, w0
    2e30:	88 29 b7    	ior.w     0x988
    2e32:	64 86 af    	btsc.b    0x664, #0x4
    2e34:	88 09 a8    	bset.b    0x988, #0x0
    2e36:	88 89 ec    	inc2.w    0x988, WREG
    2e38:	13 00 3a    	bra       NZ, 0x2e60 <L76>
    2e3a:	a8 29 b6    	and.w     0x9a8
    2e3c:	50 00 20    	mov.w     #0x5, w0
    2e3e:	30 4d 88    	mov.w     w0, 0x9a6
    2e40:	40 00 b1    	sub.w     #0x4, w0
    2e42:	42 00 ae    	btss.b    0x42, #0x0
    2e44:	00 00 20    	mov.w     #0x0, w0
    2e46:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e48:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e4a:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e4c:	f0 00 20    	mov.w     #0xf, w0
    2e4e:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e50:	c0 27 29    	mov.w     #0x927c, w0
    2e52:	b0 4d 88    	mov.w     w0, 0x9b6
    2e54:	ac a9 ae    	btss.b    0x9ac, #0x5
    2e56:	05 00 37    	bra       0x2e62 <L87>
    2e58:	00 05 20    	mov.w     #0x50, w0
    2e5a:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e5c:	50 4d 88    	mov.w     w0, 0x9aa
    2e5e:	01 00 37    	bra       0x2e62 <L87>

00002e60 <L76>:
    2e60:	a8 29 b6    	and.w     0x9a8

00002e62 <L87>:
; extra anode 16
	btss	w3,#b_ss	; Extra bit 16: SS (led) 
    2e62:	03 a0 a6    	btss.w    w3, #0xa
	bra	1f
    2e64:	03 00 37    	bra       0x2e6c <L127>
	btsc	BlinkFlag,#3	; 3 set = LED SS blinks
    2e66:	e0 69 af    	btsc.b    0x9e0, #0x3
	btss	BlinkCount,#9	; blinking freq
    2e68:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2e6a:	dd 89 a8    	bset.b    0x9dd, #0x4

00002e6c <L127>:
1:
; anodes 0...15
	mov	#Ram+21,w1
    2e6c:	51 81 20    	mov.w     #0x815, w1
	bra	disp_matrix
    2e6e:	5c 01 37    	bra       0x3128 <disp_matrix>

00002e70 <cathode11>:
;-------------------------------- MATRIX 6,7 -------------------------- cathode 11
cathode11:
	btsc	Flag,#3		; #3 self-check mode
    2e70:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in4		; no IN in self-check mode
    2e72:	07 00 37    	bra       0x2e82 <no_in4>
; IN register service
	mov.b	PORTB,WREG
    2e74:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2e76:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2e78:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2e7a:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2e7c:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2e7e:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2e80:	fb e8 b7    	mov.b     WREG, 0x8fb

00002e82 <no_in4>:
no_in4:
; test keys 6, 7
	keytest 6,5,5
    2e82:	7c 89 af    	btsc.b    0x97c, #0x4
    2e84:	1a 00 37    	bra       0x2eba <L610>
    2e86:	8a 29 d4    	sl.w      0x98a
    2e88:	00 c0 2f    	mov.w     #0xfc00, w0
    2e8a:	8a 29 b7    	ior.w     0x98a
    2e8c:	64 66 af    	btsc.b    0x664, #0x3
    2e8e:	8a 09 a8    	bset.b    0x98a, #0x0
    2e90:	8a 89 ec    	inc2.w    0x98a, WREG
    2e92:	2d 00 3a    	bra       NZ, 0x2eee <L77>
    2e94:	a8 29 b6    	and.w     0x9a8
    2e96:	60 00 20    	mov.w     #0x6, w0
    2e98:	30 4d 88    	mov.w     w0, 0x9a6
    2e9a:	40 00 b1    	sub.w     #0x4, w0
    2e9c:	42 00 ae    	btss.b    0x42, #0x0
    2e9e:	00 00 20    	mov.w     #0x0, w0
    2ea0:	fd e8 b7    	mov.b     WREG, 0x8fd
    2ea2:	dc 29 a8    	bset.b    0x9dc, #0x1
    2ea4:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ea6:	f0 00 20    	mov.w     #0xf, w0
    2ea8:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2eaa:	c0 27 29    	mov.w     #0x927c, w0
    2eac:	b0 4d 88    	mov.w     w0, 0x9b6
    2eae:	ac a9 ae    	btss.b    0x9ac, #0x5
    2eb0:	1f 00 37    	bra       0x2ef0 <L88>
    2eb2:	00 05 20    	mov.w     #0x50, w0
    2eb4:	ab e9 af    	btsc.b    0x9ab, #0x7
    2eb6:	50 4d 88    	mov.w     w0, 0x9aa
    2eb8:	1b 00 37    	bra       0x2ef0 <L88>

00002eba <L610>:
    2eba:	8c 29 d4    	sl.w      0x98c
    2ebc:	00 c0 2f    	mov.w     #0xfc00, w0
    2ebe:	8c 29 b7    	ior.w     0x98c
    2ec0:	64 86 af    	btsc.b    0x664, #0x4
    2ec2:	8c 09 a8    	bset.b    0x98c, #0x0
    2ec4:	8c 89 ec    	inc2.w    0x98c, WREG
    2ec6:	13 00 3a    	bra       NZ, 0x2eee <L77>
    2ec8:	a8 29 b6    	and.w     0x9a8
    2eca:	70 00 20    	mov.w     #0x7, w0
    2ecc:	30 4d 88    	mov.w     w0, 0x9a6
    2ece:	40 00 b1    	sub.w     #0x4, w0
    2ed0:	42 00 ae    	btss.b    0x42, #0x0
    2ed2:	00 00 20    	mov.w     #0x0, w0
    2ed4:	fd e8 b7    	mov.b     WREG, 0x8fd
    2ed6:	dc 29 a8    	bset.b    0x9dc, #0x1
    2ed8:	fc 08 a8    	bset.b    0x8fc, #0x0
    2eda:	f0 00 20    	mov.w     #0xf, w0
    2edc:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2ede:	c0 27 29    	mov.w     #0x927c, w0
    2ee0:	b0 4d 88    	mov.w     w0, 0x9b6
    2ee2:	ac a9 ae    	btss.b    0x9ac, #0x5
    2ee4:	05 00 37    	bra       0x2ef0 <L88>
    2ee6:	00 05 20    	mov.w     #0x50, w0
    2ee8:	ab e9 af    	btsc.b    0x9ab, #0x7
    2eea:	50 4d 88    	mov.w     w0, 0x9aa
    2eec:	01 00 37    	bra       0x2ef0 <L88>

00002eee <L77>:
    2eee:	a8 29 b6    	and.w     0x9a8

00002ef0 <L88>:
; extra anode 16
	btsc	w3,#b_alu	;  Extra bit 16:ALU (led) 
    2ef0:	03 b0 a7    	btsc.w    w3, #0xb
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ef2:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+23,w1
    2ef4:	71 81 20    	mov.w     #0x817, w1
	bra	disp_matrix
    2ef6:	18 01 37    	bra       0x3128 <disp_matrix>

00002ef8 <cathode12>:
;-------------------------------- MATRIX 8,9 -------------------------- cathode 12
cathode12:
; test keys 8, 9
	keytest 8,5,6
    2ef8:	7c 89 af    	btsc.b    0x97c, #0x4
    2efa:	1a 00 37    	bra       0x2f30 <L611>
    2efc:	8e 29 d4    	sl.w      0x98e
    2efe:	00 c0 2f    	mov.w     #0xfc00, w0
    2f00:	8e 29 b7    	ior.w     0x98e
    2f02:	64 66 af    	btsc.b    0x664, #0x3
    2f04:	8e 09 a8    	bset.b    0x98e, #0x0
    2f06:	8e 89 ec    	inc2.w    0x98e, WREG
    2f08:	2d 00 3a    	bra       NZ, 0x2f64 <L78>
    2f0a:	a8 29 b6    	and.w     0x9a8
    2f0c:	80 00 20    	mov.w     #0x8, w0
    2f0e:	30 4d 88    	mov.w     w0, 0x9a6
    2f10:	40 00 b1    	sub.w     #0x4, w0
    2f12:	42 00 ae    	btss.b    0x42, #0x0
    2f14:	00 00 20    	mov.w     #0x0, w0
    2f16:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f18:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f1a:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f1c:	f0 00 20    	mov.w     #0xf, w0
    2f1e:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f20:	c0 27 29    	mov.w     #0x927c, w0
    2f22:	b0 4d 88    	mov.w     w0, 0x9b6
    2f24:	ac a9 ae    	btss.b    0x9ac, #0x5
    2f26:	1f 00 37    	bra       0x2f66 <L89>
    2f28:	00 05 20    	mov.w     #0x50, w0
    2f2a:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f2c:	50 4d 88    	mov.w     w0, 0x9aa
    2f2e:	1b 00 37    	bra       0x2f66 <L89>

00002f30 <L611>:
    2f30:	90 29 d4    	sl.w      0x990
    2f32:	00 c0 2f    	mov.w     #0xfc00, w0
    2f34:	90 29 b7    	ior.w     0x990
    2f36:	64 86 af    	btsc.b    0x664, #0x4
    2f38:	90 09 a8    	bset.b    0x990, #0x0
    2f3a:	90 89 ec    	inc2.w    0x990, WREG
    2f3c:	13 00 3a    	bra       NZ, 0x2f64 <L78>
    2f3e:	a8 29 b6    	and.w     0x9a8
    2f40:	90 00 20    	mov.w     #0x9, w0
    2f42:	30 4d 88    	mov.w     w0, 0x9a6
    2f44:	40 00 b1    	sub.w     #0x4, w0
    2f46:	42 00 ae    	btss.b    0x42, #0x0
    2f48:	00 00 20    	mov.w     #0x0, w0
    2f4a:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f4c:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f4e:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f50:	f0 00 20    	mov.w     #0xf, w0
    2f52:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f54:	c0 27 29    	mov.w     #0x927c, w0
    2f56:	b0 4d 88    	mov.w     w0, 0x9b6
    2f58:	ac c9 ae    	btss.b    0x9ac, #0x6
    2f5a:	05 00 37    	bra       0x2f66 <L89>
    2f5c:	00 05 20    	mov.w     #0x50, w0
    2f5e:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f60:	50 4d 88    	mov.w     w0, 0x9aa
    2f62:	01 00 37    	bra       0x2f66 <L89>

00002f64 <L78>:
    2f64:	a8 29 b6    	and.w     0x9a8

00002f66 <L89>:
; extra anode 16
	btss	w3,#b_carry	; Extra bit 16: CARRY (key)
    2f66:	03 c0 a6    	btss.w    w3, #0xc
	bra	1f
    2f68:	03 00 37    	bra       0x2f70 <L128>
	btsc	BlinkFlag,#4	; #4 = CARRY blinks
    2f6a:	e0 89 af    	btsc.b    0x9e0, #0x4
	btss	BlinkCount,#9	; blinking freq
    2f6c:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2f6e:	dd 89 a8    	bset.b    0x9dd, #0x4

00002f70 <L128>:
1:
; anodes 0...15
	mov	#Ram+25,w1
    2f70:	91 81 20    	mov.w     #0x819, w1
	bra	disp_matrix
    2f72:	da 00 37    	bra       0x3128 <disp_matrix>

00002f74 <cathode13>:
;-------------------------------- MATRIX A,B -------------------------- cathode 13
cathode13:
; test keys 10, 11
	keytest 10,6,6
    2f74:	7c 89 af    	btsc.b    0x97c, #0x4
    2f76:	1a 00 37    	bra       0x2fac <L612>
    2f78:	92 29 d4    	sl.w      0x992
    2f7a:	00 c0 2f    	mov.w     #0xfc00, w0
    2f7c:	92 29 b7    	ior.w     0x992
    2f7e:	64 66 af    	btsc.b    0x664, #0x3
    2f80:	92 09 a8    	bset.b    0x992, #0x0
    2f82:	92 89 ec    	inc2.w    0x992, WREG
    2f84:	2d 00 3a    	bra       NZ, 0x2fe0 <L79>
    2f86:	a8 29 b6    	and.w     0x9a8
    2f88:	a0 00 20    	mov.w     #0xa, w0
    2f8a:	30 4d 88    	mov.w     w0, 0x9a6
    2f8c:	40 00 b1    	sub.w     #0x4, w0
    2f8e:	42 00 ae    	btss.b    0x42, #0x0
    2f90:	00 00 20    	mov.w     #0x0, w0
    2f92:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f94:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f96:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f98:	f0 00 20    	mov.w     #0xf, w0
    2f9a:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f9c:	c0 27 29    	mov.w     #0x927c, w0
    2f9e:	b0 4d 88    	mov.w     w0, 0x9b6
    2fa0:	ac c9 ae    	btss.b    0x9ac, #0x6
    2fa2:	1f 00 37    	bra       0x2fe2 <L810>
    2fa4:	00 05 20    	mov.w     #0x50, w0
    2fa6:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fa8:	50 4d 88    	mov.w     w0, 0x9aa
    2faa:	1b 00 37    	bra       0x2fe2 <L810>

00002fac <L612>:
    2fac:	94 29 d4    	sl.w      0x994
    2fae:	00 c0 2f    	mov.w     #0xfc00, w0
    2fb0:	94 29 b7    	ior.w     0x994
    2fb2:	64 86 af    	btsc.b    0x664, #0x4
    2fb4:	94 09 a8    	bset.b    0x994, #0x0
    2fb6:	94 89 ec    	inc2.w    0x994, WREG
    2fb8:	13 00 3a    	bra       NZ, 0x2fe0 <L79>
    2fba:	a8 29 b6    	and.w     0x9a8
    2fbc:	b0 00 20    	mov.w     #0xb, w0
    2fbe:	30 4d 88    	mov.w     w0, 0x9a6
    2fc0:	40 00 b1    	sub.w     #0x4, w0
    2fc2:	42 00 ae    	btss.b    0x42, #0x0
    2fc4:	00 00 20    	mov.w     #0x0, w0
    2fc6:	fd e8 b7    	mov.b     WREG, 0x8fd
    2fc8:	dc 29 a8    	bset.b    0x9dc, #0x1
    2fca:	fc 08 a8    	bset.b    0x8fc, #0x0
    2fcc:	f0 00 20    	mov.w     #0xf, w0
    2fce:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2fd0:	c0 27 29    	mov.w     #0x927c, w0
    2fd2:	b0 4d 88    	mov.w     w0, 0x9b6
    2fd4:	ac c9 ae    	btss.b    0x9ac, #0x6
    2fd6:	05 00 37    	bra       0x2fe2 <L810>
    2fd8:	00 05 20    	mov.w     #0x50, w0
    2fda:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fdc:	50 4d 88    	mov.w     w0, 0x9aa
    2fde:	01 00 37    	bra       0x2fe2 <L810>

00002fe0 <L79>:
    2fe0:	a8 29 b6    	and.w     0x9a8

00002fe2 <L810>:
; extra anode 16
	btss	w3,#b_save	; Extra bit 16: SAVE (key)
    2fe2:	03 d0 a6    	btss.w    w3, #0xd
	bra	1f
    2fe4:	03 00 37    	bra       0x2fec <L129>
	btsc	BlinkFlag,#5	; #5 = SAVE blinks
    2fe6:	e0 a9 af    	btsc.b    0x9e0, #0x5
	btss	BlinkCount,#9	; blinking freq
    2fe8:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2fea:	dd 89 a8    	bset.b    0x9dd, #0x4

00002fec <L129>:
1:
; anodes 0...15
	mov	#Ram+27,w1
    2fec:	b1 81 20    	mov.w     #0x81b, w1
	bra	disp_matrix
    2fee:	9c 00 37    	bra       0x3128 <disp_matrix>

00002ff0 <cathode14>:
;-------------------------------- MATRIX C,D -------------------------- cathode 14
cathode14:
	mov	BlinkCount,w0
    2ff0:	e0 4b 80    	mov.w     0x97c, w0
	mov	#0b110000,w1	; dim down/up speed
    2ff2:	01 03 20    	mov.w     #0x30, w1
	and	w0,w1,w0
    2ff4:	01 00 60    	and.w     w0, w1, w0
	bra	nz,no_dim_up
    2ff6:	0f 00 3a    	bra       NZ, 0x3016 <no_dim_up>
; dim down \\\\\\\\\\\\\\\\\\\\\
	btss	Flag,#14	; #14 set if dim down in progress
    2ff8:	dd c9 ae    	btss.b    0x9dd, #0x6
	bra	no_dim_down
    2ffa:	05 00 37    	bra       0x3006 <no_dim_down>
	cp0.b	Dimmer
    2ffc:	fe 48 e2    	cp0.b     0x8fe
	ifz
    2ffe:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#14	; end of dim down
    3000:	dd c9 a9    	bclr.b    0x9dd, #0x6
	bra	z,enter_sleep	; GO SLEEP -------------------------------------->
    3002:	19 01 32    	bra       Z, 0x3236 <enter_sleep>
	dec.b	Dimmer
    3004:	fe 68 ed    	dec.b     0x8fe

00003006 <no_dim_down>:
no_dim_down:
; dim up ///////////////////////
	btss	Flag,#15	; #15 set if dim up in progress
    3006:	dd e9 ae    	btss.b    0x9dd, #0x7
	bra	no_dim_up
    3008:	06 00 37    	bra       0x3016 <no_dim_up>
	mov.b	Temp_Dimmer,WREG
    300a:	ba c9 bf    	mov.b     0x9ba, WREG
	cp.b	Dimmer		; Dimmer - Temp_Dimmer
    300c:	fe 48 e3    	cp.b      0x8fe
	ifc
    300e:	42 00 af    	btsc.b    0x42, #0x0
	bclr	Flag,#15	; end of dim up
    3010:	dd e9 a9    	bclr.b    0x9dd, #0x7
	ifnc
    3012:	42 00 ae    	btss.b    0x42, #0x0
	inc.b	Dimmer
    3014:	fe 68 ec    	inc.b     0x8fe

00003016 <no_dim_up>:
no_dim_up:
; test keys 12, 13
	keytest 12,6,7
    3016:	7c 89 af    	btsc.b    0x97c, #0x4
    3018:	1a 00 37    	bra       0x304e <L613>
    301a:	96 29 d4    	sl.w      0x996
    301c:	00 c0 2f    	mov.w     #0xfc00, w0
    301e:	96 29 b7    	ior.w     0x996
    3020:	64 66 af    	btsc.b    0x664, #0x3
    3022:	96 09 a8    	bset.b    0x996, #0x0
    3024:	96 89 ec    	inc2.w    0x996, WREG
    3026:	2d 00 3a    	bra       NZ, 0x3082 <L710>
    3028:	a8 29 b6    	and.w     0x9a8
    302a:	c0 00 20    	mov.w     #0xc, w0
    302c:	30 4d 88    	mov.w     w0, 0x9a6
    302e:	40 00 b1    	sub.w     #0x4, w0
    3030:	42 00 ae    	btss.b    0x42, #0x0
    3032:	00 00 20    	mov.w     #0x0, w0
    3034:	fd e8 b7    	mov.b     WREG, 0x8fd
    3036:	dc 29 a8    	bset.b    0x9dc, #0x1
    3038:	fc 08 a8    	bset.b    0x8fc, #0x0
    303a:	f0 00 20    	mov.w     #0xf, w0
    303c:	f9 e8 b7    	mov.b     WREG, 0x8f9
    303e:	c0 27 29    	mov.w     #0x927c, w0
    3040:	b0 4d 88    	mov.w     w0, 0x9b6
    3042:	ac c9 ae    	btss.b    0x9ac, #0x6
    3044:	1f 00 37    	bra       0x3084 <L811>
    3046:	00 05 20    	mov.w     #0x50, w0
    3048:	ab e9 af    	btsc.b    0x9ab, #0x7
    304a:	50 4d 88    	mov.w     w0, 0x9aa
    304c:	1b 00 37    	bra       0x3084 <L811>

0000304e <L613>:
    304e:	98 29 d4    	sl.w      0x998
    3050:	00 c0 2f    	mov.w     #0xfc00, w0
    3052:	98 29 b7    	ior.w     0x998
    3054:	64 86 af    	btsc.b    0x664, #0x4
    3056:	98 09 a8    	bset.b    0x998, #0x0
    3058:	98 89 ec    	inc2.w    0x998, WREG
    305a:	13 00 3a    	bra       NZ, 0x3082 <L710>
    305c:	a8 29 b6    	and.w     0x9a8
    305e:	d0 00 20    	mov.w     #0xd, w0
    3060:	30 4d 88    	mov.w     w0, 0x9a6
    3062:	40 00 b1    	sub.w     #0x4, w0
    3064:	42 00 ae    	btss.b    0x42, #0x0
    3066:	00 00 20    	mov.w     #0x0, w0
    3068:	fd e8 b7    	mov.b     WREG, 0x8fd
    306a:	dc 29 a8    	bset.b    0x9dc, #0x1
    306c:	fc 08 a8    	bset.b    0x8fc, #0x0
    306e:	f0 00 20    	mov.w     #0xf, w0
    3070:	f9 e8 b7    	mov.b     WREG, 0x8f9
    3072:	c0 27 29    	mov.w     #0x927c, w0
    3074:	b0 4d 88    	mov.w     w0, 0x9b6
    3076:	ac e9 ae    	btss.b    0x9ac, #0x7
    3078:	05 00 37    	bra       0x3084 <L811>
    307a:	00 05 20    	mov.w     #0x50, w0
    307c:	ab e9 af    	btsc.b    0x9ab, #0x7
    307e:	50 4d 88    	mov.w     w0, 0x9aa
    3080:	01 00 37    	bra       0x3084 <L811>

00003082 <L710>:
    3082:	a8 29 b6    	and.w     0x9a8

00003084 <L811>:
; extra anode 16
	btss	w3,#b_load	; Extra bit 16: LOAD (key) 
    3084:	03 e0 a6    	btss.w    w3, #0xe
	bra	1f
    3086:	03 00 37    	bra       0x308e <L130>
	btsc	BlinkFlag,#7	; #7 = LOAD blinks
    3088:	e0 e9 af    	btsc.b    0x9e0, #0x7
	btss	BlinkCount,#9	; blinking freq
    308a:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    308c:	dd 89 a8    	bset.b    0x9dd, #0x4

0000308e <L130>:
1:
; anodes 0...15
	mov	#Ram+29,w1
    308e:	d1 81 20    	mov.w     #0x81d, w1
	bra	disp_matrix
    3090:	4b 00 37    	bra       0x3128 <disp_matrix>

00003092 <cathode15>:
;-------------------------------- MATRIX E,F -------------------------- cathode 15
cathode15:
; test keys 14, 15
	keytest 14,7,7
    3092:	7c 89 af    	btsc.b    0x97c, #0x4
    3094:	1a 00 37    	bra       0x30ca <L614>
    3096:	9a 29 d4    	sl.w      0x99a
    3098:	00 c0 2f    	mov.w     #0xfc00, w0
    309a:	9a 29 b7    	ior.w     0x99a
    309c:	64 66 af    	btsc.b    0x664, #0x3
    309e:	9a 09 a8    	bset.b    0x99a, #0x0
    30a0:	9a 89 ec    	inc2.w    0x99a, WREG
    30a2:	2d 00 3a    	bra       NZ, 0x30fe <L711>
    30a4:	a8 29 b6    	and.w     0x9a8
    30a6:	e0 00 20    	mov.w     #0xe, w0
    30a8:	30 4d 88    	mov.w     w0, 0x9a6
    30aa:	40 00 b1    	sub.w     #0x4, w0
    30ac:	42 00 ae    	btss.b    0x42, #0x0
    30ae:	00 00 20    	mov.w     #0x0, w0
    30b0:	fd e8 b7    	mov.b     WREG, 0x8fd
    30b2:	dc 29 a8    	bset.b    0x9dc, #0x1
    30b4:	fc 08 a8    	bset.b    0x8fc, #0x0
    30b6:	f0 00 20    	mov.w     #0xf, w0
    30b8:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30ba:	c0 27 29    	mov.w     #0x927c, w0
    30bc:	b0 4d 88    	mov.w     w0, 0x9b6
    30be:	ac e9 ae    	btss.b    0x9ac, #0x7
    30c0:	1f 00 37    	bra       0x3100 <L812>
    30c2:	00 05 20    	mov.w     #0x50, w0
    30c4:	ab e9 af    	btsc.b    0x9ab, #0x7
    30c6:	50 4d 88    	mov.w     w0, 0x9aa
    30c8:	1b 00 37    	bra       0x3100 <L812>

000030ca <L614>:
    30ca:	9c 29 d4    	sl.w      0x99c
    30cc:	00 c0 2f    	mov.w     #0xfc00, w0
    30ce:	9c 29 b7    	ior.w     0x99c
    30d0:	64 86 af    	btsc.b    0x664, #0x4
    30d2:	9c 09 a8    	bset.b    0x99c, #0x0
    30d4:	9c 89 ec    	inc2.w    0x99c, WREG
    30d6:	13 00 3a    	bra       NZ, 0x30fe <L711>
    30d8:	a8 29 b6    	and.w     0x9a8
    30da:	f0 00 20    	mov.w     #0xf, w0
    30dc:	30 4d 88    	mov.w     w0, 0x9a6
    30de:	40 00 b1    	sub.w     #0x4, w0
    30e0:	42 00 ae    	btss.b    0x42, #0x0
    30e2:	00 00 20    	mov.w     #0x0, w0
    30e4:	fd e8 b7    	mov.b     WREG, 0x8fd
    30e6:	dc 29 a8    	bset.b    0x9dc, #0x1
    30e8:	fc 08 a8    	bset.b    0x8fc, #0x0
    30ea:	f0 00 20    	mov.w     #0xf, w0
    30ec:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30ee:	c0 27 29    	mov.w     #0x927c, w0
    30f0:	b0 4d 88    	mov.w     w0, 0x9b6
    30f2:	ac e9 ae    	btss.b    0x9ac, #0x7
    30f4:	05 00 37    	bra       0x3100 <L812>
    30f6:	00 05 20    	mov.w     #0x50, w0
    30f8:	ab e9 af    	btsc.b    0x9ab, #0x7
    30fa:	50 4d 88    	mov.w     w0, 0x9aa
    30fc:	01 00 37    	bra       0x3100 <L812>

000030fe <L711>:
    30fe:	a8 29 b6    	and.w     0x9a8

00003100 <L812>:
; anykey ---> Flag,#11 test
	btss	BlinkCount,#4
    3100:	7c 89 ae    	btss.b    0x97c, #0x4
	bra	1f		; if odd pass
    3102:	07 00 37    	bra       0x3112 <L131>
	bclr	Flag,#11	; #11 flag "any Key Pressed"
    3104:	dd 69 a9    	bclr.b    0x9dd, #0x3
	btss	Anypress,#0	; bit 0 is reset if any key still depressed
    3106:	a8 09 ae    	btss.b    0x9a8, #0x0
	bset	Flag,#11	; #11 flag "any Key Pressed"
    3108:	dd 69 a8    	bset.b    0x9dd, #0x3
;	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
;	bset	Flag,#11	;WrFlags #11 flag "any Key Pressed"
	bclr.b	KeyStatus,#2	; user's flag "any key pressed"
    310a:	fc 48 a9    	bclr.b    0x8fc, #0x2
	btsc	Flag,#11	; #11 flag "any Key Pressed" (will be moved to KeyStatus,#2)
    310c:	dd 69 af    	btsc.b    0x9dd, #0x3
	bset.b	KeyStatus,#2	; user's flag "any key pressed"
    310e:	fc 48 a8    	bset.b    0x8fc, #0x2
	bra	2f
    3110:	08 00 37    	bra       0x3122 <L28>

00003112 <L131>:
1:
; test if last key is still pressed (service KeyStatus,#1)
	bclr.b	KeyStatus,#1	; user's flag "last key pressed"
    3112:	fc 28 a9    	bclr.b    0x8fc, #0x1
	sl.b	KeyReg,WREG	; ×2
    3114:	fd 48 d4    	sl.b      0x8fd, WREG
	and	#0x1F,w0
    3116:	f0 01 b2    	and.w     #0x1f, w0
	bra	z,2f		; if last key = 0, 1, 2, 3, 4 (illegal keys)
    3118:	04 00 32    	bra       Z, 0x3122 <L28>
	mov	#KeyRotors+8,w1
    311a:	61 98 20    	mov.w     #0x986, w1
	add	w0,w1,w0	; debouncer for the last pressed key
    311c:	01 00 40    	add.w     w0, w1, w0
	btss	[w0],#0
    311e:	10 00 a6    	btss.w    [w0], #0x0
	bset.b	KeyStatus,#1	; user's flag "last key pressed"
    3120:	fc 28 a8    	bset.b    0x8fc, #0x1

00003122 <L28>:
2:
; extra anode 16
	btsc	w3,#b_bin	; Extra bit 16: BIN (bin/sel leds) 
    3122:	03 f0 a7    	btsc.w    w3, #0xf
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3124:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+31,w1
    3126:	f1 81 20    	mov.w     #0x81f, w1

00003128 <disp_matrix>:
disp_matrix:
  ; History cathodes 8...15 conditional setup
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    3128:	dc a9 ae    	btss.b    0x9dc, #0x5
	  bra	  regular_15
    312a:	09 00 37    	bra       0x313e <regular_15>
  ; get bytes from unpacked history RAM pages
	  mov	  History_Visible,w1
    312c:	01 48 80    	mov.w     0x900, w1
	  btss	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    312e:	dc c9 ae    	btss.b    0x9dc, #0x6
	  add	  #16,w1	  ; address for hist RAM page 0 is History_Visible+16
    3130:	01 01 b0    	add.w     #0x10, w1
	  mov	  RowScan,w0
    3132:	c0 4b 80    	mov.w     0x978, w0
	  and	  #7,w0		  ; 8...15 ---> 0...7
    3134:	70 00 b2    	and.w     #0x7, w0
	  sl	  w0,w0		  ; ×2
    3136:	00 00 d0    	sl.w      w0, w0
	  add	  w0,w1,w1
    3138:	81 00 40    	add.w     w0, w1, w1
	  mov	  [w1],w0	  ; here's unpacked word ready for display ports
    313a:	11 00 78    	mov.w     [w1], w0
	  bra	  skr_15
    313c:	28 00 37    	bra       0x318e <skr_15>

0000313e <regular_15>:
regular_15:
	mov.b	Page,WREG
    313e:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    3140:	dc c9 af    	btsc.b    0x9dc, #0x6
	  clr	  w0		  ; if ALT pressed, then page 0
    3142:	00 00 eb    	clr.w     w0
	ze	w0,w0
    3144:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; w0 = 16 × Page
    3146:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w0,w1,w1	; w1 = #Ram + (16×Page) + 31
    3148:	81 00 40    	add.w     w0, w1, w1
	sub	w1,#16,w2	; w2 = #Ram + (16×Page) + 15
    314a:	70 81 50    	sub.w     w1, #0x10, w2
; if >15 then wrap to 0
	mov	#Ram+255,w0
    314c:	f0 8f 20    	mov.w     #0x8ff, w0
	cp	w1,w0
    314e:	00 08 e1    	cp.w      w1, w0
	ifc
    3150:	42 00 af    	btsc.b    0x42, #0x0
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    3152:	01 10 b1    	sub.w     #0x100, w1
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    3154:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    3156:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    3158:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    315a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; 0000 AAAA CCCC BBBB
    315c:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    315e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2],w0	; AAAA CCCC BBBB DDDD
    3160:	12 40 70    	ior.b     w0, [w2], w0
; blank matrix in mode 0 and mode 3
	mov	Mode,w2
    3162:	b2 4b 80    	mov.w     0x976, w2
	cp0	w2
    3164:	02 00 e0    	cp0.w     w2
	bra	nz,1f		; if Mode not ALU
    3166:	10 00 3a    	bra       NZ, 0x3188 <L132>
; Mode = Dir
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    3168:	df 09 af    	btsc.b    0x9df, #0x0
	bra	3f
    316a:	08 00 37    	bra       0x317c <L310>
; no buttons pressed yet (Ver/Rev mode)
	mov	RowScan,w2
    316c:	c2 4b 80    	mov.w     0x978, w2
	cp	w2,#13		; here are rows 10 and 11
    316e:	6d 10 e1    	cp.w      w2, #0xd
	ifz
    3170:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS1,w0		; if in Ver/Rev mode, show CHS
    3172:	c0 4e 80    	mov.w     0x9d8, w0
	cp	w2,#15		; here are rows 14 and 15
    3174:	6f 10 e1    	cp.w      w2, #0xf
	ifz
    3176:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS2,w0		; if in Ver/Rev mode, show CHS
    3178:	d0 4e 80    	mov.w     0x9da, w0
	bra	skr_15		; if no buttons pressed yet, show Ver/Rev
    317a:	09 00 37    	bra       0x318e <skr_15>

0000317c <L310>:
3:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    317c:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	2f		; clear matrix data
    317e:	06 00 37    	bra       0x318c <L29>
; ALT pressed in ALU mode, anodes 7-15 show Files occupancy
	sl	RowScan,WREG
    3180:	78 09 d4    	sl.w      0x978, WREG
	and	#0x0F,w0
    3182:	f0 00 b2    	and.w     #0xf, w0
	mov	#Files,w1
    3184:	61 96 20    	mov.w     #0x966, w1
	mov	[w0+w1],w0
    3186:	60 80 78    	mov.w     [w0+w1], w0

00003188 <L132>:
1:
	cp	w2,#3		; if Mode = 3 (Run)...
    3188:	63 10 e1    	cp.w      w2, #0x3
	ifz
    318a:	42 20 af    	btsc.b    0x42, #0x1

0000318c <L29>:
2:
	mov	#0,w0		; ...then clear matrix data
    318c:	00 00 20    	mov.w     #0x0, w0

0000318e <skr_15>:
; end of blank matrix in mode 0 and mode 3
skr_15:
; Final matrix anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    318e:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3190:	dd 89 a9    	bclr.b    0x9dd, #0x4
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3192:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    3194:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    3196:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATC	; LED anodes 0...7 set
    3198:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    319a:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    319c:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    319e:	7b e6 b7    	mov.b     WREG, 0x67b
	bra	t1exit
    31a0:	09 00 37    	bra       0x31b4 <t1exit>

000031a2 <disp_w0>:
; ------------------------------------------------------
disp_w0:		; display service for cathodes 0...7
; Final LED anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    31a2:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    31a4:	dd 89 a9    	bclr.b    0x9dd, #0x4

000031a6 <disp_w0_noblank>:
disp_w0_noblank:
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    31a6:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    31a8:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    31aa:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATC	; LED anodes 0...7 set
    31ac:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    31ae:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    31b0:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    31b2:	7b e6 b7    	mov.b     WREG, 0x67b

000031b4 <t1exit>:
; ------------------------------------------------------
t1exit:
; final exit from interrupt
	pop.s			; /
    31b4:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    31b6:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    31b8:	00 40 06    	retfie    

000031ba <aux_int>:
; ------------------------------------------------------
aux_int:		; aux_int only turns off LEDs, for dimming
	bclr	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    31ba:	dd a9 a9    	bclr.b    0x9dd, #0x5
	clr	LATC		; all LEDS off (here's LATC,#8 also)
    31bc:	8e 26 ef    	clr.w     0x68e
	clr.b	LATB+1		; all LEDS off
    31be:	7b 66 ef    	clr.b     0x67b

	mov	PR1copy,w0	; w0 =  10,  22,  28,  38,  52...412, 470
    31c0:	10 4e 80    	mov.w     0x9c2, w0
	mov	#475,w2
    31c2:	b2 1d 20    	mov.w     #0x1db, w2
	sub	w2,w0,w0
    31c4:	00 00 51    	sub.w     w2, w0, w0
; mov #10,w0 ;(samo za snimanje 60 fps)
	mov	w0,PR1
    31c6:	90 0c 88    	mov.w     w0, 0x192

	pop.s			; /
    31c8:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    31ca:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    31cc:	00 40 06    	retfie    

000031ce <T3Int>:

;***********************************************************************************
;****************************       T3 INTERRUPT       *****************************
;****************************       USER'S SYNC        *****************************
;***********************************************************************************
T3Int:				; TIMER 3 int, user's sync
	bset.b	RdFlags,#0	; #0 user's SYNC
    31ce:	f4 08 a8    	bset.b    0x8f4, #0x0
	nop			; * * *   MCU BUG FIX  ???   * * *
    31d0:	00 00 00    	nop       
	bclr	IFS0,#8		; clr int flag (skips this line without NOP)
    31d2:	89 00 a9    	bclr.b    0x89, #0x0
	retfie
    31d4:	00 40 06    	retfie    

000031d6 <U1RXInt>:

;***********************************************************************************
;***********************              RX1 INTERRUPT           **********************
;***********************************************************************************

; Character is received in U1RXREG
; read char and clear UART RX flag UXRDA
; if SerH:L is free, put it there and increment Received; finished
; if there is no room in FIFO, ignore all and exit (character is lost)
; else, put it at the end of FIFO (@WRPtr), inc WRPtr, calc Received

U1RXInt:			; RX1 interrupt
	push.s		   ; \
    31d6:	00 a0 fe    	push.s    
	mov	U1RXREG,w1	; <---- get received byte (this resets U1STAL,#URXDA)
    31d8:	f1 1c 80    	mov.w     0x39e, w1
	btsc	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    31da:	de 49 af    	btsc.b    0x9de, #0x2
	bra	move2fifo
    31dc:	0a 00 37    	bra       0x31f2 <move2fifo>
; move char to SerH:L
	lsr	w1,#4,w0
    31de:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    31e0:	f7 e8 b7    	mov.b     WREG, 0x8f7
	and	w1,#0x0F,w0
    31e2:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    31e4:	f6 e8 b7    	mov.b     WREG, 0x8f6
	mov	#1,w0
    31e6:	10 00 20    	mov.w     #0x1, w0
	mov.b	WREG,Received
    31e8:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    31ea:	de 49 a8    	bset.b    0x9de, #0x2
	bclr	IFS0,#11	; clr int flag
    31ec:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    31ee:	00 80 fe    	pop.s     
	retfie
    31f0:	00 40 06    	retfie    

000031f2 <move2fifo>:
move2fifo:		; move char to fifo
	mov	RXWR,w2
    31f2:	e2 4d 80    	mov.w     0x9bc, w2
	inc.b	w2,w0		; pre-inc RXWR (in byte mode, to wrap inside RX buffer)
    31f4:	02 40 e8    	inc.b     w2, w0
	cp.b	RXRD
    31f6:	be 49 e3    	cp.b      0x9be
	bra	nz,fifo_room	; if there's free place in FIFO, continue, else...
    31f8:	02 00 3a    	bra       NZ, 0x31fe <fifo_room>
	bset.b	SerCtrl,#3	; ...set error flag...
    31fa:	f5 68 a8    	bset.b    0x8f5, #0x3
	bra	nochar		; ...and quit
    31fc:	0b 00 37    	bra       0x3214 <nochar>

000031fe <fifo_room>:
fifo_room:
	mov.b	w1,[w2]		; put char to FIFO
    31fe:	01 49 78    	mov.b     w1, [w2]
	inc.b	RXWR		; inc write ptr (in byte mode, to wrap inside RX byffer)
    3200:	bc 69 ec    	inc.b     0x9bc
; Calculate Received
	mov	RXRD,WREG
    3202:	be 89 bf    	mov.w     0x9be, WREG
	sub	RXWR,WREG	; RXWR-RXRD (byte mode, to stay in range 0000-00FF)
    3204:	bc 09 b5    	sub.w     0x9bc, WREG
	ze	w0,w0
    3206:	00 80 fb    	ze        w0, w0
	inc	w0,w0		; as SerH:L is surely full
    3208:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    320a:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    320c:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    320e:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    3210:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    3212:	de 49 a8    	bset.b    0x9de, #0x2

00003214 <nochar>:
nochar:
	bclr	IFS0,#11	; clr int flag
    3214:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    3216:	00 80 fe    	pop.s     
	retfie
    3218:	00 40 06    	retfie    

0000321a <U1ErrInt>:

;***********************************************************************************
;***********************          RX1 ERROR INTERRUPT       **********************
;***********************************************************************************
U1ErrInt:			; U1EIE interrupt
	bclr	U1STA,#1	; clr err flag
    321a:	9a 23 a9    	bclr.b    0x39a, #0x1
	bclr	U1STA,#2	; clr err flag
    321c:	9a 43 a9    	bclr.b    0x39a, #0x2
	bclr	IFS4,#1
    321e:	90 20 a9    	bclr.b    0x90, #0x1
	retfie
    3220:	00 40 06    	retfie    

00003222 <U2RXInt>:

;***********************************************************************************
;***********************      CURREENTLY UNUSED INTERRUPTS     **********************
;***********************************************************************************
U2RXInt:			; RX2 interrupt
	bclr	IFS1,#14	; clr int flag
    3222:	8b c0 a9    	bclr.b    0x8b, #0x6
	retfie
    3224:	00 40 06    	retfie    

00003226 <INT2Int>:
;		
INT2Int:			; external INT2 interrupt
	bclr	IFS1,#13	; clr int flag
    3226:	8b a0 a9    	bclr.b    0x8b, #0x5
	retfie			; ---------->
    3228:	00 40 06    	retfie    

0000322a <U2ErrInt>:
;		
U2ErrInt:			; U2EIE interrupt
	bclr	U2STA,#1	; clr err flag
    322a:	b0 23 a9    	bclr.b    0x3b0, #0x1
	bclr	U2STA,#2	; clr err flag
    322c:	b0 43 a9    	bclr.b    0x3b0, #0x2
	bclr	IFS4,#2
    322e:	90 40 a9    	bclr.b    0x90, #0x2
	retfie
    3230:	00 40 06    	retfie    

00003232 <INT1Int>:

;***********************************************************************************
;***********************         EXTERNAL INT 1 SERVICE       **********************
;***********************************************************************************
INT1Int:		; ON/OFF button interrupt (shouldn't come here as INTCON2,#GIE ...
			; ...and IEC1,#4 are never ON at the same time, but just in case)
	bclr	IFS1,#4
    3232:	8a 80 a9    	bclr.b    0x8a, #0x4
	retfie
    3234:	00 40 06    	retfie    

00003236 <enter_sleep>:

;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZ                S L E E P               ZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

enter_sleep:		; set ports to lowest current consumption
			; be ready to wake up on EXT INT1 and enter sleep mode
			; After wake up, wait for button safely released and dim up
; peripheral and interrupt control bits
	bclr	INTCON2,#GIE	; global int disable
    3236:	83 e0 a9    	bclr.b    0x83, #0x7
	bclr	T1CON,#TON	; LED multiplex timer off
    3238:	95 e1 a9    	bclr.b    0x195, #0x7
	bclr	T2CON,#TON	; T2 timer off
    323a:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	bclr	T3CON,#TON	; T3 timer off
    323c:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	bclr	IEC0,#T1IE	; disable Timer 1 interrupt
    323e:	98 60 a9    	bclr.b    0x98, #0x3
	bclr	IEC0,#7		; disable Timer 2 interrupt
    3240:	98 e0 a9    	bclr.b    0x98, #0x7
	bclr	IEC0,#8		; disable Timer 3 interrupt
    3242:	99 00 a9    	bclr.b    0x99, #0x0
	bclr	IEC1,#4		; disable external interrupt
    3244:	9a 80 a9    	bclr.b    0x9a, #0x4
; LEDs off, I/O pins hi-z
	clr.b	LATB+1		; all LEDs off
    3246:	7b 66 ef    	clr.b     0x67b
	clr	LATC		; all LEDs off
    3248:	8e 26 ef    	clr.w     0x68e
	setm.b	TRISB+0		; connector ports hi-z
    324a:	76 e6 ef    	setm.b    0x676
	bset	TRISA,#1	; Tx on SAO also hi-z
    324c:	62 26 a8    	bset.b    0x662, #0x1
; wait for ON-OFF safely released and final wake initialization
	call	test_no_press	; wait for ON-OFF safely released
    324e:	8a 32 02    	call      0x328a <test_no_press>
    3250:	00 00 00 
	bclr	IFS1,#4		; clear interrupt flag to avoid self-triggering
    3252:	8a 80 a9    	bclr.b    0x8a, #0x4
	bset	INTCON2,#INT1EP	; interrupt on negative-going edge
    3254:	82 20 a8    	bset.b    0x82, #0x1
	bset	IEC1,#4		; enable external interrupt
    3256:	9a 80 a8    	bset.b    0x9a, #0x4
; SLEEP NOW    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	pwrsav	#0		; *  *   SLEEP   *  *  *  *  *  *  *  *  *  *  *  *  *
    3258:	00 40 fe    	pwrsav    #0x0
; GOOD MORNING    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	mov	#2,w0		; ×10 min autooff at wake-up
    325a:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
    325c:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
    325e:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    3260:	b0 4d 88    	mov.w     w0, 0x9b6
; restore I/O pins
	mov	#0xF0,w0	; bits 7654 = inputs, bits 3210 = outputs
    3262:	00 0f 20    	mov.w     #0xf0, w0
	mov.b	WREG,TRISB+0	; restore states of connector ports
    3264:	76 e6 b7    	mov.b     WREG, 0x676
	bclr	TRISA,#1	; Tx on SAO = output
    3266:	62 26 a9    	bclr.b    0x662, #0x1
	btsc.b	WrFlags,#0	; if UART is redirected to I/O connector, then... 
    3268:	f3 08 af    	btsc.b    0x8f3, #0x0
	bclr	TRISB,#7	; ...Tx on I/O connector = output
    326a:	76 e6 a9    	bclr.b    0x676, #0x7
; restore peripheral and interrupt control bits
	bclr	IEC1,#4		; disable external interrupt
    326c:	9a 80 a9    	bclr.b    0x9a, #0x4
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    326e:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    3270:	99 00 a8    	bset.b    0x99, #0x0
	bset	T1CON,#TON	; LED multiplex timer on
    3272:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON	; T2 timer on
    3274:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON	; T3 timer on
    3276:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	INTCON2,#GIE	; global int enable
    3278:	83 e0 a8    	bset.b    0x83, #0x7
; initialize key rotors and dim up
	mov	#KeyRotors,w1
    327a:	e1 97 20    	mov.w     #0x97e, w1
	push	RCOUNT		; \
    327c:	36 00 f8    	push      0x36
	repeat	#19-1
    327e:	12 00 09    	repeat    #0x12
	clr	[w1++]		; clear key debouncer rotors to ignore pre-pressed keys
    3280:	80 18 eb    	clr.w     [w1++]
	pop	RCOUNT		; /
    3282:	36 00 f9    	pop       0x36
	bset	Flag,#15	; dim up MAIN REQUEST
    3284:	dd e9 a8    	bset.b    0x9dd, #0x7
	goto	t1exit
    3286:	b4 31 04    	goto      0x31b4 <t1exit>
    3288:	00 00 00 

0000328a <test_no_press>:
; wait for ON-OFF safely released (90 ms debouncer)
test_no_press:
	mov	#900,w0		; w0 × 0.1 ms verify period
    328a:	40 38 20    	mov.w     #0x384, w0

0000328c <L133>:
1:
	push	RCOUNT		; \
    328c:	36 00 f8    	push      0x36
	repeat	#1600-9
    328e:	37 06 09    	repeat    #0x637
	nop
    3290:	00 00 00    	nop       
	pop	RCOUNT		; /
    3292:	36 00 f9    	pop       0x36
	btss	PORTC,#9	; skip if ON-OFF key high
    3294:	8d 26 ae    	btss.b    0x68d, #0x1
	bra	test_no_press	; it's low, re-initialize the counter from the start
    3296:	f9 ff 37    	bra       0x328a <test_no_press>
	dec	w0,w0
    3298:	00 00 e9    	dec.w     w0, w0
	bra	nz,1b		; 1 loop = 1600 t = 0.1 ms
    329a:	f8 ff 3a    	bra       NZ, 0x328c <L133>
	return
    329c:	00 00 06    	return    

0000329e <clk_table>:
    329e:	09 00 00    	nop       
    32a0:	00 00 00    	nop       
    32a2:	4f 00 00    	nop       
    32a4:	00 00 00    	nop       
    32a6:	0a 01 00    	nop       
    32a8:	00 00 00    	nop       
    32aa:	1f 03 00    	nop       
    32ac:	00 00 00    	nop       
    32ae:	6a 0a 00    	nop       
    32b0:	00 00 00    	nop       
    32b2:	3f 1f 00    	nop       
    32b4:	00 00 00    	nop       
    32b6:	7f 3e 00    	nop       
    32b8:	00 00 00    	nop       
    32ba:	3f 9c 00    	nop       
    32bc:	00 00 00    	nop       
    32be:	0f 27 00    	nop       
    32c0:	10 00 00    	nop       
    32c2:	1f 4e 00    	nop       
    32c4:	10 00 00    	nop       
    32c6:	69 18 00    	nop       
    32c8:	20 00 00    	nop       
    32ca:	d3 30 00    	nop       
    32cc:	20 00 00    	nop       
    32ce:	a7 61 00    	nop       
    32d0:	20 00 00    	nop       
    32d2:	08 3d 00    	nop       
    32d4:	30 00 00    	nop       
    32d6:	11 7a 00    	nop       
    32d8:	30 00 00    	nop       
    32da:	23 f4 00    	nop       
    32dc:	30 00 00    	nop       

000032de <clk_table_high>:
    32de:	09 00 00    	nop       
    32e0:	00 00 00    	nop       
    32e2:	09 00 00    	nop       
    32e4:	00 00 00    	nop       
    32e6:	09 00 00    	nop       
    32e8:	00 00 00    	nop       
    32ea:	4f 00 00    	nop       
    32ec:	00 00 00    	nop       
    32ee:	09 01 00    	nop       
    32f0:	00 00 00    	nop       
    32f2:	1f 03 00    	nop       
    32f4:	00 00 00    	nop       
    32f6:	3f 06 00    	nop       
    32f8:	00 00 00    	nop       
    32fa:	9f 0f 00    	nop       
    32fc:	00 00 00    	nop       
    32fe:	3f 1f 00    	nop       
    3300:	00 00 00    	nop       
    3302:	7f 3e 00    	nop       
    3304:	00 00 00    	nop       
    3306:	3f 9c 00    	nop       
    3308:	00 00 00    	nop       
    330a:	0f 27 00    	nop       
    330c:	10 00 00    	nop       
    330e:	1f 4e 00    	nop       
    3310:	10 00 00    	nop       
    3312:	69 18 00    	nop       
    3314:	20 00 00    	nop       
    3316:	d3 30 00    	nop       
    3318:	20 00 00    	nop       
    331a:	a7 61 00    	nop       
    331c:	20 00 00    	nop       

0000331e <sync_table>:
    331e:	7f 3e 00    	nop       
    3320:	00 00 00    	nop       
    3322:	2a 68 00    	nop       
    3324:	00 00 00    	nop       
    3326:	3f 9c 00    	nop       
    3328:	00 00 00    	nop       
    332a:	ff f9 00    	nop       
    332c:	00 00 00    	nop       
    332e:	14 34 00    	nop       
    3330:	10 00 00    	nop       
    3332:	1f 4e 00    	nop       
    3334:	10 00 00    	nop       
    3336:	34 82 00    	nop       
    3338:	10 00 00    	nop       
    333a:	4f c3 00    	nop       
    333c:	10 00 00    	nop       
    333e:	0f 27 00    	nop       
    3340:	20 00 00    	nop       
    3342:	1a 41 00    	nop       
    3344:	20 00 00    	nop       
    3346:	a7 61 00    	nop       
    3348:	20 00 00    	nop       
    334a:	c2 a2 00    	nop       
    334c:	20 00 00    	nop       
    334e:	23 f4 00    	nop       
    3350:	20 00 00    	nop       
    3352:	a7 61 00    	nop       
    3354:	30 00 00    	nop       
    3356:	c2 a2 00    	nop       
    3358:	30 00 00    	nop       
    335a:	23 f4 00    	nop       
    335c:	30 00 00    	nop       

0000335e <sync_table_high>:
    335e:	3f 06 00    	nop       
    3360:	00 00 00    	nop       
    3362:	6a 0a 00    	nop       
    3364:	00 00 00    	nop       
    3366:	9f 0f 00    	nop       
    3368:	00 00 00    	nop       
    336a:	ff 18 00    	nop       
    336c:	00 00 00    	nop       
    336e:	34 05 00    	nop       
    3370:	10 00 00    	nop       
    3372:	cf 07 00    	nop       
    3374:	10 00 00    	nop       
    3376:	04 0d 00    	nop       
    3378:	10 00 00    	nop       
    337a:	87 13 00    	nop       
    337c:	10 00 00    	nop       
    337e:	e7 03 00    	nop       
    3380:	20 00 00    	nop       
    3382:	82 06 00    	nop       
    3384:	20 00 00    	nop       
    3386:	c3 09 00    	nop       
    3388:	20 00 00    	nop       
    338a:	46 10 00    	nop       
    338c:	20 00 00    	nop       
    338e:	69 18 00    	nop       
    3390:	20 00 00    	nop       
    3392:	c3 09 00    	nop       
    3394:	30 00 00    	nop       
    3396:	46 10 00    	nop       
    3398:	30 00 00    	nop       
    339a:	69 18 00    	nop       
    339c:	30 00 00    	nop       

0000339e <ss_history>:
; .equ	History,0x0B00	; FIFO buffer, space: 128 × 42 by = 5376 by = 0x1500 by		
;											

ss_history:
	cp0	Insert_Count_0		; if no history inserts...
    339e:	20 09 e2    	cp0.w     0x920
	bra	z,ss_farm		; ...then ignore and return
    33a0:	1d f2 32    	bra       Z, 0x17dc <ss_farm>
	bset	BlinkFlag,#3		; #3 set: LED SS blinks
    33a2:	e0 69 a8    	bset.b    0x9e0, #0x3
	bset	Flag,#5			; #5 set: in HISTORY mode
    33a4:	dc a9 a8    	bset.b    0x9dc, #0x5

000033a6 <history_pos_1>:
history_pos_1:
	mov	#1,w0
    33a6:	10 00 20    	mov.w     #0x1, w0
	mov	w0,History_Ptr
    33a8:	f0 48 88    	mov.w     w0, 0x91e

000033aa <history_farm>:
history_farm:
	cp0	History_Ptr
    33aa:	1e 09 e2    	cp0.w     0x91e
	bra	z,history_exit
    33ac:	24 00 32    	bra       Z, 0x33f6 <history_exit>
	call	unpack_ptr		; unpack from History buffer, pos History_Ptr
    33ae:	90 34 02    	call      0x3490 <unpack_ptr>
    33b0:	00 00 00 

000033b2 <wait_key_hist>:
wait_key_hist:				; <---------------
	btss	Flag,#1
    33b2:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	wait_key_hist
    33b4:	fe ff 37    	bra       0x33b2 <wait_key_hist>
	bclr	Flag,#1
    33b6:	dc 29 a9    	bclr.b    0x9dc, #0x1

	mov	Just,w4
    33b8:	34 4d 80    	mov.w     0x9a6, w4
	cp	w4,#1
    33ba:	61 20 e1    	cp.w      w4, #0x1
	bra	z,history_pos_1		; key History again: go pos 1  ---------------->
    33bc:	f4 ff 32    	bra       Z, 0x33a6 <history_pos_1>
	cp	w4,#2
    33be:	62 20 e1    	cp.w      w4, #0x2
	bra	nz,not_hist_minus
    33c0:	0d 00 3a    	bra       NZ, 0x33dc <not_hist_minus>
;  - ADDR 				
	  inc	  History_Ptr		  ; ++
    33c2:	1e 29 ec    	inc.w     0x91e
	  mov	  History_Ptr,w0
    33c4:	f0 48 80    	mov.w     0x91e, w0
	  mov	  Insert_Count_0,w2	  ; count of 24by packets inserted in History buffer from reset
    33c6:	02 49 80    	mov.w     0x920, w2
	  inc	  w2,w2
    33c8:	02 01 e8    	inc.w     w2, w2

	  cp	  w0,w2
    33ca:	02 00 e1    	cp.w      w0, w2
	  bra	  nc,1f			  ; if [History_Ptr] >= [Insert_Count_0] then...
    33cc:	04 00 39    	bra       NC, 0x33d6 <L134>
	  dec	  History_Ptr		  ; ...clip [history ptr] to [Insert_Count_0] max
    33ce:	1e 29 ed    	dec.w     0x91e
	  bset	  History_A16,#b_load	  ; ...and also LED ADDR+ ON
    33d0:	0d c9 a8    	bset.b    0x90d, #0x6

000033d2 <L210>:
2:
	  btss	  KeyRotors+6,#0
    33d2:	84 09 ae    	btss.b    0x984, #0x0
	  bra	  2b			  ; loop and wait for key released
    33d4:	fe ff 37    	bra       0x33d2 <L210>

000033d6 <L134>:
1:
	  call	  unpack_ptr		  ; UNPACK
    33d6:	90 34 02    	call      0x3490 <unpack_ptr>
    33d8:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    33da:	e7 ff 37    	bra       0x33aa <history_farm>

000033dc <not_hist_minus>:
not_hist_minus:
	cp	w4,#3
    33dc:	63 20 e1    	cp.w      w4, #0x3
	bra	nz,not_hist_plus
    33de:	09 00 3a    	bra       NZ, 0x33f2 <not_hist_plus>
;  ADDR	+			
	  dec	  History_Ptr		  ; --
    33e0:	1e 29 ed    	dec.w     0x91e
	  bra	  nz,1f			  ; if [History_Ptr] = 0 then...
    33e2:	04 00 3a    	bra       NZ, 0x33ec <L135>
	  inc	  History_Ptr		  ; ...restore to 1, as history ptr can't reach 0
    33e4:	1e 29 ec    	inc.w     0x91e
	  bset	  History_A16,#b_save	  ; ...and also LED ADDR- ON
    33e6:	0d a9 a8    	bset.b    0x90d, #0x5

000033e8 <L211>:
2:
	  btss	  KeyRotors+4,#0
    33e8:	82 09 ae    	btss.b    0x982, #0x0
	  bra	  2b			  ; loop and wait for key released
    33ea:	fe ff 37    	bra       0x33e8 <L211>

000033ec <L135>:
1:
	  call	  unpack_ptr		  ; UNPACK
    33ec:	90 34 02    	call      0x3490 <unpack_ptr>
    33ee:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    33f0:	dc ff 37    	bra       0x33aa <history_farm>

000033f2 <not_hist_plus>:
not_hist_plus:
	cp	w4,#4
    33f2:	64 20 e1    	cp.w      w4, #0x4
	bra	nz,wait_key_hist	; no valid key hit, loop  ---------------->
    33f4:	de ff 3a    	bra       NZ, 0x33b2 <wait_key_hist>

000033f6 <history_exit>:
history_exit:
	clr	History_Ptr
    33f6:	1e 29 ef    	clr.w     0x91e
	bra	ss_farm
    33f8:	f1 f1 37    	bra       0x17dc <ss_farm>

000033fa <insert>:

; -----------------------------------------------------------------------------------
; -----------------------------------------------------------------------------------

; --------------------------------------------------  PACK
; shift buffer up, pack and insert new 21 by (DO NOT USE w5...w15)
insert:			; insert Ram current, Ram page 0 and variables to start of History
; shift FIFO up, to make room for one packet (21 by)
	mov	#History+0x14FE-42,w1
    33fa:	41 fd 21    	mov.w     #0x1fd4, w1
	mov	#History+0x14FE,w2
    33fc:	e2 ff 21    	mov.w     #0x1ffe, w2
	repeat	#2667-1		; 127 × 42 = 5334 bytes = 2667 words to move
    33fe:	6a 0a 09    	repeat    #0xa6a
	mov	[w1--],[w2--]	; shift history buffer up
    3400:	21 11 78    	mov.w     [w1--], [w2--]
	inc	Insert_Count_0
    3402:	20 29 ec    	inc.w     0x920
	btsc	Insert_Count_0,#7
    3404:	20 e9 af    	btsc.b    0x920, #0x7
	dec	Insert_Count_0
    3406:	20 29 ed    	dec.w     0x920

00003408 <pack>:
; pack proc variables and visible Ram to start of history buffer 22 bytes
pack:			; pack Ram current, Ram page 0 and variables to start of History
	mov	#History,w3	; w3 = history buffer physical address
    3408:	03 b0 20    	mov.w     #0xb00, w3
; --------------------------------------- 0...15 ----- STEP 1: page 0
	mov	#Ram+1,w2
    340a:	12 80 20    	mov.w     #0x801, w2
	add	w2,#16,w1
    340c:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    340e:	84 00 20    	mov.w     #0x8, w4

00003410 <pack_loop_1>:
pack_loop_1:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    3410:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    3412:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    3414:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    3416:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    3418:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    341a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    341c:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    341e:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    3420:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    3422:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    3424:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_1	; loop
    3426:	f4 ff 3a    	bra       NZ, 0x3410 <pack_loop_1>
; -------------------------------------- 16...31 ----- STEP 2: current page
	mov	#Ram+1,w2
    3428:	12 80 20    	mov.w     #0x801, w2
	mov.b	Page,WREG
    342a:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    342c:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; ×16
    342e:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w2,w0,w2
    3430:	00 01 41    	add.w     w2, w0, w2
	add	w2,#16,w1
    3432:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    3434:	84 00 20    	mov.w     #0x8, w4
; if Page>15 then wrap to 0
	mov.b	Page,WREG
    3436:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    3438:	00 80 fb    	ze        w0, w0
	cp	w0,#15
    343a:	6f 00 e1    	cp.w      w0, #0xf
	ifz
    343c:	42 20 af    	btsc.b    0x42, #0x1
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    343e:	01 10 b1    	sub.w     #0x100, w1

00003440 <pack_loop_2>:
pack_loop_2:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    3440:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    3442:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    3444:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    3446:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    3448:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    344a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    344c:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    344e:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    3450:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    3452:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    3454:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_2	; loop
    3456:	f4 ff 3a    	bra       NZ, 0x3440 <pack_loop_2>
; -------------------------------------- 32...35 ----- STEP 3: A16 and w9 (no pack)
	mov	A16,w0
    3458:	70 4d 80    	mov.w     0x9ae, w0
	mov	w0,[w3++]	; store
    345a:	80 19 78    	mov.w     w0, [w3++]
	mov	w9,[w3++]	; store
    345c:	89 19 78    	mov.w     w9, [w3++]
; ---------------------------------------- 36,37 ----- STEP 4: w11, w12, w13, w14
	mov	w11,w0
    345e:	0b 00 78    	mov.w     w11, w0
	sl	w0,#4,w0
    3460:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w12,w0
    3462:	0c 40 70    	ior.b     w0, w12, w0
	sl	w0,#4,w0
    3464:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w13,w0
    3466:	0d 40 70    	ior.b     w0, w13, w0
	sl	w0,#4,w0
    3468:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w14,w0
    346a:	0e 40 70    	ior.b     w0, w14, w0
	mov	w0,[w3++]	; store
    346c:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 38,39 ----- STEP 5: Atemp,Page,Sync,Speed
	mov	Atemp,w0
    346e:	40 49 80    	mov.w     0x928, w0
	sl	w0,#4,w0
    3470:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG
    3472:	f0 48 b7    	ior.b     0x8f0, WREG
	sl	w0,#4,w0
    3474:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Sync,WREG
    3476:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0
    3478:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG
    347a:	f1 48 b7    	ior.b     0x8f1, WREG
	mov	w0,[w3++]	; store
    347c:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 40,41 ----- STEP 6: V/Z/Cflag, Stack
	mov	Vflag,w0
    347e:	80 49 80    	mov.w     0x930, w0
	sl	w0,#3,w0
    3480:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Zflag,WREG
    3482:	2e 49 b7    	ior.b     0x92e, WREG
	sl	w0,#3,w0
    3484:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Cflag,WREG
    3486:	2c 49 b7    	ior.b     0x92c, WREG
	sl	w0,#3,w0
    3488:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Stack,WREG
    348a:	2a 49 b7    	ior.b     0x92a, WREG
	mov	w0,[w3++]	; store
    348c:	80 19 78    	mov.w     w0, [w3++]
; ----------------------------------------------------
	return
    348e:	00 00 06    	return    

00003490 <unpack_ptr>:
; ----------------------------------------------------  UNPACK
; unpack from History_Ptr
unpack_ptr:		; unpack using History_Ptr as input
	dec	History_Ptr,WREG
    3490:	1e 09 ed    	dec.w     0x91e, WREG
	mov	#42,w1
    3492:	a1 02 20    	mov.w     #0x2a, w1
	mul.uu	w0,w1,w0	; w0 × 42 ---> w0:w1
    3494:	01 00 b8    	mul.uu    w0, w1, w0
	mov	#History,w1
    3496:	01 b0 20    	mov.w     #0xb00, w1
	add	w0,w1,w2	; w2 = #History + 42 × (History_Ptr-1)
    3498:	01 01 40    	add.w     w0, w1, w2

0000349a <unpack>:
; unpack from history buffer [w2] 42 bytes to proc variables (Ram ---> History_Visible)
unpack:			; unpack using w2 as pointer
	mov	w2,History_Visible
    349a:	02 48 88    	mov.w     w2, 0x900
	add	#32,w2		; skip History Ram, only pointer was needed
    349c:	02 02 b0    	add.w     #0x20, w2
	mov	[w2++],w0	; Packet start + 32
    349e:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_A16
    34a0:	60 48 88    	mov.w     w0, 0x90c
	mov	[w2++],w0	; Packet start + 34
    34a2:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_w9
    34a4:	10 48 88    	mov.w     w0, 0x902
	mov	[w2++],w0	; Packet start + 36
    34a6:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    34a8:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_w14
    34aa:	51 48 88    	mov.w     w1, 0x90a
	lsr	w0,#4,w1
    34ac:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    34ae:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w13
    34b0:	41 48 88    	mov.w     w1, 0x908
	lsr	w0,#8,w1
    34b2:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    34b4:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w12
    34b6:	31 48 88    	mov.w     w1, 0x906
	lsr	w0,#12,w1
    34b8:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    34ba:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w11
    34bc:	21 48 88    	mov.w     w1, 0x904
	mov	[w2++],w0	; Packet start + 38
    34be:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    34c0:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_Speed
    34c2:	a1 48 88    	mov.w     w1, 0x914
	lsr	w0,#4,w1
    34c4:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    34c6:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Sync
    34c8:	91 48 88    	mov.w     w1, 0x912
	lsr	w0,#8,w1
    34ca:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    34cc:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Page
    34ce:	81 48 88    	mov.w     w1, 0x910
	lsr	w0,#12,w1
    34d0:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    34d2:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Atemp
    34d4:	71 48 88    	mov.w     w1, 0x90e
	mov	[w2++],w0	; Packet start + 40
    34d6:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x07,w1
    34d8:	e7 00 60    	and.w     w0, #0x7, w1
	mov	w1,History_Stack
    34da:	e1 48 88    	mov.w     w1, 0x91c
	lsr	w0,#3,w1
    34dc:	c3 00 de    	lsr.w     w0, #0x3, w1
	and	w1,#0x07,w1
    34de:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Cflag
    34e0:	d1 48 88    	mov.w     w1, 0x91a
	lsr	w0,#6,w1
    34e2:	c6 00 de    	lsr.w     w0, #0x6, w1
	and	w1,#0x07,w1
    34e4:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Zflag
    34e6:	c1 48 88    	mov.w     w1, 0x918
	lsr	w0,#9,w1
    34e8:	c9 00 de    	lsr.w     w0, #0x9, w1
	and	w1,#0x07,w1
    34ea:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Vflag
    34ec:	b1 48 88    	mov.w     w1, 0x916
	return
    34ee:	00 00 06    	return    

000034f0 <table_adder>:
    34f0:	00 02 00    	nop       
    34f2:	10 00 00    	nop       
    34f4:	10 00 00    	nop       
    34f6:	21 00 00    	nop       
    34f8:	20 00 00    	nop       
    34fa:	30 00 00    	nop       
    34fc:	30 00 00    	nop       
    34fe:	43 00 00    	nop       
    3500:	40 00 00    	nop       
    3502:	50 00 00    	nop       
    3504:	50 00 00    	nop       
    3506:	61 00 00    	nop       
    3508:	60 00 00    	nop       
    350a:	70 00 00    	nop       
    350c:	70 00 00    	nop       
    350e:	87 04 00    	nop       
    3510:	80 00 00    	nop       
    3512:	90 00 00    	nop       
    3514:	90 00 00    	nop       
    3516:	a1 00 00    	nop       
    3518:	a0 00 00    	nop       
    351a:	b0 00 00    	nop       
    351c:	b0 00 00    	nop       
    351e:	c3 00 00    	nop       
    3520:	c0 00 00    	nop       
    3522:	d0 00 00    	nop       
    3524:	d0 00 00    	nop       
    3526:	e1 00 00    	nop       
    3528:	e0 00 00    	nop       
    352a:	f0 00 00    	nop       
    352c:	f0 00 00    	nop       
    352e:	0f 03 00    	nop       
    3530:	10 00 00    	nop       
    3532:	21 00 00    	nop       
    3534:	21 00 00    	nop       
    3536:	31 00 00    	nop       
    3538:	30 00 00    	nop       
    353a:	43 00 00    	nop       
    353c:	43 00 00    	nop       
    353e:	53 00 00    	nop       
    3540:	50 00 00    	nop       
    3542:	61 00 00    	nop       
    3544:	61 00 00    	nop       
    3546:	71 00 00    	nop       
    3548:	70 00 00    	nop       
    354a:	87 04 00    	nop       
    354c:	87 04 00    	nop       
    354e:	97 04 00    	nop       
    3550:	90 00 00    	nop       
    3552:	a1 00 00    	nop       
    3554:	a1 00 00    	nop       
    3556:	b1 00 00    	nop       
    3558:	b0 00 00    	nop       
    355a:	c3 00 00    	nop       
    355c:	c3 00 00    	nop       
    355e:	d3 00 00    	nop       
    3560:	d0 00 00    	nop       
    3562:	e1 00 00    	nop       
    3564:	e1 00 00    	nop       
    3566:	f1 00 00    	nop       
    3568:	f0 00 00    	nop       
    356a:	0f 03 00    	nop       
    356c:	0f 03 00    	nop       
    356e:	1f 01 00    	nop       
    3570:	20 00 00    	nop       
    3572:	30 00 00    	nop       
    3574:	30 00 00    	nop       
    3576:	43 00 00    	nop       
    3578:	42 00 00    	nop       
    357a:	52 00 00    	nop       
    357c:	52 00 00    	nop       
    357e:	63 00 00    	nop       
    3580:	60 00 00    	nop       
    3582:	70 00 00    	nop       
    3584:	70 00 00    	nop       
    3586:	87 04 00    	nop       
    3588:	86 04 00    	nop       
    358a:	96 04 00    	nop       
    358c:	96 04 00    	nop       
    358e:	a7 04 00    	nop       
    3590:	a0 00 00    	nop       
    3592:	b0 00 00    	nop       
    3594:	b0 00 00    	nop       
    3596:	c3 00 00    	nop       
    3598:	c2 00 00    	nop       
    359a:	d2 00 00    	nop       
    359c:	d2 00 00    	nop       
    359e:	e3 00 00    	nop       
    35a0:	e0 00 00    	nop       
    35a2:	f0 00 00    	nop       
    35a4:	f0 00 00    	nop       
    35a6:	0f 03 00    	nop       
    35a8:	0e 03 00    	nop       
    35aa:	1e 01 00    	nop       
    35ac:	1e 01 00    	nop       
    35ae:	2f 01 00    	nop       
    35b0:	30 00 00    	nop       
    35b2:	43 00 00    	nop       
    35b4:	43 00 00    	nop       
    35b6:	53 00 00    	nop       
    35b8:	52 00 00    	nop       
    35ba:	63 00 00    	nop       
    35bc:	63 00 00    	nop       
    35be:	73 00 00    	nop       
    35c0:	70 00 00    	nop       
    35c2:	87 04 00    	nop       
    35c4:	87 04 00    	nop       
    35c6:	97 04 00    	nop       
    35c8:	96 04 00    	nop       
    35ca:	a7 04 00    	nop       
    35cc:	a7 04 00    	nop       
    35ce:	b7 04 00    	nop       
    35d0:	b0 00 00    	nop       
    35d2:	c3 00 00    	nop       
    35d4:	c3 00 00    	nop       
    35d6:	d3 00 00    	nop       
    35d8:	d2 00 00    	nop       
    35da:	e3 00 00    	nop       
    35dc:	e3 00 00    	nop       
    35de:	f3 00 00    	nop       
    35e0:	f0 00 00    	nop       
    35e2:	0f 03 00    	nop       
    35e4:	0f 03 00    	nop       
    35e6:	1f 01 00    	nop       
    35e8:	1e 01 00    	nop       
    35ea:	2f 01 00    	nop       
    35ec:	2f 01 00    	nop       
    35ee:	3f 01 00    	nop       
    35f0:	40 00 00    	nop       
    35f2:	50 00 00    	nop       
    35f4:	50 00 00    	nop       
    35f6:	61 00 00    	nop       
    35f8:	60 00 00    	nop       
    35fa:	70 00 00    	nop       
    35fc:	70 00 00    	nop       
    35fe:	87 04 00    	nop       
    3600:	84 04 00    	nop       
    3602:	94 04 00    	nop       
    3604:	94 04 00    	nop       
    3606:	a5 04 00    	nop       
    3608:	a4 04 00    	nop       
    360a:	b4 04 00    	nop       
    360c:	b4 04 00    	nop       
    360e:	c7 04 00    	nop       
    3610:	c0 00 00    	nop       
    3612:	d0 00 00    	nop       
    3614:	d0 00 00    	nop       
    3616:	e1 00 00    	nop       
    3618:	e0 00 00    	nop       
    361a:	f0 00 00    	nop       
    361c:	f0 00 00    	nop       
    361e:	0f 03 00    	nop       
    3620:	0c 03 00    	nop       
    3622:	1c 01 00    	nop       
    3624:	1c 01 00    	nop       
    3626:	2d 01 00    	nop       
    3628:	2c 01 00    	nop       
    362a:	3c 01 00    	nop       
    362c:	3c 01 00    	nop       
    362e:	4f 01 00    	nop       
    3630:	50 00 00    	nop       
    3632:	61 00 00    	nop       
    3634:	61 00 00    	nop       
    3636:	71 00 00    	nop       
    3638:	70 00 00    	nop       
    363a:	87 04 00    	nop       
    363c:	87 04 00    	nop       
    363e:	97 04 00    	nop       
    3640:	94 04 00    	nop       
    3642:	a5 04 00    	nop       
    3644:	a5 04 00    	nop       
    3646:	b5 04 00    	nop       
    3648:	b4 04 00    	nop       
    364a:	c7 04 00    	nop       
    364c:	c7 04 00    	nop       
    364e:	d7 04 00    	nop       
    3650:	d0 00 00    	nop       
    3652:	e1 00 00    	nop       
    3654:	e1 00 00    	nop       
    3656:	f1 00 00    	nop       
    3658:	f0 00 00    	nop       
    365a:	0f 03 00    	nop       
    365c:	0f 03 00    	nop       
    365e:	1f 01 00    	nop       
    3660:	1c 01 00    	nop       
    3662:	2d 01 00    	nop       
    3664:	2d 01 00    	nop       
    3666:	3d 01 00    	nop       
    3668:	3c 01 00    	nop       
    366a:	4f 01 00    	nop       
    366c:	4f 01 00    	nop       
    366e:	5f 01 00    	nop       
    3670:	60 00 00    	nop       
    3672:	70 00 00    	nop       
    3674:	70 00 00    	nop       
    3676:	87 04 00    	nop       
    3678:	86 04 00    	nop       
    367a:	96 04 00    	nop       
    367c:	96 04 00    	nop       
    367e:	a7 04 00    	nop       
    3680:	a4 04 00    	nop       
    3682:	b4 04 00    	nop       
    3684:	b4 04 00    	nop       
    3686:	c7 04 00    	nop       
    3688:	c6 04 00    	nop       
    368a:	d6 04 00    	nop       
    368c:	d6 04 00    	nop       
    368e:	e7 04 00    	nop       
    3690:	e0 00 00    	nop       
    3692:	f0 00 00    	nop       
    3694:	f0 00 00    	nop       
    3696:	0f 03 00    	nop       
    3698:	0e 03 00    	nop       
    369a:	1e 01 00    	nop       
    369c:	1e 01 00    	nop       
    369e:	2f 01 00    	nop       
    36a0:	2c 01 00    	nop       
    36a2:	3c 01 00    	nop       
    36a4:	3c 01 00    	nop       
    36a6:	4f 01 00    	nop       
    36a8:	4e 01 00    	nop       
    36aa:	5e 01 00    	nop       
    36ac:	5e 01 00    	nop       
    36ae:	6f 01 00    	nop       
    36b0:	70 00 00    	nop       
    36b2:	87 04 00    	nop       
    36b4:	87 04 00    	nop       
    36b6:	97 04 00    	nop       
    36b8:	96 04 00    	nop       
    36ba:	a7 04 00    	nop       
    36bc:	a7 04 00    	nop       
    36be:	b7 04 00    	nop       
    36c0:	b4 04 00    	nop       
    36c2:	c7 04 00    	nop       
    36c4:	c7 04 00    	nop       
    36c6:	d7 04 00    	nop       
    36c8:	d6 04 00    	nop       
    36ca:	e7 04 00    	nop       
    36cc:	e7 04 00    	nop       
    36ce:	f7 04 00    	nop       
    36d0:	f0 00 00    	nop       
    36d2:	0f 03 00    	nop       
    36d4:	0f 03 00    	nop       
    36d6:	1f 01 00    	nop       
    36d8:	1e 01 00    	nop       
    36da:	2f 01 00    	nop       
    36dc:	2f 01 00    	nop       
    36de:	3f 01 00    	nop       
    36e0:	3c 01 00    	nop       
    36e2:	4f 01 00    	nop       
    36e4:	4f 01 00    	nop       
    36e6:	5f 01 00    	nop       
    36e8:	5e 01 00    	nop       
    36ea:	6f 01 00    	nop       
    36ec:	6f 01 00    	nop       
    36ee:	7f 01 00    	nop       
    36f0:	80 00 00    	nop       
    36f2:	90 00 00    	nop       
    36f4:	90 00 00    	nop       
    36f6:	a1 00 00    	nop       
    36f8:	a0 00 00    	nop       
    36fa:	b0 00 00    	nop       
    36fc:	b0 00 00    	nop       
    36fe:	c3 00 00    	nop       
    3700:	c0 00 00    	nop       
    3702:	d0 00 00    	nop       
    3704:	d0 00 00    	nop       
    3706:	e1 00 00    	nop       
    3708:	e0 00 00    	nop       
    370a:	f0 00 00    	nop       
    370c:	f0 00 00    	nop       
    370e:	0f 03 00    	nop       
    3710:	08 07 00    	nop       
    3712:	18 05 00    	nop       
    3714:	18 05 00    	nop       
    3716:	29 05 00    	nop       
    3718:	28 05 00    	nop       
    371a:	38 05 00    	nop       
    371c:	38 05 00    	nop       
    371e:	4b 05 00    	nop       
    3720:	48 05 00    	nop       
    3722:	58 05 00    	nop       
    3724:	58 05 00    	nop       
    3726:	69 05 00    	nop       
    3728:	68 05 00    	nop       
    372a:	78 05 00    	nop       
    372c:	78 05 00    	nop       
    372e:	8f 01 00    	nop       
    3730:	90 00 00    	nop       
    3732:	a1 00 00    	nop       
    3734:	a1 00 00    	nop       
    3736:	b1 00 00    	nop       
    3738:	b0 00 00    	nop       
    373a:	c3 00 00    	nop       
    373c:	c3 00 00    	nop       
    373e:	d3 00 00    	nop       
    3740:	d0 00 00    	nop       
    3742:	e1 00 00    	nop       
    3744:	e1 00 00    	nop       
    3746:	f1 00 00    	nop       
    3748:	f0 00 00    	nop       
    374a:	0f 03 00    	nop       
    374c:	0f 03 00    	nop       
    374e:	1f 01 00    	nop       
    3750:	18 05 00    	nop       
    3752:	29 05 00    	nop       
    3754:	29 05 00    	nop       
    3756:	39 05 00    	nop       
    3758:	38 05 00    	nop       
    375a:	4b 05 00    	nop       
    375c:	4b 05 00    	nop       
    375e:	5b 05 00    	nop       
    3760:	58 05 00    	nop       
    3762:	69 05 00    	nop       
    3764:	69 05 00    	nop       
    3766:	79 05 00    	nop       
    3768:	78 05 00    	nop       
    376a:	8f 01 00    	nop       
    376c:	8f 01 00    	nop       
    376e:	9f 01 00    	nop       
    3770:	a0 00 00    	nop       
    3772:	b0 00 00    	nop       
    3774:	b0 00 00    	nop       
    3776:	c3 00 00    	nop       
    3778:	c2 00 00    	nop       
    377a:	d2 00 00    	nop       
    377c:	d2 00 00    	nop       
    377e:	e3 00 00    	nop       
    3780:	e0 00 00    	nop       
    3782:	f0 00 00    	nop       
    3784:	f0 00 00    	nop       
    3786:	0f 03 00    	nop       
    3788:	0e 03 00    	nop       
    378a:	1e 01 00    	nop       
    378c:	1e 01 00    	nop       
    378e:	2f 01 00    	nop       
    3790:	28 05 00    	nop       
    3792:	38 05 00    	nop       
    3794:	38 05 00    	nop       
    3796:	4b 05 00    	nop       
    3798:	4a 05 00    	nop       
    379a:	5a 05 00    	nop       
    379c:	5a 05 00    	nop       
    379e:	6b 05 00    	nop       
    37a0:	68 05 00    	nop       
    37a2:	78 05 00    	nop       
    37a4:	78 05 00    	nop       
    37a6:	8f 01 00    	nop       
    37a8:	8e 01 00    	nop       
    37aa:	9e 01 00    	nop       
    37ac:	9e 01 00    	nop       
    37ae:	af 01 00    	nop       
    37b0:	b0 00 00    	nop       
    37b2:	c3 00 00    	nop       
    37b4:	c3 00 00    	nop       
    37b6:	d3 00 00    	nop       
    37b8:	d2 00 00    	nop       
    37ba:	e3 00 00    	nop       
    37bc:	e3 00 00    	nop       
    37be:	f3 00 00    	nop       
    37c0:	f0 00 00    	nop       
    37c2:	0f 03 00    	nop       
    37c4:	0f 03 00    	nop       
    37c6:	1f 01 00    	nop       
    37c8:	1e 01 00    	nop       
    37ca:	2f 01 00    	nop       
    37cc:	2f 01 00    	nop       
    37ce:	3f 01 00    	nop       
    37d0:	38 05 00    	nop       
    37d2:	4b 05 00    	nop       
    37d4:	4b 05 00    	nop       
    37d6:	5b 05 00    	nop       
    37d8:	5a 05 00    	nop       
    37da:	6b 05 00    	nop       
    37dc:	6b 05 00    	nop       
    37de:	7b 05 00    	nop       
    37e0:	78 05 00    	nop       
    37e2:	8f 01 00    	nop       
    37e4:	8f 01 00    	nop       
    37e6:	9f 01 00    	nop       
    37e8:	9e 01 00    	nop       
    37ea:	af 01 00    	nop       
    37ec:	af 01 00    	nop       
    37ee:	bf 01 00    	nop       
    37f0:	c0 00 00    	nop       
    37f2:	d0 00 00    	nop       
    37f4:	d0 00 00    	nop       
    37f6:	e1 00 00    	nop       
    37f8:	e0 00 00    	nop       
    37fa:	f0 00 00    	nop       
    37fc:	f0 00 00    	nop       
    37fe:	0f 03 00    	nop       
    3800:	0c 03 00    	nop       
    3802:	1c 01 00    	nop       
    3804:	1c 01 00    	nop       
    3806:	2d 01 00    	nop       
    3808:	2c 01 00    	nop       
    380a:	3c 01 00    	nop       
    380c:	3c 01 00    	nop       
    380e:	4f 01 00    	nop       
    3810:	48 05 00    	nop       
    3812:	58 05 00    	nop       
    3814:	58 05 00    	nop       
    3816:	69 05 00    	nop       
    3818:	68 05 00    	nop       
    381a:	78 05 00    	nop       
    381c:	78 05 00    	nop       
    381e:	8f 01 00    	nop       
    3820:	8c 01 00    	nop       
    3822:	9c 01 00    	nop       
    3824:	9c 01 00    	nop       
    3826:	ad 01 00    	nop       
    3828:	ac 01 00    	nop       
    382a:	bc 01 00    	nop       
    382c:	bc 01 00    	nop       
    382e:	cf 01 00    	nop       
    3830:	d0 00 00    	nop       
    3832:	e1 00 00    	nop       
    3834:	e1 00 00    	nop       
    3836:	f1 00 00    	nop       
    3838:	f0 00 00    	nop       
    383a:	0f 03 00    	nop       
    383c:	0f 03 00    	nop       
    383e:	1f 01 00    	nop       
    3840:	1c 01 00    	nop       
    3842:	2d 01 00    	nop       
    3844:	2d 01 00    	nop       
    3846:	3d 01 00    	nop       
    3848:	3c 01 00    	nop       
    384a:	4f 01 00    	nop       
    384c:	4f 01 00    	nop       
    384e:	5f 01 00    	nop       
    3850:	58 05 00    	nop       
    3852:	69 05 00    	nop       
    3854:	69 05 00    	nop       
    3856:	79 05 00    	nop       
    3858:	78 05 00    	nop       
    385a:	8f 01 00    	nop       
    385c:	8f 01 00    	nop       
    385e:	9f 01 00    	nop       
    3860:	9c 01 00    	nop       
    3862:	ad 01 00    	nop       
    3864:	ad 01 00    	nop       
    3866:	bd 01 00    	nop       
    3868:	bc 01 00    	nop       
    386a:	cf 01 00    	nop       
    386c:	cf 01 00    	nop       
    386e:	df 01 00    	nop       
    3870:	e0 00 00    	nop       
    3872:	f0 00 00    	nop       
    3874:	f0 00 00    	nop       
    3876:	0f 03 00    	nop       
    3878:	0e 03 00    	nop       
    387a:	1e 01 00    	nop       
    387c:	1e 01 00    	nop       
    387e:	2f 01 00    	nop       
    3880:	2c 01 00    	nop       
    3882:	3c 01 00    	nop       
    3884:	3c 01 00    	nop       
    3886:	4f 01 00    	nop       
    3888:	4e 01 00    	nop       
    388a:	5e 01 00    	nop       
    388c:	5e 01 00    	nop       
    388e:	6f 01 00    	nop       
    3890:	68 05 00    	nop       
    3892:	78 05 00    	nop       
    3894:	78 05 00    	nop       
    3896:	8f 01 00    	nop       
    3898:	8e 01 00    	nop       
    389a:	9e 01 00    	nop       
    389c:	9e 01 00    	nop       
    389e:	af 01 00    	nop       
    38a0:	ac 01 00    	nop       
    38a2:	bc 01 00    	nop       
    38a4:	bc 01 00    	nop       
    38a6:	cf 01 00    	nop       
    38a8:	ce 01 00    	nop       
    38aa:	de 01 00    	nop       
    38ac:	de 01 00    	nop       
    38ae:	ef 01 00    	nop       
    38b0:	f0 00 00    	nop       
    38b2:	0f 03 00    	nop       
    38b4:	0f 03 00    	nop       
    38b6:	1f 01 00    	nop       
    38b8:	1e 01 00    	nop       
    38ba:	2f 01 00    	nop       
    38bc:	2f 01 00    	nop       
    38be:	3f 01 00    	nop       
    38c0:	3c 01 00    	nop       
    38c2:	4f 01 00    	nop       
    38c4:	4f 01 00    	nop       
    38c6:	5f 01 00    	nop       
    38c8:	5e 01 00    	nop       
    38ca:	6f 01 00    	nop       
    38cc:	6f 01 00    	nop       
    38ce:	7f 01 00    	nop       
    38d0:	78 05 00    	nop       
    38d2:	8f 01 00    	nop       
    38d4:	8f 01 00    	nop       
    38d6:	9f 01 00    	nop       
    38d8:	9e 01 00    	nop       
    38da:	af 01 00    	nop       
    38dc:	af 01 00    	nop       
    38de:	bf 01 00    	nop       
    38e0:	bc 01 00    	nop       
    38e2:	cf 01 00    	nop       
    38e4:	cf 01 00    	nop       
    38e6:	df 01 00    	nop       
    38e8:	de 01 00    	nop       
    38ea:	ef 01 00    	nop       
    38ec:	ef 01 00    	nop       
    38ee:	ff 01 00    	nop       
Disassembly of section .dinit:

000038f0 <.dinit>:
    38f0:	00 08 00    	nop       
    38f2:	e2 01 00    	nop       
    38f4:	80 00 00    	nop       
    38f6:	00 00 00    	nop       
