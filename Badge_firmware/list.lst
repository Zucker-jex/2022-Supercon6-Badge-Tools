
dist\default\production\Badge_firmware.production.elf:     file format elf32-pic30

Disassembly of section .ivt._ADC1Interrupt:

0000002e <.ivt._ADC1Interrupt>:
  2e:	b8 01 00    	nop       
Disassembly of section .ivt._AddressError:

00000006 <.ivt._AddressError>:
   6:	b8 01 00    	nop       
Disassembly of section .ivt._CCP1Interrupt:

00000092 <.ivt._CCP1Interrupt>:
  92:	b8 01 00    	nop       
Disassembly of section .ivt._CCP2Interrupt:

00000094 <.ivt._CCP2Interrupt>:
  94:	b8 01 00    	nop       
Disassembly of section .ivt._CCP3Interrupt:

000000d0 <__FSEC-0x2ae30>:
  d0:	b8 01 00    	nop       
Disassembly of section .ivt._CCP4Interrupt:

000000d2 <__FBSLIM-0x2ae3e>:
  d2:	b8 01 00    	nop       
Disassembly of section .ivt._CCT1Interrupt:

000000de <__FOSCSEL-0x2ae3a>:
  de:	b8 01 00    	nop       
Disassembly of section .ivt._CCT2Interrupt:

000000e0 <__FOSC-0x2ae3c>:
  e0:	b8 01 00    	nop       
Disassembly of section .ivt._CCT3Interrupt:

0000006a <__FWDT-0x2aeb6>:
  6a:	b8 01 00    	nop       
Disassembly of section .ivt._CCT4Interrupt:

0000006c <__FPOR-0x2aeb8>:
  6c:	b8 01 00    	nop       
Disassembly of section .ivt._CLC1Interrupt:

000000d4 <__FICD-0x2ae54>:
  d4:	b8 01 00    	nop       
Disassembly of section .ivt._CLC2Interrupt:

000000d6 <__FDEVOPT1-0x2ae56>:
  d6:	b8 01 00    	nop       
Disassembly of section .ivt._CRCInterrupt:

0000009a <.ivt._CRCInterrupt>:
  9a:	b8 01 00    	nop       
Disassembly of section .ivt._CTMUInterrupt:

000000ae <.ivt._CTMUInterrupt>:
  ae:	b8 01 00    	nop       
Disassembly of section .ivt._CompInterrupt:

00000038 <.ivt._CompInterrupt>:
  38:	b8 01 00    	nop       
Disassembly of section .ivt._DMA0Interrupt:

0000001c <.ivt._DMA0Interrupt>:
  1c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA1Interrupt:

00000030 <.ivt._DMA1Interrupt>:
  30:	b8 01 00    	nop       
Disassembly of section .ivt._DMA2Interrupt:

00000044 <.ivt._DMA2Interrupt>:
  44:	b8 01 00    	nop       
Disassembly of section .ivt._DMA3Interrupt:

0000005c <.ivt._DMA3Interrupt>:
  5c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA4Interrupt:

00000070 <.ivt._DMA4Interrupt>:
  70:	b8 01 00    	nop       
Disassembly of section .ivt._DMA5Interrupt:

0000008e <.ivt._DMA5Interrupt>:
  8e:	b8 01 00    	nop       
Disassembly of section .ivt._ECCInterrupt:

000000ec <.ivt._ECCInterrupt>:
  ec:	b8 01 00    	nop       
Disassembly of section .ivt._FSTInterrupt:

000000e8 <.ivt._FSTInterrupt>:
  e8:	b8 01 00    	nop       
Disassembly of section .ivt._GeneralError:

00000010 <.ivt._GeneralError>:
  10:	b8 01 00    	nop       
Disassembly of section .ivt._I2C1BCInterrupt:

000000bc <.ivt._I2C1BCInterrupt>:
  bc:	b8 01 00    	nop       
Disassembly of section .ivt._I2C2BCInterrupt:

000000be <.ivt._I2C2BCInterrupt>:
  be:	b8 01 00    	nop       
Disassembly of section .ivt._I2C3BCInterrupt:

000000ee <.ivt._I2C3BCInterrupt>:
  ee:	b8 01 00    	nop       
Disassembly of section .ivt._IC1Interrupt:

00000016 <.ivt._IC1Interrupt>:
  16:	b8 01 00    	nop       
Disassembly of section .ivt._IC2Interrupt:

0000001e <.ivt._IC2Interrupt>:
  1e:	b8 01 00    	nop       
Disassembly of section .ivt._IC3Interrupt:

0000005e <.ivt._IC3Interrupt>:
  5e:	b8 01 00    	nop       
Disassembly of section .ivt._INT0Interrupt:

00000014 <.ivt._INT0Interrupt>:
  14:	b8 01 00    	nop       
Disassembly of section .ivt._INT1Interrupt:

0000003c <.ivt._INT1Interrupt>:
  3c:	b8 01 00    	nop       
Disassembly of section .ivt._INT2Interrupt:

0000004e <.ivt._INT2Interrupt>:
  4e:	b8 01 00    	nop       
Disassembly of section .ivt._INT3Interrupt:

0000007e <.ivt._INT3Interrupt>:
  7e:	b8 01 00    	nop       
Disassembly of section .ivt._INT4Interrupt:

00000080 <.ivt._INT4Interrupt>:
  80:	b8 01 00    	nop       
Disassembly of section .ivt._IOCInterrupt:

0000003a <.ivt._IOCInterrupt>:
  3a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt100:

000000dc <.ivt._Interrupt100>:
  dc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt103:

000000e2 <.ivt._Interrupt103>:
  e2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt104:

000000e4 <.ivt._Interrupt104>:
  e4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt105:

000000e6 <.ivt._Interrupt105>:
  e6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt107:

000000ea <.ivt._Interrupt107>:
  ea:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt111:

000000f2 <.ivt._Interrupt111>:
  f2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt112:

000000f4 <.ivt._Interrupt112>:
  f4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt113:

000000f6 <.ivt._Interrupt113>:
  f6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt114:

000000f8 <.ivt._Interrupt114>:
  f8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt115:

000000fa <.ivt._Interrupt115>:
  fa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt116:

000000fc <.ivt._Interrupt116>:
  fc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt21:

0000003e <.ivt._Interrupt21>:
  3e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt22:

00000040 <.ivt._Interrupt22>:
  40:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt23:

00000042 <.ivt._Interrupt23>:
  42:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt26:

00000048 <.ivt._Interrupt26>:
  48:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt27:

0000004a <.ivt._Interrupt27>:
  4a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt28:

0000004c <.ivt._Interrupt28>:
  4c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt34:

00000058 <.ivt._Interrupt34>:
  58:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt35:

0000005a <.ivt._Interrupt35>:
  5a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt38:

00000060 <.ivt._Interrupt38>:
  60:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt39:

00000062 <.ivt._Interrupt39>:
  62:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt40:

00000064 <.ivt._Interrupt40>:
  64:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt47:

00000072 <.ivt._Interrupt47>:
  72:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt48:

00000074 <.ivt._Interrupt48>:
  74:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt51:

0000007a <.ivt._Interrupt51>:
  7a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt52:

0000007c <.ivt._Interrupt52>:
  7c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt55:

00000082 <.ivt._Interrupt55>:
  82:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt56:

00000084 <.ivt._Interrupt56>:
  84:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt57:

00000086 <.ivt._Interrupt57>:
  86:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt68:

0000009c <.ivt._Interrupt68>:
  9c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt69:

0000009e <.ivt._Interrupt69>:
  9e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt70:

000000a0 <.ivt._Interrupt70>:
  a0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt71:

000000a2 <.ivt._Interrupt71>:
  a2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt73:

000000a6 <.ivt._Interrupt73>:
  a6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt74:

000000a8 <.ivt._Interrupt74>:
  a8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt75:

000000aa <.ivt._Interrupt75>:
  aa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt76:

000000ac <.ivt._Interrupt76>:
  ac:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt78:

000000b0 <.ivt._Interrupt78>:
  b0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt79:

000000b2 <.ivt._Interrupt79>:
  b2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt80:

000000b4 <.ivt._Interrupt80>:
  b4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt81:

000000b6 <.ivt._Interrupt81>:
  b6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt82:

000000b8 <.ivt._Interrupt82>:
  b8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt83:

000000ba <.ivt._Interrupt83>:
  ba:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt86:

000000c0 <.ivt._Interrupt86>:
  c0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt87:

000000c2 <.ivt._Interrupt87>:
  c2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt88:

000000c4 <.ivt._Interrupt88>:
  c4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt89:

000000c6 <.ivt._Interrupt89>:
  c6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt92:

000000cc <.ivt._Interrupt92>:
  cc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt93:

000000ce <.ivt._Interrupt93>:
  ce:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt98:

000000d8 <.ivt._Interrupt98>:
  d8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt99:

000000da <.ivt._Interrupt99>:
  da:	b8 01 00    	nop       
Disassembly of section .ivt._JTAGInterrupt:

000000fe <.ivt._JTAGInterrupt>:
  fe:	b8 01 00    	nop       
Disassembly of section .ivt._LVDInterrupt:

000000a4 <.ivt._LVDInterrupt>:
  a4:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C1Interrupt:

00000036 <.ivt._MI2C1Interrupt>:
  36:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C2Interrupt:

00000078 <.ivt._MI2C2Interrupt>:
  78:	b8 01 00    	nop       
Disassembly of section .ivt._MathError:

0000000c <.ivt._MathError>:
   c:	b8 01 00    	nop       
Disassembly of section .ivt._NVMError:

00000008 <.ivt._NVMError>:
   8:	b8 01 00    	nop       
Disassembly of section .ivt._NVMInterrupt:

00000032 <.ivt._NVMInterrupt>:
  32:	b8 01 00    	nop       
Disassembly of section .ivt._OC1Interrupt:

00000018 <.ivt._OC1Interrupt>:
  18:	b8 01 00    	nop       
Disassembly of section .ivt._OC2Interrupt:

00000020 <.ivt._OC2Interrupt>:
  20:	b8 01 00    	nop       
Disassembly of section .ivt._OC3Interrupt:

00000046 <.ivt._OC3Interrupt>:
  46:	b8 01 00    	nop       
Disassembly of section .ivt._OC5Interrupt:

00000066 <.ivt._OC5Interrupt>:
  66:	b8 01 00    	nop       
Disassembly of section .ivt._OC6Interrupt:

00000068 <.ivt._OC6Interrupt>:
  68:	b8 01 00    	nop       
Disassembly of section .ivt._OscillatorFail:

00000004 <.ivt._OscillatorFail>:
   4:	b8 01 00    	nop       
Disassembly of section .ivt._PMPInterrupt:

0000006e <.ivt._PMPInterrupt>:
  6e:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCInterrupt:

00000090 <.ivt._RTCCInterrupt>:
  90:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCTSInterrupt:

000000f0 <.ivt._RTCCTSInterrupt>:
  f0:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap5:

0000000e <.ivt._ReservedTrap5>:
   e:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap7:

00000012 <.ivt._ReservedTrap7>:
  12:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C1Interrupt:

00000034 <.ivt._SI2C1Interrupt>:
  34:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C2Interrupt:

00000076 <.ivt._SI2C2Interrupt>:
  76:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1Interrupt:

00000026 <.ivt._SPI1Interrupt>:
  26:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1RXInterrupt:

00000088 <.ivt._SPI1RXInterrupt>:
  88:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1TXInterrupt:

00000028 <.ivt._SPI1TXInterrupt>:
  28:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2Interrupt:

00000054 <.ivt._SPI2Interrupt>:
  54:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2RXInterrupt:

0000008a <.ivt._SPI2RXInterrupt>:
  8a:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2TXInterrupt:

00000056 <.ivt._SPI2TXInterrupt>:
  56:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3Interrupt:

000000c8 <.ivt._SPI3Interrupt>:
  c8:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3RXInterrupt:

0000008c <.ivt._SPI3RXInterrupt>:
  8c:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3TXInterrupt:

000000ca <.ivt._SPI3TXInterrupt>:
  ca:	b8 01 00    	nop       
Disassembly of section .ivt._StackError:

0000000a <.ivt._StackError>:
   a:	b8 01 00    	nop       
Disassembly of section .ivt._T2Interrupt:

00000022 <.ivt._T2Interrupt>:
  22:	b8 01 00    	nop       
Disassembly of section .ivt._U1TXInterrupt:

0000002c <.ivt._U1TXInterrupt>:
  2c:	b8 01 00    	nop       
Disassembly of section .ivt._U2TXInterrupt:

00000052 <.ivt._U2TXInterrupt>:
  52:	b8 01 00    	nop       
Disassembly of section .reset:

00000000 <.reset>:
   0:	04 02 04    	goto      0x204 <__reset>
   2:	00 00 00 
Disassembly of section .text:

00000100 <__long_indirect_call>:
 100:	8a 1f 78    	mov.w     w10, [w15++]
 102:	8b 1f 78    	mov.w     w11, [w15++]
 104:	00 00 06    	return    

00000106 <__data_init>:
 106:	a1 02 88    	mov.w     w1, 0x54
 108:	80 04 78    	mov.w     w0, w9
 10a:	00 00 eb    	clr.w     w0
 10c:	1f 00 37    	bra       0x14c <L41>

0000010e <L11>:
 10e:	e2 84 44    	add.w     w9, #0x2, w9
 110:	54 a0 b4    	addc.w    0x54
 112:	99 05 ba    	tblrdl.w  [w9], w11
 114:	e2 84 44    	add.w     w9, #0x2, w9
 116:	54 a0 b4    	addc.w    0x54
 118:	99 06 ba    	tblrdl.w  [w9], w13
 11a:	e2 84 44    	add.w     w9, #0x2, w9
 11c:	54 a0 b4    	addc.w    0x54
 11e:	00 06 eb    	clr.w     w12
 120:	47 6f de    	lsr.w     w13, #0x7, w14
 122:	fd 07 b2    	and.w     #0x7f, w13
 124:	ae 01 88    	mov.w     w14, 0x34
 126:	63 6c e1    	cp.b      w13, #0x3
 128:	03 00 3a    	bra       NZ, 0x130 <L21>
 12a:	ea ff 07    	rcall     0x100 <__long_indirect_call>
 12c:	00 00 eb    	clr.w     w0
 12e:	0e 00 37    	bra       0x14c <L41>

00000130 <L21>:
 130:	60 6c e1    	cp.b      w13, #0x0
 132:	08 00 3a    	bra       NZ, 0x144 <L22>

00000134 <L91>:
 134:	00 4d eb    	clr.b     [w10]
 136:	0a 05 e8    	inc.w     w10, w10
 138:	02 00 39    	bra       NC, 0x13e <L81>
 13a:	34 20 ec    	inc.w     0x34
 13c:	0a f0 a0    	bset.w    w10, #0xf

0000013e <L81>:
 13e:	8b 05 e9    	dec.w     w11, w11
 140:	f9 ff 3e    	bra       GTU, 0x134 <L91>
 142:	04 00 37    	bra       0x14c <L41>

00000144 <L22>:
 144:	61 68 e1    	cp.w      w13, #0x1
 146:	01 00 32    	bra       Z, 0x14a <L31>
 148:	00 86 eb    	setm.w    w12

0000014a <L31>:
 14a:	0b 00 07    	rcall     0x162 <L13> <__memcpyd3extended>

0000014c <L41>:
 14c:	19 c7 ba    	tblrdh.b  [w9], w14
 14e:	19 05 ba    	tblrdl.w  [w9], w10
 150:	0e 04 e0    	cp0.b     w14
 152:	03 00 3a    	bra       NZ, 0x15a <L12>
 154:	0a 00 e0    	cp0.w     w10
 156:	db ff 3a    	bra       NZ, 0x10e <L11>
 158:	00 00 06    	return    

0000015a <L12>:
 15a:	fe 07 b2    	and.w     #0x7f, w14
 15c:	ae 02 88    	mov.w     w14, 0x54
 15e:	8a 04 78    	mov.w     w10, w9
 160:	f5 ff 37    	bra       0x14c <L41>

00000162 <L13>:
 162:	0c d0 a3    	btst.c    w12, #0xd
 164:	e2 0f 4d    	addc.w    w10, #0x2, [w15]
 166:	1c 00 39    	bra       NC, 0x1a0 <L23>
 168:	89 02 78    	mov.w     w9, w5
 16a:	35 4d ba    	tblrdl.b  [w5++], [w10]
 16c:	0a 05 e8    	inc.w     w10, w10
 16e:	02 00 39    	bra       NC, 0x174 <L32>
 170:	34 20 ec    	inc.w     0x34
 172:	0a f0 a0    	bset.w    w10, #0xf

00000174 <L32>:
 174:	8b 05 e9    	dec.w     w11, w11
 176:	0f 00 32    	bra       Z, 0x196 <L42>
 178:	25 4d ba    	tblrdl.b  [w5--], [w10]
 17a:	0a 05 e8    	inc.w     w10, w10
 17c:	02 00 39    	bra       NC, 0x182 <L33>
 17e:	34 20 ec    	inc.w     0x34
 180:	0a f0 a0    	bset.w    w10, #0xf

00000182 <L33>:
 182:	8b 05 e9    	dec.w     w11, w11
 184:	08 00 32    	bra       Z, 0x196 <L42>
 186:	0c 00 e0    	cp0.w     w12
 188:	06 00 32    	bra       Z, 0x196 <L42>
 18a:	15 cd ba    	tblrdh.b  [w5], [w10]
 18c:	0a 05 e8    	inc.w     w10, w10
 18e:	02 00 39    	bra       NC, 0x194 <L34>
 190:	34 20 ec    	inc.w     0x34
 192:	0a f0 a0    	bset.w    w10, #0xf

00000194 <L34>:
 194:	8b 05 e9    	dec.w     w11, w11

00000196 <L42>:
 196:	89 84 e8    	inc2.w    w9, w9
 198:	54 a0 b4    	addc.w    0x54
 19a:	0b 00 e0    	cp0.w     w11
 19c:	e2 ff 3a    	bra       NZ, 0x162 <L13> <__memcpyd3extended>
 19e:	00 00 06    	return    

000001a0 <L23>:
 1a0:	99 02 ba    	tblrdl.w  [w9], w5
 1a2:	05 5d 78    	mov.b     w5, [w10++]
 1a4:	8b 05 e9    	dec.w     w11, w11
 1a6:	f7 ff 32    	bra       Z, 0x196 <L42>
 1a8:	c8 2a de    	lsr.w     w5, #0x8, w5
 1aa:	05 5d 78    	mov.b     w5, [w10++]
 1ac:	8b 05 e9    	dec.w     w11, w11
 1ae:	f3 ff 32    	bra       Z, 0x196 <L42>
 1b0:	0c 00 e0    	cp0.w     w12
 1b2:	f1 ff 32    	bra       Z, 0x196 <L42>
 1b4:	19 dd ba    	tblrdh.b  [w9], [w10++]
 1b6:	ee ff 37    	bra       0x194 <L34>

000001b8 <__DefaultInterrupt>:
 1b8:	00 40 da    	break     
 1ba:	00 00 fe    	reset     

000001bc <__crt_start_mode>:
 1bc:	00 00 05    	retlw.w   #0x0, w0
Disassembly of section __FSEC:

0002af00 <__FSEC>:
   2af00:	f6 fe 00    	nop       
Disassembly of section __FBSLIM:

0002af10 <__FBSLIM>:
   2af10:	fd ff 00    	nop       
Disassembly of section __FOSCSEL:

0002af18 <__FOSCSEL>:
   2af18:	89 ff 00    	nop       
Disassembly of section __FOSC:

0002af1c <__FOSC>:
   2af1c:	e3 ff 00    	nop       
Disassembly of section __FWDT:

0002af20 <__FWDT>:
   2af20:	9f b7 00    	nop       
Disassembly of section __FPOR:

0002af24 <__FPOR>:
   2af24:	fc ff 00    	nop       
Disassembly of section __FICD:

0002af28 <__FICD>:
   2af28:	df ff 00    	nop       
Disassembly of section __FDEVOPT1:

0002af2c <__FDEVOPT1>:
   2af2c:	e7 ff 00    	nop       
Disassembly of section .ivt._T1Interrupt:

0000001a <.ivt._T1Interrupt>:
  1a:	0e 10 00    	nop       
Disassembly of section .ivt._T3Interrupt:

00000024 <.ivt._T3Interrupt>:
  24:	12 10 00    	nop       
Disassembly of section .ivt._U1RXInterrupt:

0000002a <.ivt._U1RXInterrupt>:
  2a:	1e 10 00    	nop       
Disassembly of section .ivt._U1ErrInterrupt:

00000096 <.ivt._U1ErrInterrupt>:
  96:	22 10 00    	nop       
Disassembly of section .ivt._U2RXInterrupt:

00000050 <.ivt._U2RXInterrupt>:
  50:	26 10 00    	nop       
Disassembly of section .ivt._U2ErrInterrupt:

00000098 <.ivt._U2ErrInterrupt>:
  98:	2a 10 00    	nop       
Disassembly of section .text:

000001be <.L0>:
     1be:	ff ff 00    	nop       
     1c0:	ff ff 00    	nop       
     1c2:	ff ff 00    	nop       
     1c4:	ff ff 00    	nop       
     1c6:	ff ff 00    	nop       
     1c8:	ff ff 00    	nop       
     1ca:	ff ff 00    	nop       
     1cc:	ff ff 00    	nop       
     1ce:	ff ff 00    	nop       
     1d0:	ff ff 00    	nop       
     1d2:	ff ff 00    	nop       
     1d4:	ff ff 00    	nop       
     1d6:	ff ff 00    	nop       
     1d8:	ff ff 00    	nop       
     1da:	ff ff 00    	nop       
     1dc:	ff ff 00    	nop       
     1de:	ff ff 00    	nop       
     1e0:	ff ff 00    	nop       
     1e2:	ff ff 00    	nop       
     1e4:	ff ff 00    	nop       
     1e6:	ff ff 00    	nop       
     1e8:	ff ff 00    	nop       
     1ea:	ff ff 00    	nop       
     1ec:	ff ff 00    	nop       
     1ee:	ff ff 00    	nop       
     1f0:	ff ff 00    	nop       
     1f2:	ff ff 00    	nop       
     1f4:	ff ff 00    	nop       
     1f6:	ff ff 00    	nop       
     1f8:	ff ff 00    	nop       
     1fa:	ff ff 00    	nop       
     1fc:	ff ff 00    	nop       
     1fe:	ff ff 00    	nop       
     200:	42 4f 00    	nop       
     202:	4f 54 00    	nop       

00000204 <__reset>:
; boot segment
	.ascii	"BOOT"		; boot segment start
.global __reset
__reset:
	mov	#STACK_START,w15
     204:	0f 70 24    	mov.w     #0x4700, w15
	mov	#STACK_END,w0
     206:	e0 7f 24    	mov.w     #0x47fe, w0
	mov	w0,SPLIM 		; Stack Pointer Limit
     208:	00 01 88    	mov.w     w0, 0x20
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	call	initialize
     20a:	3c 02 02    	call      0x23c <initialize>
     20c:	00 00 00 
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
;------------------------------------------ clear RAM
	mov	#0x800,w0
     20e:	00 80 20    	mov.w     #0x800, w0
	repeat	#0x400-1
     210:	ff 03 09    	repeat    #0x3ff
	xor	w2,[w0++],w2
     212:	30 01 69    	xor.w     w2, [w0++], w2
	mov	w2,w3
     214:	82 01 78    	mov.w     w2, w3
	repeat	#0x1C00-1
     216:	ff 1b 09    	repeat    #0x1bff
	xor	w3,[w0++],w3
     218:	b0 81 69    	xor.w     w3, [w0++], w3
	mov	#0x800,w1
     21a:	01 80 20    	mov.w     #0x800, w1
	repeat 	#0x2000-1	;total 0x4000=16K bytes
     21c:	ff 1f 09    	repeat    #0x1fff
	clr	[w1++]
     21e:	80 18 eb    	clr.w     [w1++]
	mov	w2,Rndlo	; initialize Rnd Seed
     220:	22 4e 88    	mov.w     w2, 0x9c4
	and	w2,#0x0F,w0
     222:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	Wreg,Ram+0xFF	; Write Rnd value
     224:	ff e8 b7    	mov.b     WREG, 0x8ff
	mov	w3,Rndhi	; initialize Rnd Seed
     226:	33 4e 88    	mov.w     w3, 0x9c6
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
; ini AutoOff
	mov	#2,w0		; 2×10 min autooff at hard reset
     228:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
     22a:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
     22c:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
     22e:	b0 4d 88    	mov.w     w0, 0x9b6
; ini dimmer
	mov	#15,w0
     230:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Dimmer
     232:	fe e8 b7    	mov.b     WREG, 0x8fe
; check if button ALT depressed (self check button)
	btsc	PORTA,#2	; PORTA,#2 = ALT key
     234:	64 46 af    	btsc.b    0x664, #0x2
	bra	selfcheck_back	; if ALT not pressed
     236:	fb 06 37    	bra       0x102e <selfcheck_back>
	bra	boot_start
     238:	00 00 37    	bra       0x23a <boot_start>

0000023a <boot_start>:
;------------------------------------------------------------------------------------
;  NOTE: FIRMWARE IN THIS PAGE IS IN PROTECTED BOOT SEGMENT, AND CAN NOT BE MODIFIED 
;------------------------------------------------------------------------------------

boot_start:		bra	go_boot_start
     23a:	0e 00 37    	bra       0x258 <go_boot_start>

0000023c <initialize>:
initialize:		bra	boot_initialize
     23c:	91 01 37    	bra       0x560 <boot_initialize>

0000023e <set_decoder_to_w1>:
set_decoder_to_w1:	bra	boot_set_decoder_to_w1
     23e:	c4 01 37    	bra       0x5c8 <boot_set_decoder_to_w1>

00000240 <w0ms2>:
w0ms2:			bra	boot_w0ms2
     240:	e3 01 37    	bra       0x608 <boot_w0ms2>

00000242 <eecalc_addr_w0>:
eecalc_addr_w0:		bra	boot_eecalc_addr_w0
     242:	e7 01 37    	bra       0x612 <boot_eecalc_addr_w0>

00000244 <eesavew0>:
eesavew0:		bra	boot_eesavew0
     244:	f6 01 37    	bra       0x632 <boot_eesavew0>

00000246 <eeload>:
eeload:			bra	boot_eeload
     246:	25 02 37    	bra       0x692 <boot_eeload>

00000248 <eemeasure>:
eemeasure:		bra	boot_eemeasure
     248:	4e 02 37    	bra       0x6e6 <boot_eemeasure>

0000024a <eeburn_128>:
eeburn_128:		bra	boot_eeburn_128
     24a:	6b 02 37    	bra       0x722 <boot_eeburn_128>

0000024c <eeerase_1K>:
eeerase_1K:		bra	boot_eeerase_1K
     24c:	62 02 37    	bra       0x712 <boot_eeerase_1K>

0000024e <burn1k>:
burn1k:			bra	boot_burn1k
     24e:	98 02 37    	bra       0x780 <boot_burn1k>

00000250 <selfcheck>:
selfcheck:		bra	boot_selfcheck
     250:	24 00 37    	bra       0x29a <boot_selfcheck>

00000252 <bootload>:
bootload:		bra	boot_bootload
     252:	dd 00 37    	bra       0x40e <boot_bootload>

00000254 <key_save>:
key_save:		bra	boot_key_save
     254:	12 01 37    	bra       0x47a <boot_key_save>

00000256 <key_load>:
key_load:		bra	boot_key_load
     256:	37 01 37    	bra       0x4c6 <boot_key_load>

00000258 <go_boot_start>:

;------------------------------------------------------------------------
;--------------------     BOOT  START     -------------------------------
;------------------------------------------------------------------------

go_boot_start:
; **********************************************************************************	
; Note:											
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These	
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons,	
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and	
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every	
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second	
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.	
; **********************************************************************************	
; ALT pressed, initialize small debouncig area
	bclr	INTCON2,#GIE	; global interrupt disable
     258:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     25a:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     25c:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     25e:	84 e9 ef    	setm.b    0x984
; Check if some other key excl. Save and Load pressed (if so, don't allow spec mode)
	mov	#7,w1		; 7 = here are keys OperY1 and DataIn
     260:	71 00 20    	mov.w     #0x7, w1
	  call	  set_decoder_to_w1
     262:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     264:	00 00 00 
	btss	PORTA,#3
     266:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if OperY 1 pressed
     268:	e2 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     26a:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if DataIn pressed
     26c:	e0 06 37    	bra       0x102e <selfcheck_back>
	  call	  set_decoder_to_w1
     26e:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     270:	00 00 00 
	btss	PORTA,#3
     272:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Mode pressed
     274:	dc 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     276:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Carry pressed
     278:	da 06 37    	bra       0x102e <selfcheck_back>
	  call	  set_decoder_to_w1
     27a:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     27c:	00 00 00 
	btss	PORTA,#3
     27e:	64 66 ae    	btss.b    0x664, #0x3
	bra	key_save	; if Save pressed -----------> SAVE
     280:	e9 ff 37    	bra       0x254 <key_save>
	btss	PORTA,#4
     282:	64 86 ae    	btss.b    0x664, #0x4
	bra	key_load	; if Load pressed -----------> LOAD
     284:	e8 ff 37    	bra       0x256 <key_load>

	mov	#6,w2		; w2 loop count
     286:	62 00 20    	mov.w     #0x6, w2

00000288 <L61>:
6:			; \
	  call	  set_decoder_to_w1
     288:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     28a:	00 00 00 
	btss	PORTA,#3
     28c:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Clock, Opcode4, etc... pressed
     28e:	cf 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     290:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Opcode8, Opcode2, etc... pressed
     292:	cd 06 37    	bra       0x102e <selfcheck_back>
	dec	w2,w2
     294:	02 01 e9    	dec.w     w2, w2
	bra	nz,6b	; /
     296:	f8 ff 3a    	bra       NZ, 0x288 <L61>
	bra	selfcheck	; if ALT only pressed
     298:	db ff 37    	bra       0x250 <selfcheck>

0000029a <boot_selfcheck>:

; ----------------------------------------------------------------------
; -----------------------  S E L F   C H E C K  ------------------------
; ----------------------------------------------------------------------
boot_selfcheck:
	mov	#5,w0
     29a:	50 00 20    	mov.w     #0x5, w0
	mov	w0,Mode
     29c:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#3		; #3 self-check mode
     29e:	dc 69 a8    	bset.b    0x9dc, #0x3

	clr	TMR1
     2a0:	90 21 ef    	clr.w     0x190
	bset	T1CON,#TON	; LED multiplex timer on
     2a2:	95 e1 a8    	bset.b    0x195, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
     2a4:	98 60 a8    	bset.b    0x98, #0x3
	bset	INTCON2,#GIE	; global int enable
     2a6:	83 e0 a8    	bset.b    0x83, #0x7
; initialize pixels for self check
	mov	#0b0100100100100100,w0
     2a8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Column1
     2aa:	40 4e 88    	mov.w     w0, 0x9c8
	mov	#0b0010010010010010,w0
     2ac:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Column2
     2ae:	50 4e 88    	mov.w     w0, 0x9ca
	mov	#0b1001001001001001,w0
     2b0:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Column3
     2b2:	60 4e 88    	mov.w     w0, 0x9cc
	mov	#0b0010010010010010,w0
     2b4:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row3
     2b6:	70 4e 88    	mov.w     w0, 0x9ce
	mov	#0b0100100100100100,w0
     2b8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row4
     2ba:	80 4e 88    	mov.w     w0, 0x9d0
	mov	#0b0010010010010010,w0
     2bc:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row5
     2be:	90 4e 88    	mov.w     w0, 0x9d2
	mov	#0b0100100100100100,w0
     2c0:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row6
     2c2:	a0 4e 88    	mov.w     w0, 0x9d4
	mov	#0b1001001001001001,w0
     2c4:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Row7
     2c6:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b1001001001001001,w0
     2c8:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,A16
     2ca:	70 4d 88    	mov.w     w0, 0x9ae

	mov	#0b010000001001,w0
     2cc:	90 40 20    	mov.w     #0x409, w0
	mov	w0,Ram+0
     2ce:	00 40 88    	mov.w     w0, 0x800
	mov	w0,Ram+6
     2d0:	30 40 88    	mov.w     w0, 0x806
	mov	w0,Ram+12
     2d2:	60 40 88    	mov.w     w0, 0x80c
	mov	w0,Ram+18
     2d4:	90 40 88    	mov.w     w0, 0x812
	mov	w0,Ram+24
     2d6:	c0 40 88    	mov.w     w0, 0x818
	mov	w0,Ram+30
     2d8:	f0 40 88    	mov.w     w0, 0x81e
	mov	#0b100100000010,w0
     2da:	20 90 20    	mov.w     #0x902, w0
	mov	w0,Ram+2
     2dc:	10 40 88    	mov.w     w0, 0x802
	mov	w0,Ram+8
     2de:	40 40 88    	mov.w     w0, 0x808
	mov	w0,Ram+14
     2e0:	70 40 88    	mov.w     w0, 0x80e
	mov	w0,Ram+20
     2e2:	a0 40 88    	mov.w     w0, 0x814
	mov	w0,Ram+26
     2e4:	d0 40 88    	mov.w     w0, 0x81a
	mov	#0b001000000100,w0
     2e6:	40 20 20    	mov.w     #0x204, w0
	mov	w0,Ram+4
     2e8:	20 40 88    	mov.w     w0, 0x804
	mov	w0,Ram+10
     2ea:	50 40 88    	mov.w     w0, 0x80a
	mov	w0,Ram+16
     2ec:	80 40 88    	mov.w     w0, 0x810
	mov	w0,Ram+22
     2ee:	b0 40 88    	mov.w     w0, 0x816
	mov	w0,Ram+28
     2f0:	e0 40 88    	mov.w     w0, 0x81c

000002f2 <self_check_loop>:
self_check_loop:
; STEP 1: WAIT ---------
	mov	BlinkCount,w0
     2f2:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x03FF,w0
     2f4:	f0 3f b2    	and.w     #0x3ff, w0
	bra	nz,self_check_loop
     2f6:	fd ff 3a    	bra       NZ, 0x2f2 <self_check_loop>

; STEP 2: SHIFT --------
.macro	rotate	variab,if,then
	lsr	\variab
	btsc	\variab,#\if
	bset	\variab,#\then
.endm
	rotate	Column1,0,15
     2f8:	c8 29 d5    	lsr.w     0x9c8
     2fa:	c8 09 af    	btsc.b    0x9c8, #0x0
     2fc:	c9 e9 a8    	bset.b    0x9c9, #0x7
	rotate	Column2,0,15
     2fe:	ca 29 d5    	lsr.w     0x9ca
     300:	ca 09 af    	btsc.b    0x9ca, #0x0
     302:	cb e9 a8    	bset.b    0x9cb, #0x7
	rotate	Column3,0,15
     304:	cc 29 d5    	lsr.w     0x9cc
     306:	cc 09 af    	btsc.b    0x9cc, #0x0
     308:	cd e9 a8    	bset.b    0x9cd, #0x7
	rotate	Row3,0,15
     30a:	ce 29 d5    	lsr.w     0x9ce
     30c:	ce 09 af    	btsc.b    0x9ce, #0x0
     30e:	cf e9 a8    	bset.b    0x9cf, #0x7
	rotate	Row4,0,15
     310:	d0 29 d5    	lsr.w     0x9d0
     312:	d0 09 af    	btsc.b    0x9d0, #0x0
     314:	d1 e9 a8    	bset.b    0x9d1, #0x7
	rotate	Row5,0,15
     316:	d2 29 d5    	lsr.w     0x9d2
     318:	d2 09 af    	btsc.b    0x9d2, #0x0
     31a:	d3 e9 a8    	bset.b    0x9d3, #0x7
	rotate	Row6,0,15
     31c:	d4 29 d5    	lsr.w     0x9d4
     31e:	d4 09 af    	btsc.b    0x9d4, #0x0
     320:	d5 e9 a8    	bset.b    0x9d5, #0x7
	rotate	Row7,0,15
     322:	d6 29 d5    	lsr.w     0x9d6
     324:	d6 09 af    	btsc.b    0x9d6, #0x0
     326:	d7 e9 a8    	bset.b    0x9d7, #0x7
	rotate	A16,6,15
     328:	ae 29 d5    	lsr.w     0x9ae
     32a:	ae c9 af    	btsc.b    0x9ae, #0x6
     32c:	af e9 a8    	bset.b    0x9af, #0x7
	bclr	A16,#2
     32e:	ae 49 a9    	bclr.b    0x9ae, #0x2
	btsc	A16,#12
     330:	af 89 af    	btsc.b    0x9af, #0x4
	bset	A16,#2
     332:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	rotate_ram
     334:	d4 05 02    	call      0x5d4 <rotate_ram>
     336:	00 00 00 

; any key pressed?
	btss	Flag,#1		; #1 handshaking flag for buttons
     338:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	self_check_loop	; no, loop ------------------------->
     33a:	db ff 37    	bra       0x2f2 <self_check_loop>

	setm	Column1
     33c:	c8 a9 ef    	setm.w    0x9c8
	setm	Column2
     33e:	ca a9 ef    	setm.w    0x9ca
	setm	Column3
     340:	cc a9 ef    	setm.w    0x9cc
	setm	Row3
     342:	ce a9 ef    	setm.w    0x9ce
	setm	Row4
     344:	d0 a9 ef    	setm.w    0x9d0
	setm	Row5
     346:	d2 a9 ef    	setm.w    0x9d2
	setm	Row6
     348:	d4 a9 ef    	setm.w    0x9d4
	mov	#0b1111000000000000,w0
     34a:	00 00 2f    	mov.w     #0xf000, w0
	mov	w0,Row7
     34c:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b0000000001111011,w0
     34e:	b0 07 20    	mov.w     #0x7b, w0
	mov	w0,A16
     350:	70 4d 88    	mov.w     w0, 0x9ae

00000352 <wait_still>:
wait_still:
; test if ASCII "BL"
	mov	Row7,w0
     352:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     354:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     356:	01 00 60    	and.w     w0, w1, w0
	mov	#0x024C,w1	; ASCII BL = 0x424C
     358:	c1 24 20    	mov.w     #0x24c, w1
	cp	w0,w1
     35a:	01 00 e1    	cp.w      w0, w1
	bra	nz,not_BL
     35c:	1a 00 3a    	bra       NZ, 0x392 <L11> <not_BL>
	btsc	A16,#b_carry	; carry   = bit 7 (should be 0)
     35e:	af 89 af    	btsc.b    0x9af, #0x4
	bra	not_BL
     360:	18 00 37    	bra       0x392 <L11> <not_BL>
	btss	A16,#b_save	; save    = bit 6 (should be 1)
     362:	af a9 ae    	btss.b    0x9af, #0x5
	bra	not_BL
     364:	16 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_load	; load    = bit 5 (should be 0)
     366:	af c9 af    	btsc.b    0x9af, #0x6
	bra	not_BL
     368:	14 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_clk_key	; clk_key = bit 4 (should be 0)
     36a:	ae 49 af    	btsc.b    0x9ae, #0x2
	bra	not_BL
     36c:	12 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_alu	; Mode field LEDs off?
     36e:	af 69 af    	btsc.b    0x9af, #0x3
	bra	not_BL
     370:	10 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_bin	; Data_In field LEDs off?
     372:	af e9 af    	btsc.b    0x9af, #0x7
	bra	not_BL
     374:	0e 00 37    	bra       0x392 <L11> <not_BL>

	clr	Column1
     376:	c8 29 ef    	clr.w     0x9c8
	clr	Column2
     378:	ca 29 ef    	clr.w     0x9ca
	clr	Column3
     37a:	cc 29 ef    	clr.w     0x9cc
	clr	Row3
     37c:	ce 29 ef    	clr.w     0x9ce
	clr	Row4
     37e:	d0 29 ef    	clr.w     0x9d0
	clr	Row5
     380:	d2 29 ef    	clr.w     0x9d2
	clr	Row6
     382:	d4 29 ef    	clr.w     0x9d4
	clr	Row7
     384:	d6 29 ef    	clr.w     0x9d6
	mov	#Ram,w0		; clr_ram
     386:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clr_ram (clear all exept SFR)
     388:	77 00 09    	repeat    #0x77
	clr	[w0++]		; clr_ram
     38a:	00 18 eb    	clr.w     [w0++]
	mov	#0b0110000000000000,w0	; only SAVE and LOAD are ON
     38c:	00 00 26    	mov.w     #0x6000, w0
	mov	w0,A16
     38e:	70 4d 88    	mov.w     w0, 0x9ae
	bra	bootload	; BOOTLOAD ------------------->
     390:	60 ff 37    	bra       0x252 <bootload>

00000392 <L11>:
not_BL:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
     392:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b		; no, loop ------------------------->
     394:	fe ff 37    	bra       0x392 <L11> <not_BL>
	bclr	Flag,#1		; #1 handshaking flag for buttons
     396:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	rotate_ram
     398:	d4 05 02    	call      0x5d4 <rotate_ram>
     39a:	00 00 00 
.macro		ct1	valct1
		mov	#0b\valct1,w0
		bra	cont_test1
.endm
.macro		ct2	valct2
		mov	#0b\valct2,w0
		bra	cont_test2
.endm
	mov	Just,w0
     39c:	30 4d 80    	mov.w     0x9a6, w0
	sl	w0,w0		; ×2
     39e:	00 00 d0    	sl.w      w0, w0
	bra	w0
     3a0:	00 60 01    	bra       w0
; ...
	ct1	0000111100000000	 ; mode
     3a2:	00 f0 20    	mov.w     #0xf00, w0
     3a4:	22 00 37    	bra       0x3ea <cont_test1>
	ct1	0001000000000000	 ; carry
     3a6:	00 00 21    	mov.w     #0x1000, w0
     3a8:	20 00 37    	bra       0x3ea <cont_test1>
	ct1	0010000000000000	 ; save
     3aa:	00 00 22    	mov.w     #0x2000, w0
     3ac:	1e 00 37    	bra       0x3ea <cont_test1>
	ct1	0100000000000000	 ; load
     3ae:	00 00 24    	mov.w     #0x4000, w0
     3b0:	1c 00 37    	bra       0x3ea <cont_test1>
	ct1	0000000000000100	 ; clock
     3b2:	40 00 20    	mov.w     #0x4, w0
     3b4:	1a 00 37    	bra       0x3ea <cont_test1>
	ct2	0000100000000000	 ; opcode 8
     3b6:	00 80 20    	mov.w     #0x800, w0
     3b8:	1a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000010000000000	 ; opcode 4
     3ba:	00 40 20    	mov.w     #0x400, w0
     3bc:	18 00 37    	bra       0x3ee <cont_test2>
	ct2	0000001000000000	 ; opcode 2
     3be:	00 20 20    	mov.w     #0x200, w0
     3c0:	16 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000100000000	 ; opcode 1
     3c2:	00 10 20    	mov.w     #0x100, w0
     3c4:	14 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000010000000	 ; oper X 8
     3c6:	00 08 20    	mov.w     #0x80, w0
     3c8:	12 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000001000000	 ; oper X 4
     3ca:	00 04 20    	mov.w     #0x40, w0
     3cc:	10 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000100000	 ; oper X 2
     3ce:	00 02 20    	mov.w     #0x20, w0
     3d0:	0e 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000010000	 ; oper X 1
     3d2:	00 01 20    	mov.w     #0x10, w0
     3d4:	0c 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000001000	 ; oper Y 8
     3d6:	80 00 20    	mov.w     #0x8, w0
     3d8:	0a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000100	 ; oper Y 4
     3da:	40 00 20    	mov.w     #0x4, w0
     3dc:	08 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000010	 ; oper Y 2
     3de:	20 00 20    	mov.w     #0x2, w0
     3e0:	06 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000001	 ; oper Y 1
     3e2:	10 00 20    	mov.w     #0x1, w0
     3e4:	04 00 37    	bra       0x3ee <cont_test2>
	ct1	1000000010000000	 ; DataIn 
     3e6:	00 08 28    	mov.w     #0x8080, w0
     3e8:	00 00 37    	bra       0x3ea <cont_test1>

000003ea <cont_test1>:
cont_test1:
	xor	A16
     3ea:	ae a9 b6    	xor.w     0x9ae
	bra	ctx
     3ec:	01 00 37    	bra       0x3f0 <ctx>

000003ee <cont_test2>:
cont_test2:
	xor	Row7
     3ee:	d6 a9 b6    	xor.w     0x9d6

000003f0 <ctx>:
ctx:
	mov	Row7,w0
     3f0:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     3f2:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     3f4:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     3f6:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     3f8:	ac ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	A16,w0
     3fa:	70 4d 80    	mov.w     0x9ae, w0
	mov	#0b1111111110000100,w1
     3fc:	41 f8 2f    	mov.w     #0xff84, w1
	and	w0,w1,w0
     3fe:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     400:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     402:	a7 ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	#-2000,w0	; count 2000 = 500 ms
     404:	00 83 2f    	mov.w     #0xf830, w0
	mov	w0,BlinkCount
     406:	e0 4b 88    	mov.w     w0, 0x97c

00000408 <wait_Xs>:
wait_Xs:
	cp0	BlinkCount
     408:	7c 09 e2    	cp0.w     0x97c
	bra	nz,wait_Xs
     40a:	fe ff 3a    	bra       NZ, 0x408 <wait_Xs>
	reset
     40c:	00 00 fe    	reset     

0000040e <boot_bootload>:

;-----------------------------------------------------------------------------
;------------------------- BOOTLOAD ------------------------------------------
;-----------------------------------------------------------------------------

boot_bootload:
	bclr	INTCON2,#GIE	; global interrupt disable
     40e:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     410:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     412:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     414:	84 e9 ef    	setm.b    0x984

00000416 <L12>:
1:
	clr.b	LATC		; all LEDS off
     416:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     418:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode driver off
     41a:	8f 06 a9    	bclr.b    0x68f, #0x0
; led SAVE on
	mov	#0b1111100001111111,w0
     41c:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     41e:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     420:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     422:	66 26 b7    	ior.w     0x666
	bset	LATC,#8		; anode 17 on
     424:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000		; ON time 0.5 ms
     426:	40 1f 09    	repeat    #0x1f40
	nop
     428:	00 00 00    	nop       
; led LOAD on
	mov	#0b1111100001111111,w0
     42a:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     42c:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     42e:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     430:	66 26 b7    	ior.w     0x666
	repeat	#8000		; ON time 0.5 ms
     432:	40 1f 09    	repeat    #0x1f40
	nop
     434:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     436:	8f 06 a9    	bclr.b    0x68f, #0x0
; set decoder output 0 and wait 2 ms
	mov	#0b1111100001111111,w0
     438:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     43a:	66 26 b6    	and.w     0x666
	mov	#0b0000010000000000,w0	; 8 = buttons MODE and CARRY
     43c:	00 40 20    	mov.w     #0x400, w0
	ior	LATA		; decoder state = 8 (there is key MODE)
     43e:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     440:	80 3e 09    	repeat    #0x3e80
	nop
     442:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     444:	80 3e 09    	repeat    #0x3e80
	nop
     446:	00 00 00    	nop       
; debounce and test key MODE
	sl.b	KeyRotors+0
     448:	7e 69 d4    	sl.b      0x97e
	btsc	PORTA,#3
     44a:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+0,#0
     44c:	7e 09 a8    	bset.b    0x97e, #0x0
	ifz
     44e:	42 20 af    	btsc.b    0x42, #0x1
	reset			; if MODE pressed then suicide
     450:	00 00 fe    	reset     
; set decoder output 1 and wait 2 ms
	mov	#0b1111100001111111,w0
     452:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     454:	66 26 b6    	and.w     0x666
	mov	#0b0000010010000000,w0	; 9 = buttons SAVE and LOAD
     456:	00 48 20    	mov.w     #0x480, w0
	ior	LATA		; decoder state = 9 (there are keys SAVE and LOAD)
     458:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     45a:	80 3e 09    	repeat    #0x3e80
	nop
     45c:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     45e:	80 3e 09    	repeat    #0x3e80
	nop
     460:	00 00 00    	nop       
; debounce and test key SAVE
	sl.b	KeyRotors+4
     462:	82 69 d4    	sl.b      0x982
	btsc	PORTA,#3
     464:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+4,#0
     466:	82 09 a8    	bset.b    0x982, #0x0
;	bra	z,key_save	; if SAVE pressed  (* THIS FUNCTION CANCELED *)
; debounce and test key LOAD
	sl.b	KeyRotors+6
     468:	84 69 d4    	sl.b      0x984
	btsc	PORTA,#4
     46a:	64 86 af    	btsc.b    0x664, #0x4
	bset.b	KeyRotors+6,#0
     46c:	84 09 a8    	bset.b    0x984, #0x0
	bra	z,key_load	; if LOAD pressed
     46e:	f3 fe 32    	bra       Z, 0x256 <key_load>
; wait 2 ms and loop 
	repeat	#16000		; 1 ms
     470:	80 3e 09    	repeat    #0x3e80
	nop
     472:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     474:	80 3e 09    	repeat    #0x3e80
	nop
     476:	00 00 00    	nop       
	bra	1b
     478:	ce ff 37    	bra       0x416 <L12>

0000047a <boot_key_save>:

;--------------------------------------------------------------
boot_key_save:



; debounce (DO NOTHING) RESET signal 2 sec first
	btsc	Flag2,#9	; #9 set = last command LOAD
     47a:	df 29 af    	btsc.b    0x9df, #0x1
	bra	6f		; no debouncer for LOAD
     47c:	0e 00 37    	bra       0x49a <L62>

	mov	#0b1111100001111111,w0
     47e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     480:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     482:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     484:	66 26 b7    	ior.w     0x666

	mov	#20,w1		; 2 sec debouncing (doing nothing, just blinking
     486:	41 01 20    	mov.w     #0x14, w1

00000488 <L13>:
1:
	bset	LATC,#8		; anode 17 on
     488:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000-1		; led SAVE ON time	
     48a:	3f 1f 09    	repeat    #0x1f3f
	nop
     48c:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     48e:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#80,w0		; led SAVE OFF timen 80 ms
     490:	00 05 20    	mov.w     #0x50, w0
	call	w0ms2
     492:	40 02 02    	call      0x240 <w0ms2>
     494:	00 00 00 

	dec	w1,w1
     496:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
     498:	f7 ff 3a    	bra       NZ, 0x488 <L13>

0000049a <L62>:
6:
; GO ON BOOT KEY_SAVE









	bset	Flag2,#6	; #6 EE pointers adjust to Boot
     49a:	de c9 a8    	bset.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load/save to/from the first half of Rom area
     49c:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
     49e:	df 29 a9    	bclr.b    0x9df, #0x1
	clr	w10		; w10 Flash Page, step 0x800
     4a0:	00 05 eb    	clr.w     w10

000004a2 <L91>:
9:			  ; \
	mov	w10,w0
     4a2:	0a 00 78    	mov.w     w10, w0
	call	eeload		; firmware 1 ---> Rom 1 (3K bytes + 1K dummy 0's)
     4a4:	46 02 02    	call      0x246 <eeload>
     4a6:	00 00 00 
	add	w10,#24,w0
     4a8:	78 00 45    	add.w     w10, #0x18, w0
	bset	Flag2,#7	; #7 EE load to second halve of Rom area
     4aa:	de e9 a8    	bset.b    0x9de, #0x7
	call	eeload		; firmware 2 ---> Rom 2 (3K bytes + 1K dummy 0's)
     4ac:	46 02 02    	call      0x246 <eeload>
     4ae:	00 00 00 

	mov	w10,w0
     4b0:	0a 00 78    	mov.w     w10, w0
	call	eesavew0	; Rom 2 ---> firmware 1 (3K bytes + 1K dummy 0's)
     4b2:	44 02 02    	call      0x244 <eesavew0>
     4b4:	00 00 00 
	add	w10,#24,w0
     4b6:	78 00 45    	add.w     w10, #0x18, w0
	bclr	Flag2,#7	; #7 EE save from first halve of Rom area
     4b8:	de e9 a9    	bclr.b    0x9de, #0x7
	call	eesavew0	; Rom 1 ---> firmware 2 (3K bytes + 1K dummy 0's)
     4ba:	44 02 02    	call      0x244 <eesavew0>
     4bc:	00 00 00 

	inc	w10,w10
     4be:	0a 05 e8    	inc.w     w10, w10
	cp	w10,#24
     4c0:	78 50 e1    	cp.w      w10, #0x18
	bra	nc,9b	  ;  /
     4c2:	ef ff 39    	bra       NC, 0x4a2 <L91>
	bra	bootload
     4c4:	c6 fe 37    	bra       0x252 <bootload>

000004c6 <boot_key_load>:

;--------------------------------------------------------------
boot_key_load:
	bset	Flag2,#6	; #6 EE subroutines adjust to Boot
     4c6:	de c9 a8    	bset.b    0x9de, #0x6
	bset	Flag2,#7	; #7 EE burn from 2nd halve of Rom area (start @ 0x3000)
     4c8:	de e9 a8    	bset.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
     4ca:	df 29 a8    	bset.b    0x9df, #0x1

; ------------------------------- DMA ------------------------------
; initialize DMA 0
	mov	#0b0000000000000000,w0	; Disabled, Fixed Priority
     4cc:	00 00 20    	mov.w     #0x0, w0
	mov	w0,DMACON		; Bit 15 = DMAEN (DMA Enable)
     4ce:	20 26 88    	mov.w     w0, 0x4c4
	mov	#0b0000001000010110,w0	; reload, SRC fixed, DST++, one-shot, byte mode
     4d0:	60 21 20    	mov.w     #0x216, w0
	mov	w0,DMACH0		; Bit 0: CHEN (Channel Enable)
     4d2:	60 26 88    	mov.w     w0, 0x4cc
	mov	#0b0100010100000000,w0	; Source is UART1 RX Interrupt
     4d4:	00 50 24    	mov.w     #0x4500, w0
	mov	w0,DMAINT0
     4d6:	70 26 88    	mov.w     w0, 0x4ce
	mov	#Rom,w0
     4d8:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMAL		; low limit
     4da:	40 26 88    	mov.w     w0, 0x4c8
	mov	#Rom+0x2000,w0
     4dc:	00 00 24    	mov.w     #0x4000, w0
	mov	w0,DMAH		; high limit
     4de:	50 26 88    	mov.w     w0, 0x4ca
	mov	#U1RXREG,w0
     4e0:	e0 39 20    	mov.w     #0x39e, w0
	mov	w0,DMASRC0	; Source address
     4e2:	80 26 88    	mov.w     w0, 0x4d0
	mov	#Rom,w0
     4e4:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMADST0	; Destination start address
     4e6:	90 26 88    	mov.w     w0, 0x4d2
	mov	#4096,w0
     4e8:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,DMACNT0	; RX block format (1024 instructions)
     4ea:	a0 26 88    	mov.w     w0, 0x4d4
	bset	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     4ec:	c5 e4 a8    	bset.b    0x4c5, #0x7
	bset	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     4ee:	cc 04 a8    	bset.b    0x4cc, #0x0
; initialize peripheral hardware and variables
	bclr	IEC0,#11	; disable RX1 interrupt
     4f0:	99 60 a9    	bclr.b    0x99, #0x3
	call	boot_rxtx_to_io2; RxTx directed to IO connector
     4f2:	ee 05 02    	call      0x5ee <boot_rxtx_to_io2>
     4f4:	00 00 00 
	mov	#0b1111100001111111,w0
     4f6:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     4f8:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     4fa:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     4fc:	66 26 b7    	ior.w     0x666
	clr	w8		; w8 = blink count (#4,#1) about 18 Hz (1 Hz, 8 Hz)
     4fe:	00 04 eb    	clr.w     w8
	mov	DMADST0,w14	; w14 = previous DMADST0
     500:	9e 26 80    	mov.w     0x4d2, w14
	mov	#50000,w13	; w13 = "DMADST changed" counter (0 when no RX data)
     502:	0d 35 2c    	mov.w     #0xc350, w13
	mov	#Rom,w0
     504:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1
     506:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve of Rom to 0xFFFF
     508:	00 98 eb    	setm.w    [w0++]
	mov	#0,w11		; Page burn pointer (×0x800)
     50a:	0b 00 20    	mov.w     #0x0, w11
; main BOOT loop
	mov	#23,w12		; max number of 4K packets (+1 non-complete at end)
     50c:	7c 01 20    	mov.w     #0x17, w12

0000050e <BootLoop>:
BootLoop:		 ; <------------------------------ bootload loop ~20t
	nop
     50e:	00 00 00    	nop       
; test if byte received (in that case set Flag2,#10 and initialize w13 counter)
	mov	DMADST0,w0	; Destination address
     510:	90 26 80    	mov.w     0x4d2, w0
	cp	w0,w14
     512:	0e 00 e1    	cp.w      w0, w14
	bra	z,equal_dst	; if byte not received in this cycle
     514:	03 00 32    	bra       Z, 0x51c <equal_dst>
; byte received, set Flag2,#10 and initialize w13 counter (patience meter)
	bset	Flag2,#10	; #8 set = 1st byte in Bootloader received
     516:	df 49 a8    	bset.b    0x9df, #0x2
	mov	w0,w14		; refresh previous DMADST0
     518:	00 07 78    	mov.w     w0, w14
	mov	#50000,w13
     51a:	0d 35 2c    	mov.w     #0xc350, w13

0000051c <equal_dst>:
equal_dst:
	btss	Flag2,#10	; #8 set = 1st byte in Bootloader received
     51c:	df 49 ae    	btss.b    0x9df, #0x2
	bra	noRXdata	; if no bytes received yet
     51e:	02 00 37    	bra       0x524 <noRXdata>
	dec	w13,w13		; patience counter
     520:	8d 06 e9    	dec.w     w13, w13
	bra	z,bl_lost_patience ; if end of reception (pause detected)
     522:	18 00 32    	bra       Z, 0x554 <bl_lost_patience>

00000524 <noRXdata>:
noRXdata:
	inc	w9,w9		; fast counter
     524:	89 04 e8    	inc.w     w9, w9
	ifz
     526:	42 20 af    	btsc.b    0x42, #0x1
	inc	w8,w8		; slow counter
     528:	08 04 e8    	inc.w     w8, w8
; fast or slow blinking
	mov	#0b0000000011110000,w0
     52a:	00 0f 20    	mov.w     #0xf0, w0
	and	w0,w9,w0
     52c:	09 00 60    	and.w     w0, w9, w0
	bra	nz,9f		; 15 of 16 cycles
     52e:	09 00 3a    	bra       NZ, 0x542 <L92>
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     530:	df 49 af    	btsc.b    0x9df, #0x2
	bra	2f		; if not 1st cycle (1st byte was received)
     532:	03 00 37    	bra       0x53a <L21>
	btss	w8,#3		; bit #4 (slow blinking)
     534:	08 30 a6    	btss.w    w8, #0x3
	bra	8f
     536:	03 00 37    	bra       0x53e <L81>
	bra	7f
     538:	05 00 37    	bra       0x544 <L71>

0000053a <L21>:
2:
	btss	w8,#0		; bit #1 (fast blinking)
     53a:	08 00 a6    	btss.w    w8, #0x0
	bra	9f
     53c:	02 00 37    	bra       0x542 <L92>

0000053e <L81>:
8:
	bset	LATC,#8		; LED LOAD on (1/16 duty cycle)
     53e:	8f 06 a8    	bset.b    0x68f, #0x0
	bra	7f
     540:	01 00 37    	bra       0x544 <L71>

00000542 <L92>:
9:
	bclr	LATC,#8		; LED LOAD off (15/16 duty cycle)
     542:	8f 06 a9    	bclr.b    0x68f, #0x0

00000544 <L71>:
7:
	btss	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     544:	ce a4 ae    	btss.b    0x4ce, #0x5
	bra	BootLoop ; ------------------------------> bootload loop
     546:	e3 ff 37    	bra       0x50e <BootLoop>
; Operation Completed, 1st halve of Rom received 4K bytes via UART
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     548:	ce a4 a9    	bclr.b    0x4ce, #0x5
	dec	w12,w12
     54a:	0c 06 e9    	dec.w     w12, w12
	bra	z,bl_lost_patience ; number of received bytes overflow
     54c:	03 00 32    	bra       Z, 0x554 <bl_lost_patience>
	call	burn1k		; burn 1 K block received
     54e:	4e 02 02    	call      0x24e <burn1k>
     550:	00 00 00 
	bra	BootLoop ; --------> bootload loop after one 1K instr segment written
     552:	dd ff 37    	bra       0x50e <BootLoop>

00000554 <bl_lost_patience>:
;------------------------
bl_lost_patience:
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     554:	ce a4 a9    	bclr.b    0x4ce, #0x5
	bclr	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     556:	c5 e4 a9    	bclr.b    0x4c5, #0x7
	bclr	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     558:	cc 04 a9    	bclr.b    0x4cc, #0x0
	call	burn1k		; burn last block received, even incomplete
     55a:	4e 02 02    	call      0x24e <burn1k>
     55c:	00 00 00 
	bra	bootload	; end of reception (pause detected)
     55e:	79 fe 37    	bra       0x252 <bootload>

00000560 <boot_initialize>:
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	

boot_initialize:
	bclr	INTCON2,#GIE		; global int disable
     560:	83 e0 a9    	bclr.b    0x83, #0x7

; -------------------------------------	; --- oscilator -----------------------
	mov	#0b0000000100000000,w0	; FRC with PLL, /1, PLL always active
     562:	00 10 20    	mov.w     #0x100, w0
	mov	w0,CLKDIV
     564:	10 08 88    	mov.w     w0, 0x102

; -------------------------------------	; --- REMAPABLE PINS ------------------
	mov	#25,w0			; RP25 PORT_C9...
     566:	90 01 20    	mov.w     #0x19, w0
	mov.b	WREG,RPINR0+1		; ...to Ext_Int_1
     568:	91 e7 b7    	mov.b     WREG, 0x791

	mov	#26,w0			; RP26 PORT  (A0)... (0x3f to disable RX input)
     56a:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18		; ...to U1_RX
     56c:	b4 e7 b7    	mov.b     WREG, 0x7b4
;	mov	#6,w0			; RP6  PORT  (B6)...  (0x3f to disable RX input)
;	mov.b	WREG,RPINR18		; ...to U1_RX
; both pins can be Tx (why not?)
	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
     56e:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR13+1		; ...to RP27 (A1)
     570:	ef e7 b7    	mov.b     WREG, 0x7ef
;	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
;	mov.b	WREG,RPOR3+1		; ...to RP7  (B7)

; -------------------------------------	; --- TIMERS --------------------------
	mov	#0b0010000000010000,w0	; stops in sleep mode, prescaler = 1:8
     572:	00 01 22    	mov.w     #0x2010, w0
	mov	w0,T1CON		; TIMER 1 = 3300 Hz (display matrix rfsh)
     574:	a0 0c 88    	mov.w     w0, 0x194
	mov	#514-40-1,w0		; heartbeat def period 16M/8/514=3888Hz, /16=243Hz
     576:	90 1d 20    	mov.w     #0x1d9, w0
	mov	w0,PR1
     578:	90 0c 88    	mov.w     w0, 0x192

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (CLOCK period)
     57a:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T2CON		; TIMER 2 = instruction clock (no interrupt, IFS0,#7 only!)
     57c:	00 0d 88    	mov.w     w0, 0x1a0
	mov	#10-1,w0		; instruction def period
     57e:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR2
     580:	e0 0c 88    	mov.w     w0, 0x19c

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (SYNC period)
     582:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T3CON		; TIMER 3 = user's sync (interrupt only sets RdFlags,#0)
     584:	10 0d 88    	mov.w     w0, 0x1a2
	mov	#10-1,w0		; sync def period
     586:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR3
     588:	f0 0c 88    	mov.w     w0, 0x19e

; -------------------------------------	; --- UART -----------------------------
	mov	#0b0010100000001000,w0	; BRGH=1, UART disabled, RTS/CTS disabled, BRGH set
     58a:	80 80 22    	mov.w     #0x2808, w0
	mov	w0,U1MODE		; UART1 je za infrared
     58c:	c0 1c 88    	mov.w     w0, 0x398
	mov	#0b0000000000000000,w0	; TX idle mode = high
     58e:	00 00 20    	mov.w     #0x0, w0
	mov	w0,U1STAL
     590:	d0 1c 88    	mov.w     w0, 0x39a
	mov	#417-1,w0		; 16 M / 4 / 417 = 9600 Baud
     592:	00 1a 20    	mov.w     #0x1a0, w0
	mov	w0,U1BRG
     594:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
     596:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#URXEN		; enable RX 1 (must be after UART enable)
     598:	9b 83 a8    	bset.b    0x39b, #0x4
	bset	U1STAL,#UTXEN		; enable TX 1 (must be after UART enable)
     59a:	9b 43 a8    	bset.b    0x39b, #0x2

; ------------------------------------- ; --- INTERRUPTS -----------------------
	bclr	RCON,#SWDTEN		; disable WDT
     59c:	10 a1 a9    	bclr.b    0x110, #0x5
	bset	INTCON1,#NSTDIS		; disable interrupt nesting
     59e:	81 e0 a8    	bset.b    0x81, #0x7

; -------------------------------------	; --- PORTS ----------------------------
	clr	ANSA
     5a0:	6a 26 ef    	clr.w     0x66a
	clr	ANSB
     5a2:	7e 26 ef    	clr.w     0x67e
	clr	ANSC
     5a4:	92 26 ef    	clr.w     0x692

	mov	#0b0000000000011100,w0	; pull-ups
     5a6:	c0 01 20    	mov.w     #0x1c, w0
	mov	w0,IOCPUA
     5a8:	90 33 88    	mov.w     w0, 0x672
	mov	#0b0000001000000000,w0	; pull-ups
     5aa:	00 20 20    	mov.w     #0x200, w0
	mov	w0,IOCPUC
     5ac:	d0 34 88    	mov.w     w0, 0x69a

	mov	#0b0000000000000110,w0
     5ae:	60 00 20    	mov.w     #0x6, w0
	mov	w0,LATA
     5b0:	30 33 88    	mov.w     w0, 0x666
	mov	#0b0000000011110000,w0
     5b2:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,LATB
     5b4:	d0 33 88    	mov.w     w0, 0x67a
	mov	#0b0000000000000000,w0
     5b6:	00 00 20    	mov.w     #0x0, w0
	mov	w0,LATC
     5b8:	70 34 88    	mov.w     w0, 0x68e
	mov	#0b0000000000011101,w0
     5ba:	d0 01 20    	mov.w     #0x1d, w0
	mov	w0,TRISA
     5bc:	10 33 88    	mov.w     w0, 0x662
	mov	#0b0000000011110000,w0
     5be:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,TRISB
     5c0:	b0 33 88    	mov.w     w0, 0x676
	mov	#0b0000001000000000,w0
     5c2:	00 20 20    	mov.w     #0x200, w0
	mov	w0,TRISC
     5c4:	50 34 88    	mov.w     w0, 0x68a
	return
     5c6:	00 00 06    	return    

000005c8 <boot_set_decoder_to_w1>:

;------------------------------------------------------------------------------------
;-----------------------------  S U B S  --------------------------------------------
;------------------------------------------------------------------------------------

boot_set_decoder_to_w1:
	mov	#0b1111100001111111,w0
     5c8:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     5ca:	66 26 b6    	and.w     0x666
	sl	w1,#7,w0
     5cc:	47 08 dd    	sl.w      w1, #0x7, w0
	ior	LATA		; decoder state is at LATA,#7...#10 control
     5ce:	66 26 b7    	ior.w     0x666
	inc	w1,w1
     5d0:	81 00 e8    	inc.w     w1, w1
	return
     5d2:	00 00 06    	return    

000005d4 <rotate_ram>:

rotate_ram:
	mov	#0x0F0F,w0
     5d4:	f0 f0 20    	mov.w     #0xf0f, w0
	mov	#Ram+0,w1
     5d6:	01 80 20    	mov.w     #0x800, w1
	mov	#16,w2
     5d8:	02 01 20    	mov.w     #0x10, w2

000005da <L22>:
2:
	lsr	[w1],[w1]	; (skips this line without NOP)
     5da:	91 08 d1    	lsr.w     [w1], [w1]
	btsc	[w1],#0
     5dc:	11 00 a7    	btsc.w    [w1], #0x0
	bset	[w1],#3
     5de:	11 30 a0    	bset.w    [w1], #0x3
	btsc	[w1],#8
     5e0:	11 80 a7    	btsc.w    [w1], #0x8
	bset	[w1],#11
     5e2:	11 b0 a0    	bset.w    [w1], #0xb
	and	w0,[w1],[w1++]
     5e4:	91 18 60    	and.w     w0, [w1], [w1++]
	nop			; * * *   MCU BUG FIX  ???   * * *
     5e6:	00 00 00    	nop       
	dec	w2,w2
     5e8:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b
     5ea:	f7 ff 3a    	bra       NZ, 0x5da <L22>
	return
     5ec:	00 00 06    	return    

000005ee <boot_rxtx_to_io2>:

;										
;-------
boot_rxtx_to_io2:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
     5ee:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
     5f0:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
     5f2:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
     5f4:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
     5f6:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
     5f8:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
     5fa:	de 69 a8    	bset.b    0x9de, #0x3
	bset	U1MODE,#15		; enable UART 1
     5fc:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
     5fe:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
     600:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
     602:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
     604:	f0 4d 88    	mov.w     w0, 0x9be
	return
     606:	00 00 06    	return    

00000608 <boot_w0ms2>:
;------------------------------------------------------------------------
boot_w0ms2:
	repeat	#16000-1
     608:	7f 3e 09    	repeat    #0x3e7f
	nop
     60a:	00 00 00    	nop       
	dec	w0,w0
     60c:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms2
     60e:	18 fe 3a    	bra       NZ, 0x240 <w0ms2>
	return
     610:	00 00 06    	return    

00000612 <boot_eecalc_addr_w0>:

;-----------------------------------------------------------------------------
;----------------------                              -------------------------
;----------------------        EE SUBROUTINES        -------------------------
;----------------------                              -------------------------
;-----------------------------------------------------------------------------

boot_eecalc_addr_w0:	; USER PROGRAM SAVE/LOAD (8K=0x2000 by blocks, 0x1A000...)
			; w0 × 0x1000 + 0x1A000 ----> w6:w7 (end must be < 2AFFE)
			; one record 0x1000 bytes, start 0x1A000, end 0x2A000
	btsc	Flag2,#6	; #6 EE subroutines adjust to Boot
     612:	de c9 af    	btsc.b    0x9de, #0x6
	bra	eecalc_page
     614:	07 00 37    	bra       0x624 <eecalc_page>
	mov	#0x1000,w1
     616:	01 00 21    	mov.w     #0x1000, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x1000
     618:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0xA000,w0
     61a:	00 00 2a    	mov.w     #0xa000, w0
	mov	#0x0001,w1	; w0:w1 = 0x0001:A000 start of 1st flash save block
     61c:	11 00 20    	mov.w     #0x1, w1
	add	w6,w0,w6
     61e:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     620:	81 83 4b    	addc.w    w7, w1, w7
	return
     622:	00 00 06    	return    

00000624 <eecalc_page>:
;-----------------------
eecalc_page:		; BOOTLOAD (4K=0x800 by blocks, 0x1000,0x1800...)
			; w0 × 0x800 + 0x1000 ---> w6:w7 (one record 0x800 = 2K by)
			; w0 = page, 0...23 (for Firmware Backup, w0 = 24...47)
	mov	#0x800,w1
     624:	01 80 20    	mov.w     #0x800, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x800
     626:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0x1000,w0
     628:	00 00 21    	mov.w     #0x1000, w0
	mov	#0x0000,w1	; w0:w1 = 0x0000:1000 start of 1st flash save block
     62a:	01 00 20    	mov.w     #0x0, w1
	add	w6,w0,w6
     62c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     62e:	81 83 4b    	addc.w    w7, w1, w7
	return
     630:	00 00 06    	return    

00000632 <boot_eesavew0>:
;----------------------------------------------------------------------------------
boot_eesavew0:		; data (@Rom) ----> flash w0
	call	eecalc_addr_w0
     632:	42 02 02    	call      0x242 <eecalc_addr_w0>
     634:	00 00 00 
	bclr	INTCON2,#GIE	; global int disable
     636:	83 e0 a9    	bclr.b    0x83, #0x7
	clr.b	LATC		; all LEDS off
     638:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     63a:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; anode 17 off
     63c:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#0b1111100001111111,w0
     63e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     640:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     642:	00 68 20    	mov.w     #0x680, w0
	btsc	Flag2,#9	; #9 set = last command LOAD
     644:	df 29 af    	btsc.b    0x9df, #0x1
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     646:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 13 or 14 (there is led SAVE or LOAD)
     648:	66 26 b7    	ior.w     0x666
	push.d	w6	   ; \    w6, w7
     64a:	86 9f be    	mov.d     w6, [w15++]
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     64c:	4c 02 02    	call      0x24c <eeerase_1K>
     64e:	00 00 00 
	btss	Flag2,#6	; only one page for BOOT !
     650:	de c9 ae    	btss.b    0x9de, #0x6
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     652:	4c 02 02    	call      0x24c <eeerase_1K>
     654:	00 00 00 
	pop.d	w6	   ; /    w6, w7
     656:	4f 03 be    	mov.d     [--w15], w6
	mov	#Rom,w2
     658:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE save from 2nd halve of Rom area (starting at 0x3000)
     65a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     65c:	02 00 23    	mov.w     #0x3000, w2
	mov	#16,w8		; 16× for User's Program Save (4K chunks)
     65e:	08 01 20    	mov.w     #0x10, w8
	btsc	Flag2,#6
     660:	de c9 af    	btsc.b    0x9de, #0x6
	mov	#8,w8		; only 8× for BOOT ! (2K chunks)
     662:	88 00 20    	mov.w     #0x8, w8

00000664 <L82>:
8:                        ; <----------
	call	eeburn_128	; burn
     664:	4a 02 02    	call      0x24a <eeburn_128>
     666:	00 00 00 
	btss	Flag2,#6	; #6 EE Boot
     668:	de c9 ae    	btss.b    0x9de, #0x6
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     66a:	df 49 af    	btsc.b    0x9df, #0x2
	bset	LATC,#8		; anode 17 on
     66c:	8f 06 a8    	bset.b    0x68f, #0x0

	inc	Dummy
     66e:	b0 29 ec    	inc.w     0x9b0
	mov	Dummy,w0
     670:	80 4d 80    	mov.w     0x9b0, w0
	and	#15,w0
     672:	f0 00 b2    	and.w     #0xf, w0
	bra	nz,7f
     674:	02 00 3a    	bra       NZ, 0x67a <L72>

	repeat	#8000-1		; led SAVE ON time	
     676:	3f 1f 09    	repeat    #0x1f3f
	nop
     678:	00 00 00    	nop       

0000067a <L72>:
7:
	bclr	LATC,#8		; anode 17 off
     67a:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#5,w0		; led SAVE OFF time	
     67c:	50 00 20    	mov.w     #0x5, w0
	call	w0ms2
     67e:	40 02 02    	call      0x240 <w0ms2>
     680:	00 00 00 
	dec.b	w8,w8
     682:	08 44 e9    	dec.b     w8, w8
	bra	nz,8b     ; ---------->
     684:	ef ff 3a    	bra       NZ, 0x664 <L82>
	clr	TBLPAG
     686:	54 20 ef    	clr.w     0x54
	btss	Flag2,#6	; #6 EE Boot mode
     688:	de c9 ae    	btss.b    0x9de, #0x6
	bset	INTCON2,#GIE	; global int enable
     68a:	83 e0 a8    	bset.b    0x83, #0x7
	mov	#0x1000,w0
     68c:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,NVMCON
     68e:	00 3b 88    	mov.w     w0, 0x760
	return
     690:	00 00 06    	return    

00000692 <boot_eeload>:

;---------------------------------------------------------------------------
boot_eeload:		; flash (w0×0x1000+0x1A000 or w0×0x800+0x1000) --> data (Rom or Rom+0x1000)
	call	eecalc_addr_w0
     692:	42 02 02    	call      0x242 <eecalc_addr_w0>
     694:	00 00 00 
	mov	w7,TBLPAG
     696:	a7 02 88    	mov.w     w7, 0x54
	mov	#Rom,w2
     698:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE load to second halve of Rom area (start at 0x3000)
     69a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     69c:	02 00 23    	mov.w     #0x3000, w2
	btsc	Flag2,#6
     69e:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_read_bootload
     6a0:	13 00 37    	bra       0x6c8 <case_read_bootload>
	mov	#0x800,w3	; 2048×24 bits for User's Program Load
     6a2:	03 80 20    	mov.w     #0x800, w3

000006a4 <L31>:
3:			;  <---- RD WR ----------------------------------
	tblrdh.b [w6],w1	; 8    w1 = high 2n xxxx xxxx BA98 ba98	
     6a4:	96 c0 ba    	tblrdh.b  [w6], w1
	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6a6:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6a8:	00 80 fd    	swap.w    w0
	mov.b	w1,w0		;      w0 = low by  7654 3210 BA98 ba98	
     6aa:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF ba98 (complemented data)
     6ac:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF ba98 7654 3210	
     6ae:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 1st program word		
     6b0:	00 19 78    	mov.w     w0, [w2++]

	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6b2:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6b4:	00 80 fd    	swap.w    w0
	swap.b	w1		;      w1 = high 2n xxxx xxxx ba98 BA98	
     6b6:	01 c0 fd    	swap.b    w1
	mov.b	w1,w0		;      w0 = low by  7654 3210 ba98 BA98	
     6b8:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF BA98 (complemented data)
     6ba:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF BA98 7654 3210	
     6bc:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 2nd program word		
     6be:	00 19 78    	mov.w     w0, [w2++]

	dec	w3,w3
     6c0:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; ---------------------------------------------->
     6c2:	f0 ff 3a    	bra       NZ, 0x6a4 <L31>
	clr	TBLPAG
     6c4:	54 20 ef    	clr.w     0x54
	return
     6c6:	00 00 06    	return    

000006c8 <case_read_bootload>:
;			
case_read_bootload:
	mov	#0x400,w3	; only 1024×24 bits for Boot !
     6c8:	03 40 20    	mov.w     #0x400, w3

000006ca <L32>:
3:			; \
	tblrdh.b [w6],w1	; read bits 16-23
     6ca:	96 c0 ba    	tblrdh.b  [w6], w1
	nop
     6cc:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 0-7
     6ce:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d0:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 8-15
     6d2:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d4:	00 00 00    	nop       
	mov.b	w1,[w2++]	; write bits 16-23
     6d6:	01 59 78    	mov.b     w1, [w2++]
	nop
     6d8:	00 00 00    	nop       
	clr.b	[w2++]		; skip 4th dummy byte
     6da:	00 59 eb    	clr.b     [w2++]
	nop
     6dc:	00 00 00    	nop       
	dec	w3,w3
     6de:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; /
     6e0:	f4 ff 3a    	bra       NZ, 0x6ca <L32>
	clr	TBLPAG
     6e2:	54 20 ef    	clr.w     0x54
	return
     6e4:	00 00 06    	return    

000006e6 <boot_eemeasure>:

;-------------------------------
boot_eemeasure:		; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
     6e6:	de c9 a9    	bclr.b    0x9de, #0x6
	call	eecalc_addr_w0	; w6:w7
     6e8:	42 02 02    	call      0x242 <eecalc_addr_w0>
     6ea:	00 00 00 
	mov	w7,TBLPAG
     6ec:	a7 02 88    	mov.w     w7, 0x54
	mov	#0x8,w3		; w3 loop counter, 8 steps, 0x200 words = 1 bit ea
     6ee:	83 00 20    	mov.w     #0x8, w3
	mov	#0,w2		; w2 measured occupance (8 bits)
     6f0:	02 00 20    	mov.w     #0x0, w2

000006f2 <L33>:
3:			   ; \
	mov	#0x100,w4	; w4 inner loop counter
     6f2:	04 10 20    	mov.w     #0x100, w4
	setm	w1
     6f4:	80 80 eb    	setm.w    w1

000006f6 <L41>:
4:			   ; \\
	tblrdh.b [w6],w0	; w1 = high 2n xxxx xxxx BA98 ba98
     6f6:	16 c0 ba    	tblrdh.b  [w6], w0
	and.b	w1,w0,w1
     6f8:	80 c0 60    	and.b     w1, w0, w1
	tblrdl [w6++],w0	; w0 = low by  7654 3210 7654 3210
     6fa:	36 00 ba    	tblrdl.w  [w6++], w0
	and	w1,w0,w1
     6fc:	80 80 60    	and.w     w1, w0, w1
	dec	w4,w4
     6fe:	04 02 e9    	dec.w     w4, w4
	bra	nz,4b	   ; //
     700:	fa ff 3a    	bra       NZ, 0x6f6 <L41>
	sl	w2,w2
     702:	02 01 d0    	sl.w      w2, w2
	inc	w1,w1
     704:	81 00 e8    	inc.w     w1, w1
	ifnz
     706:	42 20 ae    	btss.b    0x42, #0x1
	bset	w2,#0
     708:	02 00 a0    	bset.w    w2, #0x0
	dec	w3,w3
     70a:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	   ; /
     70c:	f2 ff 3a    	bra       NZ, 0x6f2 <L33>
	clr	TBLPAG
     70e:	54 20 ef    	clr.w     0x54
	return
     710:	00 00 06    	return    

00000712 <boot_eeerase_1K>:

; ------------------------------ PAGE ERASE -----------------------------
boot_eeerase_1K:	; erase block of 1K instructions (2K user pgm bytes + 1K high)
	mov	#0x5003,w0
     712:	30 00 25    	mov.w     #0x5003, w0
	mov	w0,NVMCON
     714:	00 3b 88    	mov.w     w0, 0x760
; Load the address of the page to be erased into the NVMADR register pair
	mov	w6,NVMADR
     716:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     718:	27 3b 88    	mov.w     w7, 0x764
	mov	#0x800,w0
     71a:	00 80 20    	mov.w     #0x800, w0
	add	w6,w0,w6
     71c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,#0,w7
     71e:	e0 83 4b    	addc.w    w7, #0x0, w7
; Set the WR bit
	bra	eeiniseq_128
     720:	17 00 37    	bra       0x750 <eeiniseq_128>

00000722 <boot_eeburn_128>:

; ------------------------------- ROW BURN ------------------------------
boot_eeburn_128:	; burn row of 128 instructions, source ptr w2, dest w6:w7
; Set NVMCON for 128 instruction words (256 user pgm words), rd ptr w2, wr ptr w6:w7
	mov	#0x5002,w0
     722:	20 00 25    	mov.w     #0x5002, w0
	mov	w0,NVMCON
     724:	00 3b 88    	mov.w     w0, 0x760
; Set the NVMADRU/NVMADR reg pair to starting address
	mov	w6,NVMADR
     726:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     728:	27 3b 88    	mov.w     w7, 0x764
	add	#256,w6		; prepare for the next row programming
     72a:	06 10 b0    	add.w     #0x100, w6
	addc	w7,#0,w7
     72c:	e0 83 4b    	addc.w    w7, #0x0, w7
; Initialize the TBLPAG register for writing to the latches
	mov	#0xfa,w0	; pgm latches are mapped at 0xFA0000-0xFA00FE
     72e:	a0 0f 20    	mov.w     #0xfa, w0
	mov	w0,TBLPAG
     730:	a0 02 88    	mov.w     w0, 0x54
	clr	w1		; low address
     732:	80 00 eb    	clr.w     w1
; Set up write data address pointer, W2 point to data in RAM
	mov	#128,w3		; loop counter
     734:	03 08 20    	mov.w     #0x80, w3
	btsc	Flag2,#6	; #6 EE Boot
     736:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_boot
     738:	18 00 37    	bra       0x76a <L42> <case_boot>

0000073a <L34>:
3:			; read 8+4+8+4 data bits, write 8+8+8 bits to latches
			;	 rd wr				
	tblwtl.b [w2++],[w1++]	; 8 8  [w1] = low by  7654 3210
     73a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	ze	[w2++],w4	; 4    w4 = 0000 0000 xxxx ba98
     73c:	32 82 fb    	ze        [w2++], w4
	and	#0x0F,w4	;      w4 = 0000 0000 0000 ba98
     73e:	f4 00 b2    	and.w     #0xf, w4
	tblwtl.b [w2++],[w1--]	; 8 8  [w1] = mid by  7654 3210
     740:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	ze	[w2++],w5	; 4    w5 = 0000 0000 xxxx BA98
     742:	b2 82 fb    	ze        [w2++], w5
	sl	w5,#4,w5	;      w4 = 0000 xxxx BA98 0000
     744:	c4 2a dd    	sl.w      w5, #0x4, w5
	ior	w4,w5,w4	;      w4 = 0000 xxxx BA98 ba98 (low word=low nib)
     746:	05 02 72    	ior.w     w4, w5, w4
	tblwth.b w4,[w1]	;   8  [w1] = high 2n BA98 ba98
     748:	84 c8 bb    	tblwth.b  w4, [w1]
	inc2	w1,w1
     74a:	81 80 e8    	inc2.w    w1, w1
	dec	w3,w3
     74c:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b
     74e:	f5 ff 3a    	bra       NZ, 0x73a <L34>

00000750 <eeiniseq_128>:
; Set the WR bit
eeiniseq_128:
	disi	#5		; DI for next 5 instructions
     750:	05 00 fc    	disi      #0x5
	mov.b	#0x55,w0
     752:	50 c5 b3    	mov.b     #0x55, w0
	mov	w0,NVMKEY	; Write the 1st key
     754:	30 3b 88    	mov.w     w0, 0x766
	mov.b	#0xAA,w0
     756:	a0 ca b3    	mov.b     #0xaa, w0
	mov	w0,NVMKEY	; Write the 2nd key
     758:	30 3b 88    	mov.w     w0, 0x766
	bset	NVMCON,#WR	; Start the programming sequence
     75a:	61 e7 a8    	bset.b    0x761, #0x7
	...
	nop			; Required delay
	nop			; Required delay
	nop			; Required delay
	btsc	NVMCON,#15	; and wait for it to be completed
     762:	61 e7 af    	btsc.b    0x761, #0x7

00000764 <L0>:
	bra	$-2
     764:	fe ff 37    	bra       0x762
	clr	TBLPAG
     766:	54 20 ef    	clr.w     0x54
	return
     768:	00 00 06    	return    

0000076a <L42>:
;	
case_boot:
4:			; read 8+8+8 data bits + skip, write 8+8+8 bits to latches
	tblwtl.b [w2++],[w1++]	; bits 0-7
     76a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	nop
     76c:	00 00 00    	nop       
	tblwtl.b [w2++],[w1--]	; bits 8-15
     76e:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	nop
     770:	00 00 00    	nop       
	tblwth.b [w2++],[w1]	; bits 16-23
     772:	b2 c8 bb    	tblwth.b  [w2++], [w1]
	nop
     774:	00 00 00    	nop       
	inc2	w1,w1		; write ptr +2
     776:	81 80 e8    	inc2.w    w1, w1
	inc	w2,w2		; skip 4th dummy byte
     778:	02 01 e8    	inc.w     w2, w2
	dec	w3,w3
     77a:	83 01 e9    	dec.w     w3, w3
	bra	nz,4b
     77c:	f6 ff 3a    	bra       NZ, 0x76a <L42> <case_boot>
; Set the WR bit
	bra	eeiniseq_128
     77e:	e8 ff 37    	bra       0x750 <eeiniseq_128>

00000780 <boot_burn1k>:
;------------------------------------------------------------------------
boot_burn1k:		; burn 1K instructions, 3K bytes + 1K dummy 0's
	mov	#Rom,w0
     780:	00 00 22    	mov.w     #0x2000, w0
	mov	#Rom+0x1000,w1
     782:	01 00 23    	mov.w     #0x3000, w1
	repeat	#0x800-1	; 2048 ×
     784:	ff 07 09    	repeat    #0x7ff
	mov	[w0++],[w1++]	; move 4K bytes from Rom 1st halve to 2nd halve
     786:	b0 18 78    	mov.w     [w0++], [w1++]
	mov	#Rom,w0
     788:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1	; 2048 ×
     78a:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve
     78c:	00 98 eb    	setm.w    [w0++]
	mov	w11,w0
     78e:	0b 00 78    	mov.w     w11, w0
	call	eesavew0	; burn 1024 instructions (×24 bits) from Rom 2nd halve
     790:	44 02 02    	call      0x244 <eesavew0>
     792:	00 00 00 
	inc	w11,w11
     794:	8b 05 e8    	inc.w     w11, w11
	return
     796:	00 00 06    	return    
     798:	ff ff 00    	nop       
     79a:	ff ff 00    	nop       
     79c:	ff ff 00    	nop       
     79e:	ff ff 00    	nop       
     7a0:	ff ff 00    	nop       
     7a2:	ff ff 00    	nop       
     7a4:	ff ff 00    	nop       
     7a6:	ff ff 00    	nop       
     7a8:	ff ff 00    	nop       
     7aa:	ff ff 00    	nop       
     7ac:	ff ff 00    	nop       
     7ae:	ff ff 00    	nop       
     7b0:	ff ff 00    	nop       
     7b2:	ff ff 00    	nop       
     7b4:	ff ff 00    	nop       
     7b6:	ff ff 00    	nop       
     7b8:	ff ff 00    	nop       
     7ba:	ff ff 00    	nop       
     7bc:	ff ff 00    	nop       
     7be:	ff ff 00    	nop       
     7c0:	ff ff 00    	nop       
     7c2:	ff ff 00    	nop       
     7c4:	ff ff 00    	nop       
     7c6:	ff ff 00    	nop       
     7c8:	ff ff 00    	nop       
     7ca:	ff ff 00    	nop       
     7cc:	ff ff 00    	nop       
     7ce:	ff ff 00    	nop       
     7d0:	ff ff 00    	nop       
     7d2:	ff ff 00    	nop       
     7d4:	ff ff 00    	nop       
     7d6:	ff ff 00    	nop       
     7d8:	ff ff 00    	nop       
     7da:	ff ff 00    	nop       
     7dc:	ff ff 00    	nop       
     7de:	ff ff 00    	nop       
     7e0:	ff ff 00    	nop       
     7e2:	ff ff 00    	nop       
     7e4:	ff ff 00    	nop       
     7e6:	ff ff 00    	nop       
     7e8:	ff ff 00    	nop       
     7ea:	ff ff 00    	nop       
     7ec:	ff ff 00    	nop       
     7ee:	ff ff 00    	nop       
     7f0:	ff ff 00    	nop       
     7f2:	ff ff 00    	nop       
     7f4:	ff ff 00    	nop       
     7f6:	ff ff 00    	nop       
     7f8:	ff ff 00    	nop       
     7fa:	ff ff 00    	nop       
     7fc:	ff ff 00    	nop       
     7fe:	ff ff 00    	nop       
     800:	ff ff 00    	nop       
     802:	ff ff 00    	nop       
     804:	ff ff 00    	nop       
     806:	ff ff 00    	nop       
     808:	ff ff 00    	nop       
     80a:	ff ff 00    	nop       
     80c:	ff ff 00    	nop       
     80e:	ff ff 00    	nop       
     810:	ff ff 00    	nop       
     812:	ff ff 00    	nop       
     814:	ff ff 00    	nop       
     816:	ff ff 00    	nop       
     818:	ff ff 00    	nop       
     81a:	ff ff 00    	nop       
     81c:	ff ff 00    	nop       
     81e:	ff ff 00    	nop       
     820:	ff ff 00    	nop       
     822:	ff ff 00    	nop       
     824:	ff ff 00    	nop       
     826:	ff ff 00    	nop       
     828:	ff ff 00    	nop       
     82a:	ff ff 00    	nop       
     82c:	ff ff 00    	nop       
     82e:	ff ff 00    	nop       
     830:	ff ff 00    	nop       
     832:	ff ff 00    	nop       
     834:	ff ff 00    	nop       
     836:	ff ff 00    	nop       
     838:	ff ff 00    	nop       
     83a:	ff ff 00    	nop       
     83c:	ff ff 00    	nop       
     83e:	ff ff 00    	nop       
     840:	ff ff 00    	nop       
     842:	ff ff 00    	nop       
     844:	ff ff 00    	nop       
     846:	ff ff 00    	nop       
     848:	ff ff 00    	nop       
     84a:	ff ff 00    	nop       
     84c:	ff ff 00    	nop       
     84e:	ff ff 00    	nop       
     850:	ff ff 00    	nop       
     852:	ff ff 00    	nop       
     854:	ff ff 00    	nop       
     856:	ff ff 00    	nop       
     858:	ff ff 00    	nop       
     85a:	ff ff 00    	nop       
     85c:	ff ff 00    	nop       
     85e:	ff ff 00    	nop       
     860:	ff ff 00    	nop       
     862:	ff ff 00    	nop       
     864:	ff ff 00    	nop       
     866:	ff ff 00    	nop       
     868:	ff ff 00    	nop       
     86a:	ff ff 00    	nop       
     86c:	ff ff 00    	nop       
     86e:	ff ff 00    	nop       
     870:	ff ff 00    	nop       
     872:	ff ff 00    	nop       
     874:	ff ff 00    	nop       
     876:	ff ff 00    	nop       
     878:	ff ff 00    	nop       
     87a:	ff ff 00    	nop       
     87c:	ff ff 00    	nop       
     87e:	ff ff 00    	nop       
     880:	ff ff 00    	nop       
     882:	ff ff 00    	nop       
     884:	ff ff 00    	nop       
     886:	ff ff 00    	nop       
     888:	ff ff 00    	nop       
     88a:	ff ff 00    	nop       
     88c:	ff ff 00    	nop       
     88e:	ff ff 00    	nop       
     890:	ff ff 00    	nop       
     892:	ff ff 00    	nop       
     894:	ff ff 00    	nop       
     896:	ff ff 00    	nop       
     898:	ff ff 00    	nop       
     89a:	ff ff 00    	nop       
     89c:	ff ff 00    	nop       
     89e:	ff ff 00    	nop       
     8a0:	ff ff 00    	nop       
     8a2:	ff ff 00    	nop       
     8a4:	ff ff 00    	nop       
     8a6:	ff ff 00    	nop       
     8a8:	ff ff 00    	nop       
     8aa:	ff ff 00    	nop       
     8ac:	ff ff 00    	nop       
     8ae:	ff ff 00    	nop       
     8b0:	ff ff 00    	nop       
     8b2:	ff ff 00    	nop       
     8b4:	ff ff 00    	nop       
     8b6:	ff ff 00    	nop       
     8b8:	ff ff 00    	nop       
     8ba:	ff ff 00    	nop       
     8bc:	ff ff 00    	nop       
     8be:	ff ff 00    	nop       
     8c0:	ff ff 00    	nop       
     8c2:	ff ff 00    	nop       
     8c4:	ff ff 00    	nop       
     8c6:	ff ff 00    	nop       
     8c8:	ff ff 00    	nop       
     8ca:	ff ff 00    	nop       
     8cc:	ff ff 00    	nop       
     8ce:	ff ff 00    	nop       
     8d0:	ff ff 00    	nop       
     8d2:	ff ff 00    	nop       
     8d4:	ff ff 00    	nop       
     8d6:	ff ff 00    	nop       
     8d8:	ff ff 00    	nop       
     8da:	ff ff 00    	nop       
     8dc:	ff ff 00    	nop       
     8de:	ff ff 00    	nop       
     8e0:	ff ff 00    	nop       
     8e2:	ff ff 00    	nop       
     8e4:	ff ff 00    	nop       
     8e6:	ff ff 00    	nop       
     8e8:	ff ff 00    	nop       
     8ea:	ff ff 00    	nop       
     8ec:	ff ff 00    	nop       
     8ee:	ff ff 00    	nop       
     8f0:	ff ff 00    	nop       
     8f2:	ff ff 00    	nop       
     8f4:	ff ff 00    	nop       
     8f6:	ff ff 00    	nop       
     8f8:	ff ff 00    	nop       
     8fa:	ff ff 00    	nop       
     8fc:	ff ff 00    	nop       
     8fe:	ff ff 00    	nop       
     900:	ff ff 00    	nop       
     902:	ff ff 00    	nop       
     904:	ff ff 00    	nop       
     906:	ff ff 00    	nop       
     908:	ff ff 00    	nop       
     90a:	ff ff 00    	nop       
     90c:	ff ff 00    	nop       
     90e:	ff ff 00    	nop       
     910:	ff ff 00    	nop       
     912:	ff ff 00    	nop       
     914:	ff ff 00    	nop       
     916:	ff ff 00    	nop       
     918:	ff ff 00    	nop       
     91a:	ff ff 00    	nop       
     91c:	ff ff 00    	nop       
     91e:	ff ff 00    	nop       
     920:	ff ff 00    	nop       
     922:	ff ff 00    	nop       
     924:	ff ff 00    	nop       
     926:	ff ff 00    	nop       
     928:	ff ff 00    	nop       
     92a:	ff ff 00    	nop       
     92c:	ff ff 00    	nop       
     92e:	ff ff 00    	nop       
     930:	ff ff 00    	nop       
     932:	ff ff 00    	nop       
     934:	ff ff 00    	nop       
     936:	ff ff 00    	nop       
     938:	ff ff 00    	nop       
     93a:	ff ff 00    	nop       
     93c:	ff ff 00    	nop       
     93e:	ff ff 00    	nop       
     940:	ff ff 00    	nop       
     942:	ff ff 00    	nop       
     944:	ff ff 00    	nop       
     946:	ff ff 00    	nop       
     948:	ff ff 00    	nop       
     94a:	ff ff 00    	nop       
     94c:	ff ff 00    	nop       
     94e:	ff ff 00    	nop       
     950:	ff ff 00    	nop       
     952:	ff ff 00    	nop       
     954:	ff ff 00    	nop       
     956:	ff ff 00    	nop       
     958:	ff ff 00    	nop       
     95a:	ff ff 00    	nop       
     95c:	ff ff 00    	nop       
     95e:	ff ff 00    	nop       
     960:	ff ff 00    	nop       
     962:	ff ff 00    	nop       
     964:	ff ff 00    	nop       
     966:	ff ff 00    	nop       
     968:	ff ff 00    	nop       
     96a:	ff ff 00    	nop       
     96c:	ff ff 00    	nop       
     96e:	ff ff 00    	nop       
     970:	ff ff 00    	nop       
     972:	ff ff 00    	nop       
     974:	ff ff 00    	nop       
     976:	ff ff 00    	nop       
     978:	ff ff 00    	nop       
     97a:	ff ff 00    	nop       
     97c:	ff ff 00    	nop       
     97e:	ff ff 00    	nop       
     980:	ff ff 00    	nop       
     982:	ff ff 00    	nop       
     984:	ff ff 00    	nop       
     986:	ff ff 00    	nop       
     988:	ff ff 00    	nop       
     98a:	ff ff 00    	nop       
     98c:	ff ff 00    	nop       
     98e:	ff ff 00    	nop       
     990:	ff ff 00    	nop       
     992:	ff ff 00    	nop       
     994:	ff ff 00    	nop       
     996:	ff ff 00    	nop       
     998:	ff ff 00    	nop       
     99a:	ff ff 00    	nop       
     99c:	ff ff 00    	nop       
     99e:	ff ff 00    	nop       
     9a0:	ff ff 00    	nop       
     9a2:	ff ff 00    	nop       
     9a4:	ff ff 00    	nop       
     9a6:	ff ff 00    	nop       
     9a8:	ff ff 00    	nop       
     9aa:	ff ff 00    	nop       
     9ac:	ff ff 00    	nop       
     9ae:	ff ff 00    	nop       
     9b0:	ff ff 00    	nop       
     9b2:	ff ff 00    	nop       
     9b4:	ff ff 00    	nop       
     9b6:	ff ff 00    	nop       
     9b8:	ff ff 00    	nop       
     9ba:	ff ff 00    	nop       
     9bc:	ff ff 00    	nop       
     9be:	ff ff 00    	nop       
     9c0:	ff ff 00    	nop       
     9c2:	ff ff 00    	nop       
     9c4:	ff ff 00    	nop       
     9c6:	ff ff 00    	nop       
     9c8:	ff ff 00    	nop       
     9ca:	ff ff 00    	nop       
     9cc:	ff ff 00    	nop       
     9ce:	ff ff 00    	nop       
     9d0:	ff ff 00    	nop       
     9d2:	ff ff 00    	nop       
     9d4:	ff ff 00    	nop       
     9d6:	ff ff 00    	nop       
     9d8:	ff ff 00    	nop       
     9da:	ff ff 00    	nop       
     9dc:	ff ff 00    	nop       
     9de:	ff ff 00    	nop       
     9e0:	ff ff 00    	nop       
     9e2:	ff ff 00    	nop       
     9e4:	ff ff 00    	nop       
     9e6:	ff ff 00    	nop       
     9e8:	ff ff 00    	nop       
     9ea:	ff ff 00    	nop       
     9ec:	ff ff 00    	nop       
     9ee:	ff ff 00    	nop       
     9f0:	ff ff 00    	nop       
     9f2:	ff ff 00    	nop       
     9f4:	ff ff 00    	nop       
     9f6:	ff ff 00    	nop       
     9f8:	ff ff 00    	nop       
     9fa:	ff ff 00    	nop       
     9fc:	ff ff 00    	nop       
     9fe:	ff ff 00    	nop       
     a00:	ff ff 00    	nop       
     a02:	ff ff 00    	nop       
     a04:	ff ff 00    	nop       
     a06:	ff ff 00    	nop       
     a08:	ff ff 00    	nop       
     a0a:	ff ff 00    	nop       
     a0c:	ff ff 00    	nop       
     a0e:	ff ff 00    	nop       
     a10:	ff ff 00    	nop       
     a12:	ff ff 00    	nop       
     a14:	ff ff 00    	nop       
     a16:	ff ff 00    	nop       
     a18:	ff ff 00    	nop       
     a1a:	ff ff 00    	nop       
     a1c:	ff ff 00    	nop       
     a1e:	ff ff 00    	nop       
     a20:	ff ff 00    	nop       
     a22:	ff ff 00    	nop       
     a24:	ff ff 00    	nop       
     a26:	ff ff 00    	nop       
     a28:	ff ff 00    	nop       
     a2a:	ff ff 00    	nop       
     a2c:	ff ff 00    	nop       
     a2e:	ff ff 00    	nop       
     a30:	ff ff 00    	nop       
     a32:	ff ff 00    	nop       
     a34:	ff ff 00    	nop       
     a36:	ff ff 00    	nop       
     a38:	ff ff 00    	nop       
     a3a:	ff ff 00    	nop       
     a3c:	ff ff 00    	nop       
     a3e:	ff ff 00    	nop       
     a40:	ff ff 00    	nop       
     a42:	ff ff 00    	nop       
     a44:	ff ff 00    	nop       
     a46:	ff ff 00    	nop       
     a48:	ff ff 00    	nop       
     a4a:	ff ff 00    	nop       
     a4c:	ff ff 00    	nop       
     a4e:	ff ff 00    	nop       
     a50:	ff ff 00    	nop       
     a52:	ff ff 00    	nop       
     a54:	ff ff 00    	nop       
     a56:	ff ff 00    	nop       
     a58:	ff ff 00    	nop       
     a5a:	ff ff 00    	nop       
     a5c:	ff ff 00    	nop       
     a5e:	ff ff 00    	nop       
     a60:	ff ff 00    	nop       
     a62:	ff ff 00    	nop       
     a64:	ff ff 00    	nop       
     a66:	ff ff 00    	nop       
     a68:	ff ff 00    	nop       
     a6a:	ff ff 00    	nop       
     a6c:	ff ff 00    	nop       
     a6e:	ff ff 00    	nop       
     a70:	ff ff 00    	nop       
     a72:	ff ff 00    	nop       
     a74:	ff ff 00    	nop       
     a76:	ff ff 00    	nop       
     a78:	ff ff 00    	nop       
     a7a:	ff ff 00    	nop       
     a7c:	ff ff 00    	nop       
     a7e:	ff ff 00    	nop       
     a80:	ff ff 00    	nop       
     a82:	ff ff 00    	nop       
     a84:	ff ff 00    	nop       
     a86:	ff ff 00    	nop       
     a88:	ff ff 00    	nop       
     a8a:	ff ff 00    	nop       
     a8c:	ff ff 00    	nop       
     a8e:	ff ff 00    	nop       
     a90:	ff ff 00    	nop       
     a92:	ff ff 00    	nop       
     a94:	ff ff 00    	nop       
     a96:	ff ff 00    	nop       
     a98:	ff ff 00    	nop       
     a9a:	ff ff 00    	nop       
     a9c:	ff ff 00    	nop       
     a9e:	ff ff 00    	nop       
     aa0:	ff ff 00    	nop       
     aa2:	ff ff 00    	nop       
     aa4:	ff ff 00    	nop       
     aa6:	ff ff 00    	nop       
     aa8:	ff ff 00    	nop       
     aaa:	ff ff 00    	nop       
     aac:	ff ff 00    	nop       
     aae:	ff ff 00    	nop       
     ab0:	ff ff 00    	nop       
     ab2:	ff ff 00    	nop       
     ab4:	ff ff 00    	nop       
     ab6:	ff ff 00    	nop       
     ab8:	ff ff 00    	nop       
     aba:	ff ff 00    	nop       
     abc:	ff ff 00    	nop       
     abe:	ff ff 00    	nop       
     ac0:	ff ff 00    	nop       
     ac2:	ff ff 00    	nop       
     ac4:	ff ff 00    	nop       
     ac6:	ff ff 00    	nop       
     ac8:	ff ff 00    	nop       
     aca:	ff ff 00    	nop       
     acc:	ff ff 00    	nop       
     ace:	ff ff 00    	nop       
     ad0:	ff ff 00    	nop       
     ad2:	ff ff 00    	nop       
     ad4:	ff ff 00    	nop       
     ad6:	ff ff 00    	nop       
     ad8:	ff ff 00    	nop       
     ada:	ff ff 00    	nop       
     adc:	ff ff 00    	nop       
     ade:	ff ff 00    	nop       
     ae0:	ff ff 00    	nop       
     ae2:	ff ff 00    	nop       
     ae4:	ff ff 00    	nop       
     ae6:	ff ff 00    	nop       
     ae8:	ff ff 00    	nop       
     aea:	ff ff 00    	nop       
     aec:	ff ff 00    	nop       
     aee:	ff ff 00    	nop       
     af0:	ff ff 00    	nop       
     af2:	ff ff 00    	nop       
     af4:	ff ff 00    	nop       
     af6:	ff ff 00    	nop       
     af8:	ff ff 00    	nop       
     afa:	ff ff 00    	nop       
     afc:	ff ff 00    	nop       
     afe:	ff ff 00    	nop       
     b00:	ff ff 00    	nop       
     b02:	ff ff 00    	nop       
     b04:	ff ff 00    	nop       
     b06:	ff ff 00    	nop       
     b08:	ff ff 00    	nop       
     b0a:	ff ff 00    	nop       
     b0c:	ff ff 00    	nop       
     b0e:	ff ff 00    	nop       
     b10:	ff ff 00    	nop       
     b12:	ff ff 00    	nop       
     b14:	ff ff 00    	nop       
     b16:	ff ff 00    	nop       
     b18:	ff ff 00    	nop       
     b1a:	ff ff 00    	nop       
     b1c:	ff ff 00    	nop       
     b1e:	ff ff 00    	nop       
     b20:	ff ff 00    	nop       
     b22:	ff ff 00    	nop       
     b24:	ff ff 00    	nop       
     b26:	ff ff 00    	nop       
     b28:	ff ff 00    	nop       
     b2a:	ff ff 00    	nop       
     b2c:	ff ff 00    	nop       
     b2e:	ff ff 00    	nop       
     b30:	ff ff 00    	nop       
     b32:	ff ff 00    	nop       
     b34:	ff ff 00    	nop       
     b36:	ff ff 00    	nop       
     b38:	ff ff 00    	nop       
     b3a:	ff ff 00    	nop       
     b3c:	ff ff 00    	nop       
     b3e:	ff ff 00    	nop       
     b40:	ff ff 00    	nop       
     b42:	ff ff 00    	nop       
     b44:	ff ff 00    	nop       
     b46:	ff ff 00    	nop       
     b48:	ff ff 00    	nop       
     b4a:	ff ff 00    	nop       
     b4c:	ff ff 00    	nop       
     b4e:	ff ff 00    	nop       
     b50:	ff ff 00    	nop       
     b52:	ff ff 00    	nop       
     b54:	ff ff 00    	nop       
     b56:	ff ff 00    	nop       
     b58:	ff ff 00    	nop       
     b5a:	ff ff 00    	nop       
     b5c:	ff ff 00    	nop       
     b5e:	ff ff 00    	nop       
     b60:	ff ff 00    	nop       
     b62:	ff ff 00    	nop       
     b64:	ff ff 00    	nop       
     b66:	ff ff 00    	nop       
     b68:	ff ff 00    	nop       
     b6a:	ff ff 00    	nop       
     b6c:	ff ff 00    	nop       
     b6e:	ff ff 00    	nop       
     b70:	ff ff 00    	nop       
     b72:	ff ff 00    	nop       
     b74:	ff ff 00    	nop       
     b76:	ff ff 00    	nop       
     b78:	ff ff 00    	nop       
     b7a:	ff ff 00    	nop       
     b7c:	ff ff 00    	nop       
     b7e:	ff ff 00    	nop       
     b80:	ff ff 00    	nop       
     b82:	ff ff 00    	nop       
     b84:	ff ff 00    	nop       
     b86:	ff ff 00    	nop       
     b88:	ff ff 00    	nop       
     b8a:	ff ff 00    	nop       
     b8c:	ff ff 00    	nop       
     b8e:	ff ff 00    	nop       
     b90:	ff ff 00    	nop       
     b92:	ff ff 00    	nop       
     b94:	ff ff 00    	nop       
     b96:	ff ff 00    	nop       
     b98:	ff ff 00    	nop       
     b9a:	ff ff 00    	nop       
     b9c:	ff ff 00    	nop       
     b9e:	ff ff 00    	nop       
     ba0:	ff ff 00    	nop       
     ba2:	ff ff 00    	nop       
     ba4:	ff ff 00    	nop       
     ba6:	ff ff 00    	nop       
     ba8:	ff ff 00    	nop       
     baa:	ff ff 00    	nop       
     bac:	ff ff 00    	nop       
     bae:	ff ff 00    	nop       
     bb0:	ff ff 00    	nop       
     bb2:	ff ff 00    	nop       
     bb4:	ff ff 00    	nop       
     bb6:	ff ff 00    	nop       
     bb8:	ff ff 00    	nop       
     bba:	ff ff 00    	nop       
     bbc:	ff ff 00    	nop       
     bbe:	ff ff 00    	nop       
     bc0:	ff ff 00    	nop       
     bc2:	ff ff 00    	nop       
     bc4:	ff ff 00    	nop       
     bc6:	ff ff 00    	nop       
     bc8:	ff ff 00    	nop       
     bca:	ff ff 00    	nop       
     bcc:	ff ff 00    	nop       
     bce:	ff ff 00    	nop       
     bd0:	ff ff 00    	nop       
     bd2:	ff ff 00    	nop       
     bd4:	ff ff 00    	nop       
     bd6:	ff ff 00    	nop       
     bd8:	ff ff 00    	nop       
     bda:	ff ff 00    	nop       
     bdc:	ff ff 00    	nop       
     bde:	ff ff 00    	nop       
     be0:	ff ff 00    	nop       
     be2:	ff ff 00    	nop       
     be4:	ff ff 00    	nop       
     be6:	ff ff 00    	nop       
     be8:	ff ff 00    	nop       
     bea:	ff ff 00    	nop       
     bec:	ff ff 00    	nop       
     bee:	ff ff 00    	nop       
     bf0:	ff ff 00    	nop       
     bf2:	ff ff 00    	nop       
     bf4:	ff ff 00    	nop       
     bf6:	ff ff 00    	nop       
     bf8:	ff ff 00    	nop       
     bfa:	ff ff 00    	nop       
     bfc:	ff ff 00    	nop       
     bfe:	ff ff 00    	nop       
     c00:	ff ff 00    	nop       
     c02:	ff ff 00    	nop       
     c04:	ff ff 00    	nop       
     c06:	ff ff 00    	nop       
     c08:	ff ff 00    	nop       
     c0a:	ff ff 00    	nop       
     c0c:	ff ff 00    	nop       
     c0e:	ff ff 00    	nop       
     c10:	ff ff 00    	nop       
     c12:	ff ff 00    	nop       
     c14:	ff ff 00    	nop       
     c16:	ff ff 00    	nop       
     c18:	ff ff 00    	nop       
     c1a:	ff ff 00    	nop       
     c1c:	ff ff 00    	nop       
     c1e:	ff ff 00    	nop       
     c20:	ff ff 00    	nop       
     c22:	ff ff 00    	nop       
     c24:	ff ff 00    	nop       
     c26:	ff ff 00    	nop       
     c28:	ff ff 00    	nop       
     c2a:	ff ff 00    	nop       
     c2c:	ff ff 00    	nop       
     c2e:	ff ff 00    	nop       
     c30:	ff ff 00    	nop       
     c32:	ff ff 00    	nop       
     c34:	ff ff 00    	nop       
     c36:	ff ff 00    	nop       
     c38:	ff ff 00    	nop       
     c3a:	ff ff 00    	nop       
     c3c:	ff ff 00    	nop       
     c3e:	ff ff 00    	nop       
     c40:	ff ff 00    	nop       
     c42:	ff ff 00    	nop       
     c44:	ff ff 00    	nop       
     c46:	ff ff 00    	nop       
     c48:	ff ff 00    	nop       
     c4a:	ff ff 00    	nop       
     c4c:	ff ff 00    	nop       
     c4e:	ff ff 00    	nop       
     c50:	ff ff 00    	nop       
     c52:	ff ff 00    	nop       
     c54:	ff ff 00    	nop       
     c56:	ff ff 00    	nop       
     c58:	ff ff 00    	nop       
     c5a:	ff ff 00    	nop       
     c5c:	ff ff 00    	nop       
     c5e:	ff ff 00    	nop       
     c60:	ff ff 00    	nop       
     c62:	ff ff 00    	nop       
     c64:	ff ff 00    	nop       
     c66:	ff ff 00    	nop       
     c68:	ff ff 00    	nop       
     c6a:	ff ff 00    	nop       
     c6c:	ff ff 00    	nop       
     c6e:	ff ff 00    	nop       
     c70:	ff ff 00    	nop       
     c72:	ff ff 00    	nop       
     c74:	ff ff 00    	nop       
     c76:	ff ff 00    	nop       
     c78:	ff ff 00    	nop       
     c7a:	ff ff 00    	nop       
     c7c:	ff ff 00    	nop       
     c7e:	ff ff 00    	nop       
     c80:	ff ff 00    	nop       
     c82:	ff ff 00    	nop       
     c84:	ff ff 00    	nop       
     c86:	ff ff 00    	nop       
     c88:	ff ff 00    	nop       
     c8a:	ff ff 00    	nop       
     c8c:	ff ff 00    	nop       
     c8e:	ff ff 00    	nop       
     c90:	ff ff 00    	nop       
     c92:	ff ff 00    	nop       
     c94:	ff ff 00    	nop       
     c96:	ff ff 00    	nop       
     c98:	ff ff 00    	nop       
     c9a:	ff ff 00    	nop       
     c9c:	ff ff 00    	nop       
     c9e:	ff ff 00    	nop       
     ca0:	ff ff 00    	nop       
     ca2:	ff ff 00    	nop       
     ca4:	ff ff 00    	nop       
     ca6:	ff ff 00    	nop       
     ca8:	ff ff 00    	nop       
     caa:	ff ff 00    	nop       
     cac:	ff ff 00    	nop       
     cae:	ff ff 00    	nop       
     cb0:	ff ff 00    	nop       
     cb2:	ff ff 00    	nop       
     cb4:	ff ff 00    	nop       
     cb6:	ff ff 00    	nop       
     cb8:	ff ff 00    	nop       
     cba:	ff ff 00    	nop       
     cbc:	ff ff 00    	nop       
     cbe:	ff ff 00    	nop       
     cc0:	ff ff 00    	nop       
     cc2:	ff ff 00    	nop       
     cc4:	ff ff 00    	nop       
     cc6:	ff ff 00    	nop       
     cc8:	ff ff 00    	nop       
     cca:	ff ff 00    	nop       
     ccc:	ff ff 00    	nop       
     cce:	ff ff 00    	nop       
     cd0:	ff ff 00    	nop       
     cd2:	ff ff 00    	nop       
     cd4:	ff ff 00    	nop       
     cd6:	ff ff 00    	nop       
     cd8:	ff ff 00    	nop       
     cda:	ff ff 00    	nop       
     cdc:	ff ff 00    	nop       
     cde:	ff ff 00    	nop       
     ce0:	ff ff 00    	nop       
     ce2:	ff ff 00    	nop       
     ce4:	ff ff 00    	nop       
     ce6:	ff ff 00    	nop       
     ce8:	ff ff 00    	nop       
     cea:	ff ff 00    	nop       
     cec:	ff ff 00    	nop       
     cee:	ff ff 00    	nop       
     cf0:	ff ff 00    	nop       
     cf2:	ff ff 00    	nop       
     cf4:	ff ff 00    	nop       
     cf6:	ff ff 00    	nop       
     cf8:	ff ff 00    	nop       
     cfa:	ff ff 00    	nop       
     cfc:	ff ff 00    	nop       
     cfe:	ff ff 00    	nop       
     d00:	ff ff 00    	nop       
     d02:	ff ff 00    	nop       
     d04:	ff ff 00    	nop       
     d06:	ff ff 00    	nop       
     d08:	ff ff 00    	nop       
     d0a:	ff ff 00    	nop       
     d0c:	ff ff 00    	nop       
     d0e:	ff ff 00    	nop       
     d10:	ff ff 00    	nop       
     d12:	ff ff 00    	nop       
     d14:	ff ff 00    	nop       
     d16:	ff ff 00    	nop       
     d18:	ff ff 00    	nop       
     d1a:	ff ff 00    	nop       
     d1c:	ff ff 00    	nop       
     d1e:	ff ff 00    	nop       
     d20:	ff ff 00    	nop       
     d22:	ff ff 00    	nop       
     d24:	ff ff 00    	nop       
     d26:	ff ff 00    	nop       
     d28:	ff ff 00    	nop       
     d2a:	ff ff 00    	nop       
     d2c:	ff ff 00    	nop       
     d2e:	ff ff 00    	nop       
     d30:	ff ff 00    	nop       
     d32:	ff ff 00    	nop       
     d34:	ff ff 00    	nop       
     d36:	ff ff 00    	nop       
     d38:	ff ff 00    	nop       
     d3a:	ff ff 00    	nop       
     d3c:	ff ff 00    	nop       
     d3e:	ff ff 00    	nop       
     d40:	ff ff 00    	nop       
     d42:	ff ff 00    	nop       
     d44:	ff ff 00    	nop       
     d46:	ff ff 00    	nop       
     d48:	ff ff 00    	nop       
     d4a:	ff ff 00    	nop       
     d4c:	ff ff 00    	nop       
     d4e:	ff ff 00    	nop       
     d50:	ff ff 00    	nop       
     d52:	ff ff 00    	nop       
     d54:	ff ff 00    	nop       
     d56:	ff ff 00    	nop       
     d58:	ff ff 00    	nop       
     d5a:	ff ff 00    	nop       
     d5c:	ff ff 00    	nop       
     d5e:	ff ff 00    	nop       
     d60:	ff ff 00    	nop       
     d62:	ff ff 00    	nop       
     d64:	ff ff 00    	nop       
     d66:	ff ff 00    	nop       
     d68:	ff ff 00    	nop       
     d6a:	ff ff 00    	nop       
     d6c:	ff ff 00    	nop       
     d6e:	ff ff 00    	nop       
     d70:	ff ff 00    	nop       
     d72:	ff ff 00    	nop       
     d74:	ff ff 00    	nop       
     d76:	ff ff 00    	nop       
     d78:	ff ff 00    	nop       
     d7a:	ff ff 00    	nop       
     d7c:	ff ff 00    	nop       
     d7e:	ff ff 00    	nop       
     d80:	ff ff 00    	nop       
     d82:	ff ff 00    	nop       
     d84:	ff ff 00    	nop       
     d86:	ff ff 00    	nop       
     d88:	ff ff 00    	nop       
     d8a:	ff ff 00    	nop       
     d8c:	ff ff 00    	nop       
     d8e:	ff ff 00    	nop       
     d90:	ff ff 00    	nop       
     d92:	ff ff 00    	nop       
     d94:	ff ff 00    	nop       
     d96:	ff ff 00    	nop       
     d98:	ff ff 00    	nop       
     d9a:	ff ff 00    	nop       
     d9c:	ff ff 00    	nop       
     d9e:	ff ff 00    	nop       
     da0:	ff ff 00    	nop       
     da2:	ff ff 00    	nop       
     da4:	ff ff 00    	nop       
     da6:	ff ff 00    	nop       
     da8:	ff ff 00    	nop       
     daa:	ff ff 00    	nop       
     dac:	ff ff 00    	nop       
     dae:	ff ff 00    	nop       
     db0:	ff ff 00    	nop       
     db2:	ff ff 00    	nop       
     db4:	ff ff 00    	nop       
     db6:	ff ff 00    	nop       
     db8:	ff ff 00    	nop       
     dba:	ff ff 00    	nop       
     dbc:	ff ff 00    	nop       
     dbe:	ff ff 00    	nop       
     dc0:	ff ff 00    	nop       
     dc2:	ff ff 00    	nop       
     dc4:	ff ff 00    	nop       
     dc6:	ff ff 00    	nop       
     dc8:	ff ff 00    	nop       
     dca:	ff ff 00    	nop       
     dcc:	ff ff 00    	nop       
     dce:	ff ff 00    	nop       
     dd0:	ff ff 00    	nop       
     dd2:	ff ff 00    	nop       
     dd4:	ff ff 00    	nop       
     dd6:	ff ff 00    	nop       
     dd8:	ff ff 00    	nop       
     dda:	ff ff 00    	nop       
     ddc:	ff ff 00    	nop       
     dde:	ff ff 00    	nop       
     de0:	ff ff 00    	nop       
     de2:	ff ff 00    	nop       
     de4:	ff ff 00    	nop       
     de6:	ff ff 00    	nop       
     de8:	ff ff 00    	nop       
     dea:	ff ff 00    	nop       
     dec:	ff ff 00    	nop       
     dee:	ff ff 00    	nop       
     df0:	ff ff 00    	nop       
     df2:	ff ff 00    	nop       
     df4:	ff ff 00    	nop       
     df6:	ff ff 00    	nop       
     df8:	ff ff 00    	nop       
     dfa:	ff ff 00    	nop       
     dfc:	ff ff 00    	nop       
     dfe:	ff ff 00    	nop       
     e00:	ff ff 00    	nop       
     e02:	ff ff 00    	nop       
     e04:	ff ff 00    	nop       
     e06:	ff ff 00    	nop       
     e08:	ff ff 00    	nop       
     e0a:	ff ff 00    	nop       
     e0c:	ff ff 00    	nop       
     e0e:	ff ff 00    	nop       
     e10:	ff ff 00    	nop       
     e12:	ff ff 00    	nop       
     e14:	ff ff 00    	nop       
     e16:	ff ff 00    	nop       
     e18:	ff ff 00    	nop       
     e1a:	ff ff 00    	nop       
     e1c:	ff ff 00    	nop       
     e1e:	ff ff 00    	nop       
     e20:	ff ff 00    	nop       
     e22:	ff ff 00    	nop       
     e24:	ff ff 00    	nop       
     e26:	ff ff 00    	nop       
     e28:	ff ff 00    	nop       
     e2a:	ff ff 00    	nop       
     e2c:	ff ff 00    	nop       
     e2e:	ff ff 00    	nop       
     e30:	ff ff 00    	nop       
     e32:	ff ff 00    	nop       
     e34:	ff ff 00    	nop       
     e36:	ff ff 00    	nop       
     e38:	ff ff 00    	nop       
     e3a:	ff ff 00    	nop       
     e3c:	ff ff 00    	nop       
     e3e:	ff ff 00    	nop       
     e40:	ff ff 00    	nop       
     e42:	ff ff 00    	nop       
     e44:	ff ff 00    	nop       
     e46:	ff ff 00    	nop       
     e48:	ff ff 00    	nop       
     e4a:	ff ff 00    	nop       
     e4c:	ff ff 00    	nop       
     e4e:	ff ff 00    	nop       
     e50:	ff ff 00    	nop       
     e52:	ff ff 00    	nop       
     e54:	ff ff 00    	nop       
     e56:	ff ff 00    	nop       
     e58:	ff ff 00    	nop       
     e5a:	ff ff 00    	nop       
     e5c:	ff ff 00    	nop       
     e5e:	ff ff 00    	nop       
     e60:	ff ff 00    	nop       
     e62:	ff ff 00    	nop       
     e64:	ff ff 00    	nop       
     e66:	ff ff 00    	nop       
     e68:	ff ff 00    	nop       
     e6a:	ff ff 00    	nop       
     e6c:	ff ff 00    	nop       
     e6e:	ff ff 00    	nop       
     e70:	ff ff 00    	nop       
     e72:	ff ff 00    	nop       
     e74:	ff ff 00    	nop       
     e76:	ff ff 00    	nop       
     e78:	ff ff 00    	nop       
     e7a:	ff ff 00    	nop       
     e7c:	ff ff 00    	nop       
     e7e:	ff ff 00    	nop       
     e80:	ff ff 00    	nop       
     e82:	ff ff 00    	nop       
     e84:	ff ff 00    	nop       
     e86:	ff ff 00    	nop       
     e88:	ff ff 00    	nop       
     e8a:	ff ff 00    	nop       
     e8c:	ff ff 00    	nop       
     e8e:	ff ff 00    	nop       
     e90:	ff ff 00    	nop       
     e92:	ff ff 00    	nop       
     e94:	ff ff 00    	nop       
     e96:	ff ff 00    	nop       
     e98:	ff ff 00    	nop       
     e9a:	ff ff 00    	nop       
     e9c:	ff ff 00    	nop       
     e9e:	ff ff 00    	nop       
     ea0:	ff ff 00    	nop       
     ea2:	ff ff 00    	nop       
     ea4:	ff ff 00    	nop       
     ea6:	ff ff 00    	nop       
     ea8:	ff ff 00    	nop       
     eaa:	ff ff 00    	nop       
     eac:	ff ff 00    	nop       
     eae:	ff ff 00    	nop       
     eb0:	ff ff 00    	nop       
     eb2:	ff ff 00    	nop       
     eb4:	ff ff 00    	nop       
     eb6:	ff ff 00    	nop       
     eb8:	ff ff 00    	nop       
     eba:	ff ff 00    	nop       
     ebc:	ff ff 00    	nop       
     ebe:	ff ff 00    	nop       
     ec0:	ff ff 00    	nop       
     ec2:	ff ff 00    	nop       
     ec4:	ff ff 00    	nop       
     ec6:	ff ff 00    	nop       
     ec8:	ff ff 00    	nop       
     eca:	ff ff 00    	nop       
     ecc:	ff ff 00    	nop       
     ece:	ff ff 00    	nop       
     ed0:	ff ff 00    	nop       
     ed2:	ff ff 00    	nop       
     ed4:	ff ff 00    	nop       
     ed6:	ff ff 00    	nop       
     ed8:	ff ff 00    	nop       
     eda:	ff ff 00    	nop       
     edc:	ff ff 00    	nop       
     ede:	ff ff 00    	nop       
     ee0:	ff ff 00    	nop       
     ee2:	ff ff 00    	nop       
     ee4:	ff ff 00    	nop       
     ee6:	ff ff 00    	nop       
     ee8:	ff ff 00    	nop       
     eea:	ff ff 00    	nop       
     eec:	ff ff 00    	nop       
     eee:	ff ff 00    	nop       
     ef0:	ff ff 00    	nop       
     ef2:	ff ff 00    	nop       
     ef4:	ff ff 00    	nop       
     ef6:	ff ff 00    	nop       
     ef8:	ff ff 00    	nop       
     efa:	ff ff 00    	nop       
     efc:	ff ff 00    	nop       
     efe:	ff ff 00    	nop       
     f00:	ff ff 00    	nop       
     f02:	ff ff 00    	nop       
     f04:	ff ff 00    	nop       
     f06:	ff ff 00    	nop       
     f08:	ff ff 00    	nop       
     f0a:	ff ff 00    	nop       
     f0c:	ff ff 00    	nop       
     f0e:	ff ff 00    	nop       
     f10:	ff ff 00    	nop       
     f12:	ff ff 00    	nop       
     f14:	ff ff 00    	nop       
     f16:	ff ff 00    	nop       
     f18:	ff ff 00    	nop       
     f1a:	ff ff 00    	nop       
     f1c:	ff ff 00    	nop       
     f1e:	ff ff 00    	nop       
     f20:	ff ff 00    	nop       
     f22:	ff ff 00    	nop       
     f24:	ff ff 00    	nop       
     f26:	ff ff 00    	nop       
     f28:	ff ff 00    	nop       
     f2a:	ff ff 00    	nop       
     f2c:	ff ff 00    	nop       
     f2e:	ff ff 00    	nop       
     f30:	ff ff 00    	nop       
     f32:	ff ff 00    	nop       
     f34:	ff ff 00    	nop       
     f36:	ff ff 00    	nop       
     f38:	ff ff 00    	nop       
     f3a:	ff ff 00    	nop       
     f3c:	ff ff 00    	nop       
     f3e:	ff ff 00    	nop       
     f40:	ff ff 00    	nop       
     f42:	ff ff 00    	nop       
     f44:	ff ff 00    	nop       
     f46:	ff ff 00    	nop       
     f48:	ff ff 00    	nop       
     f4a:	ff ff 00    	nop       
     f4c:	ff ff 00    	nop       
     f4e:	ff ff 00    	nop       
     f50:	ff ff 00    	nop       
     f52:	ff ff 00    	nop       
     f54:	ff ff 00    	nop       
     f56:	ff ff 00    	nop       
     f58:	ff ff 00    	nop       
     f5a:	ff ff 00    	nop       
     f5c:	ff ff 00    	nop       
     f5e:	ff ff 00    	nop       
     f60:	ff ff 00    	nop       
     f62:	ff ff 00    	nop       
     f64:	ff ff 00    	nop       
     f66:	ff ff 00    	nop       
     f68:	ff ff 00    	nop       
     f6a:	ff ff 00    	nop       
     f6c:	ff ff 00    	nop       
     f6e:	ff ff 00    	nop       
     f70:	ff ff 00    	nop       
     f72:	ff ff 00    	nop       
     f74:	ff ff 00    	nop       
     f76:	ff ff 00    	nop       
     f78:	ff ff 00    	nop       
     f7a:	ff ff 00    	nop       
     f7c:	ff ff 00    	nop       
     f7e:	ff ff 00    	nop       
     f80:	ff ff 00    	nop       
     f82:	ff ff 00    	nop       
     f84:	ff ff 00    	nop       
     f86:	ff ff 00    	nop       
     f88:	ff ff 00    	nop       
     f8a:	ff ff 00    	nop       
     f8c:	ff ff 00    	nop       
     f8e:	ff ff 00    	nop       
     f90:	ff ff 00    	nop       
     f92:	ff ff 00    	nop       
     f94:	ff ff 00    	nop       
     f96:	ff ff 00    	nop       
     f98:	ff ff 00    	nop       
     f9a:	ff ff 00    	nop       
     f9c:	ff ff 00    	nop       
     f9e:	ff ff 00    	nop       
     fa0:	ff ff 00    	nop       
     fa2:	ff ff 00    	nop       
     fa4:	ff ff 00    	nop       
     fa6:	ff ff 00    	nop       
     fa8:	ff ff 00    	nop       
     faa:	ff ff 00    	nop       
     fac:	ff ff 00    	nop       
     fae:	ff ff 00    	nop       
     fb0:	ff ff 00    	nop       
     fb2:	ff ff 00    	nop       
     fb4:	ff ff 00    	nop       
     fb6:	ff ff 00    	nop       
     fb8:	ff ff 00    	nop       
     fba:	ff ff 00    	nop       
     fbc:	ff ff 00    	nop       
     fbe:	ff ff 00    	nop       
     fc0:	ff ff 00    	nop       
     fc2:	ff ff 00    	nop       
     fc4:	ff ff 00    	nop       
     fc6:	ff ff 00    	nop       
     fc8:	ff ff 00    	nop       
     fca:	ff ff 00    	nop       
     fcc:	ff ff 00    	nop       
     fce:	ff ff 00    	nop       
     fd0:	ff ff 00    	nop       
     fd2:	ff ff 00    	nop       
     fd4:	ff ff 00    	nop       
     fd6:	ff ff 00    	nop       
     fd8:	ff ff 00    	nop       
     fda:	ff ff 00    	nop       
     fdc:	ff ff 00    	nop       
     fde:	ff ff 00    	nop       
     fe0:	ff ff 00    	nop       
     fe2:	ff ff 00    	nop       
     fe4:	ff ff 00    	nop       
     fe6:	ff ff 00    	nop       
     fe8:	ff ff 00    	nop       
     fea:	ff ff 00    	nop       
     fec:	ff ff 00    	nop       
     fee:	ff ff 00    	nop       
     ff0:	ff ff 00    	nop       
     ff2:	ff ff 00    	nop       
     ff4:	ff ff 00    	nop       
     ff6:	ff ff 00    	nop       
     ff8:	ff ff 00    	nop       
     ffa:	ff ff 00    	nop       
     ffc:	ff ff 00    	nop       
     ffe:	ff ff 00    	nop       
    1000:	47 45 00    	nop       
    1002:	4e 53 00    	nop       

00001004 <ver_data>:
    1004:	01 00 00    	nop       
    1006:	03 00 00    	nop       
    1008:	18 00 00    	nop       
    100a:	08 00 00    	nop       
    100c:	0d 00 00    	nop       

0000100e <__T1Interrupt>:
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	.include	"Boot.inc"
	.include	"flash.inc"

;											
;				0 x 1 0 0 0    (physical)				
;_______________________________________________________________________________________
	.org	0x1000-0x1BE, 0xFF	;   * * *   0x1000 (fill 0xFF's)
; general segment
	.ascii	"GENS"		; general segment start
; Ver/Rev/Year/Month/Day
ver_data:
	.word	Ver
	.word	Rev
	.word	Year
	.word	Month
	.word	Day
; IVT 
.global __T1Interrupt		; must be @ 0x1000
__T1Interrupt:
	goto	T1Int
    100e:	86 29 04    	goto      0x2986 <T1Int>
    1010:	00 00 00 

00001012 <__T3Interrupt>:
.global __T3Interrupt		; must be @ 0x1004
__T3Interrupt:
	goto	T3Int
    1012:	c8 31 04    	goto      0x31c8 <T3Int>
    1014:	00 00 00 

00001016 <_INT1Interrupt>:
.global	_INT1Interrupt		; must be @ 0x1008
_INT1Interrupt:
	goto	INT1Int
    1016:	2c 32 04    	goto      0x322c <INT1Int>
    1018:	00 00 00 

0000101a <_INT2Interrupt>:
.global	_INT2Interrupt		; must be @ 0x100C
_INT2Interrupt:
	goto	INT2Int
    101a:	20 32 04    	goto      0x3220 <INT2Int>
    101c:	00 00 00 

0000101e <__U1RXInterrupt>:
.global __U1RXInterrupt		; must be @ 0x1010
__U1RXInterrupt:
	goto	U1RXInt
    101e:	d0 31 04    	goto      0x31d0 <U1RXInt>
    1020:	00 00 00 

00001022 <__U1ErrInterrupt>:
.global __U1ErrInterrupt	; must be @ 0x1014
__U1ErrInterrupt:
	goto	U1ErrInt
    1022:	14 32 04    	goto      0x3214 <U1ErrInt>
    1024:	00 00 00 

00001026 <__U2RXInterrupt>:
.global __U2RXInterrupt		; must be @ 0x1018
__U2RXInterrupt:
	goto	U2RXInt
    1026:	1c 32 04    	goto      0x321c <U2RXInt>
    1028:	00 00 00 

0000102a <__U2ErrInterrupt>:
.global __U2ErrInterrupt	; must be @ 0x101C
__U2ErrInterrupt:
	goto	U2ErrInt
    102a:	24 32 04    	goto      0x3224 <U2ErrInt>
    102c:	00 00 00 

0000102e <selfcheck_back>:

; **********************************************************************

selfcheck_back:
; ini Mode specific params
	mov	#Ram+11,w8
    102e:	b8 80 20    	mov.w     #0x80b, w8
	mov	#Rom,w9
    1030:	09 00 22    	mov.w     #0x2000, w9
	mov	w9,SSTempPMAddr
    1032:	29 4a 88    	mov.w     w9, 0x944
	mov	w9,RunTempPMAddr
    1034:	a9 4a 88    	mov.w     w9, 0x954
	mov	#Ram,w10
    1036:	0a 80 20    	mov.w     #0x800, w10
	clr	w11
    1038:	80 05 eb    	clr.w     w11
	clr	w12
    103a:	00 06 eb    	clr.w     w12
	clr	w13
    103c:	80 06 eb    	clr.w     w13
	clr	w14
    103e:	00 07 eb    	clr.w     w14
	mov	w9,History_w9
    1040:	19 48 88    	mov.w     w9, 0x902
; ini Rx FIFO
	mov	#RX_buf,w0
    1042:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1044:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1046:	f0 4d 88    	mov.w     w0, 0x9be
; ini function LEDs on Cathode 17
	mov	#0b0000100010001000,w0	; ALU def (Set ALU, SEL, -CLK)
    1048:	80 88 20    	mov.w     #0x888, w0
	mov	w0,A16
    104a:	70 4d 88    	mov.w     w0, 0x9ae
; ini SFR
	mov	#3,w0
    104c:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,SerCtrl
    104e:	f5 e8 b7    	mov.b     WREG, 0x8f5
	call	def_U1BRG
    1050:	c0 27 02    	call      0x27c0 <def_U1BRG>
    1052:	00 00 00 
	call	rxtx_to_rxtxpos
    1054:	f8 27 02    	call      0x27f8 <rxtx_to_rxtxpos>
    1056:	00 00 00 
	call	show_vrymd
    1058:	b4 10 02    	call      0x10b4 <show_vrymd>
    105a:	00 00 00 
; show CHS in the middle of matrix
	mov	#0,w1
    105c:	01 00 20    	mov.w     #0x0, w1
	mov	#0x1000/2,w2
    105e:	02 80 20    	mov.w     #0x800, w2
	mov	#CHS1,w4	; point w4 to CHS1
    1060:	84 9d 20    	mov.w     #0x9d8, w4
	call	get_chs
    1062:	9e 10 02    	call      0x109e <get_chs>
    1064:	00 00 00 
; show CHS in the bottom of matrix
	mov	#0x1000,w1
    1066:	01 00 21    	mov.w     #0x1000, w1
	mov	#tbloffset(pgm_end)-0x1000,w2
    1068:	a2 8e 22    	mov.w     #0x28ea, w2
	lsr	w2,w2		; /2
    106a:	02 01 d1    	lsr.w     w2, w2
	mov	#CHS2,w4	; point w4 to CHS2
    106c:	a4 9d 20    	mov.w     #0x9da, w4
	call	get_chs
    106e:	9e 10 02    	call      0x109e <get_chs>
    1070:	00 00 00 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	bset	Flag2,#4	; #4 set when initialized
    1072:	de 89 a8    	bset.b    0x9de, #0x4
	call	peek_flash	; record flash occupance  (37 ms)
    1074:	40 17 02    	call      0x1740 <peek_flash>
    1076:	00 00 00 
; -----------------------------
; ini perif
	clr	TMR1
    1078:	90 21 ef    	clr.w     0x190
	clr	TMR2
    107a:	96 21 ef    	clr.w     0x196
	clr	TMR3
    107c:	9a 21 ef    	clr.w     0x19a
	bset	T1CON,#TON	; LED multiplex timer on
    107e:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON
    1080:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON
    1082:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    1084:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    1086:	99 00 a8    	bset.b    0x99, #0x0
	bset	IEC0,#11	; enable RX1 interrupt
    1088:	99 60 a8    	bset.b    0x99, #0x3
	bset	IEC4,#1		; enable RX1 Error Interrupt
    108a:	a0 20 a8    	bset.b    0xa0, #0x1
	bset	INTCON2,#GIE	; global interrupt enable
    108c:	83 e0 a8    	bset.b    0x83, #0x7

0000108e <main_farm>:

;------------------------------------------------------------------------
;------------------------------------------------------------------------
;---------------------------   F A R M   --------------------------------
;------------------------------------------------------------------------
;------------------------------------------------------------------------

main_farm:
	bra	alu_ept
    108e:	2c 00 37    	bra       0x10e8 <alu_ept>

00001090 <txword>:

;											
txword:				; TX w0_low, w0_high
	call	txbyte
    1090:	96 10 02    	call      0x1096 <txbyte>
    1092:	00 00 00 
	swap	w0
    1094:	00 80 fd    	swap.w    w0

00001096 <txbyte>:
txbyte:				; TX w0
	btsc	U1STA,#UTXBF
    1096:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	txbyte
    1098:	fe ff 37    	bra       0x1096 <txbyte>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    109a:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    109c:	00 00 06    	return    

0000109e <get_chs>:

;											
get_chs:		; pointer w1, length (in words) w2, CHS in w3 on exit, wr ptr w4
	clr	w3
    109e:	80 01 eb    	clr.w     w3

000010a0 <chs_loop>:
chs_loop:
	tblrdh.b [w1],w0
    10a0:	11 c0 ba    	tblrdh.b  [w1], w0
	ze	w0,w0
    10a2:	00 80 fb    	ze        w0, w0
	add	w0,w3,w3
    10a4:	83 01 40    	add.w     w0, w3, w3
	tblrdl	[w1++],w0
    10a6:	31 00 ba    	tblrdl.w  [w1++], w0
	add	w0,w3,w3
    10a8:	83 01 40    	add.w     w0, w3, w3
	dec	w2,w2
    10aa:	02 01 e9    	dec.w     w2, w2
	bra	nz,chs_loop
    10ac:	f9 ff 3a    	bra       NZ, 0x10a0 <chs_loop>
; CHS is in w3
	swap	w3	; because display routine shows in little endian, should be big
    10ae:	03 80 fd    	swap.w    w3
	mov	w3,[w4]
    10b0:	03 0a 78    	mov.w     w3, [w4]
	return
    10b2:	00 00 06    	return    

000010b4 <show_vrymd>:

;-----------------------
show_vrymd:	; show Ver/Rev/Year/Month/Day
	mov	#Ram+0,w1
    10b4:	01 80 20    	mov.w     #0x800, w1
	mov	#tbloffset(ver_data),w3
    10b6:	43 00 21    	mov.w     #0x1004, w3
	call	vrymd
    10b8:	c8 10 02    	call      0x10c8 <vrymd>
    10ba:	00 00 00 
	call	vrymd
    10bc:	c8 10 02    	call      0x10c8 <vrymd>
    10be:	00 00 00 
	call	vrymd
    10c0:	c8 10 02    	call      0x10c8 <vrymd>
    10c2:	00 00 00 
	call	vrymd
    10c4:	c8 10 02    	call      0x10c8 <vrymd>
    10c6:	00 00 00 

000010c8 <vrymd>:
vrymd:			; Ver / Rev / Year / Month / Day
	tblrdl	[w3++],w2
    10c8:	33 01 ba    	tblrdl.w  [w3++], w2
	and	w2,#0xF,w0
    10ca:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	w0,[w1]
    10cc:	80 48 78    	mov.b     w0, [w1]
	lsr	w2,#4,w0
    10ce:	44 10 de    	lsr.w     w2, #0x4, w0
	mov.b	w0,[w1+16]
    10d0:	80 50 98    	mov.b     w0, [w1+16]
	inc	w1,w1
    10d2:	81 00 e8    	inc.w     w1, w1
	return
    10d4:	00 00 06    	return    

000010d6 <clr_ram>:
;-----------------------
clr_ram:
	mov	#Ram,w0
    10d6:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clear all exept SFR
    10d8:	77 00 09    	repeat    #0x77
	clr	[w0++]
    10da:	00 18 eb    	clr.w     [w0++]
	return
    10dc:	00 00 06    	return    

000010de <w0ms>:
;------------------------------------------------------------------------
w0ms:
	repeat	#16000-1
    10de:	7f 3e 09    	repeat    #0x3e7f
	nop
    10e0:	00 00 00    	nop       
	dec	w0,w0
    10e2:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms
    10e4:	fc ff 3a    	bra       NZ, 0x10de <w0ms>
	return
    10e6:	00 00 06    	return    

000010e8 <alu_ept>:

alu_ept:	; <-------------------------------------------
; prepare A16 (set ALU and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    10e8:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    10ea:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000100000001000,w0	; set ALU and -CLK
    10ec:	80 80 20    	mov.w     #0x808, w0
	ior	A16
    10ee:	ae 29 b7    	ior.w     0x9ae
; restore ALU params
	mov	AluTempOpcode,w0
    10f0:	90 49 80    	mov.w     0x932, w0
	mov	w0,Opcode	; Opcode
    10f2:	10 49 88    	mov.w     w0, 0x922
	mov	AluTempOperX,w0
    10f4:	a0 49 80    	mov.w     0x934, w0
	mov	w0,OperX	; OperX
    10f6:	20 49 88    	mov.w     w0, 0x924
	mov	AluTempOperY,w0
    10f8:	b0 49 80    	mov.w     0x936, w0
	mov	w0,OperY	; OperY
    10fa:	30 49 88    	mov.w     w0, 0x926
	mov	AluTempAtemp,w0
    10fc:	c0 49 80    	mov.w     0x938, w0
	mov	w0,Atemp	; Accu temp
    10fe:	40 49 88    	mov.w     w0, 0x928
	mov	AluTempw14,w14	; Accu Out
    1100:	ee 49 80    	mov.w     0x93c, w14
	mov	AluTempw13,w13	; Accu In
    1102:	dd 49 80    	mov.w     0x93a, w13
; repair all blinking (non-existing) combinations
	mov	#8,w1
    1104:	81 00 20    	mov.w     #0x8, w1
	mov	Opcode,WREG	; affects Z flag
    1106:	22 89 bf    	mov.w     0x922, WREG
	bra	z,eight_bit_opc	; if eight bit opcode
    1108:	04 00 32    	bra       Z, 0x1112 <eight_bit_opc>
	cp	w0,#9
    110a:	69 00 e1    	cp.w      w0, #0x9
	ifc			; if Opcode >= 9...
    110c:	42 00 af    	btsc.b    0x42, #0x0
	mov	w1,Opcode	; ...then fix it to 8
    110e:	11 49 88    	mov.w     w1, 0x922
	bra	fixed
    1110:	09 00 37    	bra       0x1124 <fixed>

00001112 <eight_bit_opc>:
eight_bit_opc:
	mov	#2,w1
    1112:	21 00 20    	mov.w     #0x2, w1
	mov	OperX,w0
    1114:	20 49 80    	mov.w     0x924, w0
	cp	w0,#2		; 2 = INC RY, legal instruction
    1116:	62 00 e1    	cp.w      w0, #0x2
	bra	z,fixed
    1118:	05 00 32    	bra       Z, 0x1124 <fixed>
	cp	w0,#3		; 3 = DEC RY, legal instruction
    111a:	63 00 e1    	cp.w      w0, #0x3
	bra	z,fixed
    111c:	03 00 32    	bra       Z, 0x1124 <fixed>
	cp	w0,#13		; 13 = RRC RY, legal instruction
    111e:	6d 00 e1    	cp.w      w0, #0xd
	ifnz
    1120:	42 20 ae    	btss.b    0x42, #0x1
	mov	w1,OperX	; if unlegal, fix it to 2
    1122:	21 49 88    	mov.w     w1, 0x924

00001124 <fixed>:
fixed:
; restore ALU flags
	mov	AluTempVflag,w0
    1124:	f0 49 80    	mov.w     0x93e, w0
	mov	w0,Vflag
    1126:	80 49 88    	mov.w     w0, 0x930
	mov	AluTempZflag,w0
    1128:	00 4a 80    	mov.w     0x940, w0
	mov	w0,Zflag
    112a:	70 49 88    	mov.w     w0, 0x92e
	mov	AluTempCflag,w0
    112c:	10 4a 80    	mov.w     0x942, w0
	mov	w0,Cflag
    112e:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    1130:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    1132:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    1134:	af 89 a8    	bset.b    0x9af, #0x4
; initialize ALU
	clr	Mode			; 0 = ALU
    1136:	76 29 ef    	clr.w     0x976
	clr	BlinkFlag
    1138:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    113a:	54 20 ef    	clr.w     0x54
	mov	w9,PgmTempPMAddr
    113c:	29 4b 88    	mov.w     w9, 0x964
	clr.b	Page
    113e:	f0 68 ef    	clr.b     0x8f0
	clr	Stack
    1140:	2a 29 ef    	clr.w     0x92a
	clr	w9
    1142:	80 04 eb    	clr.w     w9
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    1144:	dc 49 a8    	bset.b    0x9dc, #0x2
	mov	#1,w0
    1146:	10 00 20    	mov.w     #0x1, w0
	cp0.b	Speed
    1148:	f1 48 e2    	cp0.b     0x8f1
	ifz
    114a:	42 20 af    	btsc.b    0x42, #0x1
	mov.b	WREG,Speed
    114c:	f1 e8 b7    	mov.b     WREG, 0x8f1
	mov	#0b011100000,w0	; autorpt for Opcode, OperX, OperY
    114e:	00 0e 20    	mov.w     #0xe0, w0
	mov	w0,AutorptFlag
    1150:	60 4d 88    	mov.w     w0, 0x9ac

00001152 <alu_farm>:
;------------------------------
alu_farm:			; <------------
	bset	IEC0,#11	; enable RX1 interrupt
    1152:	99 60 a8    	bset.b    0x99, #0x3
; IN register service
	mov	#PORTB,w0
    1154:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    1156:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    1158:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    115a:	0b e8 b7    	mov.b     WREG, 0x80b
; read instruction opcode
	mov	Opcode,w0	; read instruction opcode here...
    115c:	10 49 80    	mov.w     0x922, w0
	mov	OperX,w11	; ...or here
    115e:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12
    1160:	3c 49 80    	mov.w     0x926, w12
	cp0	w0		; w0 = Opcode
    1162:	00 00 e0    	cp0.w     w0
	bra	z,jpt_8alu	; if it's 8-bit opcode
    1164:	12 00 32    	bra       Z, 0x118a <jpt_8alu>
	mov	#OperX,w7	; default result write address
    1166:	47 92 20    	mov.w     #0x924, w7
; w0 = table pos
	bra	w0
    1168:	00 60 01    	bra       w0
;jp table
	bra	alu_cmd	   ; impossible instruction
    116a:	27 00 37    	bra       0x11ba <alu_cmd> <alu_wait_key>
	bra	alu_A1	   ; ADD  RX,RY
    116c:	af 02 37    	bra       0x16cc <alu_A1>
	bra	alu_A2	   ; ADC  RX,RY
    116e:	b3 02 37    	bra       0x16d6 <alu_A2>
	bra	alu_A3	   ; SUB  RX,RY
    1170:	b7 02 37    	bra       0x16e0 <alu_A3>
	bra	alu_A4	   ; SBB  RX,RY
    1172:	bb 02 37    	bra       0x16ea <alu_A4>
	bra	alu_A5	   ; OR   RX,RY
    1174:	bf 02 37    	bra       0x16f4 <alu_A5>
	bra	alu_A6	   ; AND  RX,RY
    1176:	c3 02 37    	bra       0x16fe <alu_A6>
	bra	alu_A7	   ; XOR  RX,RY
    1178:	c7 02 37    	bra       0x1708 <alu_A7>
	bra	alu_A8	   ; MOV  RX,RY
    117a:	cb 02 37    	bra       0x1712 <alu_A8>
	bra	alu_blink1 ; MOV  RX,RY   (non-existing in ALU mode)
    117c:	18 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; MOV  RX,N    (non-existing in ALU mode)
    117e:	17 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; MOV  [XY],R0 (non-existing in ALU mode)
    1180:	16 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[XY] (non-existing in ALU mode)
    1182:	15 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; MOV  [NN],R0 (non-existing in ALU mode)
    1184:	14 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[NN] (non-existing in ALU mode)
    1186:	13 00 37    	bra       0x11ae <alu_blink1>
	bra	alu_blink1 ; JR   NN      (non-existing in ALU mode)
    1188:	12 00 37    	bra       0x11ae <alu_blink1>

0000118a <jpt_8alu>:

jpt_8alu:
	mov	#Dummy,w7	; default result write address (R0 = Accu in)
    118a:	07 9b 20    	mov.w     #0x9b0, w7
; w0 = table pos
	bra	w11
    118c:	0b 60 01    	bra       w11
;jp table
	bra	alu_blink2   ; CP   R0,N    (uses R0)
    118e:	12 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; ADD  R0,N    (uses R0)
    1190:	11 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_G2	     ; INC  RY
    1192:	c4 02 37    	bra       0x171c <alu_G2>
	bra	alu_G3	     ; DEC  RY
    1194:	c9 02 37    	bra       0x1728 <alu_G3>
	bra	alu_blink2   ; DSZ  RY      (non-existing in ALU mode)
    1196:	0e 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; OR   R0,N    (uses R0)
    1198:	0d 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; AND  R0,N    (uses R0)
    119a:	0c 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; XOR  R0,N    (uses R0)
    119c:	0b 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; EXR  N       (non-existing in ALU mode)
    119e:	0a 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; BIT  RG,M    (uses R0)
    11a0:	09 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; BSET RG,M    (uses R0)
    11a2:	08 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; BCLR RG,M    (uses R0)
    11a4:	07 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; BTG  RG,M    (uses R0)
    11a6:	06 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_G13	     ; RRC  RY
    11a8:	c5 02 37    	bra       0x1734 <alu_G13>
	bra	alu_blink2   ; RET  RY,N    (non-existing in ALU mode)
    11aa:	04 00 37    	bra       0x11b4 <alu_blink2>
	bra	alu_blink2   ; SKIP F,M     (non-existing in ALU mode)
    11ac:	03 00 37    	bra       0x11b4 <alu_blink2>

000011ae <alu_blink1>:
;...
; --------------------------------------------------------------------

alu_blink1:			; if non-existent, instruction column 1 should blink
	bset	BlinkFlag,#0
    11ae:	e0 09 a8    	bset.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    11b0:	e0 29 a9    	bclr.b    0x9e0, #0x1
	bra	alu_wait_key
    11b2:	03 00 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000011b4 <alu_blink2>:
alu_blink2:			; if non-existent, instruction column 2 should blink
	bclr	BlinkFlag,#0
    11b4:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bset	BlinkFlag,#1
    11b6:	e0 29 a8    	bset.b    0x9e0, #0x1
	bra	alu_wait_key
    11b8:	00 00 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000011ba <alu_cmd>:

;-------------------------------
alu_cmd:			; w11 = Transfer Flag
alu_wait_key:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    11ba:	dc c9 af    	btsc.b    0x9dc, #0x6
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11bc:	df 09 a8    	bset.b    0x9df, #0x0
	mov	#PORTB,w0
    11be:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    11c0:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    11c2:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    11c4:	0b e8 b7    	mov.b     WREG, 0x80b

	btss	Flag,#1		; #1 handshaking flag for buttons
    11c6:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	alu_wait_key
    11c8:	f8 ff 37    	bra       0x11ba <alu_cmd> <alu_wait_key>
	bclr	Flag,#1
    11ca:	dc 29 a9    	bclr.b    0x9dc, #0x1
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11cc:	df 09 af    	btsc.b    0x9df, #0x0
	bra	not_first
    11ce:	08 00 37    	bra       0x11e0 <not_first>
; first keypress, clear Ver/Rev
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    11d0:	df 09 a8    	bset.b    0x9df, #0x0
	clr	Ram+0x00
    11d2:	00 28 ef    	clr.w     0x800
	clr	Ram+0x02
    11d4:	02 28 ef    	clr.w     0x802
	clr	Ram+0x04
    11d6:	04 28 ef    	clr.w     0x804
	clr	Ram+0x10
    11d8:	10 28 ef    	clr.w     0x810
	clr	Ram+0x12
    11da:	12 28 ef    	clr.w     0x812
	clr	Ram+0x14
    11dc:	14 28 ef    	clr.w     0x814
	bra	alu_wait_key
    11de:	ed ff 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000011e0 <not_first>:
not_first:
	bclr	BlinkFlag,#5	; switch off "SAVE blink" flag
    11e0:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bclr	BlinkFlag,#7	; switch off "LOAD blink" flag
    11e2:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	mov	Just,w0
    11e4:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    11e6:	65 00 e1    	cp.w      w0, #0x5
	ifc
    11e8:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    11ea:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    11ec:	00 60 01    	bra       w0
; jump table FOR BUTTONS
	bra	leave_alu_ept	; -------> next mode (Single Step)
    11ee:	b2 02 37    	bra       0x1754 <leave_alu_ept>
	bra	button_CARRY
    11f0:	04 00 37    	bra       0x11fa <button_CARRY>
	bra	button_SAVE
    11f2:	05 00 37    	bra       0x11fe <button_SAVE>
	bra	button_LOAD
    11f4:	6a 00 37    	bra       0x12ca <button_LOAD>
	bra	button_CLOCK
    11f6:	f3 00 37    	bra       0x13de <button_CLOCK>
	bra	general_alu_5
    11f8:	05 01 37    	bra       0x1404 <general_alu_5>

000011fa <button_CARRY>:

; button entry points
; -----------------------------------------------------------------
button_CARRY:
	btg	A16,#b_carry
    11fa:	af 89 aa    	btg.b     0x9af, #0x4
	bra	alu_farm
    11fc:	aa ff 37    	bra       0x1152 <alu_farm>

000011fe <button_SAVE>:

; -----------------------------------------------------------------
; TX format:
; Header 00 FF 00 FF A5 C3
; file length (word count, 16-bit length, low byte first)
; message body (words, low byte first)
; checksum (16-bit sum of FILE LENGTH WORD plus MESSAGE BODY words, low byte first)

button_SAVE:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    11fe:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    1200:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
    1202:	df 29 a9    	bclr.b    0x9df, #0x1
	bset	A16,#b_save	; led SAVE on
    1204:	af a9 a8    	bset.b    0x9af, #0x5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1206:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	save2tx		; ALT not pressed: save to serial port
    1208:	05 00 37    	bra       0x1214 <save2tx>
; ALT pressed: save to Flash
	mov	FlashAddr,w0
    120a:	00 4e 80    	mov.w     0x9c0, w0
	cp	w0,#15
    120c:	6f 00 e1    	cp.w      w0, #0xf
	bra	nc,save2flash	; save to flash, loc 0...14
    120e:	3e 00 39    	bra       NC, 0x128c <save2flash>
	bclr	A16,#b_save	; led SAVE off
    1210:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	alu_farm
    1212:	9f ff 37    	bra       0x1152 <alu_farm>

00001214 <save2tx>:
save2tx:		; save to serial port
; save to serial port TX
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    1214:	0e 28 02    	call      0x280e <rxtx_to_io>
    1216:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    1218:	c0 27 02    	call      0x27c0 <def_U1BRG>
    121a:	00 00 00 
; measure the file length first
	mov	#0x1000,w5	; file length countdown (in words)
    121c:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom+0x1FFE,w3	; pointer backwards from the last program memory word
    121e:	e3 ff 23    	mov.w     #0x3ffe, w3

00001220 <L51>:
5:
	cp0	[w3--]		; test if word contains data
    1220:	23 00 e0    	cp0.w     [w3--]
	bra	nz,6f		; if found meaningful content >0000
    1222:	0a 00 3a    	bra       NZ, 0x1238 <L63>
	dec	w5,w5
    1224:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    1226:	fc ff 3a    	bra       NZ, 0x1220 <L51>
	bset	A16,#b_save	; LED SAVE on
    1228:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    122a:	e0 a9 a8    	bset.b    0x9e0, #0x5

0000122c <waitany1>:
waitany1:
	btss	Flag,#1		; #1 = "key pressed" flag
    122c:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany1
    122e:	fe ff 37    	bra       0x122c <waitany1>
	bclr	Flag,#1		; #1 = "key pressed" flag
    1230:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    1232:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    1234:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    1236:	40 00 37    	bra       0x12b8 <saveload_exit>

00001238 <L63>:
6:				; found >0000
; send header 00 FF 00 FF A5 C3 
	mov	#0xFF00,w0
    1238:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    123a:	90 10 02    	call      0x1090 <txword>
    123c:	00 00 00 
	mov	#0xFF00,w0
    123e:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    1240:	90 10 02    	call      0x1090 <txword>
    1242:	00 00 00 
	mov	#0xC3A5,w0
    1244:	50 3a 2c    	mov.w     #0xc3a5, w0
	call	txword		; ----> TX header A5 C3
    1246:	90 10 02    	call      0x1090 <txword>
    1248:	00 00 00 
; send file length w5 (in words)
	bset	A16,#b_save	; "SAVE" LED on
    124a:	af a9 a8    	bset.b    0x9af, #0x5
	mov	w5,w4		; w4 CHS
    124c:	05 02 78    	mov.w     w5, w4
	lsr	w5,#2,w2	; w2 file length/4, will be used in taskbar calculation
    124e:	42 29 de    	lsr.w     w5, #0x2, w2
	ifz
    1250:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    1252:	12 00 20    	mov.w     #0x1, w2
	mov	w5,w0
    1254:	05 00 78    	mov.w     w5, w0
	call	txword		; ----> TX record length in words 16-bit (little endian)
    1256:	90 10 02    	call      0x1090 <txword>
    1258:	00 00 00 
	mov	#Rom,w3		; program memory pointer from the beginning
    125a:	03 00 22    	mov.w     #0x2000, w3

0000125c <L52>:
; send message body (pointer w3, length w5)
5:			  ; \
	mov	[w3++],w0	; read word from program memory
    125c:	33 00 78    	mov.w     [w3++], w0
	add	w4,w0,w4	; update CHS
    125e:	00 02 42    	add.w     w4, w0, w4
	call	txword		; ----> TX data 16-bit (little endian, hi byte 0000xxxx)
    1260:	90 10 02    	call      0x1090 <txword>
    1262:	00 00 00 
; taskbar ------
	sl	w5,#3,w6	; w6 = w5 × 8
    1264:	43 2b dd    	sl.w      w5, #0x3, w6
	repeat	#17
    1266:	11 00 09    	repeat    #0x11
	div.u	w6,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    1268:	02 83 d8    	div.uw    w6, w2
	cp	w0,#31
    126a:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    126c:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    126e:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    1270:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    1272:	f1 ff 2f    	mov.w     #0xffff, w1
	sl	w1,w0,w1
    1274:	80 08 dd    	sl.w      w1, w0, w1
	mov	w1,Taskbar
    1276:	c1 4d 88    	mov.w     w1, 0x9b8

	dec	w5,w5
    1278:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b	  ; /
    127a:	f0 ff 3a    	bra       NZ, 0x125c <L52>
; send checksum
	mov	w4,w0
    127c:	04 00 78    	mov.w     w4, w0
	call	txword		; ----> TX CHS 16-bit (little endian)
    127e:	90 10 02    	call      0x1090 <txword>
    1280:	00 00 00 
	mov	#140,w0
    1282:	c0 08 20    	mov.w     #0x8c, w0
	call	w0ms		; give some time to send the whole queue
    1284:	de 10 02    	call      0x10de <w0ms>
    1286:	00 00 00 
; finale
	bclr	A16,#b_save	; "SAVE" LED off
    1288:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	saveload_exit
    128a:	16 00 37    	bra       0x12b8 <saveload_exit>

0000128c <save2flash>:

save2flash:		; save to flash
	mov	#0x1000,w5	; file length countdown (in words)
    128c:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom,w3		; pointer
    128e:	03 00 22    	mov.w     #0x2000, w3

00001290 <L53>:
5:
	cp0	[w3++]		; test if word contains data
    1290:	33 00 e0    	cp0.w     [w3++]
	bra	nz,6f		; if found meaningful content >0000
    1292:	0a 00 3a    	bra       NZ, 0x12a8 <L64>
	dec	w5,w5
    1294:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    1296:	fc ff 3a    	bra       NZ, 0x1290 <L53>
	bset	A16,#b_save	; LED SAVE on
    1298:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    129a:	e0 a9 a8    	bset.b    0x9e0, #0x5

0000129c <waitany2>:
waitany2:
	btss	Flag,#1		; #1 = "key pressed" flag
    129c:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany2
    129e:	fe ff 37    	bra       0x129c <waitany2>
	bclr	Flag,#1		; #1 = "key pressed" flag
    12a0:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    12a2:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    12a4:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    12a6:	08 00 37    	bra       0x12b8 <saveload_exit>

000012a8 <L64>:
6:			; found meaningful content >0000
	call	com_rom
    12a8:	f8 13 02    	call      0x13f8 <com_rom>
    12aa:	00 00 00 
	mov	FlashAddr,w0
    12ac:	00 4e 80    	mov.w     0x9c0, w0
	call	eesavew0	; EEsave
    12ae:	44 02 02    	call      0x244 <eesavew0>
    12b0:	00 00 00 
	call	com_rom
    12b2:	f8 13 02    	call      0x13f8 <com_rom>
    12b4:	00 00 00 
	bclr	A16,#b_save
    12b6:	af a9 a9    	bclr.b    0x9af, #0x5

000012b8 <saveload_exit>:
saveload_exit:
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxPos
    12b8:	f8 27 02    	call      0x27f8 <rxtx_to_rxtxpos>
    12ba:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    12bc:	c4 27 02    	call      0x27c4 <set_U1BRG>
    12be:	00 00 00 
	clr	Taskbar
    12c0:	b8 29 ef    	clr.w     0x9b8
	bclr	Flag,#1		; reset handshaking flag for buttons (ignore it during save!)
    12c2:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	peek_flash	; record flash occupance  (37 ms)
    12c4:	40 17 02    	call      0x1740 <peek_flash>
    12c6:	00 00 00 
	bra	alu_farm
    12c8:	44 ff 37    	bra       0x1152 <alu_farm>

000012ca <button_LOAD>:

; ---------------------------------------------------------------------------------------

button_LOAD:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    12ca:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    12cc:	de e9 a9    	bclr.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
    12ce:	df 29 a8    	bset.b    0x9df, #0x1
	bset	A16,#b_load	; LED on
    12d0:	af c9 a8    	bset.b    0x9af, #0x6
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    12d2:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	nc,ALTload	; if ALT pressed: load from Flash
    12d4:	56 00 39    	bra       NC, 0x1382 <ALTload>

000012d6 <LoadFromRx>:
LoadFromRx:		; load from serial port
	bclr	IEC0,#11	; disable RX1 interrupt
    12d6:	99 60 a9    	bclr.b    0x99, #0x3
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    12d8:	0e 28 02    	call      0x280e <rxtx_to_io>
    12da:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    12dc:	c0 27 02    	call      0x27c0 <def_U1BRG>
    12de:	00 00 00 

000012e0 <L65>:
; synchronize to header A5 C3
6:
	call	rxbyte_20s	; <---------- first RX attempt (timeout 20 sec)
    12e0:	ac 13 02    	call      0x13ac <rxbyte_20s>
    12e2:	00 00 00 
	bra	c,rx_patience_1	; if patience lost or keypress
    12e4:	49 00 31    	bra       C, 0x1378 <rx_patience_1>
	mov	#16,w5		; 16 attempts before giving up
    12e6:	05 01 20    	mov.w     #0x10, w5

000012e8 <L54>:
5:
	call	rxbyte_4s	; <---------- attempt to RX header 1 (A5) (timeout 4 sec)
    12e8:	b0 13 02    	call      0x13b0 <rxbyte_4s>
    12ea:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    12ec:	5b 00 31    	bra       C, 0x13a4 <rx_patience>
	sub	#0xA5,w0
    12ee:	50 0a b1    	sub.w     #0xa5, w0
	bra	z,found_header_a5
    12f0:	04 00 32    	bra       Z, 0x12fa <found_header_a5>
	dec	w5,w5
    12f2:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    12f4:	f9 ff 3a    	bra       NZ, 0x12e8 <L54>
	mov	#0,w0
    12f6:	00 00 20    	mov.w     #0x0, w0
	bra	rx_patience	; giving up after 16 attempts to recognize header
    12f8:	55 00 37    	bra       0x13a4 <rx_patience>

000012fa <found_header_a5>:
found_header_a5:
	call	rxbyte_500ms	; <---------- RX header 2 (C3)
    12fa:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    12fc:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    12fe:	52 00 31    	bra       C, 0x13a4 <rx_patience>
	sub	#0xC3,w0
    1300:	30 0c b1    	sub.w     #0xc3, w0
	bra	nz,6b		; one more chance
    1302:	ee ff 3a    	bra       NZ, 0x12e0 <L65>
; header A5 C3 recognized, now get file length (low byte first)
	call	rxbyte_500ms	; <---------- RX file length low
    1304:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    1306:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    1308:	4d 00 31    	bra       C, 0x13a4 <rx_patience>
	ze	w0,w3		; w3 first low byte (file length low)
    130a:	80 81 fb    	ze        w0, w3
	call	rxbyte_500ms	; <---------- RX file length high
    130c:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    130e:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    1310:	49 00 31    	bra       C, 0x13a4 <rx_patience>
	sl	w0,#8,w0	; high byte go high
    1312:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w3,w3	; w3 file length (in words)
    1314:	83 01 70    	ior.w     w0, w3, w3
	mov	w3,w5		; w5 = CHS
    1316:	83 02 78    	mov.w     w3, w5
	lsr	w3,#2,w2	; w2 file length/4, will be used in taskbar calculation
    1318:	42 19 de    	lsr.w     w3, #0x2, w2
	ifz
    131a:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    131c:	12 00 20    	mov.w     #0x1, w2
	bra	z,only_timeout	; zero length - file too short (LOAD blinks)
    131e:	44 00 32    	bra       Z, 0x13a8 <only_timeout>
	mov	#0x1001,w1	; max length+1 (number of words!)
    1320:	11 00 21    	mov.w     #0x1001, w1
	cp	w3,w1
    1322:	01 18 e1    	cp.w      w3, w1
	bra	c,only_timeout	; file too long (LOAD blinks)
    1324:	41 00 31    	bra       C, 0x13a8 <only_timeout>
; receive message body
	mov	#Rom,w6		; write pointer
    1326:	06 00 22    	mov.w     #0x2000, w6

00001328 <L35>:
3:			; <-------- RX loop
	call	rxbyte_500ms	; <---------- RX message body low
    1328:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    132a:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    132c:	3b 00 31    	bra       C, 0x13a4 <rx_patience>
	ze	w0,w4
    132e:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX message body high
    1330:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    1332:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1334:	37 00 31    	bra       C, 0x13a4 <rx_patience>
	sl	w0,#8,w0	; high byte go high
    1336:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w4,w0
    1338:	04 00 70    	ior.w     w0, w4, w0
	mov	w0,[w6++]	; WRITE RECEIVED WORD
    133a:	00 1b 78    	mov.w     w0, [w6++]
	add	w0,w5,w5	; update CHS
    133c:	85 02 40    	add.w     w0, w5, w5

; taskbar ------
	sl	w3,#3,w1	; w1 = w5 × 8
    133e:	c3 18 dd    	sl.w      w3, #0x3, w1
	repeat	#17
    1340:	11 00 09    	repeat    #0x11
	div.u	w1,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    1342:	82 80 d8    	div.uw    w1, w2
	cp	w0,#31
    1344:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    1346:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    1348:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    134a:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    134c:	f1 ff 2f    	mov.w     #0xffff, w1
	lsr	w1,w0,w1	; taskbar progress  UP ---> DOWN
    134e:	80 08 de    	lsr.w     w1, w0, w1
	mov	w1,Taskbar
    1350:	c1 4d 88    	mov.w     w1, 0x9b8
	dec	w3,w3
    1352:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b		; loop
    1354:	e9 ff 3a    	bra       NZ, 0x1328 <L35>
; receive checksum
	call	rxbyte_500ms	; <---------- RX CHS low
    1356:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    1358:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    135a:	24 00 31    	bra       C, 0x13a4 <rx_patience>
	ze	w0,w4
    135c:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX CHS high
    135e:	b4 13 02    	call      0x13b4 <rxbyte_500ms>
    1360:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    1362:	20 00 31    	bra       C, 0x13a4 <rx_patience>
	swap	w0
    1364:	00 80 fd    	swap.w    w0
	ior	w0,w4,w0
    1366:	04 00 70    	ior.w     w0, w4, w0
	cp	w0,w5		; received CHS - calculated CHS
    1368:	05 00 e1    	cp.w      w0, w5
	bra	nz,rx_patience	; CHS does not match!
    136a:	1c 00 3a    	bra       NZ, 0x13a4 <rx_patience>

0000136c <fill00>:
; RX finished, fill 00s to the end (pointer w6)
fill00:
	btsc	w6,#14		; #14 will be set when w6 reaches 0x4000
    136c:	06 e0 a7    	btsc.w    w6, #0xe
	bra	filled
    136e:	02 00 37    	bra       0x1374 <filled>
	clr.b	[w6++]
    1370:	00 5b eb    	clr.b     [w6++]
	bra	fill00
    1372:	fc ff 37    	bra       0x136c <fill00>

00001374 <filled>:
filled:
	bclr	A16,#b_load
    1374:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit	; -----> RX LOAD FINISHED
    1376:	a0 ff 37    	bra       0x12b8 <saveload_exit>

00001378 <rx_patience_1>:

;								
rx_patience_1:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0
    1378:	00 00 e0    	cp0.w     w0
	bra	z,only_timeout	; if no key pressed or gave up after 16 attempts to recognize header
    137a:	16 00 32    	bra       Z, 0x13a8 <only_timeout>
	bclr	A16,#b_load	; LED LOAD off
    137c:	af c9 a9    	bclr.b    0x9af, #0x6
	bclr	BlinkFlag,#7	; no blinking
    137e:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	bra	saveload_exit	; key pressed, just exit
    1380:	9b ff 37    	bra       0x12b8 <saveload_exit>

00001382 <ALTload>:

;			
ALTload:		; ALT pressed, load from Flash
	bset	A16,#b_load
    1382:	af c9 a8    	bset.b    0x9af, #0x6
	call	com_rom
    1384:	f8 13 02    	call      0x13f8 <com_rom>
    1386:	00 00 00 
	mov	#15,w0
    1388:	f0 00 20    	mov.w     #0xf, w0
	cp.b	FlashAddr
    138a:	c0 49 e3    	cp.b      0x9c0
	ifnz
    138c:	42 20 ae    	btss.b    0x42, #0x1
	call	eesavew0	; just in case, saved on record 15
    138e:	44 02 02    	call      0x244 <eesavew0>
    1390:	00 00 00 
	call	com_rom
    1392:	f8 13 02    	call      0x13f8 <com_rom>
    1394:	00 00 00 

	mov	FlashAddr,w0
    1396:	00 4e 80    	mov.w     0x9c0, w0
	call	eeload
    1398:	46 02 02    	call      0x246 <eeload>
    139a:	00 00 00 
	call	com_rom
    139c:	f8 13 02    	call      0x13f8 <com_rom>
    139e:	00 00 00 
	bclr	A16,#b_load
    13a0:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit
    13a2:	8a ff 37    	bra       0x12b8 <saveload_exit>

000013a4 <rx_patience>:
;			
rx_patience:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0		; w0=0 if no key pressed
    13a4:	00 00 e0    	cp0.w     w0
	ifnz			; if key pressed, then LED LOAD blinks = TIMEOUT
    13a6:	42 20 ae    	btss.b    0x42, #0x1

000013a8 <only_timeout>:
only_timeout:
	bset	BlinkFlag,#7	; LED LOAD blinks = TIMEOUT
    13a8:	e0 e9 a8    	bset.b    0x9e0, #0x7
	bra	saveload_exit	; regular exit
    13aa:	86 ff 37    	bra       0x12b8 <saveload_exit>

000013ac <rxbyte_20s>:

;											
rxbyte_20s:		; RX byte ---> w0 (NC), patience 20s (C set if pat lost)
	mov	#20000,w1	; patience 20 s
    13ac:	01 e2 24    	mov.w     #0x4e20, w1
	bra	1f
    13ae:	03 00 37    	bra       0x13b6 <L14>

000013b0 <rxbyte_4s>:
rxbyte_4s:		; RX byte ---> w0 (NC), patience 4s (C set if pat lost)
	mov	#4000,w1	; patience 4 s
    13b0:	01 fa 20    	mov.w     #0xfa0, w1
	bra	1f
    13b2:	01 00 37    	bra       0x13b6 <L14>

000013b4 <rxbyte_500ms>:
rxbyte_500ms:		; RX byte ---> w0 (NC), patience 500 ms (C set if pat lost)
	mov	#500,w1		; patience 500 ms
    13b4:	41 1f 20    	mov.w     #0x1f4, w1

000013b6 <L14>:
1:
	mov	#2240,w0	; inner loop 1 ms
    13b6:	00 8c 20    	mov.w     #0x8c0, w0

000013b8 <L23>:
2:
	btsc	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    13b8:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	button_press_rx	; if button pressed
    13ba:	0d 00 37    	bra       0x13d6 <button_press_rx>
	btsc	U1STAL,#URXDA	; bit set if RX data available
    13bc:	9a 03 af    	btsc.b    0x39a, #0x0
	bra	rx_arrived_2
    13be:	07 00 37    	bra       0x13ce <rx_arrived_2>
	dec	w0,w0
    13c0:	00 00 e9    	dec.w     w0, w0
	bra	nz,2b		; loop 7t × 2240 = 15680t = 1 ms (INT time estimated)
    13c2:	fa ff 3a    	bra       NZ, 0x13b8 <L23>
	dec	w1,w1
    13c4:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b		; loop 1 ms × 500 = 500 ms
    13c6:	f7 ff 3a    	bra       NZ, 0x13b6 <L14>
;patience_lost
	mov	#0,w0		; flag no keys pressed (only timeout)
    13c8:	00 00 20    	mov.w     #0x0, w0
	setc			; Carry set = NOT OK
    13ca:	42 00 a8    	bset.b    0x42, #0x0
	return
    13cc:	00 00 06    	return    

000013ce <rx_arrived_2>:
;				
rx_arrived_2:
	mov.b	U1RXREG,WREG	; <---- get received byte (this resets U1STAL,#URXDA)
    13ce:	9e c3 bf    	mov.b     0x39e, WREG
	ze	w0,w0
    13d0:	00 80 fb    	ze        w0, w0
	clrc
    13d2:	42 00 a9    	bclr.b    0x42, #0x0
	return
    13d4:	00 00 06    	return    

000013d6 <button_press_rx>:
;				
button_press_rx:
	bclr	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    13d6:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	#1,w0		; flag key pressed (not timeout)
    13d8:	10 00 20    	mov.w     #0x1, w0
	setc			; Carry set = NOT OK
    13da:	42 00 a8    	bset.b    0x42, #0x0
	return
    13dc:	00 00 06    	return    

000013de <button_CLOCK>:
; -----------------------------------------------------------------
button_CLOCK:
	mov	#3,w0
    13de:	30 00 20    	mov.w     #0x3, w0
	and	BlinkFlag,WREG
    13e0:	e0 09 b6    	and.w     0x9e0, WREG
	bra	nz,alu_farm	; no execution if the instruction is illegal
    13e2:	b7 fe 3a    	bra       NZ, 0x1152 <alu_farm>

	bset	A16,#b_clk_key	; set CLK key
    13e4:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w11 bits to decide flag transfer
    13e6:	b0 14 02    	call      0x14b0 <transfer1>
    13e8:	00 00 00 

000013ea <L15>:
1:
	inc	KeyRotors+8,WREG
    13ea:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,1b		; if not yet 0x11111111
    13ec:	fe ff 3a    	bra       NZ, 0x13ea <L15>
	bclr	A16,#b_clk_key
    13ee:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w11 bits to decide flag transfer
    13f0:	94 15 02    	call      0x1594 <transfer2>
    13f2:	00 00 00 

	mov.b	w13,[w7]	; write result to destination
    13f4:	8d 4b 78    	mov.b     w13, [w7]
	bra	alu_farm
    13f6:	ad fe 37    	bra       0x1152 <alu_farm>

000013f8 <com_rom>:

; **********************************************************************************************
com_rom:		; complement Rom 0x1800 bytes
	mov	#Rom,w2
    13f8:	02 00 22    	mov.w     #0x2000, w2
	mov	#0x1000,w1
    13fa:	01 00 21    	mov.w     #0x1000, w1

000013fc <L16>:
1:
	com	[w2],[w2++]
    13fc:	12 99 ea    	com.w     [w2], [w2++]
	dec	w1,w1
    13fe:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    1400:	fd ff 3a    	bra       NZ, 0x13fc <L16>
	return
    1402:	00 00 06    	return    

00001404 <general_alu_5>:

; --------------------------------------------------------------------------------------
; buttons Opcode - OperX - OperY - DataIn						
; --------------------------------------------------------------------------------------

general_alu_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	alu_key_3
    1404:	0a 14 02    	call      0x140a <alu_key_3>
    1406:	00 00 00 
	bra	alu_farm
    1408:	a4 fe 37    	bra       0x1152 <alu_farm>

0000140a <alu_key_3>:
; ------------------------------
alu_key_3:		; Opcode-OperX-OperY --- Dim-Dummy-FlashAddr
	mov	#Opcode,w3
    140a:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    140c:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    140e:	65 92 20    	mov.w     #0x926, w5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1410:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    1412:	1b 00 37    	bra       0x144a <general>
	mov	#Dimmer,w3
    1414:	e3 8f 20    	mov.w     #0x8fe, w3
	mov	#SerCtrl,w4
    1416:	54 8f 20    	mov.w     #0x8f5, w4
	bclr.b	[w4],#3		; spec case: Buad Rate can't be greater than 7
    1418:	14 34 a1    	bclr.b    [w4], #0x3
	mov	#FlashAddr,w5
    141a:	05 9c 20    	mov.w     #0x9c0, w5
	call	general
    141c:	4a 14 02    	call      0x144a <general>
    141e:	00 00 00 
	bclr.b	SerCtrl,#3	; spec case: Buad Rate can't be greater than 7
    1420:	f5 68 a9    	bclr.b    0x8f5, #0x3
	mov.b	SerCtrl,WREG
    1422:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    1424:	70 00 b2    	and.w     #0x7, w0
	call	set_U1BRG_from_w0	; set new Baud Rate
    1426:	c8 27 02    	call      0x27c8 <set_U1BRG_from_w0>
    1428:	00 00 00 
	return
    142a:	00 00 06    	return    

0000142c <limited_key_3>:
limited_key_3:		; can't affect pgm data, only Dim Clock Page
	mov	#Dummy,w3
    142c:	03 9b 20    	mov.w     #0x9b0, w3
	mov	#Dummy,w4
    142e:	04 9b 20    	mov.w     #0x9b0, w4
	mov	#Dummy,w5
    1430:	05 9b 20    	mov.w     #0x9b0, w5
	bra	uni_key
    1432:	03 00 37    	bra       0x143a <uni_key>

00001434 <general_key_3O>:
general_key_3O:
	mov	#Opcode,w3
    1434:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    1436:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    1438:	65 92 20    	mov.w     #0x926, w5

0000143a <uni_key>:
uni_key:
	mov	Mode,w0		; *** if PGM mode (disable 12 keys)
    143a:	b0 4b 80    	mov.w     0x976, w0
	cp.b	w0,#3		; *** if PGM mode (disable 12 keys)
    143c:	63 04 e1    	cp.b      w0, #0x3
	bra	z,general	; *** if PGM mode (disable 12 keys)
    143e:	05 00 32    	bra       Z, 0x144a <general>

	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1440:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    1442:	03 00 37    	bra       0x144a <general>
	mov	#Sync,w3
    1444:	23 8f 20    	mov.w     #0x8f2, w3
	mov	#Speed,w4
    1446:	14 8f 20    	mov.w     #0x8f1, w4
	mov	#Page,w5
    1448:	05 8f 20    	mov.w     #0x8f0, w5

0000144a <general>:
general:
; is it key 5...8?
	mov	Just,w0
    144a:	30 4d 80    	mov.w     0x9a6, w0
	sub	#5,w0
    144c:	50 00 b1    	sub.w     #0x5, w0
	cp	w0,#4
    144e:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    1450:	0d 00 39    	bra       NC, 0x146c <key0_3>
; is it key 9...12?
	mov	w4,w3
    1452:	84 01 78    	mov.w     w4, w3
	sub	#4,w0
    1454:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    1456:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    1458:	09 00 39    	bra       NC, 0x146c <key0_3>
; is it key 13...16?
	mov	w5,w3
    145a:	85 01 78    	mov.w     w5, w3
	sub	#4,w0
    145c:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    145e:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    1460:	05 00 39    	bra       NC, 0x146c <key0_3>
; then it must be key 17 = Data In
	btg	A16,#b_bin
    1462:	af e9 aa    	btg.b     0x9af, #0x7
	bclr	A16,#b_sel
    1464:	ae e9 a9    	bclr.b    0x9ae, #0x7
	btss	A16,#b_bin
    1466:	af e9 ae    	btss.b    0x9af, #0x7
	bset	A16,#b_sel
    1468:	ae e9 a8    	bset.b    0x9ae, #0x7
	return
    146a:	00 00 06    	return    

0000146c <key0_3>:
; -------- 
key0_3:
	btss	A16,#b_bin
    146c:	af e9 ae    	btss.b    0x9af, #0x7
	bra	its_sel
    146e:	0d 00 37    	bra       0x148a <its_sel>
; it's binary mode here
	cp0	w0
    1470:	00 00 e0    	cp0.w     w0
	ifz
    1472:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#3		; key 8 in binary mode
    1474:	13 34 a2    	btg.b     [w3], #0x3
	cp	w0,#1
    1476:	61 00 e1    	cp.w      w0, #0x1
	ifz
    1478:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#2		; key 4 in binary mode
    147a:	13 24 a2    	btg.b     [w3], #0x2
	cp	w0,#2
    147c:	62 00 e1    	cp.w      w0, #0x2
	ifz
    147e:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#1		; key 2 in binary mode
    1480:	13 14 a2    	btg.b     [w3], #0x1
	cp	w0,#3
    1482:	63 00 e1    	cp.w      w0, #0x3
	ifz
    1484:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#0		; key 1 in binary mode
    1486:	13 04 a2    	btg.b     [w3], #0x0
	return
    1488:	00 00 06    	return    

0000148a <its_sel>:
its_sel:
	ze	[w3],w4
    148a:	13 82 fb    	ze        [w3], w4
	cp0	w0
    148c:	00 00 e0    	cp0.w     w0
	ifz
    148e:	42 20 af    	btsc.b    0x42, #0x1
	sub	#4,w4		; key ---- in select mode
    1490:	44 00 b1    	sub.w     #0x4, w4
	cp	w0,#1
    1492:	61 00 e1    	cp.w      w0, #0x1
	ifz
    1494:	42 20 af    	btsc.b    0x42, #0x1
	dec	w4,w4		; key - in select mode
    1496:	04 02 e9    	dec.w     w4, w4
	cp	w0,#2
    1498:	62 00 e1    	cp.w      w0, #0x2
	ifz
    149a:	42 20 af    	btsc.b    0x42, #0x1
	inc	w4,w4		; key + in select mode
    149c:	04 02 e8    	inc.w     w4, w4
	cp	w0,#3
    149e:	63 00 e1    	cp.w      w0, #0x3
	ifz
    14a0:	42 20 af    	btsc.b    0x42, #0x1
	add	#4,w4		; key ++++ in select mode
    14a2:	44 00 b0    	add.w     #0x4, w4
; clip w3 to 0...15
	btsc	w4,#15		; if w4<0...
    14a4:	04 f0 a7    	btsc.w    w4, #0xf
	clr	w4		; ...then w4=0
    14a6:	00 02 eb    	clr.w     w4
	btsc	w4,#4		; if w4>15...
    14a8:	04 40 a7    	btsc.w    w4, #0x4
	mov	#15,w4		; ...then w4=15
    14aa:	f4 00 20    	mov.w     #0xf, w4
	mov.b	w4,[w3]
    14ac:	84 49 78    	mov.b     w4, [w3]
	return
    14ae:	00 00 06    	return    

000014b0 <transfer1>:

; --------------------------------------------------------------------------------------
; Transfers through Accu and Flags  In - Temp - Out					
; --------------------------------------------------------------------------------------
transfer1:		; in the first clock semiphase or when STEP is depressed
	bclr	A16,#b_noclk_sch
    14b0:	ae 69 a9    	bclr.b    0x9ae, #0x3
	bset	A16,#b_clk_sch	; set CLK schematic
    14b2:	ae 09 a8    	bset.b    0x9ae, #0x0
	bra	w6
    14b4:	06 60 01    	bra       w6
;...
	return			; no transfers if w6=0000
    14b6:	00 00 06    	return    
	bra	n0001
    14b8:	0e 00 37    	bra       0x14d6 <n0001>
	bra	n0010
    14ba:	0f 00 37    	bra       0x14da <n0010>
	bra	n0011
    14bc:	12 00 37    	bra       0x14e2 <n0011>
	bra	n0100
    14be:	16 00 37    	bra       0x14ec <n0100>
	bra	n0101
    14c0:	19 00 37    	bra       0x14f4 <n0101>
	bra	n0110
    14c2:	1d 00 37    	bra       0x14fe <n0110>
	bra	n0111
    14c4:	23 00 37    	bra       0x150c <n0111>
	bra	n1000
    14c6:	2a 00 37    	bra       0x151c <n1000>
	bra	n1001
    14c8:	2d 00 37    	bra       0x1524 <n1001>
	bra	n1010
    14ca:	31 00 37    	bra       0x152e <n1010>
	bra	n1011
    14cc:	37 00 37    	bra       0x153c <n1011>
	bra	n1100
    14ce:	3e 00 37    	bra       0x154c <n1100>
	bra	n1101
    14d0:	44 00 37    	bra       0x155a <n1101>
	bra	n1110
    14d2:	4b 00 37    	bra       0x156a <n1110>
	bra	n1111
    14d4:	54 00 37    	bra       0x157e <n1111>

000014d6 <n0001>:
; -------------------
n0001:
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    14d6:	4d 49 88    	mov.w     w13, 0x928
	return
    14d8:	00 00 06    	return    

000014da <n0010>:
n0010:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    14da:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    14dc:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    14de:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    14e0:	00 00 06    	return    

000014e2 <n0011>:
n0011:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    14e2:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    14e4:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    14e6:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    14e8:	4d 49 88    	mov.w     w13, 0x928
	return
    14ea:	00 00 06    	return    

000014ec <n0100>:
n0100:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    14ec:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    14ee:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    14f0:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    14f2:	00 00 06    	return    

000014f4 <n0101>:
n0101:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    14f4:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    14f6:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    14f8:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    14fa:	4d 49 88    	mov.w     w13, 0x928
	return
    14fc:	00 00 06    	return    

000014fe <n0110>:
n0110:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    14fe:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1500:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1502:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1504:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1506:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1508:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    150a:	00 00 06    	return    

0000150c <n0111>:
n0111:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    150c:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    150e:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1510:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1512:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1514:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1516:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1518:	4d 49 88    	mov.w     w13, 0x928
	return
    151a:	00 00 06    	return    

0000151c <n1000>:
n1000:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    151c:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    151e:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1520:	30 29 a8    	bset.b    0x930, #0x1
	return
    1522:	00 00 06    	return    

00001524 <n1001>:
n1001:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    1524:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1526:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1528:	30 29 a8    	bset.b    0x930, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    152a:	4d 49 88    	mov.w     w13, 0x928
	return
    152c:	00 00 06    	return    

0000152e <n1010>:
n1010:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    152e:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1530:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1532:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1534:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1536:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1538:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    153a:	00 00 06    	return    

0000153c <n1011>:
n1011:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    153c:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    153e:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1540:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1542:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1544:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1546:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1548:	4d 49 88    	mov.w     w13, 0x928
	return
    154a:	00 00 06    	return    

0000154c <n1100>:

n1100:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    154c:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    154e:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1550:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1552:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1554:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1556:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    1558:	00 00 06    	return    

0000155a <n1101>:
n1101:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    155a:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    155c:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    155e:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1560:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1562:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1564:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1566:	4d 49 88    	mov.w     w13, 0x928
	return
    1568:	00 00 06    	return    

0000156a <n1110>:
n1110:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    156a:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    156c:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    156e:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1570:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1572:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1574:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1576:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1578:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    157a:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    157c:	00 00 06    	return    

0000157e <n1111>:
n1111:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    157e:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1580:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1582:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1584:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1586:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1588:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    158a:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    158c:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    158e:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1590:	4d 49 88    	mov.w     w13, 0x928
	return
    1592:	00 00 06    	return    

00001594 <transfer2>:
;-----------------------------------------------------------------------------------

transfer2:		; in the second clack semiphase or when STEP is released
	bclr	A16,#b_clk_sch
    1594:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch ; set NOCLK schematic
    1596:	ae 69 a8    	bset.b    0x9ae, #0x3
	bra	w6
    1598:	06 60 01    	bra       w6
;...
	return
    159a:	00 00 06    	return    
	bra	z0001
    159c:	0e 00 37    	bra       0x15ba <z0001>
	bra	z0010
    159e:	0f 00 37    	bra       0x15be <z0010>
	bra	z0011
    15a0:	15 00 37    	bra       0x15cc <z0011>
	bra	z0100
    15a2:	1c 00 37    	bra       0x15dc <z0100>
	bra	z0101
    15a4:	1f 00 37    	bra       0x15e4 <z0101>
	bra	z0110
    15a6:	23 00 37    	bra       0x15ee <z0110>
	bra	z0111
    15a8:	2c 00 37    	bra       0x1602 <z0111>
	bra	z1000
    15aa:	36 00 37    	bra       0x1618 <z1000>
	bra	z1001
    15ac:	3c 00 37    	bra       0x1626 <z1001>
	bra	z1010
    15ae:	43 00 37    	bra       0x1636 <z1010>
	bra	z1011
    15b0:	49 00 37    	bra       0x1644 <z1011>
	bra	z1100
    15b2:	56 00 37    	bra       0x1660 <z1100>
	bra	z1101
    15b4:	5f 00 37    	bra       0x1674 <z1101>
	bra	z1110
    15b6:	69 00 37    	bra       0x168a <z1110>
	bra	z1111
    15b8:	78 00 37    	bra       0x16aa <z1111>

000015ba <z0001>:
; -------------------
z0001:
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15ba:	4e 49 80    	mov.w     0x928, w14
	return
    15bc:	00 00 06    	return    

000015be <z0010>:
z0010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15be:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15c0:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15c2:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    15c4:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    15c6:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    15c8:	af 89 a8    	bset.b    0x9af, #0x4
	return
    15ca:	00 00 06    	return    

000015cc <z0011>:
z0011:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15cc:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15ce:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15d0:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    15d2:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    15d4:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    15d6:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15d8:	4e 49 80    	mov.w     0x928, w14
	return
    15da:	00 00 06    	return    

000015dc <z0100>:
z0100:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15dc:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15de:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15e0:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    15e2:	00 00 06    	return    

000015e4 <z0101>:
z0101:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15e4:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15e6:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15e8:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    15ea:	4e 49 80    	mov.w     0x928, w14
	return
    15ec:	00 00 06    	return    

000015ee <z0110>:
z0110:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    15ee:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    15f0:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    15f2:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    15f4:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    15f6:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    15f8:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    15fa:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    15fc:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    15fe:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1600:	00 00 06    	return    

00001602 <z0111>:
z0111:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1602:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1604:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1606:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1608:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    160a:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    160c:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    160e:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1610:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1612:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1614:	4e 49 80    	mov.w     0x928, w14
	return
    1616:	00 00 06    	return    

00001618 <z1000>:
z1000:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1618:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    161a:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    161c:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    161e:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1620:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1622:	f4 28 a8    	bset.b    0x8f4, #0x1
	return
    1624:	00 00 06    	return    

00001626 <z1001>:
z1001:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1626:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1628:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    162a:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    162c:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    162e:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1630:	f4 28 a8    	bset.b    0x8f4, #0x1
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1632:	4e 49 80    	mov.w     0x928, w14
	return
    1634:	00 00 06    	return    

00001636 <z1010>:
z1010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1636:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1638:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    163a:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    163c:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    163e:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1640:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1642:	00 00 06    	return    

00001644 <z1011>:
z1011:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1644:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1646:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1648:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    164a:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    164c:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    164e:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1650:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1652:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1654:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1656:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1658:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    165a:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    165c:	4e 49 80    	mov.w     0x928, w14
	return
    165e:	00 00 06    	return    

00001660 <z1100>:
z1100:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1660:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1662:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1664:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1666:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1668:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    166a:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    166c:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    166e:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1670:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    1672:	00 00 06    	return    

00001674 <z1101>:
z1101:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1674:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1676:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1678:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    167a:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    167c:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    167e:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1680:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1682:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1684:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1686:	4e 49 80    	mov.w     0x928, w14
	return
    1688:	00 00 06    	return    

0000168a <z1110>:
z1110:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    168a:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    168c:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    168e:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1690:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1692:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1694:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1696:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1698:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    169a:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    169c:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    169e:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16a0:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16a2:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16a4:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16a6:	af 89 a8    	bset.b    0x9af, #0x4
	return
    16a8:	00 00 06    	return    

000016aa <z1111>:
z1111:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16aa:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16ac:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16ae:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16b0:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16b2:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16b4:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    16b6:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    16b8:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    16ba:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    16bc:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    16be:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16c0:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16c2:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16c4:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16c6:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    16c8:	4e 49 80    	mov.w     0x928, w14
	return
    16ca:	00 00 06    	return    

000016cc <alu_A1>:

; ----------------------------------------------------------   INSTRUCTIONS  -----

alu_A1:			; ADD  RX,RY
	bclr	BlinkFlag,#0
    16cc:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16ce:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_1
    16d0:	14 1e 02    	call      0x1e14 <dir_4_1>
    16d2:	00 00 00 
	bra	alu_cmd
    16d4:	72 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000016d6 <alu_A2>:
alu_A2:			; ADC  RX,RY
	bclr	BlinkFlag,#0
    16d6:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16d8:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_2
    16da:	7c 1e 02    	call      0x1e7c <dir_4_2>
    16dc:	00 00 00 
	bra	alu_cmd
    16de:	6d fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000016e0 <alu_A3>:
alu_A3:			; SUB  RX,RY
	bclr	BlinkFlag,#0
    16e0:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16e2:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_3
    16e4:	da 1e 02    	call      0x1eda <dir_4_3>
    16e6:	00 00 00 
	bra	alu_cmd
    16e8:	68 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000016ea <alu_A4>:
alu_A4:			; SBB  RX,RY
	bclr	BlinkFlag,#0
    16ea:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16ec:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_4
    16ee:	30 1f 02    	call      0x1f30 <dir_4_4>
    16f0:	00 00 00 
	bra	alu_cmd
    16f2:	63 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000016f4 <alu_A5>:
alu_A5:			; OR   RX,RY
	bclr	BlinkFlag,#0
    16f4:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    16f6:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_5
    16f8:	94 1f 02    	call      0x1f94 <dir_4_5>
    16fa:	00 00 00 
	bra	alu_cmd
    16fc:	5e fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

000016fe <alu_A6>:
alu_A6:			; AND  RX,RY
	bclr	BlinkFlag,#0
    16fe:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1700:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_6
    1702:	d0 1f 02    	call      0x1fd0 <dir_4_6>
    1704:	00 00 00 
	bra	alu_cmd
    1706:	59 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

00001708 <alu_A7>:
alu_A7:			; XOR  RX,RY
	bclr	BlinkFlag,#0
    1708:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    170a:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_7
    170c:	02 20 02    	call      0x2002 <dir_4_7>
    170e:	00 00 00 
	bra	alu_cmd
    1710:	54 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

00001712 <alu_A8>:
alu_A8:			; MOV  RX,RY
	bclr	BlinkFlag,#0
    1712:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1714:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_8
    1716:	34 20 02    	call      0x2034 <dir_4_8>
    1718:	00 00 00 
	bra	alu_cmd
    171a:	4f fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

0000171c <alu_G2>:
;-----------------------
;alu_G0:			; CP    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_0
;	bra	alu_cmd
;alu_G1:			; ADD   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_1
;	bra	alu_cmd
alu_G2:			; INC   RY
	bclr	BlinkFlag,#0
    171c:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    171e:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    1720:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_2
    1722:	44 22 02    	call      0x2244 <dir_8_2>
    1724:	00 00 00 
	bra	alu_cmd
    1726:	49 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

00001728 <alu_G3>:
alu_G3:			; DEC   RY
	bclr	BlinkFlag,#0
    1728:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    172a:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    172c:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_3
    172e:	c4 22 02    	call      0x22c4 <dir_8_3>
    1730:	00 00 00 
	bra	alu_cmd
    1732:	43 fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

00001734 <alu_G13>:
;alu_G5:			; OR    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_5
;	bra	alu_cmd
;alu_G6:			; AND   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_6
;	bra	alu_cmd
;alu_G7:			; XOR   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_7
;	bra	alu_cmd
;alu_G9:			; BIT   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+11,w7	; register read address = IN port
;	call	dir_8_9
;	bra	alu_cmd
;alu_G10:		; BSET  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_10
;	bra	alu_cmd
;alu_G11:		; BCLR  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_11
;	bra	alu_cmd
;alu_G12:		; BTG   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_12
;	bra	alu_cmd
alu_G13:		; RRC   RY
	bclr	BlinkFlag,#0
    1734:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1736:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    1738:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_13
    173a:	5a 25 02    	call      0x255a <dir_8_13>
    173c:	00 00 00 
	bra	alu_cmd
    173e:	3d fd 37    	bra       0x11ba <alu_cmd> <alu_wait_key>

00001740 <peek_flash>:

; --------------------------------------------------------------------

peek_flash:		; measure all 16 Flash occupancies, write to Files (16×1 by) 37 ms
	mov	#Files,w5	; wr ptr
    1740:	65 96 20    	mov.w     #0x966, w5
	mov	#0,w8		; loop count and record count
    1742:	08 00 20    	mov.w     #0x0, w8

00001744 <L83>:
8:
	mov	w8,w0
    1744:	08 00 78    	mov.w     w8, w0
	call	eemeasure	; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
    1746:	48 02 02    	call      0x248 <eemeasure>
    1748:	00 00 00 
	mov.b	w2,[w5++]
    174a:	82 5a 78    	mov.b     w2, [w5++]
	inc	w8,w8
    174c:	08 04 e8    	inc.w     w8, w8
	btss	w8,#4
    174e:	08 40 a6    	btss.w    w8, #0x4
	bra	8b
    1750:	f9 ff 37    	bra       0x1744 <L83>
	return
    1752:	00 00 06    	return    

00001754 <leave_alu_ept>:

; --------------------------------------------------------------------
; --------------------------------------------------------------------
; --------------------------------------------------------------------

leave_alu_ept:
; save ALU variables to ALU Temp
	mov	Opcode,w0
    1754:	10 49 80    	mov.w     0x922, w0
	mov	w0,AluTempOpcode ; Opcode
    1756:	90 49 88    	mov.w     w0, 0x932
	mov	OperX,w0
    1758:	20 49 80    	mov.w     0x924, w0
	mov	w0,AluTempOperX	; OperX
    175a:	a0 49 88    	mov.w     w0, 0x934
	mov	OperY,w0
    175c:	30 49 80    	mov.w     0x926, w0
	mov	w0,AluTempOperY	; OperY
    175e:	b0 49 88    	mov.w     w0, 0x936
	mov	Atemp,w0
    1760:	40 49 80    	mov.w     0x928, w0
	mov	w0,AluTempAtemp	; Accu temp
    1762:	c0 49 88    	mov.w     w0, 0x938
	mov	w14,AluTempw14	; Accu out
    1764:	ee 49 88    	mov.w     w14, 0x93c
	mov	w13,AluTempw13	; Accu in
    1766:	dd 49 88    	mov.w     w13, 0x93a
; save Alu flags
	mov	Vflag,w0
    1768:	80 49 80    	mov.w     0x930, w0
	mov	w0,AluTempVflag
    176a:	f0 49 88    	mov.w     w0, 0x93e
	mov	Zflag,w0
    176c:	70 49 80    	mov.w     0x92e, w0
	mov	w0,AluTempZflag
    176e:	00 4a 88    	mov.w     w0, 0x940
	mov	Cflag,w0
    1770:	60 49 80    	mov.w     0x92c, w0
	mov	w0,AluTempCflag
    1772:	10 4a 88    	mov.w     w0, 0x942
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1774:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_ept
    1776:	01 00 37    	bra       0x177a <ss_ept>
	bra	pgm_ept
    1778:	67 08 37    	bra       0x2848 <pgm_ept>

0000177a <ss_ept>:

ss_ept:
	btss	Flag2,#12
    177a:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    177c:	d6 10 02    	call      0x10d6 <clr_ram>
    177e:	00 00 00 
	bset	Flag2,#12
    1780:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload SS variables from RUN Temp
	mov	SSTempPage,w0
    1782:	30 4a 80    	mov.w     0x946, w0
	mov.b	WREG,Page	; Page
    1784:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	SSTempStack,w0
    1786:	40 4a 80    	mov.w     0x948, w0
	mov	w0,Stack	; Stack
    1788:	50 49 88    	mov.w     w0, 0x92a
	mov	SSTempPMAddr,w9	; PC
    178a:	29 4a 80    	mov.w     0x944, w9
	mov	SSTempw14,w14
    178c:	9e 4a 80    	mov.w     0x952, w14
	mov	SSTempw13,w13
    178e:	8d 4a 80    	mov.w     0x950, w13
; restore SS flags
	mov	SSTempVflag,w0
    1790:	50 4a 80    	mov.w     0x94a, w0
	mov	w0,Vflag
    1792:	80 49 88    	mov.w     w0, 0x930
	mov	SSTempZflag,w0
    1794:	60 4a 80    	mov.w     0x94c, w0
	mov	w0,Zflag
    1796:	70 49 88    	mov.w     w0, 0x92e
	mov	SSTempCflag,w0
    1798:	70 4a 80    	mov.w     0x94e, w0
	mov	w0,Cflag
    179a:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    179c:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    179e:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    17a0:	af 89 a8    	bset.b    0x9af, #0x4
; SS initialize
	mov	#1,w0		; 1 = SS
    17a2:	10 00 20    	mov.w     #0x1, w0
	mov	w0,Mode		; Mode
    17a4:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    17a6:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    17a8:	54 20 ef    	clr.w     0x54
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    17aa:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    17ac:	df 69 a8    	bset.b    0x9df, #0x3
	mov	SSTempPMAddr,w9 ; const
    17ae:	29 4a 80    	mov.w     0x944, w9
	mov	#Ram,w10	; const
    17b0:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    17b2:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    17b4:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    17b6:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b011111100,w0	; autorpt allow flag: #0-4=keys1-5, #5=keys6-9,
    17b8:	c0 0f 20    	mov.w     #0xfc, w0
	mov	w0,AutorptFlag	; #6=keys10-13, #7=keys14-17, #8=key18
    17ba:	60 4d 88    	mov.w     w0, 0x9ac
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    17bc:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    17be:	00 07 eb    	clr.w     w14
	bclr	Flag2,#5	; #5 Fatal Stack Error
    17c0:	de a9 a9    	bclr.b    0x9de, #0x5
; prepare A16 (set SS and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    17c2:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    17c4:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000010000001000,w0	; set SS and -CLK
    17c6:	80 40 20    	mov.w     #0x408, w0
	ior	A16
    17c8:	ae 29 b7    	ior.w     0x9ae
;	
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    17ca:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    17cc:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    17ce:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    17d0:	9b 83 a8    	bset.b    0x39b, #0x4
	bclr	Flag,#9		; possible write to SFR area
    17d2:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10	; possible read from SFR area
    17d4:	dd 49 a9    	bclr.b    0x9dd, #0x2

000017d6 <ss_farm>:
; ------------------------------
ss_farm:
	bclr	Flag,#5		; #5 set: in HISTORY mode
    17d6:	dc a9 a9    	bclr.b    0x9dc, #0x5
	bclr	BlinkFlag,#3	; #3 set: LED SS blinks
    17d8:	e0 69 a9    	bclr.b    0x9e0, #0x3
	call	read12
    17da:	6c 29 02    	call      0x296c <read12>
    17dc:	00 00 00 
; check if Stack Error occured
	btss	Flag2,#5	; #5 Fatal Stack Error
    17de:	de a9 ae    	btss.b    0x9de, #0x5
	bra	no_SS_StackErr
    17e0:	09 00 37    	bra       0x17f4 <no_SS_StackErr> <ss_noread>
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    17e2:	e0 c9 a8    	bset.b    0x9e0, #0x6

000017e4 <L17>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    17e4:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    17e6:	02 00 37    	bra       0x17ec <L24>
	btss	Flag,#1		; #1 handshaking flag for buttons
    17e8:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    17ea:	fc ff 37    	bra       0x17e4 <L17>

000017ec <L24>:
2:
	bclr	Flag,#1
    17ec:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    17ee:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    17f0:	2a 29 ef    	clr.w     0x92a
	bclr	Flag2,#5	; #5 Fatal Stack Error
    17f2:	de a9 a9    	bclr.b    0x9de, #0x5

000017f4 <no_SS_StackErr>:
;	call	clr_ram
no_SS_StackErr:
ss_noread:
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    17f4:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    17f6:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    17f8:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    17fa:	7a e6 b7    	mov.b     WREG, 0x67a

	bclr	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    17fc:	dc 89 a9    	bclr.b    0x9dc, #0x4
	mov	OperX,w11	; w11 = OperX
    17fe:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12	; w12 = OperY
    1800:	3c 49 80    	mov.w     0x926, w12
	mov	Opcode,w0	; w0 = Opcode
    1802:	10 49 80    	mov.w     0x922, w0
	and	#0x0F,w0
    1804:	f0 00 b2    	and.w     #0xf, w0
	bra	z,group8runb	; ---------> 8-bit opcode
    1806:	32 00 32    	bra       Z, 0x186c <group8runb>
; w0 = instruction
	mul.uu	w0,#3,w0
    1808:	63 00 b8    	mul.uu    w0, #0x3, w0
	bra	w0
    180a:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0		; non-existing instruction
	callSS	ind_4_1		; ADD  RX,RY
    1812:	06 1e 02    	call      0x1e06 <ind_4_1>
    1814:	00 00 00 
    1816:	5c 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_2		; ADC  RX,RY
    1818:	6e 1e 02    	call      0x1e6e <ind_4_2>
    181a:	00 00 00 
    181c:	59 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_3		; SUB  RX,RY
    181e:	cc 1e 02    	call      0x1ecc <ind_4_3>
    1820:	00 00 00 
    1822:	56 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_4		; SBB  RX,RY
    1824:	22 1f 02    	call      0x1f22 <ind_4_4>
    1826:	00 00 00 
    1828:	53 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_5		; OR   RX,RY
    182a:	86 1f 02    	call      0x1f86 <ind_4_5>
    182c:	00 00 00 
    182e:	50 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_6		; AND  RX,RY
    1830:	c2 1f 02    	call      0x1fc2 <ind_4_6>
    1832:	00 00 00 
    1834:	4d 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_7		; XOR  RX,RY
    1836:	f4 1f 02    	call      0x1ff4 <ind_4_7>
    1838:	00 00 00 
    183a:	4a 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_8		; MOV  RX,RY
    183c:	26 20 02    	call      0x2026 <ind_4_8>
    183e:	00 00 00 
    1840:	47 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_9		; MOV  RX,N (TEST PCL)
    1842:	60 20 02    	call      0x2060 <ind_4_9>
    1844:	00 00 00 
    1846:	44 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_10	; MOV  [XY],R0
    1848:	94 20 02    	call      0x2094 <ind_4_10>
    184a:	00 00 00 
    184c:	41 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_11	; MOV  R0,[XY]
    184e:	ca 20 02    	call      0x20ca <ind_4_11>
    1850:	00 00 00 
    1852:	3e 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_12	; MOV  [NN],R0
    1854:	02 21 02    	call      0x2102 <ind_4_12>
    1856:	00 00 00 
    1858:	3b 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_13	; MOV  R0,[NN]
    185a:	34 21 02    	call      0x2134 <ind_4_13>
    185c:	00 00 00 
    185e:	38 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_14	; MOV  PC,NN
    1860:	68 21 02    	call      0x2168 <ind_4_14>
    1862:	00 00 00 
    1864:	35 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_4_15	; JR   NN
    1866:	88 21 02    	call      0x2188 <ind_4_15>
    1868:	00 00 00 
    186a:	32 00 37    	bra       0x18d0 <L18> <ss_cont>

0000186c <group8runb>:
;...
group8runb:
; w0 = instruction
	mul.uu	w11,#3,w0
    186c:	63 58 b8    	mul.uu    w11, #0x3, w0
	bra	w0
    186e:	00 60 01    	bra       w0
;jp table
	callSS	ind_8_0		; CP   R0,N
    1870:	a4 21 02    	call      0x21a4 <ind_8_0>
    1872:	00 00 00 
    1874:	2d 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_1		; ADD  R0,N
    1876:	f0 21 02    	call      0x21f0 <ind_8_1>
    1878:	00 00 00 
    187a:	2a 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_2		; INC  RY (TEST PCL)
    187c:	40 22 02    	call      0x2240 <ind_8_2>
    187e:	00 00 00 
    1880:	27 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_3		; DEC  RY (TEST PCL)
    1882:	c0 22 02    	call      0x22c0 <ind_8_3>
    1884:	00 00 00 
    1886:	24 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_4		; DSZ  RY
    1888:	3e 23 02    	call      0x233e <ind_8_4>
    188a:	00 00 00 
    188c:	21 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_5		; OR   R0,N
    188e:	7a 23 02    	call      0x237a <ind_8_5>
    1890:	00 00 00 
    1892:	1e 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_6		; AND  R0,N
    1894:	c4 23 02    	call      0x23c4 <ind_8_6>
    1896:	00 00 00 
    1898:	1b 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_7		; XOR  R0,N
    189a:	fe 23 02    	call      0x23fe <ind_8_7>
    189c:	00 00 00 
    189e:	18 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_8		; EXR  N
    18a0:	44 24 02    	call      0x2444 <ind_8_8>
    18a2:	00 00 00 
    18a4:	15 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_9		; BIT  RG,M
    18a6:	7a 24 02    	call      0x247a <ind_8_9>
    18a8:	00 00 00 
    18aa:	12 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_10	; BSET RG,M
    18ac:	bc 24 02    	call      0x24bc <ind_8_10>
    18ae:	00 00 00 
    18b0:	0f 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_11	; BCLR RG,M
    18b2:	ec 24 02    	call      0x24ec <ind_8_11>
    18b4:	00 00 00 
    18b6:	0c 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_12	; BTG  RG,M
    18b8:	1e 25 02    	call      0x251e <ind_8_12>
    18ba:	00 00 00 
    18bc:	09 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_13	; RRC  RY
    18be:	4e 25 02    	call      0x254e <ind_8_13>
    18c0:	00 00 00 
    18c2:	06 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_14	; RET  R0,N
    18c4:	90 25 02    	call      0x2590 <ind_8_14>
    18c6:	00 00 00 
    18c8:	03 00 37    	bra       0x18d0 <L18> <ss_cont>
	callSS	ind_8_15	; SKIP F,M
    18ca:	bc 25 02    	call      0x25bc <ind_8_15>
    18cc:	00 00 00 
    18ce:	00 00 37    	bra       0x18d0 <L18> <ss_cont>

000018d0 <L18>:
;..............................................
ss_cont:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    18d0:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    18d2:	fe ff 37    	bra       0x18d0 <L18> <ss_cont>
	bclr	Flag,#1
    18d4:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    18d6:	30 4d 80    	mov.w     0x9a6, w0
; test if Rnd has to be invoked
	cp.b	w0,#17		; Data In
    18d8:	71 04 e1    	cp.b      w0, #0x11
	bra	nz,9f		; if not key Data In
    18da:	06 00 3a    	bra       NZ, 0x18e8 <L93>
	mov	Page,w0
    18dc:	80 47 80    	mov.w     0x8f0, w0
	cp.b	w0,#0x0F
    18de:	6f 04 e1    	cp.b      w0, #0xf
	ifz			; if Page=15
    18e0:	42 20 af    	btsc.b    0x42, #0x1
	call	new_rnd
    18e2:	b8 27 02    	call      0x27b8 <new_rnd>
    18e4:	00 00 00 
	mov	Just,w0
    18e6:	30 4d 80    	mov.w     0x9a6, w0

000018e8 <L93>:
9:
; continue
	cp	w0,#5
    18e8:	65 00 e1    	cp.w      w0, #0x5
	ifc
    18ea:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    18ec:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    18ee:	00 60 01    	bra       w0
; ...
	bra	leave_ss_ept		; mode ++
    18f0:	47 00 37    	bra       0x1980 <leave_ss_ept>
	bra	button_ss_history	; ss_history
    18f2:	04 00 37    	bra       0x18fc <button_ss_history>
	bra	button_ss_addr_minus	; ss_addr_minus
    18f4:	0c 00 37    	bra       0x190e <button_ss_addr_minus>
	bra	button_ss_addr_plus	; ss_addr_plus
    18f6:	11 00 37    	bra       0x191a <button_ss_addr_plus>
	bra	button_ss_step		; ss_step
    18f8:	2b 00 37    	bra       0x1950 <button_ss_step>
	bra	button_ss_key5plus
    18fa:	06 00 37    	bra       0x1908 <button_ss_key5plus>

000018fc <button_ss_history>:
;				
button_ss_history:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    18fc:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_history		; ss_history ------>
    18fe:	4c 0d 37    	bra       0x3398 <ss_history>
	btg	A16,#b_carry
    1900:	af 89 aa    	btg.b     0x9af, #0x4
	call	read12
    1902:	6c 29 02    	call      0x296c <read12>
    1904:	00 00 00 
	bra	ss_noread
    1906:	76 ff 37    	bra       0x17f4 <no_SS_StackErr> <ss_noread>

00001908 <button_ss_key5plus>:
;				
button_ss_key5plus:
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    1908:	34 14 02    	call      0x1434 <general_key_3O>
    190a:	00 00 00 
	bra	ss_noread
    190c:	73 ff 37    	bra       0x17f4 <no_SS_StackErr> <ss_noread>

0000190e <button_ss_addr_minus>:
; --------------------------------------------------
button_ss_addr_minus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    190e:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adr000_ss	; if alt-ADR minus pressed
    1910:	0a 00 37    	bra       0x1926 <adr000_ss>
	dec2	w9,w9		; decrement address
    1912:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    1914:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    1916:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	ss_farm
    1918:	5e ff 37    	bra       0x17d6 <ss_farm>

0000191a <button_ss_addr_plus>:
; -----------
button_ss_addr_plus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    191a:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adrFFF_ss	; if alt-ADR plus pressed
    191c:	0c 00 37    	bra       0x1936 <adrFFF_ss>

0000191e <ss_adr_plus>:
ss_adr_plus:
	inc2	w9,w9		; increment address
    191e:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    1920:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    1922:	09 00 22    	mov.w     #0x2000, w9
	bra	ss_farm
    1924:	58 ff 37    	bra       0x17d6 <ss_farm>

00001926 <adr000_ss>:
;		
adr000_ss:
	clr	Stack
    1926:	2a 29 ef    	clr.w     0x92a
	clr.b	Page
    1928:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    192a:	09 00 22    	mov.w     #0x2000, w9
	call	clr_ram
    192c:	d6 10 02    	call      0x10d6 <clr_ram>
    192e:	00 00 00 
	call	read12
    1930:	6c 29 02    	call      0x296c <read12>
    1932:	00 00 00 
	bra	ss_noread
    1934:	5f ff 37    	bra       0x17f4 <no_SS_StackErr> <ss_noread>

00001936 <adrFFF_ss>:
;		
adrFFF_ss:
	call	find_last
    1936:	40 19 02    	call      0x1940 <find_last>
    1938:	00 00 00 
	call	read12
    193a:	6c 29 02    	call      0x296c <read12>
    193c:	00 00 00 
	bra	ss_noread
    193e:	5a ff 37    	bra       0x17f4 <no_SS_StackErr> <ss_noread>

00001940 <find_last>:
;		
find_last:
	mov	#Rom+0x2000,w9	; pointer on top of pgm mem
    1940:	09 00 24    	mov.w     #0x4000, w9
	mov	#0x1000,w1	; loop count
    1942:	01 00 21    	mov.w     #0x1000, w1

00001944 <L19>:
1:
	cp0	[--w9]
    1944:	49 00 e0    	cp0.w     [--w9]
	ifnz
    1946:	42 20 ae    	btss.b    0x42, #0x1
	return
    1948:	00 00 06    	return    
	dec	w1,w1
    194a:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    194c:	fb ff 3a    	bra       NZ, 0x1944 <L19>
	return
    194e:	00 00 06    	return    

00001950 <button_ss_step>:

; ------------------------------------------------
button_ss_step:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1950:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	final_ss_step	; if not ALT, then simple ss_step
    1952:	09 00 37    	bra       0x1966 <final_ss_step>
; address set from Opc/OperX/OperY
	mov	Opcode,w0
    1954:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    1956:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    1958:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    195a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    195c:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    195e:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    1960:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    1962:	81 04 40    	add.w     w0, w1, w9
	bra	ss_farm
    1964:	38 ff 37    	bra       0x17d6 <ss_farm>

00001966 <final_ss_step>:
;		
final_ss_step:
	call	insert		; shift buffer up, pack and insert new 32 by (used 28, spare 4)
    1966:	f4 33 02    	call      0x33f4 <insert>
    1968:	00 00 00 
; w6 = flags to affect
	bset	A16,#b_clk_key	; set CLK key
    196a:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w6 bits to decide flag transfer
    196c:	b0 14 02    	call      0x14b0 <transfer1>
    196e:	00 00 00 

00001970 <L25>:
2:				; wait for key STEP released
	inc	KeyRotors+8,WREG
    1970:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,2b		; if not yet 0x1111111111111111
    1972:	fe ff 3a    	bra       NZ, 0x1970 <L25>
	bclr	A16,#b_clk_key
    1974:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w6 bits to decide flag transfer
    1976:	94 15 02    	call      0x1594 <transfer2>
    1978:	00 00 00 
	call	ins_part_2	; INSTRUCTION PART 2
    197a:	2c 1d 02    	call      0x1d2c <ins_part_2>
    197c:	00 00 00 
	bra	ss_farm		; LOOP -------------------------------------->
    197e:	2b ff 37    	bra       0x17d6 <ss_farm>

00001980 <leave_ss_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_ss_ept:
	clr	BlinkFlag
    1980:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    1982:	54 20 ef    	clr.w     0x54
; save SS variables to SS Temp
	mov.b	Page,WREG
    1984:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,SSTempPage	; Page
    1986:	46 e9 b7    	mov.b     WREG, 0x946
	mov	Stack,w0
    1988:	50 49 80    	mov.w     0x92a, w0
	mov	w0,SSTempStack	; Stack
    198a:	40 4a 88    	mov.w     w0, 0x948
	mov	w9,SSTempPMAddr	; PC
    198c:	29 4a 88    	mov.w     w9, 0x944
	mov	w14,SSTempw14
    198e:	9e 4a 88    	mov.w     w14, 0x952
	mov	w13,SSTempw13
    1990:	8d 4a 88    	mov.w     w13, 0x950
; save SS flags
	mov	Vflag,w0
    1992:	80 49 80    	mov.w     0x930, w0
	mov	w0,SSTempVflag
    1994:	50 4a 88    	mov.w     w0, 0x94a
	mov	Zflag,w0
    1996:	70 49 80    	mov.w     0x92e, w0
	mov	w0,SSTempZflag
    1998:	60 4a 88    	mov.w     w0, 0x94c
	mov	Cflag,w0
    199a:	60 49 80    	mov.w     0x92c, w0
	mov	w0,SSTempCflag
    199c:	70 4a 88    	mov.w     w0, 0x94e
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    199e:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	run_ept
    19a0:	01 00 37    	bra       0x19a4 <run_ept>
	bra	alu_ept
    19a2:	a2 fb 37    	bra       0x10e8 <alu_ept>

000019a4 <run_ept>:
; #2 set: Transfer Zero flag after this instruction
; #3 set: Transfer Overflow flag after this instruction

run_ept:
	btss	Flag2,#12
    19a4:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    19a6:	d6 10 02    	call      0x10d6 <clr_ram>
    19a8:	00 00 00 
	bset	Flag2,#12
    19aa:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload RUN variables from RUN Temp
	mov	RunTempPMAddr,w9 ; PC
    19ac:	a9 4a 80    	mov.w     0x954, w9
	mov	RunTempStack,w0
    19ae:	b0 4a 80    	mov.w     0x956, w0
	mov	w0,Stack
    19b0:	50 49 88    	mov.w     w0, 0x92a
	mov	RunTempPage,w0
    19b2:	c0 4a 80    	mov.w     0x958, w0
	mov.b	WREG,Page	; restore Page
    19b4:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	RunTempw14,w14
    19b6:	1e 4b 80    	mov.w     0x962, w14
	mov	RunTempw13,w13
    19b8:	0d 4b 80    	mov.w     0x960, w13
; restore RUN flags
	mov	RunTempVflag,w0
    19ba:	d0 4a 80    	mov.w     0x95a, w0
	mov	w0,Vflag
    19bc:	80 49 88    	mov.w     w0, 0x930
	mov	RunTempZflag,w0
    19be:	e0 4a 80    	mov.w     0x95c, w0
	mov	w0,Zflag
    19c0:	70 49 88    	mov.w     w0, 0x92e
	mov	RunTempCflag,w0
    19c2:	f0 4a 80    	mov.w     0x95e, w0
	mov	w0,Cflag
    19c4:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    19c6:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    19c8:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    19ca:	af 89 a8    	bset.b    0x9af, #0x4
; RUN initialize
	mov	#2,w0		; 2 = RUN
    19cc:	20 00 20    	mov.w     #0x2, w0
	mov	w0,Mode
    19ce:	b0 4b 88    	mov.w     w0, 0x976
	mov	#0,w0		; default speed 0 (max)
    19d0:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    19d2:	08 26 02    	call      0x2608 <set_T2_from_w0>
    19d4:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    19d6:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    19d8:	3a 26 02    	call      0x263a <set_T3_from_w0>
    19da:	00 00 00 
	mov	#Ram,w10	; const
    19dc:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    19de:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    19e0:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    19e2:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    19e4:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    19e6:	60 4d 88    	mov.w     w0, 0x9ac
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    19e8:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#5		; #5 set in HISTORY mode
    19ea:	dc a9 a9    	bclr.b    0x9dc, #0x5
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    19ec:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    19ee:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    19f0:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    19f2:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000001000001000,w0	; set RUN and -CLK
    19f4:	80 20 20    	mov.w     #0x208, w0
	ior	A16
    19f6:	ae 29 b7    	ior.w     0x9ae

	bclr	Flag,#9
    19f8:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10
    19fa:	dd 49 a9    	bclr.b    0x9dd, #0x2

000019fc <run_wait_key>:
run_wait_key:		; outside pgm execution
	bclr	Flag2,#1	; #1 program Runs 
    19fc:	de 29 a9    	bclr.b    0x9de, #0x1
	bclr	A16,#b_clk_key	; LED RUN off
    19fe:	ae 49 a9    	bclr.b    0x9ae, #0x2

00001a00 <L110>:
1:
	bclr	Flag,#3		; #3 set = no RAM matrix display
    1a00:	dc 69 a9    	bclr.b    0x9dc, #0x3
	btss	Flag,#1		; #1 handshaking flag for buttons
    1a02:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1a04:	fd ff 37    	bra       0x1a00 <L110>
	bclr	Flag,#1
    1a06:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1a08:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1a0a:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1a0c:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1a0e:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1a10:	00 60 01    	bra       w0
; ...
	bra	leave_run_ept	; mode ++
    1a12:	0a 07 37    	bra       0x2828 <leave_run_ept>
	bra	run_wait_key	; run_fast
    1a14:	f3 ff 37    	bra       0x19fc <run_wait_key>
	bra	run_wait_key	; run_pause
    1a16:	f2 ff 37    	bra       0x19fc <run_wait_key>
	bra	run_wait_key	; run_break
    1a18:	f1 ff 37    	bra       0x19fc <run_wait_key>
	bra	run_run
    1a1a:	08 00 37    	bra       0x1a2c <run_run>
	bra	run_keys_5
    1a1c:	00 00 37    	bra       0x1a1e <run_keys_5>

00001a1e <run_keys_5>:
;				
run_keys_5:
; 13 buttons OPCODE 8... DATA IN
	call	limited_key_3	; can't affect pgm data, only Sync Clock Page
    1a1e:	2c 14 02    	call      0x142c <limited_key_3>
    1a20:	00 00 00 
	call	set_T2_from_Speed
    1a22:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    1a24:	00 00 00 
	call	set_T3_from_Sync
    1a26:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    1a28:	00 00 00 
	bra	run_wait_key
    1a2a:	e8 ff 37    	bra       0x19fc <run_wait_key>

00001a2c <run_run>:

; ------------------------------------------------
run_run:
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    1a2c:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    1a2e:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    1a30:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    1a32:	9b 83 a8    	bset.b    0x39b, #0x4

	bclr	BlinkFlag,#2	; 2 set = LED Run blinks
    1a34:	e0 49 a9    	bclr.b    0x9e0, #0x2
	mov	#RX_buf,w0
    1a36:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1a38:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1a3a:	f0 4d 88    	mov.w     w0, 0x9be
	bset	Flag2,#1	; #1 program Runs 
    1a3c:	de 29 a8    	bset.b    0x9de, #0x1
	mov	#0b000000000,w0	; no autorpt in runtime
    1a3e:	00 00 20    	mov.w     #0x0, w0
	mov	w0,AutorptFlag
    1a40:	60 4d 88    	mov.w     w0, 0x9ac
	bset	A16,#b_clk_key	 ; LED RUN on
    1a42:	ae 49 a8    	bset.b    0x9ae, #0x2
	bclr	A16,#b_carry
    1a44:	af 89 a9    	bclr.b    0x9af, #0x4
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1a46:	de a9 a9    	bclr.b    0x9de, #0x5
	mov	#Rom,w9
    1a48:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1a4a:	6c 29 02    	call      0x296c <read12>
    1a4c:	00 00 00 
	call	clr_ram
    1a4e:	d6 10 02    	call      0x10d6 <clr_ram>
    1a50:	00 00 00 
	clr	Stack
    1a52:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    1a54:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    1a56:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    1a58:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1a5a:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1a5c:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1a5e:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1a60:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1a62:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1a64:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1a66:	f8 27 02    	call      0x27f8 <rxtx_to_rxtxpos>
    1a68:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1a6a:	c4 27 02    	call      0x27c4 <set_U1BRG>
    1a6c:	00 00 00 
	call	read12		; READ 12
    1a6e:	6c 29 02    	call      0x296c <read12>
    1a70:	00 00 00 

00001a72 <run_farm>:
run_farm:
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    1a72:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    1a74:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    1a76:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    1a78:	7a e6 b7    	mov.b     WREG, 0x67a
; check if Stack Error occured
	btsc	Flag2,#5	; #5 Fatal Stack Error
    1a7a:	de a9 af    	btsc.b    0x9de, #0x5
	bra	Run_StackErr
    1a7c:	18 01 37    	bra       0x1cae <Run_StackErr>
; check if runtime key pressed
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1a7e:	dc 89 a9    	bclr.b    0x9dc, #0x4
	btsc	Flag,#1		; #1 handshaking flag for buttons
    1a80:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	runtime_key_0	; key pressed during pgm execution
    1a82:	d0 00 37    	bra       0x1c24 <runtime_key_0>

00001a84 <runtime_back_0>:
runtime_back_0:
	bclr	Flag2,#11	; #11 = previous Flag,#2
    1a84:	df 69 a9    	bclr.b    0x9df, #0x3
	btsc	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    1a86:	dc 49 af    	btsc.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    1a88:	df 69 a8    	bset.b    0x9df, #0x3
; [PC] ---> w12,OperY, w11,OperX, w0,Opcode
	mov	[w9],w0		; read instruction
    1a8a:	19 00 78    	mov.w     [w9], w0
	and	w0,#0x0F,w12
    1a8c:	6f 06 60    	and.w     w0, #0xf, w12
	mov	w12,OperY	; w12 = OperY
    1a8e:	3c 49 88    	mov.w     w12, 0x926
	lsr	w0,#4,w11
    1a90:	c4 05 de    	lsr.w     w0, #0x4, w11
	and	w11,#0x0F,w11
    1a92:	ef 85 65    	and.w     w11, #0xf, w11
	mov	w11,OperX	; w11 = OperX
    1a94:	2b 49 88    	mov.w     w11, 0x924
	lsr	w0,#8,w0
    1a96:	48 00 de    	lsr.w     w0, #0x8, w0
	mov	w0,Opcode	; w0 = Opcode
    1a98:	10 49 88    	mov.w     w0, 0x922
	bra	z,group8run	; ---------> 8-bit opcode
    1a9a:	62 00 32    	bra       Z, 0x1b60 <group8run>
; table jump, w0 = instruction
	mul.uu	w0,#6,w0
    1a9c:	66 00 b8    	mul.uu    w0, #0x6, w0
	bra	w0		; execution step 1 (4-bit opcode)
    1a9e:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0,0,0,0	; non-existing instruction
	callRUN	ind_4_1		; ADD  RX,RY
    1aac:	06 1e 02    	call      0x1e06 <ind_4_1>
    1aae:	00 00 00 
    1ab0:	df 69 af    	btsc.b    0x9df, #0x3
    1ab2:	0c 1d 02    	call      0x1d0c <run_cont>
    1ab4:	00 00 00 
    1ab6:	dd ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_2		; ADC  RX,RY
    1ab8:	6e 1e 02    	call      0x1e6e <ind_4_2>
    1aba:	00 00 00 
    1abc:	df 69 af    	btsc.b    0x9df, #0x3
    1abe:	0c 1d 02    	call      0x1d0c <run_cont>
    1ac0:	00 00 00 
    1ac2:	d7 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_3		; SUB  RX,RY
    1ac4:	cc 1e 02    	call      0x1ecc <ind_4_3>
    1ac6:	00 00 00 
    1ac8:	df 69 af    	btsc.b    0x9df, #0x3
    1aca:	0c 1d 02    	call      0x1d0c <run_cont>
    1acc:	00 00 00 
    1ace:	d1 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_4		; SBB  RX,RY
    1ad0:	22 1f 02    	call      0x1f22 <ind_4_4>
    1ad2:	00 00 00 
    1ad4:	df 69 af    	btsc.b    0x9df, #0x3
    1ad6:	0c 1d 02    	call      0x1d0c <run_cont>
    1ad8:	00 00 00 
    1ada:	cb ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_5		; OR   RX,RY
    1adc:	86 1f 02    	call      0x1f86 <ind_4_5>
    1ade:	00 00 00 
    1ae0:	df 69 af    	btsc.b    0x9df, #0x3
    1ae2:	0c 1d 02    	call      0x1d0c <run_cont>
    1ae4:	00 00 00 
    1ae6:	c5 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_6		; AND  RX,RY
    1ae8:	c2 1f 02    	call      0x1fc2 <ind_4_6>
    1aea:	00 00 00 
    1aec:	df 69 af    	btsc.b    0x9df, #0x3
    1aee:	0c 1d 02    	call      0x1d0c <run_cont>
    1af0:	00 00 00 
    1af2:	bf ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_7		; XOR  RX,RY
    1af4:	f4 1f 02    	call      0x1ff4 <ind_4_7>
    1af6:	00 00 00 
    1af8:	df 69 af    	btsc.b    0x9df, #0x3
    1afa:	0c 1d 02    	call      0x1d0c <run_cont>
    1afc:	00 00 00 
    1afe:	b9 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_8		; MOV  RX,RY (TEST PCL)
    1b00:	26 20 02    	call      0x2026 <ind_4_8>
    1b02:	00 00 00 
    1b04:	df 69 af    	btsc.b    0x9df, #0x3
    1b06:	0c 1d 02    	call      0x1d0c <run_cont>
    1b08:	00 00 00 
    1b0a:	b3 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_9		; MOV  RX,N (TEST PCL)
    1b0c:	60 20 02    	call      0x2060 <ind_4_9>
    1b0e:	00 00 00 
    1b10:	df 69 af    	btsc.b    0x9df, #0x3
    1b12:	0c 1d 02    	call      0x1d0c <run_cont>
    1b14:	00 00 00 
    1b16:	ad ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_10	; MOV  [XY],R0
    1b18:	94 20 02    	call      0x2094 <ind_4_10>
    1b1a:	00 00 00 
    1b1c:	df 69 af    	btsc.b    0x9df, #0x3
    1b1e:	0c 1d 02    	call      0x1d0c <run_cont>
    1b20:	00 00 00 
    1b22:	a7 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_11	; MOV  R0,[XY]
    1b24:	ca 20 02    	call      0x20ca <ind_4_11>
    1b26:	00 00 00 
    1b28:	df 69 af    	btsc.b    0x9df, #0x3
    1b2a:	0c 1d 02    	call      0x1d0c <run_cont>
    1b2c:	00 00 00 
    1b2e:	a1 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_12	; MOV  [NN],R0
    1b30:	02 21 02    	call      0x2102 <ind_4_12>
    1b32:	00 00 00 
    1b34:	df 69 af    	btsc.b    0x9df, #0x3
    1b36:	0c 1d 02    	call      0x1d0c <run_cont>
    1b38:	00 00 00 
    1b3a:	9b ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_13	; MOV  R0,[NN]
    1b3c:	34 21 02    	call      0x2134 <ind_4_13>
    1b3e:	00 00 00 
    1b40:	df 69 af    	btsc.b    0x9df, #0x3
    1b42:	0c 1d 02    	call      0x1d0c <run_cont>
    1b44:	00 00 00 
    1b46:	95 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_14	; MOV  PC,NN
    1b48:	68 21 02    	call      0x2168 <ind_4_14>
    1b4a:	00 00 00 
    1b4c:	df 69 af    	btsc.b    0x9df, #0x3
    1b4e:	0c 1d 02    	call      0x1d0c <run_cont>
    1b50:	00 00 00 
    1b52:	8f ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_4_15	; JR   NN
    1b54:	88 21 02    	call      0x2188 <ind_4_15>
    1b56:	00 00 00 
    1b58:	df 69 af    	btsc.b    0x9df, #0x3
    1b5a:	0c 1d 02    	call      0x1d0c <run_cont>
    1b5c:	00 00 00 
    1b5e:	89 ff 37    	bra       0x1a72 <run_farm>

00001b60 <group8run>:
;...
group8run:
; table jump, w0 = instruction
	mul.uu	w11,#6,w0
    1b60:	66 58 b8    	mul.uu    w11, #0x6, w0
	bra	w0		; execution step 1 (8-bit opcode)
    1b62:	00 60 01    	bra       w0
;jp table
	callRUN	ind_8_0		; CP   R0,N
    1b64:	a4 21 02    	call      0x21a4 <ind_8_0>
    1b66:	00 00 00 
    1b68:	df 69 af    	btsc.b    0x9df, #0x3
    1b6a:	0c 1d 02    	call      0x1d0c <run_cont>
    1b6c:	00 00 00 
    1b6e:	81 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_1		; ADD  R0,N
    1b70:	f0 21 02    	call      0x21f0 <ind_8_1>
    1b72:	00 00 00 
    1b74:	df 69 af    	btsc.b    0x9df, #0x3
    1b76:	0c 1d 02    	call      0x1d0c <run_cont>
    1b78:	00 00 00 
    1b7a:	7b ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_2		; INC  RY (TEST PCL)
    1b7c:	40 22 02    	call      0x2240 <ind_8_2>
    1b7e:	00 00 00 
    1b80:	df 69 af    	btsc.b    0x9df, #0x3
    1b82:	0c 1d 02    	call      0x1d0c <run_cont>
    1b84:	00 00 00 
    1b86:	75 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_3		; DEC  RY (TEST PCL)
    1b88:	c0 22 02    	call      0x22c0 <ind_8_3>
    1b8a:	00 00 00 
    1b8c:	df 69 af    	btsc.b    0x9df, #0x3
    1b8e:	0c 1d 02    	call      0x1d0c <run_cont>
    1b90:	00 00 00 
    1b92:	6f ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_4		; DSZ  RY
    1b94:	3e 23 02    	call      0x233e <ind_8_4>
    1b96:	00 00 00 
    1b98:	df 69 af    	btsc.b    0x9df, #0x3
    1b9a:	0c 1d 02    	call      0x1d0c <run_cont>
    1b9c:	00 00 00 
    1b9e:	69 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_5		; OR   R0,N
    1ba0:	7a 23 02    	call      0x237a <ind_8_5>
    1ba2:	00 00 00 
    1ba4:	df 69 af    	btsc.b    0x9df, #0x3
    1ba6:	0c 1d 02    	call      0x1d0c <run_cont>
    1ba8:	00 00 00 
    1baa:	63 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_6		; AND  R0,N
    1bac:	c4 23 02    	call      0x23c4 <ind_8_6>
    1bae:	00 00 00 
    1bb0:	df 69 af    	btsc.b    0x9df, #0x3
    1bb2:	0c 1d 02    	call      0x1d0c <run_cont>
    1bb4:	00 00 00 
    1bb6:	5d ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_7		; XOR  R0,N
    1bb8:	fe 23 02    	call      0x23fe <ind_8_7>
    1bba:	00 00 00 
    1bbc:	df 69 af    	btsc.b    0x9df, #0x3
    1bbe:	0c 1d 02    	call      0x1d0c <run_cont>
    1bc0:	00 00 00 
    1bc2:	57 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_8		; EXR  N
    1bc4:	44 24 02    	call      0x2444 <ind_8_8>
    1bc6:	00 00 00 
    1bc8:	df 69 af    	btsc.b    0x9df, #0x3
    1bca:	0c 1d 02    	call      0x1d0c <run_cont>
    1bcc:	00 00 00 
    1bce:	51 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_9		; BIT  RG,M
    1bd0:	7a 24 02    	call      0x247a <ind_8_9>
    1bd2:	00 00 00 
    1bd4:	df 69 af    	btsc.b    0x9df, #0x3
    1bd6:	0c 1d 02    	call      0x1d0c <run_cont>
    1bd8:	00 00 00 
    1bda:	4b ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_10	; BSET RG,M
    1bdc:	bc 24 02    	call      0x24bc <ind_8_10>
    1bde:	00 00 00 
    1be0:	df 69 af    	btsc.b    0x9df, #0x3
    1be2:	0c 1d 02    	call      0x1d0c <run_cont>
    1be4:	00 00 00 
    1be6:	45 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_11	; BCLR RG,M
    1be8:	ec 24 02    	call      0x24ec <ind_8_11>
    1bea:	00 00 00 
    1bec:	df 69 af    	btsc.b    0x9df, #0x3
    1bee:	0c 1d 02    	call      0x1d0c <run_cont>
    1bf0:	00 00 00 
    1bf2:	3f ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_12	; BTG  RG,M
    1bf4:	1e 25 02    	call      0x251e <ind_8_12>
    1bf6:	00 00 00 
    1bf8:	df 69 af    	btsc.b    0x9df, #0x3
    1bfa:	0c 1d 02    	call      0x1d0c <run_cont>
    1bfc:	00 00 00 
    1bfe:	39 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_13	; RRC  RY
    1c00:	4e 25 02    	call      0x254e <ind_8_13>
    1c02:	00 00 00 
    1c04:	df 69 af    	btsc.b    0x9df, #0x3
    1c06:	0c 1d 02    	call      0x1d0c <run_cont>
    1c08:	00 00 00 
    1c0a:	33 ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_14	; RET  R0,N
    1c0c:	90 25 02    	call      0x2590 <ind_8_14>
    1c0e:	00 00 00 
    1c10:	df 69 af    	btsc.b    0x9df, #0x3
    1c12:	0c 1d 02    	call      0x1d0c <run_cont>
    1c14:	00 00 00 
    1c16:	2d ff 37    	bra       0x1a72 <run_farm>
	callRUN	ind_8_15	; SKIP F,M
    1c18:	bc 25 02    	call      0x25bc <ind_8_15>
    1c1a:	00 00 00 
    1c1c:	df 69 af    	btsc.b    0x9df, #0x3
    1c1e:	0c 1d 02    	call      0x1d0c <run_cont>
    1c20:	00 00 00 
    1c22:	27 ff 37    	bra       0x1a72 <run_farm>

00001c24 <runtime_key_0>:
;...
; #######################################################################################

runtime_key_0:
	mov	#0,w0
    1c24:	00 00 20    	mov.w     #0x0, w0

00001c26 <runtime_key>:
runtime_key:			; key pressed during pgm execution (don't trash w5-w15!)
	mov	w0,BackIndex
    1c26:	a0 4d 88    	mov.w     w0, 0x9b4
	bclr	Flag,#1
    1c28:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1c2a:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1c2c:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1c2e:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1c30:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1c32:	00 60 01    	bra       w0
; ...
	bra	runtime_back_X	; runtime mode (just ignore)
    1c34:	0b 00 37    	bra       0x1c4c <runtime_back_X>
	bra	runtime_fast 	; runtime fast 
    1c36:	04 00 37    	bra       0x1c40 <runtime_fast>
	bra	runtime_pause	; runtime pause
    1c38:	18 00 37    	bra       0x1c6a <runtime_pause>
	bra	runtime_break	; runtime break
    1c3a:	41 00 37    	bra       0x1cbe <runtime_break>
	bra	runtime_back_X	; runtime run (just ignore)
    1c3c:	07 00 37    	bra       0x1c4c <runtime_back_X>
	bra	runtime_keys_5
    1c3e:	0c 00 37    	bra       0x1c58 <runtime_keys_5>

00001c40 <runtime_fast>:
;...............................
runtime_fast:			; runtime FAST
	btg	Flag2,#0	; #0 Run Fast toggler (1=fast)
    1c40:	de 09 aa    	btg.b     0x9de, #0x0
	btg	BlinkFlag,#2	; 2 set = LED Run blinks
    1c42:	e0 49 aa    	btg.b     0x9e0, #0x2
	call	set_T2_from_Speed
    1c44:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    1c46:	00 00 00 
	call	set_T3_from_Sync
    1c48:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    1c4a:	00 00 00 

00001c4c <runtime_back_X>:
;...
runtime_back_X:		; uses BackIndex to return exactly where it came from
	mov	BackIndex,w0
    1c4c:	a0 4d 80    	mov.w     0x9b4, w0
	cp0	w0
    1c4e:	00 00 e0    	cp0.w     w0
	bra	z,runtime_back_0 ; if [BackIndex] = 0
    1c50:	19 ff 32    	bra       Z, 0x1a84 <runtime_back_0>
	dec	w0,w0
    1c52:	00 00 e9    	dec.w     w0, w0
	bra	z,runtime_back_1 ; if [BackIndex] = 1
    1c54:	5e 00 32    	bra       Z, 0x1d12 <runtime_back_1>
	bra	runtime_back_2	 ; if [BackIndex] = 2
    1c56:	65 00 37    	bra       0x1d22 <runtime_back_2>

00001c58 <runtime_keys_5>:
;				
runtime_keys_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1c58:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1c5a:	2c 14 02    	call      0x142c <limited_key_3>
    1c5c:	00 00 00 
	call	set_T2_from_Speed
    1c5e:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    1c60:	00 00 00 
	call	set_T3_from_Sync
    1c62:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    1c64:	00 00 00 
	pop	w5	; /
    1c66:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_back_X
    1c68:	f1 ff 37    	bra       0x1c4c <runtime_back_X>

00001c6a <runtime_pause>:
;-----------------------------------------------
runtime_pause:			; runtime PAUSE
	bclr	Flag2,#1	; #1 program Runs 
    1c6a:	de 29 a9    	bclr.b    0x9de, #0x1
	bset	A16,#b_noclk_sch
    1c6c:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1c6e:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_save
    1c70:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1c72:	e0 a9 a8    	bset.b    0x9e0, #0x5
	bclr	A16,#b_clk_sch
    1c74:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1c76:	ae 69 a8    	bset.b    0x9ae, #0x3

00001c78 <L111>:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    1c78:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1c7a:	fe ff 37    	bra       0x1c78 <L111>
	bclr	Flag,#1
    1c7c:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1c7e:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1c80:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1c82:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1c84:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1c86:	00 60 01    	bra       w0
; ...
	bra	runtime_pause	; pause mode (just ignore)
    1c88:	f0 ff 37    	bra       0x1c6a <runtime_pause>
	bra	pause_exit 	; pause fast (exit from pause)
    1c8a:	0d 00 37    	bra       0x1ca6 <pause_exit>
	bra	pause_exit	; pause pause (exit from pause)
    1c8c:	0c 00 37    	bra       0x1ca6 <pause_exit>
	bra	runtime_break	; pause break (break pgm execution)
    1c8e:	17 00 37    	bra       0x1cbe <runtime_break>
	bra	pause_exit	; pause run (exit from pause)
    1c90:	0a 00 37    	bra       0x1ca6 <pause_exit>
	bra	general_pause_5	; keys 6...18
    1c92:	00 00 37    	bra       0x1c94 <general_pause_5>

00001c94 <general_pause_5>:
;................................
general_pause_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1c94:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1c96:	2c 14 02    	call      0x142c <limited_key_3>
    1c98:	00 00 00 
	call	set_T2_from_Speed
    1c9a:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    1c9c:	00 00 00 
	call	set_T3_from_Sync
    1c9e:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    1ca0:	00 00 00 
	pop	w5	; /
    1ca2:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_pause
    1ca4:	e2 ff 37    	bra       0x1c6a <runtime_pause>

00001ca6 <pause_exit>:
; ------------------------------
pause_exit:
	bset	Flag2,#1	; #1 program Runs 
    1ca6:	de 29 a8    	bset.b    0x9de, #0x1
	bclr	A16,#b_save
    1ca8:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1caa:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	runtime_back_X	; continue execution
    1cac:	cf ff 37    	bra       0x1c4c <runtime_back_X>

00001cae <Run_StackErr>:
;------------------------------------------------
Run_StackErr:		; Stack Error occured
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    1cae:	e0 c9 a8    	bset.b    0x9e0, #0x6

00001cb0 <L112>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    1cb0:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    1cb2:	02 00 37    	bra       0x1cb8 <L26>
	btss	Flag,#1		; #1 handshaking flag for buttons
    1cb4:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1cb6:	fc ff 37    	bra       0x1cb0 <L112>

00001cb8 <L26>:
2:
	bclr	Flag,#1
    1cb8:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    1cba:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    1cbc:	2a 29 ef    	clr.w     0x92a

00001cbe <runtime_break>:
runtime_break:			; runtime BREAK
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1cbe:	de a9 a9    	bclr.b    0x9de, #0x5
	bclr	A16,#b_clk_sch
    1cc0:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1cc2:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_key
    1cc4:	ae 49 a9    	bclr.b    0x9ae, #0x2
	bset	A16,#b_noclk_sch
    1cc6:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1cc8:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bclr	A16,#b_save
    1cca:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1ccc:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    1cce:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    1cd0:	60 4d 88    	mov.w     w0, 0x9ac
; clear SFR and spec registers
	bclr	A16,#b_carry
    1cd2:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#Rom,w9
    1cd4:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1cd6:	6c 29 02    	call      0x296c <read12>
    1cd8:	00 00 00 
;	call	clr_ram
;	clr	Stack
;	clr.b	Page		; default page 0
;	clr.b	Speed		; default Clock max
;	clr.b	Sync		; default Sync max
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1cda:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1cdc:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1cde:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1ce0:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1ce2:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1ce4:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1ce6:	f8 27 02    	call      0x27f8 <rxtx_to_rxtxpos>
    1ce8:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1cea:	c4 27 02    	call      0x27c4 <set_U1BRG>
    1cec:	00 00 00 
; clear Fast parameters
	  bclr	  BlinkFlag,#2		; 2 set = LED Run blinks
    1cee:	e0 49 a9    	bclr.b    0x9e0, #0x2
	  btss	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1cf0:	de 09 ae    	btss.b    0x9de, #0x0
	  bra	  not_running_fast
    1cf2:	05 00 37    	bra       0x1cfe <not_running_fast>
	  bclr	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1cf4:	de 09 a9    	bclr.b    0x9de, #0x0
	  call	  set_T2_from_Speed
    1cf6:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    1cf8:	00 00 00 
	  call	  set_T3_from_Sync
    1cfa:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    1cfc:	00 00 00 

00001cfe <not_running_fast>:
not_running_fast:
	mov	#0,w0		; default speed 0 (max)
    1cfe:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    1d00:	08 26 02    	call      0x2608 <set_T2_from_w0>
    1d02:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    1d04:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    1d06:	3a 26 02    	call      0x263a <set_T3_from_w0>
    1d08:	00 00 00 
	bra	run_wait_key
    1d0a:	78 fe 37    	bra       0x19fc <run_wait_key>

00001d0c <run_cont>:

; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

run_cont:			; phases (ONLY IF SPEED>0)
wait_phase_1:
	  mov	  #1,w0
    1d0c:	10 00 20    	mov.w     #0x1, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1d0e:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1d10:	8a ff 37    	bra       0x1c26 <runtime_key>

00001d12 <runtime_back_1>:
runtime_back_1:
	  btss	  IFS0,#7	; test int flag
    1d12:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_1
    1d14:	fb ff 37    	bra       0x1d0c <run_cont> <wait_phase_1>
	  bclr	  IFS0,#7	; clr int flag
    1d16:	88 e0 a9    	bclr.b    0x88, #0x7
;	
	  call	  transfer1	; uses w6 bits to decide flag transfer
    1d18:	b0 14 02    	call      0x14b0 <transfer1>
    1d1a:	00 00 00 

00001d1c <wait_phase_2>:
wait_phase_2:
	  mov	  #2,w0
    1d1c:	20 00 20    	mov.w     #0x2, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1d1e:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1d20:	82 ff 37    	bra       0x1c26 <runtime_key>

00001d22 <runtime_back_2>:
runtime_back_2:
	  btss	  IFS0,#7	; test int flag
    1d22:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_2
    1d24:	fb ff 37    	bra       0x1d1c <wait_phase_2>
	  bclr	  IFS0,#7	; clr int flag
    1d26:	88 e0 a9    	bclr.b    0x88, #0x7
	  call	  transfer2	; uses w6 bits to decide flag transfer
    1d28:	94 15 02    	call      0x1594 <transfer2>
    1d2a:	00 00 00 

00001d2c <ins_part_2>:
; ------
ins_part_2:			; called from SS mode
	incpc			; increment address     * * * * * * * * * * * * * * * * *
    1d2c:	89 84 e8    	inc2.w    w9, w9
    1d2e:	09 e0 a7    	btsc.w    w9, #0xe
    1d30:	09 00 22    	mov.w     #0x2000, w9
; check if w7 < 8, if so perform special instruction
	cp	w7,#8		; flag for special instructions (if w7 < 8)
    1d32:	68 38 e1    	cp.w      w7, #0x8
	bra	nc,spec_ins
    1d34:	14 00 39    	bra       NC, 0x1d5e <spec_ins>
	mov.b	w13,[w7]	;  W R I T E   R E S U L T   T O   D E S T I N A T I O N
    1d36:	8d 4b 78    	mov.b     w13, [w7]
; check if destination was JSR or PCL, if so, then perform CALL or JUMP
	btss	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1d38:	dc 89 ae    	btss.b    0x9dc, #0x4
	bra	chk_sfr
    1d3a:	0a 00 37    	bra       0x1d50 <chk_sfr>
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1d3c:	dc 89 a9    	bclr.b    0x9dc, #0x4
; check and perform if there is PCM, PCH 12-bit extension
	  mov	  PcmPch,w0
    1d3e:	90 4d 80    	mov.w     0x9b2, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    1d40:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    1d42:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    1d44:	dc e9 a9    	bclr.b    0x9dc, #0x7
	mov	#Ram+12,w0	; Ram+12=JSR
    1d46:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    1d48:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    1d4a:	3c 00 32    	bra       Z, 0x1dc4 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    1d4c:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    1d4e:	4e 00 32    	bra       Z, 0x1dec <run_jump>

00001d50 <chk_sfr>:
; check if source or dest was in SFR area, if so perform perpheral service
chk_sfr:
	  btsc	  Flag,#9		; #9 set if instruction is writing to SFR area
    1d50:	dd 29 af    	btsc.b    0x9dd, #0x1
	  call	  perform_SFR_write
    1d52:	8e 26 02    	call      0x268e <perform_SFR_write>
    1d54:	00 00 00 
	  btsc	  Flag,#10		; #10 set if instruction is reading from SFR area
    1d56:	dd 49 af    	btsc.b    0x9dd, #0x2
	  call	  perform_SFR_read
    1d58:	2e 27 02    	call      0x272e <perform_SFR_read>
    1d5a:	00 00 00 
	return
    1d5c:	00 00 06    	return    

00001d5e <spec_ins>:
;------------------------
spec_ins:			; <------ executed both from SS and RUN
	bra	w7
    1d5e:	07 60 01    	bra       w7
;...
	bra	spec0	; dummy
    1d60:	07 00 37    	bra       0x1d70 <spec0>
	bra	spec1	; JR   N
    1d62:	07 00 37    	bra       0x1d72 <spec1>
	bra	spec2	; DSZ  RY
    1d64:	0f 00 37    	bra       0x1d84 <spec2>
	bra	spec3	; EXR  N
    1d66:	16 00 37    	bra       0x1d94 <spec3>
	bra	spec4	; RET R0,N
    1d68:	18 00 37    	bra       0x1d9a <spec4>
	bra	spec5	; LPC  NN
    1d6a:	1d 00 37    	bra       0x1da6 <spec5>
	bra	spec6	; SKIP F,M
    1d6c:	22 00 37    	bra       0x1db2 <spec6>
	bra	spec7	; reserved
    1d6e:	23 00 37    	bra       0x1db6 <spec7>

00001d70 <spec0>:
; --------------------
spec0:			; flag 00 = dummy instruction
	return
    1d70:	00 00 06    	return    

00001d72 <spec1>:
;		
spec1:			; flag 01 = special instruction: JR NN
	btsc	w5,#8		; displacement is signed 9-bit number
    1d72:	05 80 a7    	btsc.w    w5, #0x8
	sub	#0x200,w5	; if displacement is negative
    1d74:	05 20 b1    	sub.w     #0x200, w5
	add	w9,w5,w9	; new PC value
    1d76:	85 84 44    	add.w     w9, w5, w9

00001d78 <w9range>:
w9range:
	mov	#0x2000,w0
    1d78:	00 00 22    	mov.w     #0x2000, w0
	btsc	w9,#14
    1d7a:	09 e0 a7    	btsc.w    w9, #0xe
	sub	w9,w0,w9	; fit w9 < end of program memory
    1d7c:	80 84 54    	sub.w     w9, w0, w9
	btss	w9,#13
    1d7e:	09 d0 a6    	btss.w    w9, #0xd
	add	w9,w0,w9	; fit w9 > start-1 of program memory
    1d80:	80 84 44    	add.w     w9, w0, w9
	return
    1d82:	00 00 06    	return    

00001d84 <spec2>:
;		
spec2:			; flag 02 = special instruction: DSZ RY
	mov.b	w13,[w5]	; w13 = RY after decrement, w5 = RY address
    1d84:	8d 4a 78    	mov.b     w13, [w5]
	cp0	w13
    1d86:	0d 00 e0    	cp0.w     w13
	ifnz
    1d88:	42 20 ae    	btss.b    0x42, #0x1
	return
    1d8a:	00 00 06    	return    
	inc2	w9,w9		; skip (inrement PC)
    1d8c:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    1d8e:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    1d90:	09 00 22    	mov.w     #0x2000, w9
	return
    1d92:	00 00 06    	return    

00001d94 <spec3>:
;		
spec3:			; flag 03 = special instruction: EXR N
	btg	A16,#b_exr
    1d94:	ae 29 aa    	btg.b     0x9ae, #0x1
	goto	swapper
    1d96:	5c 24 04    	goto      0x245c <swapper>
    1d98:	00 00 00 

00001d9a <spec4>:
;		
spec4:			; flag 04 = special instruction: RET R0,N
	cp0	Stack
    1d9a:	2a 09 e2    	cp0.w     0x92a
	bra	z,stackerr7	; stack underflow
    1d9c:	0f 00 32    	bra       Z, 0x1dbc <stackerr7>
	mov.b	w12,[w10]	; store #N to R0
    1d9e:	0c 4d 78    	mov.b     w12, [w10]
	mov	w5,w9		; store ret address to PC
    1da0:	85 04 78    	mov.w     w5, w9
	dec	Stack		; new Stack
    1da2:	2a 29 ed    	dec.w     0x92a
	return
    1da4:	00 00 06    	return    

00001da6 <spec5>:
;		
spec5:			; flag 05 = special instruction: MOV PC,NN
	mov.b	w5,[w10+15]	; write hi nibble to PCH (irregular, but possible use of w5)
    1da6:	75 4d 98    	mov.b     w5, [w10+15]
	mov.b	w8,[w10+14]	; write low nibble to PCL (irregular, but possible use of w8)
    1da8:	68 4d 98    	mov.b     w8, [w10+14]
	mov	#Ram+0x0B,w8	; restore w8
    1daa:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    1dac:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; restore w8
    1dae:	b8 8f 20    	mov.w     #0x8fb, w8
	return
    1db0:	00 00 06    	return    

00001db2 <spec6>:
;		
spec6:			; flag 06 = special instruction: SKIP F,M
	mov	w5,w9		; store new address to PC
    1db2:	85 04 78    	mov.w     w5, w9
	return
    1db4:	00 00 06    	return    

00001db6 <spec7>:
;		
spec7:			; flag 07 is reserved
	return
    1db6:	00 00 06    	return    

00001db8 <stackerr6>:
;------------------------------------------
stackerr6:			; Fatal Error, Stack overflow
	mov	#6,w0		; Stack=6: Overflow (5+1)
    1db8:	60 00 20    	mov.w     #0x6, w0
	bra	skrerr
    1dba:	01 00 37    	bra       0x1dbe <skrerr>

00001dbc <stackerr7>:
stackerr7:			; Fatal Error, Stack underflow
	mov	#7,w0		; Stack=7: Underflow (0-1)
    1dbc:	70 00 20    	mov.w     #0x7, w0

00001dbe <skrerr>:
skrerr:
	mov	w0,Stack
    1dbe:	50 49 88    	mov.w     w0, 0x92a
	bset	Flag2,#5	; #5 Fatal Stack Error
    1dc0:	de a9 a8    	bset.b    0x9de, #0x5
	return
    1dc2:	00 00 06    	return    

00001dc4 <run_call>:

;#################################################################################
run_call:			; - - - - - - - - - - - - - - - - -  RUN CALL   <----
	mov	Stack,w0
    1dc4:	50 49 80    	mov.w     0x92a, w0
	cp	w0,#5
    1dc6:	65 00 e1    	cp.w      w0, #0x5
	bra	c,stackerr6	; stack overflow
    1dc8:	f7 ff 31    	bra       C, 0x1db8 <stackerr6>
	mul.uu	w0,#3,w0	; w0:w1
    1dca:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16,w0		; stack starts at Ram+16
    1dcc:	00 01 b0    	add.w     #0x10, w0
	add	w0,w10,w1	; w1 = current stack
    1dce:	8a 00 40    	add.w     w0, w10, w1
; push ret addr on stack
	mov	#Rom,w0
    1dd0:	00 00 22    	mov.w     #0x2000, w0
	sub	w9,w0,w9
    1dd2:	80 84 54    	sub.w     w9, w0, w9
	lsr	w9,w9
    1dd4:	89 04 d1    	lsr.w     w9, w9
	and	w9,#0x0F,w0
    1dd6:	6f 80 64    	and.w     w9, #0xf, w0
	mov.b	w0,[w1++]	; push low ret addr on stack
    1dd8:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#4,w0
    1dda:	44 48 de    	lsr.w     w9, #0x4, w0
	and	w0,#0x0F,w0
    1ddc:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push med ret addr on stack
    1dde:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#8,w0
    1de0:	48 48 de    	lsr.w     w9, #0x8, w0
	and	w0,#0x0F,w0
    1de2:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push hi ret addr on stack
    1de4:	80 58 78    	mov.b     w0, [w1++]
	inc	Stack
    1de6:	2a 29 ec    	inc.w     0x92a
; load new ProgMemAddr from registers RC RE RF
	mov.b	Ram+12,WREG
    1de8:	0c c8 bf    	mov.b     0x80c, WREG
	bra	skr_run
    1dea:	01 00 37    	bra       0x1dee <skr_run>

00001dec <run_jump>:
run_jump:			; - - - - - - - - - - - - - - - - -  RUN JUMP   <----
	mov.b	Ram+13,WREG
    1dec:	0d c8 bf    	mov.b     0x80d, WREG

00001dee <skr_run>:
skr_run:
	ze	w0,w1
    1dee:	80 80 fb    	ze        w0, w1
	mov.b	Ram+15,WREG
    1df0:	0f c8 bf    	mov.b     0x80f, WREG
	sl	w0,#4,w0
    1df2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Ram+14,WREG
    1df4:	0e 48 b7    	ior.b     0x80e, WREG
	ze	w0,w0
    1df6:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0
    1df8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w1,w0
    1dfa:	01 40 70    	ior.b     w0, w1, w0
	mov	w0,w9		; correction, as SS farm increments Prog Mem Addr
    1dfc:	80 04 78    	mov.w     w0, w9
	sl	w9,w9		; ×2
    1dfe:	89 04 d0    	sl.w      w9, w9
	mov	#Rom,w0
    1e00:	00 00 22    	mov.w     #0x2000, w0
	add	w9,w0,w9
    1e02:	80 84 44    	add.w     w9, w0, w9
	return
    1e04:	00 00 06    	return    

00001e06 <ind_4_1>:

; ----------------------------------------------------------------------------------- 
; ------------------------     I N S T R U C T I O N S     -------------------------- 
; ----------------------------------------------------------------------------------- 
; Label Name Rules:								      
; IND subroutines: with INDirectly addressed operands (SS and RUN modes)              
; DIR subroutines: with DIRectly addressed operands (ALU mode)                        
; First digit: _4 means 4-bit operand						      
; First digit: _8 means 8-bit operand						      
; Second digit _0..._15 is Opcode (or Opcode extension) digit			      

ind_4_1:   ; ------------------------------------------------------   1   ADD RX,RY (49T)
; IN register service
	mov	PORTB,w0
    1e06:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1e08:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1e0a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1e0c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1e0e:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1e10:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1e12:	6a 46 7e    	mov.b     [w10+w12], w12

00001e14 <dir_4_1>:
dir_4_1:
	mov	w11,Atemp	; pre-load Accu temp
    1e14:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1e16:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds		; uses w0
    1e18:	f0 f8 2f    	mov.w     #0xff8f, w0
    1e1a:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1e1c:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1e1e:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1e20:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1e22:	a2 4e 23    	mov.w     #0x34ea, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1e24:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1e26:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1e28:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1e2a:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1e2c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1e2e:	14 00 37    	bra       0x1e58 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1e30:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1e32:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1e34:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1e36:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1e38:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1e3a:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1e3c:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1e3e:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1e40:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1e42:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1e44:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1e46:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1e48:	89 84 e8    	inc2.w    w9, w9
    1e4a:	09 e0 a7    	btsc.w    w9, #0xe
    1e4c:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1e4e:	00 40 a6    	btss.w    w0, #0x4
	return
    1e50:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1e52:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1e54:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1e56:	00 00 06    	return    

00001e58 <slow3flags1111>:

slow3flags1111:
	mov	#0b1111,w6	; move VZCA
    1e58:	f6 00 20    	mov.w     #0xf, w6

00001e5a <slow3flags_keepw6>:
slow3flags_keepw6:
	bclr	Vflag,#0
    1e5a:	30 09 a9    	bclr.b    0x930, #0x0
	bclr	Zflag,#0
    1e5c:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    1e5e:	2c 09 a9    	bclr.b    0x92c, #0x0
	btsc	w0,#6
    1e60:	00 60 a7    	btsc.w    w0, #0x6
	bset	Vflag,#0
    1e62:	30 09 a8    	bset.b    0x930, #0x0
	btsc	w0,#5
    1e64:	00 50 a7    	btsc.w    w0, #0x5
	bset	Zflag,#0
    1e66:	2e 09 a8    	bset.b    0x92e, #0x0
	btsc	w0,#4
    1e68:	00 40 a7    	btsc.w    w0, #0x4
	bset	Cflag,#0
    1e6a:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    1e6c:	00 00 06    	return    

00001e6e <ind_4_2>:

ind_4_2:   ; ------------------------------------------------------   2   ADC RX,RY (52T)
; IN register service
	mov	PORTB,w0
    1e6e:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1e70:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1e72:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1e74:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1e76:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1e78:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1e7a:	6a 46 7e    	mov.b     [w10+w12], w12

00001e7c <dir_4_2>:
dir_4_2:
	mov	w11,Atemp	; pre-load Accu temp
    1e7c:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1e7e:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	bclr	A16,#b_data_inv
    1e80:	ae 89 a9    	bclr.b    0x9ae, #0x4
	bset	A16,#b_cena
    1e82:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1e84:	e0 9a 20    	mov.w     #0x9ae, w0
	btst.c	[w0],#b_carry	; A16,#b_carry ---> C
    1e86:	10 c0 a3    	btst.c    [w0], #0xc
	mov	#b_cin,w3
    1e88:	53 00 20    	mov.w     #0x5, w3
	bsw.c	[w0],w3		; C ---> A16,#b_cin
    1e8a:	10 18 ad    	bsw.c     [w0], w3
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1e8c:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1e8e:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1e90:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1e92:	a2 4e 23    	mov.w     #0x34ea, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1e94:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1e96:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1e98:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1e9a:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1e9c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1e9e:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1ea0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1ea2:	da ff 37    	bra       0x1e58 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1ea4:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1ea6:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1ea8:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1eaa:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1eac:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1eae:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1eb0:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1eb2:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1eb4:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1eb6:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1eb8:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1eba:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1ebc:	89 84 e8    	inc2.w    w9, w9
    1ebe:	09 e0 a7    	btsc.w    w9, #0xe
    1ec0:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1ec2:	00 40 a6    	btss.w    w0, #0x4
	return
    1ec4:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1ec6:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1ec8:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1eca:	00 00 06    	return    

00001ecc <ind_4_3>:

ind_4_3:   ; ------------------------------------------------------   3   SUB RX,RY (50T)
; IN register service
	mov	PORTB,w0
    1ecc:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1ece:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1ed0:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1ed2:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1ed4:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1ed6:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1ed8:	6a 46 7e    	mov.b     [w10+w12], w12

00001eda <dir_4_3>:
dir_4_3:
	mov	w11,Atemp	; pre-load Accu temp
    1eda:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1edc:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1ede:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1ee0:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    1ee2:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    1ee4:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1ee6:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1ee8:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1eea:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    1eec:	c2 4e 23    	mov.w     #0x34ec, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1eee:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1ef0:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1ef2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1ef4:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1ef6:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1ef8:	af ff 37    	bra       0x1e58 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1efa:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1efc:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1efe:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f00:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f02:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f04:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f06:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f08:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f0a:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f0c:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f0e:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1f10:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1f12:	89 84 e8    	inc2.w    w9, w9
    1f14:	09 e0 a7    	btsc.w    w9, #0xe
    1f16:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1f18:	00 40 a6    	btss.w    w0, #0x4
	return
    1f1a:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1f1c:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1f1e:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1f20:	00 00 06    	return    

00001f22 <ind_4_4>:

ind_4_4:   ; ------------------------------------------------------   4   SBB RX,RY (54T)
; IN register service
	mov	PORTB,w0
    1f22:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f24:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f26:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f28:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f2a:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1f2c:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1f2e:	6a 46 7e    	mov.b     [w10+w12], w12

00001f30 <dir_4_4>:
dir_4_4:
	mov	w11,Atemp	; pre-load Accu temp
    1f30:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f32:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1f34:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1f36:	ae 89 a8    	bset.b    0x9ae, #0x4
	bset	A16,#b_cena
    1f38:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1f3a:	e0 9a 20    	mov.w     #0x9ae, w0
	btst	[w0],#b_carry	; A16,#b_carry ---> C
    1f3c:	10 c8 a3    	btst.z    [w0], #0xc
	ccf
    1f3e:	42 00 aa    	btg.b     0x42, #0x0
	mov	#b_cin,w3
    1f40:	53 00 20    	mov.w     #0x5, w3
	bsw	[w0],w3		; C ---> A16,#b_cin
    1f42:	10 98 ad    	bsw.z     [w0], w3
	ccf
    1f44:	42 00 aa    	btg.b     0x42, #0x0
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1f46:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1f48:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1f4a:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1f4c:	a2 4e 23    	mov.w     #0x34ea, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1f4e:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1f50:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1f52:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1f54:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1f56:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1f58:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1f5a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1f5c:	7d ff 37    	bra       0x1e58 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1f5e:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1f60:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1f62:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f64:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f66:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f68:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f6a:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f6c:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f6e:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f70:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f72:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1f74:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1f76:	89 84 e8    	inc2.w    w9, w9
    1f78:	09 e0 a7    	btsc.w    w9, #0xe
    1f7a:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1f7c:	00 40 a6    	btss.w    w0, #0x4
	return
    1f7e:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1f80:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1f82:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1f84:	00 00 06    	return    

00001f86 <ind_4_5>:

ind_4_5:   ; ------------------------------------------------------   5   OR RX,RY (T)
; IN register service
	mov	PORTB,w0
    1f86:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f88:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f8a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f8c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f8e:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    1f90:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    1f92:	6a 46 7e    	mov.b     [w10+w12], w12

00001f94 <dir_4_5>:
dir_4_5:
	mov	w11,Atemp	; pre-load Accu temp
    1f94:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f96:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    1f98:	f0 f8 2f    	mov.w     #0xff8f, w0
    1f9a:	ae 29 b6    	and.w     0x9ae
; exec
	ior	w11,w12,w13	; exec
    1f9c:	8c 86 75    	ior.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1f9e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    1fa0:	0b 00 37    	bra       0x1fb8 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1fa2:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    1fa4:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    1fa6:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    1fa8:	2e 29 ef    	clr.w     0x92e
	ifz
    1faa:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    1fac:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1fae:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1fb0:	89 84 e8    	inc2.w    w9, w9
    1fb2:	09 e0 a7    	btsc.w    w9, #0xe
    1fb4:	09 00 22    	mov.w     #0x2000, w9

	return
    1fb6:	00 00 06    	return    

00001fb8 <slowZflag0101>:
slowZflag0101:
	mov	#0b0101,w6	; move VZCA
    1fb8:	56 00 20    	mov.w     #0x5, w6
	bclr	Zflag,#0
    1fba:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    1fbc:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    1fbe:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    1fc0:	00 00 06    	return    

00001fc2 <ind_4_6>:

ind_4_6:   ; ------------------------------------------------------   6   AND RX,RY (T)
; IN register service
	mov	PORTB,w0
    1fc2:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1fc4:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1fc6:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1fc8:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1fca:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    1fcc:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    1fce:	6a 46 7e    	mov.b     [w10+w12], w12

00001fd0 <dir_4_6>:
dir_4_6:
	mov	w11,Atemp	; pre-load Accu temp
    1fd0:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1fd2:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    1fd4:	f0 f8 2f    	mov.w     #0xff8f, w0
    1fd6:	ae 29 b6    	and.w     0x9ae
; exec
	and	w11,w12,w13	; exec
    1fd8:	8c 86 65    	and.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1fda:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    1fdc:	ed ff 37    	bra       0x1fb8 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1fde:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    1fe0:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    1fe2:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    1fe4:	2e 29 ef    	clr.w     0x92e
	ifz
    1fe6:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    1fe8:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1fea:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1fec:	89 84 e8    	inc2.w    w9, w9
    1fee:	09 e0 a7    	btsc.w    w9, #0xe
    1ff0:	09 00 22    	mov.w     #0x2000, w9

	return
    1ff2:	00 00 06    	return    

00001ff4 <ind_4_7>:

ind_4_7:   ; ------------------------------------------------------   7   XOR RX,RY (T)
; IN register service
	mov	PORTB,w0
    1ff4:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1ff6:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1ff8:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1ffa:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1ffc:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    1ffe:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2000:	6a 46 7e    	mov.b     [w10+w12], w12

00002002 <dir_4_7>:
dir_4_7:
	mov	w11,Atemp	; pre-load Accu temp
    2002:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2004:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2006:	f0 f8 2f    	mov.w     #0xff8f, w0
    2008:	ae 29 b6    	and.w     0x9ae
; exec
	xor	w11,w12,w13	; exec
    200a:	8c 86 6d    	xor.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    200c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    200e:	d4 ff 37    	bra       0x1fb8 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2010:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2012:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    2014:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2016:	2e 29 ef    	clr.w     0x92e
	ifz
    2018:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    201a:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    201c:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    201e:	89 84 e8    	inc2.w    w9, w9
    2020:	09 e0 a7    	btsc.w    w9, #0xe
    2022:	09 00 22    	mov.w     #0x2000, w9

	return
    2024:	00 00 06    	return    

00002026 <ind_4_8>:

ind_4_8:   ; ------------------------------------------------------   8   MOV RX,RY (T)
; IN register service
	mov	PORTB,w0
    2026:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2028:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    202a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    202c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    202e:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    2030:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    2032:	6a 46 7e    	mov.b     [w10+w12], w12

00002034 <dir_4_8>:
dir_4_8:
	mov	w11,Atemp	; pre-load Accu temp
    2034:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2036:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    2038:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    203a:	f0 f8 2f    	mov.w     #0xff8f, w0
    203c:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    203e:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2040:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2042:	0c 00 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2044:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2046:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2048:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    204a:	89 84 e8    	inc2.w    w9, w9
    204c:	09 e0 a7    	btsc.w    w9, #0xe
    204e:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    2050:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    2052:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    2054:	b7 fe 32    	bra       Z, 0x1dc4 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    2056:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    2058:	c9 fe 32    	bra       Z, 0x1dec <run_jump>
	return
    205a:	00 00 06    	return    

0000205c <slowAccu0001>:
slowAccu0001:
	mov	#0b0001,w6	; move VZCA
    205c:	16 00 20    	mov.w     #0x1, w6
	return
    205e:	00 00 06    	return    

00002060 <ind_4_9>:

ind_4_9:   ; ------------------------------------------------------   9   MOV RX,N (T)
; IN register service
	mov	PORTB,w0
    2060:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2062:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2064:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2066:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    2068:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    206a:	ea c5 7d    	mov.b     [w10+w11], w11
	mov	w11,Atemp	; pre-load Accu temp
    206c:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    206e:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    2070:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    2072:	f0 f8 2f    	mov.w     #0xff8f, w0
    2074:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    2076:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2078:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    207a:	f0 ff 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    207c:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    207e:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2080:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2082:	89 84 e8    	inc2.w    w9, w9
    2084:	09 e0 a7    	btsc.w    w9, #0xe
    2086:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    2088:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    208a:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    208c:	9b fe 32    	bra       Z, 0x1dc4 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    208e:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    2090:	ad fe 32    	bra       Z, 0x1dec <run_jump>
	return
    2092:	00 00 06    	return    

00002094 <ind_4_10>:

ind_4_10:   ; -----------------------------------------------------   10  MOV [XY],R0 (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    2094:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2096:	6a 46 7e    	mov.b     [w10+w12], w12
	sl	w11,#4,w7	; 16 × X
    2098:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    209a:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    209c:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    209e:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    20a0:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    20a2:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    20a4:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    20a6:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    20a8:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    20aa:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    20ac:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    20ae:	f0 f8 2f    	mov.w     #0xff8f, w0
    20b0:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    20b2:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    20b4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    20b6:	d2 ff 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    20b8:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20ba:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    20bc:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20be:	89 84 e8    	inc2.w    w9, w9
    20c0:	09 e0 a7    	btsc.w    w9, #0xe
    20c2:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    20c4:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    20c6:	00 00 06    	return    
	bra	perform_SFR_write
    20c8:	e2 02 37    	bra       0x268e <perform_SFR_write>

000020ca <ind_4_11>:

ind_4_11:   ; -----------------------------------------------------   11  MOV R0,[XY] (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    20ca:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    20cc:	6a 46 7e    	mov.b     [w10+w12], w12
	mov	w10,w7		; dst addr to w7 (just for convention)
    20ce:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    20d0:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    20d2:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    20d4:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    20d6:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    20d8:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    20da:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr1
    20dc:	02 00 3a    	bra       NZ, 0x20e2 <nosfr1>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    20de:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    20e0:	8c 02 78    	mov.w     w12, w5

000020e2 <nosfr1>:
nosfr1:
	clr	w11		; clear 1st operand displayed
    20e2:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    20e4:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    20e6:	f0 f8 2f    	mov.w     #0xff8f, w0
    20e8:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    20ea:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    20ec:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    20ee:	b6 ff 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    20f0:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20f2:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    20f4:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20f6:	89 84 e8    	inc2.w    w9, w9
    20f8:	09 e0 a7    	btsc.w    w9, #0xe
    20fa:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    20fc:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    20fe:	00 00 06    	return    
	bra	perform_SFR_read
    2100:	16 03 37    	bra       0x272e <perform_SFR_read>

00002102 <ind_4_12>:

ind_4_12:   ; -----------------------------------------------------   12  MOV [NN],R0 (T)
	sl	w11,#4,w7	; 16 × X
    2102:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    2104:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    2106:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    2108:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    210a:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    210c:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    210e:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    2110:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    2112:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    2114:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    2116:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    2118:	f0 f8 2f    	mov.w     #0xff8f, w0
    211a:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    211c:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    211e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2120:	9d ff 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2122:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2124:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2126:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2128:	89 84 e8    	inc2.w    w9, w9
    212a:	09 e0 a7    	btsc.w    w9, #0xe
    212c:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    212e:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    2130:	00 00 06    	return    
	bra	perform_SFR_write
    2132:	ad 02 37    	bra       0x268e <perform_SFR_write>

00002134 <ind_4_13>:


ind_4_13:   ; -----------------------------------------------------   13  MOV R0,[NN] (T)
	mov	w10,w7		; dst addr to w7 (just for convention)
    2134:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    2136:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    2138:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    213a:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    213c:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    213e:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    2140:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr2
    2142:	02 00 3a    	bra       NZ, 0x2148 <nosfr2>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    2144:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    2146:	8c 02 78    	mov.w     w12, w5

00002148 <nosfr2>:
nosfr2:
	clr	w11		; clear 1st operand displayed
    2148:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    214a:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    214c:	f0 f8 2f    	mov.w     #0xff8f, w0
    214e:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    2150:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2152:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2154:	83 ff 37    	bra       0x205c <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2156:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2158:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    215a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    215c:	89 84 e8    	inc2.w    w9, w9
    215e:	09 e0 a7    	btsc.w    w9, #0xe
    2160:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    2162:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    2164:	00 00 06    	return    
	bra	perform_SFR_read
    2166:	e3 02 37    	bra       0x272e <perform_SFR_read>

00002168 <ind_4_14>:

ind_4_14:   ; -----------------------------------------------------   14  MOV PC,NN (T)
; maintain logic diagram
	clr3leds
    2168:	f0 f8 2f    	mov.w     #0xff8f, w0
    216a:	ae 29 b6    	and.w     0x9ae

	mov	w11,w5
    216c:	8b 02 78    	mov.w     w11, w5
	mov	w12,w8
    216e:	0c 04 78    	mov.w     w12, w8
	clr	w11		; clear 1st operand displayed
    2170:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    2172:	00 06 eb    	clr.w     w12

	mov	#0x05,w7	; flag "MOV PC,NN" instead of "MOV W13,[W7]"
    2174:	57 00 20    	mov.w     #0x5, w7
	mov	w14,w13
    2176:	8e 06 78    	mov.w     w14, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2178:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    217a:	04 00 37    	bra       0x2184 <phases_0>

	incpc			; w9++
    217c:	89 84 e8    	inc2.w    w9, w9
    217e:	09 e0 a7    	btsc.w    w9, #0xe
    2180:	09 00 22    	mov.w     #0x2000, w9

	bra	spec5
    2182:	11 fe 37    	bra       0x1da6 <spec5>

00002184 <phases_0>:
phases_0:
	mov	#0b0000,w6	; move VZCA
    2184:	06 00 20    	mov.w     #0x0, w6
	return
    2186:	00 00 06    	return    

00002188 <ind_4_15>:

ind_4_15:   ; -----------------------------------------------------   15  JR NN (T)
; maintain logic diagram
	clr3leds
    2188:	f0 f8 2f    	mov.w     #0xff8f, w0
    218a:	ae 29 b6    	and.w     0x9ae
; exec
	sl	w11,#4,w5	; 16 × X
    218c:	c4 5a dd    	sl.w      w11, #0x4, w5
	add	w5,w12,w5	; 16 × X + Y (8-bit displacement addr)
    218e:	8c 82 42    	add.w     w5, w12, w5
	sl	w5,w5		; ×2, now in 9-bit range 0...0x1FE (signed -0x100...0xFF)
    2190:	85 02 d0    	sl.w      w5, w5
	clr	w11		; clear 1st operand displayed
    2192:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    2194:	00 06 eb    	clr.w     w12

	mov	#0x01,w7	; flag "JR NN" instead of "MOV W13,[W7]"
    2196:	17 00 20    	mov.w     #0x1, w7
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2198:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    219a:	f4 ff 37    	bra       0x2184 <phases_0>
				; fast simplified exit (no flags)
	incpc			; w9++
    219c:	89 84 e8    	inc2.w    w9, w9
    219e:	09 e0 a7    	btsc.w    w9, #0xe
    21a0:	09 00 22    	mov.w     #0x2000, w9

	bra	spec1
    21a2:	e7 fd 37    	bra       0x1d72 <spec1>

000021a4 <ind_8_0>:

; ###################################################################################

ind_8_0:   ; -----------------------------------------------------    00  CP R0,N (T)
; IN register service
	mov	PORTB,w0
    21a4:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    21a6:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    21a8:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    21aa:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    21ac:	9a 85 fb    	ze        [w10], w11

000021ae <dir_8_0>:
dir_8_0:
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    21ae:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    21b0:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    21b2:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    21b4:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    21b6:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    21b8:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    21ba:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    21bc:	c2 4e 23    	mov.w     #0x34ec, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    21be:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    21c0:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    21c2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; result to Accu IN
    21c4:	ef 06 60    	and.w     w0, #0xf, w13
	mov	#Dummy,w7
    21c6:	07 9b 20    	mov.w     #0x9b0, w7
; get flags
	mov	#0b1110,w6	; move VZCA
    21c8:	e6 00 20    	mov.w     #0xe, w6
	btsc	Flag,#2		; #2 set if Speed>0
    21ca:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags_keepw6
    21cc:	46 fe 37    	bra       0x1e5a <slow3flags_keepw6>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	clr	Vflag
    21ce:	30 29 ef    	clr.w     0x930
	clr	Zflag
    21d0:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    21d2:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    21d4:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    21d6:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    21d8:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    21da:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    21dc:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    21de:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    21e0:	89 84 e8    	inc2.w    w9, w9
    21e2:	09 e0 a7    	btsc.w    w9, #0xe
    21e4:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    21e6:	00 40 a6    	btss.w    w0, #0x4
	return
    21e8:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    21ea:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    21ec:	af 89 a8    	bset.b    0x9af, #0x4
	return
    21ee:	00 00 06    	return    

000021f0 <ind_8_1>:

ind_8_1:   ; -----------------------------------------------------    01  ADD R0,N (T)
; IN register service
	mov	PORTB,w0
    21f0:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    21f2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    21f4:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    21f6:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    21f8:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    21fa:	8a 03 78    	mov.w     w10, w7

000021fc <dir_8_1>:
dir_8_1:
	mov	w11,Atemp	; pre-load Accu temp
    21fc:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    21fe:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2200:	f0 f8 2f    	mov.w     #0xff8f, w0
    2202:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2204:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2206:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    2208:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    220a:	a2 4e 23    	mov.w     #0x34ea, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    220c:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    220e:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    2210:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2212:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2214:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    2216:	20 fe 37    	bra       0x1e58 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2218:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    221a:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    221c:	30 29 ef    	clr.w     0x930
	clr	Zflag
    221e:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2220:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2222:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2224:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    2226:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    2228:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    222a:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    222c:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    222e:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2230:	89 84 e8    	inc2.w    w9, w9
    2232:	09 e0 a7    	btsc.w    w9, #0xe
    2234:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    2236:	00 40 a6    	btss.w    w0, #0x4
	return
    2238:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    223a:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    223c:	af 89 a8    	bset.b    0x9af, #0x4
	return
    223e:	00 00 06    	return    

00002240 <ind_8_2>:

ind_8_2:   ; -----------------------------------------------------    02  INC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    2240:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    2242:	6a 46 7e    	mov.b     [w10+w12], w12

00002244 <dir_8_2>:
dir_8_2:
	mov	w12,Atemp	; pre-load Accu temp
    2244:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2246:	0c 07 78    	mov.w     w12, w14
	mov	#1,w11		; "add 1" = "inc" (will be displayed)
    2248:	1b 00 20    	mov.w     #0x1, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    224a:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    224c:	f0 f8 2f    	mov.w     #0xff8f, w0
    224e:	ae 29 b6    	and.w     0x9ae
; exec 
	inc	w12,w0		; exec
    2250:	0c 00 e8    	inc.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2252:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    2254:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    2256:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 13)
    2258:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    225a:	0f 00 3a    	bra       NZ, 0x227a <L43>
	cp0	Mode
    225c:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    225e:	0d 00 32    	bra       Z, 0x227a <L43>
; extension to PCM and PCH
	cp0	w13
    2260:	0d 00 e0    	cp0.w     w13
	bra	nz,4f		; if no overflow from nibble 1
    2262:	0b 00 3a    	bra       NZ, 0x227a <L43>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    2264:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    2266:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    2268:	90 4d 88    	mov.w     w0, 0x9b2
	  inc.b	  PcmPch+0	; inc PCM
    226a:	b2 69 ec    	inc.b     0x9b2
	  btss.b  PcmPch+0,#4	; PCM overflow?
    226c:	b2 89 ae    	btss.b    0x9b2, #0x4
	  bra	  4f		; if no overflow
    226e:	05 00 37    	bra       0x227a <L43>
	  bclr.b  PcmPch+0,#4	; keep PCM in 4-bit range
    2270:	b2 89 a9    	bclr.b    0x9b2, #0x4
	  cp0.b	  PcmPch+0	; is there overflow from PCM nibble?
    2272:	b2 49 e2    	cp0.b     0x9b2
	  ifz			; if overflow from PCM nibble...
    2274:	42 20 af    	btsc.b    0x42, #0x1
	  inc.b	  PcmPch+1	; ...then inc PCH...
    2276:	b3 69 ec    	inc.b     0x9b3
	  bclr.b  PcmPch+1,#4	; ...and keep it in 4-bit range
    2278:	b3 89 a9    	bclr.b    0x9b3, #0x4

0000227a <L43>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    227a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow0111
    227c:	19 00 37    	bra       0x22b0 <slow0111>

	incpc			; w9++
    227e:	89 84 e8    	inc2.w    w9, w9
    2280:	09 e0 a7    	btsc.w    w9, #0xe
    2282:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2284:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2286:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2288:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    228a:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    228c:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    228e:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    2290:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    2292:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2294:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2296:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2298:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    229a:	0d 00 e0    	cp0.w     w13
	bra	nz,no_write_02
    229c:	03 00 3a    	bra       NZ, 0x22a4 <no_write_02>
	mov	w2,Zflag	; if result zero, Z flag set
    229e:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; if overflow, C flag set
    22a0:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    22a2:	af 89 a8    	bset.b    0x9af, #0x4

000022a4 <no_write_02>:
no_write_02:
; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    22a4:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    22a6:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    22a8:	8d fd 32    	bra       Z, 0x1dc4 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    22aa:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    22ac:	9f fd 32    	bra       Z, 0x1dec <run_jump>
	return
    22ae:	00 00 06    	return    

000022b0 <slow0111>:
slow0111:
	mov	#0b0111,w6	; move VZCA
    22b0:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    22b2:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    22b4:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    22b6:	0d 00 e0    	cp0.w     w13
	bra	nz,goback
    22b8:	02 00 3a    	bra       NZ, 0x22be <goback>
	bset	Zflag,#0	; if result zero, Z flag set
    22ba:	2e 09 a8    	bset.b    0x92e, #0x0
	bset	Cflag,#0	; if overflow, C flag set
    22bc:	2c 09 a8    	bset.b    0x92c, #0x0

000022be <goback>:
goback:
	return
    22be:	00 00 06    	return    

000022c0 <ind_8_3>:

ind_8_3:   ; -----------------------------------------------------    03  DEC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    22c0:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    22c2:	6a 46 7e    	mov.b     [w10+w12], w12

000022c4 <dir_8_3>:
dir_8_3:
	mov	w12,Atemp	; pre-load Accu temp
    22c4:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    22c6:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    22c8:	fb 00 20    	mov.w     #0xf, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    22ca:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    22cc:	f0 f8 2f    	mov.w     #0xff8f, w0
    22ce:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w0		; exec
    22d0:	0c 00 e9    	dec.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    22d2:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    22d4:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    22d6:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 12)
    22d8:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    22da:	0e 00 3a    	bra       NZ, 0x22f8 <L44>
	cp0	Mode
    22dc:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    22de:	0c 00 32    	bra       Z, 0x22f8 <L44>
; extension to PCM and PCH
	cp0	w12
    22e0:	0c 00 e0    	cp0.w     w12
	bra	nz,4f		; if PCL or JSR was not 0 before dec
    22e2:	0a 00 3a    	bra       NZ, 0x22f8 <L44>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    22e4:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    22e6:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    22e8:	90 4d 88    	mov.w     w0, 0x9b2
	  dec.b	  PcmPch+0	; dec PCM
    22ea:	b2 69 ed    	dec.b     0x9b2
	  btss.b  PcmPch+0,#7	; PCM underflow?
    22ec:	b2 e9 ae    	btss.b    0x9b2, #0x7
	  bra	  4f		; if no underflow
    22ee:	04 00 37    	bra       0x22f8 <L44>
	mov	#0x0F,w0
    22f0:	f0 00 20    	mov.w     #0xf, w0
	and.b	PcmPch+0	; mask low nibble bits of PCM
    22f2:	b2 69 b6    	and.b     0x9b2
	dec.b	PcmPch+1	; dec PCH
    22f4:	b3 69 ed    	dec.b     0x9b3
	and.b	PcmPch+1	; mask low nibble bits of PCH
    22f6:	b3 69 b6    	and.b     0x9b3

000022f8 <L44>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    22f8:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow03
    22fa:	17 00 37    	bra       0x232a <slow03>

	incpc			; w9++
    22fc:	89 84 e8    	inc2.w    w9, w9
    22fe:	09 e0 a7    	btsc.w    w9, #0xe
    2300:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2302:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2304:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2306:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    2308:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    230a:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    230c:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    230e:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    2310:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2312:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2314:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2316:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    2318:	0d 00 e0    	cp0.w     w13
	ifz
    231a:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if zero, Z flag set
    231c:	72 49 88    	mov.w     w2, 0x92e
	cp	w13,#0x0F
    231e:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    2320:	42 20 ae    	btss.b    0x42, #0x1
	return
    2322:	00 00 06    	return    
	mov	w2,Cflag	; if "dec" did not cause result 0x1111
    2324:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    2326:	af 89 a8    	bset.b    0x9af, #0x4
	return
    2328:	00 00 06    	return    

0000232a <slow03>:
slow03:
	mov	#0b0111,w6	; move VZCA
    232a:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    232c:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    232e:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    2330:	0d 00 e0    	cp0.w     w13
	ifz
    2332:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0	; if zero, Z flag set
    2334:	2e 09 a8    	bset.b    0x92e, #0x0
	cp	w13,#0x0F
    2336:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    2338:	42 20 ae    	btss.b    0x42, #0x1
	bset	Cflag,#0	; if "dec" did not cause result 0x1111
    233a:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    233c:	00 00 06    	return    

0000233e <ind_8_4>:

ind_8_4:   ; -----------------------------------------------------    04  DSZ RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    233e:	8c 03 45    	add.w     w10, w12, w7
	ze	[w7],w12	; Y value
    2340:	17 86 fb    	ze        [w7], w12

00002342 <dir_8_4>:
dir_8_4:
	mov	w12,Atemp	; pre-load Accu temp
    2342:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2344:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    2346:	fb 00 20    	mov.w     #0xf, w11
; maintain logic diagram
	clr3leds
    2348:	f0 f8 2f    	mov.w     #0xff8f, w0
    234a:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w2		; exec
    234c:	0c 01 e9    	dec.w     w12, w2
	and	w2,#0x0F,w13	; w13 = new Accu value
    234e:	ef 06 61    	and.w     w2, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2350:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow04
    2352:	0d 00 37    	bra       0x236e <slow04>

	incpc			; w9++
    2354:	89 84 e8    	inc2.w    w9, w9
    2356:	09 e0 a7    	btsc.w    w9, #0xe
    2358:	09 00 22    	mov.w     #0x2000, w9
				; fast simplified execution (no flags)
	mov.b	w13,[w7]	; write result to destination
    235a:	8d 4b 78    	mov.b     w13, [w7]
	mov	w13,w14
    235c:	0d 07 78    	mov.w     w13, w14
	mov	w13,Atemp
    235e:	4d 49 88    	mov.w     w13, 0x928
	cp0	w13
    2360:	0d 00 e0    	cp0.w     w13
	ifnz
    2362:	42 20 ae    	btss.b    0x42, #0x1
	return
    2364:	00 00 06    	return    

	incpc			; w9++
    2366:	89 84 e8    	inc2.w    w9, w9
    2368:	09 e0 a7    	btsc.w    w9, #0xe
    236a:	09 00 22    	mov.w     #0x2000, w9

	return
    236c:	00 00 06    	return    

0000236e <slow04>:
slow04:
	mov	w12,Atemp	; pre-load Accu temp
    236e:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2370:	0c 07 78    	mov.w     w12, w14
	mov	w7,w5		; new destination address (not w7)!
    2372:	87 02 78    	mov.w     w7, w5
	mov	#0x02,w7	; flag "DSZ RY" instead of "MOV W13,[W7]"
    2374:	27 00 20    	mov.w     #0x2, w7
	mov	#0b0000,w6	; move VZCA
    2376:	06 00 20    	mov.w     #0x0, w6
	return
    2378:	00 00 06    	return    

0000237a <ind_8_5>:

ind_8_5:   ; -----------------------------------------------------    05  OR R0,N (T)
; IN register service
	mov	PORTB,w0
    237a:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    237c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    237e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2380:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2382:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    2384:	8a 03 78    	mov.w     w10, w7

00002386 <dir_8_5>:
dir_8_5:
	mov	w11,Atemp	; pre-load Accu temp
    2386:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2388:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    238a:	f0 f8 2f    	mov.w     #0xff8f, w0
    238c:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w11,w12,w0
    238e:	0c 80 75    	ior.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2390:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	setc			; SET C unconditionally
    2392:	42 00 a8    	bset.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    2394:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    2396:	0e 00 37    	bra       0x23b4 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2398:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    239a:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    239c:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    239e:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    23a0:	0d 00 e0    	cp0.w     w13
	ifz
    23a2:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    23a4:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; SET C unconditionally
    23a6:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED unconditionally
    23a8:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    23aa:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    23ac:	89 84 e8    	inc2.w    w9, w9
    23ae:	09 e0 a7    	btsc.w    w9, #0xe
    23b0:	09 00 22    	mov.w     #0x2000, w9

	return
    23b2:	00 00 06    	return    

000023b4 <slowZCAflag0111>:

slowZCAflag0111:
	mov	#0b0111,w6	; move VZCA
    23b4:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    23b6:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    23b8:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    23ba:	2e 09 a8    	bset.b    0x92e, #0x0
	bclr	Cflag,#0
    23bc:	2c 09 a9    	bclr.b    0x92c, #0x0
	ifc
    23be:	42 00 af    	btsc.b    0x42, #0x0
	bset	Cflag,#0
    23c0:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    23c2:	00 00 06    	return    

000023c4 <ind_8_6>:

ind_8_6:   ; -----------------------------------------------------    06  AND R0,N (T)
; IN register service
	mov	PORTB,w0
    23c4:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    23c6:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    23c8:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    23ca:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    23cc:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    23ce:	8a 03 78    	mov.w     w10, w7

000023d0 <dir_8_6>:
dir_8_6:
	mov	w11,Atemp	; pre-load Accu temp
    23d0:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    23d2:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    23d4:	f0 f8 2f    	mov.w     #0xff8f, w0
    23d6:	ae 29 b6    	and.w     0x9ae
; exec 
	and	w11,w12,w0
    23d8:	0c 80 65    	and.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    23da:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	clrc			; CLR C unconditionally
    23dc:	42 00 a9    	bclr.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    23de:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    23e0:	e9 ff 37    	bra       0x23b4 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    23e2:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    23e4:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    23e6:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    23e8:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    23ea:	0d 00 e0    	cp0.w     w13
	ifz
    23ec:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    23ee:	72 49 88    	mov.w     w2, 0x92e
	clr	Cflag		; clr C unconditionally
    23f0:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED unconditionally
    23f2:	af 89 a9    	bclr.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    23f4:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    23f6:	89 84 e8    	inc2.w    w9, w9
    23f8:	09 e0 a7    	btsc.w    w9, #0xe
    23fa:	09 00 22    	mov.w     #0x2000, w9

	return
    23fc:	00 00 06    	return    

000023fe <ind_8_7>:

ind_8_7:   ; -----------------------------------------------------    07  XOR R0,N (T)
; IN register service
	mov	PORTB,w0
    23fe:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2400:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2402:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2404:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2406:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    2408:	8a 03 78    	mov.w     w10, w7

0000240a <dir_8_7>:
dir_8_7:
	mov	w11,Atemp	; pre-load Accu temp
    240a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    240c:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    240e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2410:	ae 29 b6    	and.w     0x9ae
; exec 
	clrc
    2412:	42 00 a9    	bclr.b    0x42, #0x0
	btss	A16,#b_carry
    2414:	af 89 ae    	btss.b    0x9af, #0x4
	setc			; CPL C unconditionally
    2416:	42 00 a8    	bset.b    0x42, #0x0
	xor	w11,w12,w0
    2418:	0c 80 6d    	xor.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    241a:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    241c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    241e:	ca ff 37    	bra       0x23b4 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2420:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2422:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    2424:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2426:	2e 29 ef    	clr.w     0x92e
	bclr	A16,#b_carry	; Carry button LED
    2428:	af 89 a9    	bclr.b    0x9af, #0x4
	cp0	w13
    242a:	0d 00 e0    	cp0.w     w13
	ifz
    242c:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; Z flag
    242e:	72 49 88    	mov.w     w2, 0x92e

	btsc	Cflag,#2
    2430:	2c 49 af    	btsc.b    0x92c, #0x2
	clr	w2		; w2,#2,1,0 = complement Cflag,#2
    2432:	00 01 eb    	clr.w     w2
	mov	w2,Cflag	; cpl C unconditionally (bits 2,1,0)
    2434:	62 49 88    	mov.w     w2, 0x92c
	
	btsc	w2,#0
    2436:	02 00 a7    	btsc.w    w2, #0x0
	bset	A16,#b_carry	; Carry button LED
    2438:	af 89 a8    	bset.b    0x9af, #0x4

	mov.b	w13,[w7]	; write result to destination
    243a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    243c:	89 84 e8    	inc2.w    w9, w9
    243e:	09 e0 a7    	btsc.w    w9, #0xe
    2440:	09 00 22    	mov.w     #0x2000, w9

	return
    2442:	00 00 06    	return    

00002444 <ind_8_8>:

ind_8_8:   ; -----------------------------------------------------    08  EXR N (T)
; IN register service
	mov	PORTB,w0
    2444:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2446:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2448:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    244a:	00 4c 78    	mov.b     w0, [w8]

	clr	w11		; 1st operand = 0 (what else?)
    244c:	80 05 eb    	clr.w     w11
; maintain logic diagram
	clr3leds
    244e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2450:	ae 29 b6    	and.w     0x9ae
	btsc	Flag,#2		; #2 set if Speed>0
    2452:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow08
    2454:	0f 00 37    	bra       0x2474 <slow08>

	incpc			; w9++
    2456:	89 84 e8    	inc2.w    w9, w9
    2458:	09 e0 a7    	btsc.w    w9, #0xe
    245a:	09 00 22    	mov.w     #0x2000, w9

0000245c <swapper>:
; exec 
swapper:
	mov	w12,w2
    245c:	0c 01 78    	mov.w     w12, w2
	cp0	w2
    245e:	02 00 e0    	cp0.w     w2
	ifz
    2460:	42 20 af    	btsc.b    0x42, #0x1
	mov	#16,w2		; 0 members ---> 16 members
    2462:	02 01 20    	mov.w     #0x10, w2
	mov	#Ram,w3
    2464:	03 80 20    	mov.w     #0x800, w3
	mov	#Ram+(14*16),w4	; page 14
    2466:	04 8e 20    	mov.w     #0x8e0, w4

00002468 <L27>:
2:
	ze	[w4],w0		; [page 14] ---> w0
    2468:	14 80 fb    	ze        [w4], w0
	mov.b	[w3],[w4++]	;  [page 0] ---> [page 14]
    246a:	13 5a 78    	mov.b     [w3], [w4++]
	mov.b	w0,[w3++]	;        w0 ---> [page 0]
    246c:	80 59 78    	mov.b     w0, [w3++]
	dec	w2,w2
    246e:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b		; swap loop -------->
    2470:	fb ff 3a    	bra       NZ, 0x2468 <L27>
	return
    2472:	00 00 06    	return    

00002474 <slow08>:
slow08:
	mov	#0x03,w7	; flag "EXR N" instead of "MOV W13,[W7]"
    2474:	37 00 20    	mov.w     #0x3, w7
	mov	#0b0000,w6	; move VZCA
    2476:	06 00 20    	mov.w     #0x0, w6
	return
    2478:	00 00 06    	return    

0000247a <ind_8_9>:

ind_8_9:   ; -----------------------------------------------------    09  BIT RG,M (T)
; IN register service
	mov	PORTB,w0
    247a:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    247c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    247e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2480:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    2482:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    2484:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2486:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if reading from reg 0, 1, 2
    2488:	03 00 3a    	bra       NZ, 0x2490 <L113>
; if reading from reg 3 (IN port)
	mov	#0x0B,w0	; R0A (IN A)
    248a:	b0 00 20    	mov.w     #0xb, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    248c:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFB,w0	; RFA (IN B)
    248e:	b0 0f 20    	mov.w     #0xfb, w0

00002490 <L113>:
1:
	add	w10,w0,w7	; result write address
    2490:	80 03 45    	add.w     w10, w0, w7

00002492 <dir_8_9>:
dir_8_9:
	ze	[w7],w11	; value of addressed nibble
    2492:	97 85 fb    	ze        [w7], w11
	ze	[w7],w13	; this cancels later writing to [w7] (in routine "phases")
    2494:	97 86 fb    	ze        [w7], w13
	and	w12,#3,w2	; w2 = M isolated
    2496:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2498:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    249a:	02 06 dd    	sl.w      w0, w2, w12
; exec 
	and	w12,w11,w0	; only flag Z is the result
    249c:	0b 00 66    	and.w     w12, w11, w0
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    249e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0100
    24a0:	08 00 37    	bra       0x24b2 <slowZflag0100>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	#7,w2		; constant to write to in/temp/out flag
    24a2:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    24a4:	2e 29 ef    	clr.w     0x92e
	ifz
    24a6:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    24a8:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    24aa:	89 84 e8    	inc2.w    w9, w9
    24ac:	09 e0 a7    	btsc.w    w9, #0xe
    24ae:	09 00 22    	mov.w     #0x2000, w9

	return
    24b0:	00 00 06    	return    

000024b2 <slowZflag0100>:
slowZflag0100:
	mov	#0b0100,w6	; move VZCA
    24b2:	46 00 20    	mov.w     #0x4, w6
	bclr	Zflag,#0
    24b4:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    24b6:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    24b8:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    24ba:	00 00 06    	return    

000024bc <ind_8_10>:

ind_8_10:   ; -----------------------------------------------------    0A  BSET RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    24bc:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    24be:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    24c0:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    24c2:	03 00 3a    	bra       NZ, 0x24ca <L114>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    24c4:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    24c6:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    24c8:	a0 0f 20    	mov.w     #0xfa, w0

000024ca <L114>:
1:
	add	w10,w0,w7	; result write address
    24ca:	80 03 45    	add.w     w10, w0, w7

000024cc <dir_8_10>:
dir_8_10:
	ze	[w7],w11	; value of addressed nibble
    24cc:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    24ce:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    24d0:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    24d2:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    24d4:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    24d6:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    24d8:	f0 f8 2f    	mov.w     #0xff8f, w0
    24da:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w12,w11,w13	; w11 with bit set to Accu in
    24dc:	8b 06 76    	ior.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    24de:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    24e0:	51 fe 37    	bra       0x2184 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    24e2:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    24e4:	89 84 e8    	inc2.w    w9, w9
    24e6:	09 e0 a7    	btsc.w    w9, #0xe
    24e8:	09 00 22    	mov.w     #0x2000, w9

	return
    24ea:	00 00 06    	return    

000024ec <ind_8_11>:

ind_8_11:   ; -----------------------------------------------------    0B  BCLR RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    24ec:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    24ee:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    24f0:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    24f2:	03 00 3a    	bra       NZ, 0x24fa <L115>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    24f4:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    24f6:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    24f8:	a0 0f 20    	mov.w     #0xfa, w0

000024fa <L115>:
1:
	add	w10,w0,w7	; result write address
    24fa:	80 03 45    	add.w     w10, w0, w7

000024fc <dir_8_11>:
dir_8_11:
	ze	[w7],w11	; value of addressed nibble
    24fc:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    24fe:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2500:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    2502:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2504:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    2506:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    2508:	f0 f8 2f    	mov.w     #0xff8f, w0
    250a:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,#0x0F,w0
    250c:	6f 00 6e    	xor.w     w12, #0xf, w0
	and	w0,w11,w13	; w11 with bit reset to Accu in
    250e:	8b 06 60    	and.w     w0, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2510:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2512:	38 fe 37    	bra       0x2184 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    2514:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2516:	89 84 e8    	inc2.w    w9, w9
    2518:	09 e0 a7    	btsc.w    w9, #0xe
    251a:	09 00 22    	mov.w     #0x2000, w9

	return
    251c:	00 00 06    	return    

0000251e <ind_8_12>:

ind_8_12:   ; -----------------------------------------------------    0C  BTG RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    251e:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    2520:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2522:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    2524:	03 00 3a    	bra       NZ, 0x252c <L116>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    2526:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    2528:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    252a:	a0 0f 20    	mov.w     #0xfa, w0

0000252c <L116>:
1:
	add	w10,w0,w7	; result write address
    252c:	80 03 45    	add.w     w10, w0, w7

0000252e <dir_8_12>:
dir_8_12:
	ze	[w7],w11	; value of addressed nibble
    252e:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    2530:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2532:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    2534:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2536:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    2538:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    253a:	f0 f8 2f    	mov.w     #0xff8f, w0
    253c:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,w11,w13	; w11 with bit flipped to Accu in
    253e:	8b 06 6e    	xor.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2540:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2542:	20 fe 37    	bra       0x2184 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    2544:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2546:	89 84 e8    	inc2.w    w9, w9
    2548:	09 e0 a7    	btsc.w    w9, #0xe
    254a:	09 00 22    	mov.w     #0x2000, w9

	return
    254c:	00 00 06    	return    

0000254e <ind_8_13>:

ind_8_13:   ; -----------------------------------------------------    0D  RRC RY (T)
; IN register service
	mov	PORTB,w0
    254e:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2550:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2552:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2554:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from OperY
	add	w10,w12,w7	; result write address
    2556:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    2558:	6a 46 7e    	mov.b     [w10+w12], w12

0000255a <dir_8_13>:
dir_8_13:
	clr	w11		; clr oper 1 (will be displayed)
    255a:	80 05 eb    	clr.w     w11
	mov	w12,Atemp	; pre-load Accu temp
    255c:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    255e:	0c 07 78    	mov.w     w12, w14
; maintain logic diagram
	clr3leds
    2560:	f0 f8 2f    	mov.w     #0xff8f, w0
    2562:	ae 29 b6    	and.w     0x9ae
; exec 
	btsc	A16,#b_carry
    2564:	af 89 af    	btsc.b    0x9af, #0x4
	bset	w12,#4		; Carry flag for 4-bit operand
    2566:	0c 40 a0    	bset.w    w12, #0x4
	lsr	w12,w13		; write result straight to Accu in
    2568:	8c 06 d1    	lsr.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    256a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    256c:	23 ff 37    	bra       0x23b4 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    256e:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2570:	0d 07 78    	mov.w     w13, w14
	clr	Zflag
    2572:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2574:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2576:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2578:	72 00 20    	mov.w     #0x7, w2
	ifz
    257a:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    257c:	72 49 88    	mov.w     w2, 0x92e
	ifc
    257e:	42 00 af    	btsc.b    0x42, #0x0
	mov	w2,Cflag	; if C flag set
    2580:	62 49 88    	mov.w     w2, 0x92c
	ifc
    2582:	42 00 af    	btsc.b    0x42, #0x0
	bset	A16,#b_carry	; Carry button LED
    2584:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    2586:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2588:	89 84 e8    	inc2.w    w9, w9
    258a:	09 e0 a7    	btsc.w    w9, #0xe
    258c:	09 00 22    	mov.w     #0x2000, w9

	return
    258e:	00 00 06    	return    

00002590 <ind_8_14>:

ind_8_14:   ; -----------------------------------------------------    0E  RET R0,N (T)
	clr	w11		; will be displayed
    2590:	80 05 eb    	clr.w     w11
	mov.b	w12,w13		; preset #N to Acc in
    2592:	8c 46 78    	mov.b     w12, w13
	mov.b	[w10],w14	; preset previous R0 to Acc out
    2594:	1a 47 78    	mov.b     [w10], w14
	mov	w14,Atemp	; preset previous R0 to Acc temp
    2596:	4e 49 88    	mov.w     w14, 0x928
	mov	#0x04,w7	; flag "RET R0,N" instead of "MOV W13,[W7]"
    2598:	47 00 20    	mov.w     #0x4, w7
; maintain logic diagram
	clr3leds
    259a:	f0 f8 2f    	mov.w     #0xff8f, w0
    259c:	ae 29 b6    	and.w     0x9ae
; exec
	mov	Stack,w0
    259e:	50 49 80    	mov.w     0x92a, w0
	mul.uu	w0,#3,w0	; w0:w1
    25a0:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16-1,w0	; stack starts at Ram+16
    25a2:	f0 00 b0    	add.w     #0xf, w0
	add	w0,w10,w1	; stack starts at Ram+16
    25a4:	8a 00 40    	add.w     w0, w10, w1
	ze	[w1--],w0	; high nibble of ret addr
    25a6:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0
    25a8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1--],w0	; medium nibble of ret addr
    25aa:	21 40 70    	ior.b     w0, [w1--], w0
	sl	w0,#4,w0
    25ac:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; low nibble of ret addr
    25ae:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,w0		; ×2
    25b0:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w5
    25b2:	05 00 22    	mov.w     #0x2000, w5
	add	w0,w5,w5	; ret address
    25b4:	85 02 40    	add.w     w0, w5, w5
	btss	Flag,#2		; #2 set if Speed>0
    25b6:	dc 49 ae    	btss.b    0x9dc, #0x2
	bra	spec4
    25b8:	f0 fb 37    	bra       0x1d9a <spec4>
	bra	phases_0
    25ba:	e4 fd 37    	bra       0x2184 <phases_0>

000025bc <ind_8_15>:

ind_8_15:   ; -----------------------------------------------------    0F  SKIP F,M (T)
	clr	w11		; will be displayed
    25bc:	80 05 eb    	clr.w     w11
	mov	#0x06,w7	; flag "SKIP F,M" instead of "MOV W13,[W7]"
    25be:	67 00 20    	mov.w     #0x6, w7
; maintain logic diagram
	clr3leds
    25c0:	f0 f8 2f    	mov.w     #0xff8f, w0
    25c2:	ae 29 b6    	and.w     0x9ae
; exec
	and	w12,#3,w0	; w0 skip format
    25c4:	63 00 66    	and.w     w12, #0x3, w0
	ifz
    25c6:	42 20 af    	btsc.b    0x42, #0x1
	mov	#4,w0		; skip 0 = skip 4
    25c8:	40 00 20    	mov.w     #0x4, w0
	sl	w0,w0		; ×2
    25ca:	00 00 d0    	sl.w      w0, w0
	lsr	w12,#2,w1	; w1 = condition
    25cc:	c2 60 de    	lsr.w     w12, #0x2, w1
	and	#3,w1
    25ce:	31 00 b2    	and.w     #0x3, w1
	bra	w1
    25d0:	01 60 01    	bra       w1
;.........................
	bra	skip_C
    25d2:	03 00 37    	bra       0x25da <skip_C>
	bra	skip_NC
    25d4:	06 00 37    	bra       0x25e2 <skip_NC>
	bra	skip_Z
    25d6:	09 00 37    	bra       0x25ea <skip_Z>
	bra	skip_NZ
    25d8:	0c 00 37    	bra       0x25f2 <skip_NZ>

000025da <skip_C>:
skip_C:
	mov	w9,w5
    25da:	89 02 78    	mov.w     w9, w5
	btsc	A16,#b_carry	; cc0: C
    25dc:	af 89 af    	btsc.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    25de:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25e0:	0b 00 37    	bra       0x25f8 <skr_skip>

000025e2 <skip_NC>:
skip_NC:
	mov	w9,w5
    25e2:	89 02 78    	mov.w     w9, w5
	btss	A16,#b_carry	; cc1: NC
    25e4:	af 89 ae    	btss.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    25e6:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25e8:	07 00 37    	bra       0x25f8 <skr_skip>

000025ea <skip_Z>:
skip_Z:
	mov	w9,w5
    25ea:	89 02 78    	mov.w     w9, w5
	btsc	Zflag,#2	; cc2: Z
    25ec:	2e 49 af    	btsc.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    25ee:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    25f0:	03 00 37    	bra       0x25f8 <skr_skip>

000025f2 <skip_NZ>:
skip_NZ:
	mov	w9,w5
    25f2:	89 02 78    	mov.w     w9, w5
	btss	Zflag,#2	; cc3: NZ
    25f4:	2e 49 ae    	btss.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    25f6:	80 82 42    	add.w     w5, w0, w5

000025f8 <skr_skip>:
skr_skip:
	inc2	w5,w5		; because INC2 W5 will not be executed like INC2 W9
    25f8:	85 82 e8    	inc2.w    w5, w5
	btsc	w5,#14
    25fa:	05 e0 a7    	btsc.w    w5, #0xe
	mov	#Rom,w5		; wrap to start of program memory
    25fc:	05 00 22    	mov.w     #0x2000, w5

	btsc	Flag,#2		; #2 set if Speed>0
    25fe:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2600:	c1 fd 37    	bra       0x2184 <phases_0>

	mov	w5,w9
    2602:	85 04 78    	mov.w     w5, w9
	bra	w9range
    2604:	b9 fb 37    	bra       0x1d78 <w9range>

00002606 <set_T2_from_Speed>:

; ---------------------------------------------------------------------------
set_T2_from_Speed:
	mov.b	Speed,WREG
    2606:	f1 c8 bf    	mov.b     0x8f1, WREG

00002608 <set_T2_from_w0>:
set_T2_from_w0:
	and	#0x0F,w0
    2608:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Speed	; Speed index, bit 3210
    260a:	f1 e8 b7    	mov.b     WREG, 0x8f1
	clr	TBLPAG
    260c:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(clk_table),w1
    260e:	81 29 23    	mov.w     #0x3298, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    2610:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(clk_table_high),w1
    2612:	81 2d 23    	mov.w     #0x32d8, w1
	bclr	T2CON,#TON	; stop Timer 2
    2614:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	clr	TMR2		; clear timing counter
    2616:	96 21 ef    	clr.w     0x196
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    2618:	dc 49 a8    	bset.b    0x9dc, #0x2
	  cp0.b	  w0
    261a:	00 04 e0    	cp0.b     w0
	  ifz
    261c:	42 20 af    	btsc.b    0x42, #0x1
	  bclr	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    261e:	dc 49 a9    	bclr.b    0x9dc, #0x2
	bclr	IFS0,#7		; clr int flag
    2620:	88 e0 a9    	bclr.b    0x88, #0x7
	sl	w0,#2,w0	; × 4
    2622:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Speed × 4
    2624:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    2626:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR2		; update T2 divider value
    2628:	e1 0c 88    	mov.w     w1, 0x19c
	tblrdl	[w0++],w0
    262a:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T2CON	; update prescaler value (low byte only)
    262c:	a0 e1 b7    	mov.b     WREG, 0x1a0
	  dec2	  Mode,WREG
    262e:	76 89 ed    	dec2.w    0x976, WREG
	  ifnz
    2630:	42 20 ae    	btss.b    0x42, #0x1
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    2632:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	T2CON,#TON	; start Timer 2
    2634:	a1 e1 a8    	bset.b    0x1a1, #0x7
	return
    2636:	00 00 06    	return    

00002638 <set_T3_from_Sync>:

; ---------------------------------------------------------------------------
set_T3_from_Sync:
	mov.b	Sync,WREG
    2638:	f2 c8 bf    	mov.b     0x8f2, WREG

0000263a <set_T3_from_w0>:
set_T3_from_w0:
	and	#0x0F,w0
    263a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Sync	; Sync index, bit 3210
    263c:	f2 e8 b7    	mov.b     WREG, 0x8f2
	clr	TBLPAG
    263e:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(sync_table),w1
    2640:	81 31 23    	mov.w     #0x3318, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    2642:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(sync_table_high),w1
    2644:	81 35 23    	mov.w     #0x3358, w1
	bclr	T3CON,#TON	; stop Timer 3
    2646:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	clr	TMR3		; clear timing counter
    2648:	9a 21 ef    	clr.w     0x19a
	bclr	IFS0,#8		; clr int flag
    264a:	89 00 a9    	bclr.b    0x89, #0x0
	bclr.b	RdFlags,#0	; clr Sync flag
    264c:	f4 08 a9    	bclr.b    0x8f4, #0x0
	sl	w0,#2,w0	; × 4
    264e:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Sync × 4
    2650:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    2652:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR3		; update T3 divider value
    2654:	f1 0c 88    	mov.w     w1, 0x19e
	tblrdl	[w0++],w0
    2656:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T3CON	; update prescaler value (low byte only)
    2658:	a2 e1 b7    	mov.b     WREG, 0x1a2
	bset	T3CON,#TON	; start Timer 3
    265a:	a3 e1 a8    	bset.b    0x1a3, #0x7
	return
    265c:	00 00 06    	return    

0000265e <rnd>:

; ------------------------------------------------------------------------------
rnd:				; RND to w0 bits 3-0
;           not needed       needed1          needed2
; AB * CD = (A*C << 32) + ((B*C + A*D) << 16) + B*D
; A=w5:B=w4 × C=w3=0x41c6:D=w2=4e6d + 0x6073 ---> w4:w5

	mov	Rndhi,w5	; existing hi
    265e:	35 4e 80    	mov.w     0x9c6, w5
	mov	Rndlo,w4	; existing lo
    2660:	24 4e 80    	mov.w     0x9c4, w4
	mov	#0x41c6,w3	; hi
    2662:	63 1c 24    	mov.w     #0x41c6, w3
	mov	#0x4e6d,w2	; lo
    2664:	d2 e6 24    	mov.w     #0x4e6d, w2

	mul.uu	w4,w3,w0	; B*C ---> w0(:w1)
    2666:	03 20 b8    	mul.uu    w4, w3, w0
	mov	w0,w6		; ---> w6
    2668:	00 03 78    	mov.w     w0, w6
	mul.uu	w5,w2,w0	; A*D ---> w0(:w1)
    266a:	02 28 b8    	mul.uu    w5, w2, w0
	add	w0,w6,w3	; w3 = needed1
    266c:	86 01 40    	add.w     w0, w6, w3

	mul.uu	w4,w2,w4	; B*D ---> w4:w5 = needed2 (w4 low word)
    266e:	02 22 b8    	mul.uu    w4, w2, w4
	add	w5,w3,w5	; w5 high word
    2670:	83 82 42    	add.w     w5, w3, w5

	mov	#0x6073,w3
    2672:	33 07 26    	mov.w     #0x6073, w3
	add	w4,w3,w4	; lo + 0x6073 --> lo
    2674:	03 02 42    	add.w     w4, w3, w4
	addc	w5,#0,w5	; hi + Carry ---> hi
    2676:	e0 82 4a    	addc.w    w5, #0x0, w5
    ; w4:w5 ---> rnd seed
	mov	w4,Rndlo	; new lo
    2678:	24 4e 88    	mov.w     w4, 0x9c4
	mov	w5,Rndhi	; new hi
    267a:	35 4e 88    	mov.w     w5, 0x9c6

0000267c <extract4bits>:
extract4bits:
	xor	w4,w5,w0	; [w5] 31-16  XOR  [w4] 15-00  --->  [w0] 15-0
    267c:	05 00 6a    	xor.w     w4, w5, w0
	add.b	_WREG0+1,WREG	; [w0] 15-08   +   [w0] 07-00  --->  [w0] 7-0
    267e:	01 40 b4    	add.b     0x1, WREG
	lsr	w0,#4,w2
    2680:	44 01 de    	lsr.w     w0, #0x4, w2
	xor	w0,w2,w0	; [w2] 07-04  XOR  [w0] 03-00  --->  [w0] 3-0
    2682:	02 00 68    	xor.w     w0, w2, w0
	and	w0,#0x0F,w0	; RND in w0 bits 3-0
    2684:	6f 00 60    	and.w     w0, #0xf, w0
	return
    2686:	00 00 06    	return    

00002688 <getrnd>:

getrnd:
	mov	Rndlo,w4	; existing lo
    2688:	24 4e 80    	mov.w     0x9c4, w4
	mov	Rndhi,w5	; existing hi
    268a:	35 4e 80    	mov.w     0x9c6, w5
	bra	extract4bits
    268c:	f7 ff 37    	bra       0x267c <extract4bits>

0000268e <perform_SFR_write>:

; ------------------------------------------------------------------------------
perform_SFR_write:
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    268e:	dd 29 a9    	bclr.b    0x9dd, #0x1
	and	#0x0f,w5
    2690:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    2692:	05 60 01    	bra       w5
;...
	return
    2694:	00 00 06    	return    
	bra	SFR_write_1
    2696:	0e 00 37    	bra       0x26b4 <SFR_write_1>
	bra	SFR_write_2
    2698:	10 00 37    	bra       0x26ba <SFR_write_2>
	bra	SFR_write_3
    269a:	12 00 37    	bra       0x26c0 <SFR_write_3>
	return
    269c:	00 00 06    	return    
	bra	SFR_write_5
    269e:	1d 00 37    	bra       0x26da <SFR_write_5>
	bra	SFR_write_6
    26a0:	1e 00 37    	bra       0x26de <SFR_write_6>
	return
    26a2:	00 00 06    	return    
	bra	SFR_write_8
    26a4:	23 00 37    	bra       0x26ec <SFR_write_8>
	bra	SFR_write_9
    26a6:	29 00 37    	bra       0x26fa <SFR_write_9>
	return
    26a8:	00 00 06    	return    
	return
    26aa:	00 00 06    	return    
	return
    26ac:	00 00 06    	return    
	return
    26ae:	00 00 06    	return    
	return
    26b0:	00 00 06    	return    
	bra	SFR_write_15
    26b2:	26 00 37    	bra       0x2700 <SFR_write_15>

000026b4 <SFR_write_1>:
;...
SFR_write_1:		; Speed
	call	set_T2_from_Speed
    26b4:	06 26 02    	call      0x2606 <set_T2_from_Speed>
    26b6:	00 00 00 
	return
    26b8:	00 00 06    	return    

000026ba <SFR_write_2>:
;	
SFR_write_2:		; Sync
	call	set_T3_from_Sync
    26ba:	38 26 02    	call      0x2638 <set_T3_from_Sync>
    26bc:	00 00 00 
	return
    26be:	00 00 06    	return    

000026c0 <SFR_write_3>:
;	
SFR_write_3:		; WrFlags (PinPos); in: SerCtrl,#3=0...1,  out: RPINR, RPOR
	mov.b	SerCtrl,WREG
    26c0:	f5 c8 bf    	mov.b     0x8f5, WREG

000026c2 <sel_pinpos>:
sel_pinpos:
	btss.b	WrFlags,#0	; #0 RxTxPos
    26c2:	f3 08 ae    	btss.b    0x8f3, #0x0
	bra	RxTx0
    26c4:	05 00 37    	bra       0x26d0 <RxTx0>
; RxTxPos=1 (Rx and Tx are on I/O connector)
	btsc	Flag2,#3	; #3 Previous RxTxPos
    26c6:	de 69 af    	btsc.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    26c8:	07 00 37    	bra       0x26d8 <WrFlags_next>
	  call	  rxtx_to_io	; SWITCH RxTx to IO
    26ca:	0e 28 02    	call      0x280e <rxtx_to_io>
    26cc:	00 00 00 
	bra	WrFlags_next
    26ce:	04 00 37    	bra       0x26d8 <WrFlags_next>

000026d0 <RxTx0>:
RxTx0:
	btss	Flag2,#3	; #3 Previous RxTxPos
    26d0:	de 69 ae    	btss.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    26d2:	02 00 37    	bra       0x26d8 <WrFlags_next>
	  call	  rxtx_to_sao	; SWITCH RxTx to SAO
    26d4:	fc 27 02    	call      0x27fc <rxtx_to_sao>
    26d6:	00 00 00 

000026d8 <WrFlags_next>:
WrFlags_next:
	return
    26d8:	00 00 06    	return    

000026da <SFR_write_5>:
;	
SFR_write_5:		; SerCtrl (SERVICE BaudRate)
	and	w13,#0x07,w0
    26da:	67 80 66    	and.w     w13, #0x7, w0
	bra	set_U1BRG_from_w0
    26dc:	75 00 37    	bra       0x27c8 <set_U1BRG_from_w0>

000026de <SFR_write_6>:
;	
SFR_write_6:		; SerLow (TX BYTE)
	mov.b	SerHigh,WREG
    26de:	f7 c8 bf    	mov.b     0x8f7, WREG
	sl	w0,#4,w0
    26e0:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerLow,WREG
    26e2:	f6 48 b7    	ior.b     0x8f6, WREG

000026e4 <waittx_2>:
waittx_2:
	btsc	U1STA,#UTXBF
    26e4:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	waittx_2
    26e6:	fe ff 37    	bra       0x26e4 <waittx_2>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    26e8:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    26ea:	00 00 06    	return    

000026ec <SFR_write_8>:
;	
SFR_write_8:		; Received
	cp0.b	Received
    26ec:	f8 48 e2    	cp0.b     0x8f8
	bra	nz,go_cont_8_2
    26ee:	03 00 3a    	bra       NZ, 0x26f6 <go_cont_8_2>
	mov	#RX_buf,w0
    26f0:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    26f2:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    26f4:	f0 4d 88    	mov.w     w0, 0x9be

000026f6 <go_cont_8_2>:
go_cont_8_2:
	ifnz
    26f6:	42 20 ae    	btss.b    0x42, #0x1
	return
    26f8:	00 00 06    	return    

000026fa <SFR_write_9>:
;	
SFR_write_9:		; AutoOff
; as the destination is AutoOff, AutoOff_Hi must be preloaded
	mov	#37500,w0
    26fa:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    26fc:	b0 4d 88    	mov.w     w0, 0x9b6
	return
    26fe:	00 00 06    	return    

00002700 <SFR_write_15>:
;	
SFR_write_15:		; RND
	cp.b	w13,#15
    2700:	6f 6c e1    	cp.b      w13, #0xf
	bra	z,seed15
    2702:	09 00 32    	bra       Z, 0x2716 <seed15>
	sl	w13,#4,w0
    2704:	44 68 dd    	sl.w      w13, #0x4, w0
	ior	w13,w0,w0	; 4 ---> 8 bits
    2706:	00 80 76    	ior.w     w13, w0, w0
	sl	w0,#8,w13
    2708:	c8 06 dd    	sl.w      w0, #0x8, w13
	ior	w13,w0,w0	; 8 ---> 16 bits
    270a:	00 80 76    	ior.w     w13, w0, w0
	mov	w0,Rndhi
    270c:	30 4e 88    	mov.w     w0, 0x9c6
	mov	w0,Rndlo
    270e:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    2710:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    2712:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    2714:	00 00 06    	return    

00002716 <seed15>:
seed15:			; if seed=15, then total RND
	mov	TMR2,w0
    2716:	b0 0c 80    	mov.w     0x196, w0
	sl	w0,#4,w0
    2718:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	RowScan,WREG
    271a:	78 49 b7    	ior.b     0x978, WREG
	sl	w0,#4,w0
    271c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	TMR1,WREG
    271e:	90 41 b7    	ior.b     0x190, WREG
	mov	w0,Rndhi
    2720:	30 4e 88    	mov.w     w0, 0x9c6
	mov	AutoOff_Hi,w1
    2722:	b1 4d 80    	mov.w     0x9b6, w1
	xor	w0,w1,w0
    2724:	01 00 68    	xor.w     w0, w1, w0
	mov	w0,Rndlo
    2726:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    2728:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    272a:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    272c:	00 00 06    	return    

0000272e <perform_SFR_read>:

; ------------------------------------------------------------------------------

perform_SFR_read:
	bclr	Flag,#10	; #10 set if instruction is reading from SFR area
    272e:	dd 49 a9    	bclr.b    0x9dd, #0x2
	and	#0x0f,w5
    2730:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    2732:	05 60 01    	bra       w5
;...
	return
    2734:	00 00 06    	return    
	return
    2736:	00 00 06    	return    
	return
    2738:	00 00 06    	return    
	return
    273a:	00 00 06    	return    
	bra	SFR_read_4
    273c:	0b 00 37    	bra       0x2754 <SFR_read_4>
	bra	SFR_read_5
    273e:	15 00 37    	bra       0x276a <SFR_read_5>
	bra	SFR_read_6
    2740:	16 00 37    	bra       0x276e <SFR_read_6>
	return
    2742:	00 00 06    	return    
	return
    2744:	00 00 06    	return    
	return
    2746:	00 00 06    	return    
	return	;bra	SFR_read_10
    2748:	00 00 06    	return    
	return
    274a:	00 00 06    	return    
	bra	SFR_read_12
    274c:	2d 00 37    	bra       0x27a8 <SFR_read_12>
	return
    274e:	00 00 06    	return    
	return
    2750:	00 00 06    	return    
	bra	SFR_read_15
    2752:	2f 00 37    	bra       0x27b2 <SFR_read_15>

00002754 <SFR_read_4>:
;...
SFR_read_4:		; RdFlags
	bclr	IEC0,#8		; disable Timer 3 interrupt
    2754:	99 00 a9    	bclr.b    0x99, #0x0
	mov.b	RdFlags,WREG
    2756:	f4 c8 bf    	mov.b     0x8f4, WREG
	and.b	Ram+0,WREG
    2758:	00 48 b6    	and.b     0x800, WREG
	btss	w0,#0
    275a:	00 00 a6    	btss.w    w0, #0x0
	bra	1f
    275c:	04 00 37    	bra       0x2766 <L117>
	mov.b	RdFlags,WREG
    275e:	f4 c8 bf    	mov.b     0x8f4, WREG
	mov.b	WREG,Ram+0	; write to R0 again, timing is critical!
    2760:	00 e8 b7    	mov.b     WREG, 0x800
	and	#0b1110,w0	; kill flag UserSync (#0)
    2762:	e0 00 b2    	and.w     #0xe, w0
	mov.b	WREG,RdFlags
    2764:	f4 e8 b7    	mov.b     WREG, 0x8f4

00002766 <L117>:
1:
	bset	IEC0,#8		; enable Timer 3 interrupt
    2766:	99 00 a8    	bset.b    0x99, #0x0
	return
    2768:	00 00 06    	return    

0000276a <SFR_read_5>:
;	
SFR_read_5:
	bclr	SerCtrl,#3
    276a:	f5 68 a9    	bclr.b    0x8f5, #0x3
	return
    276c:	00 00 06    	return    

0000276e <SFR_read_6>:
;	
SFR_read_6:		; SerLow
	cp0.b	Received
    276e:	f8 48 e2    	cp0.b     0x8f8
	ifz
    2770:	42 20 af    	btsc.b    0x42, #0x1
	return			; if zero received
    2772:	00 00 06    	return    
	bclr	IEC0,#11   ; \    disable RX1 interrupt
    2774:	99 60 a9    	bclr.b    0x99, #0x3
; move char from SerLow to r0
	mov.b	SerLow,WREG
    2776:	f6 c8 bf    	mov.b     0x8f6, WREG
	mov.b	w0,[w7]
    2778:	80 4b 78    	mov.b     w0, [w7]
	bclr	Flag2,#2	; clr handshaking flag (for FIFO ---> SerHigh:SerLow)
    277a:	de 49 a9    	bclr.b    0x9de, #0x2
; test if there is anything in FIFO...
	mov	RXRD,w0
    277c:	f0 4d 80    	mov.w     0x9be, w0
	cp.b	RXWR
    277e:	bc 49 e3    	cp.b      0x9bc
	bra	z,calc_rcvd	; if FIFO empty
    2780:	08 00 32    	bra       Z, 0x2792 <calc_rcvd>
; ...checked, FIFO > 0, move 1st char from FIFO to ser buf Ser L:H and inc RDPtr
	ze	[w0],w1		; w1 1st byte from FIFO
    2782:	90 80 fb    	ze        [w0], w1
	and	w1,#0x0F,w0	; low nibble
    2784:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    2786:	f6 e8 b7    	mov.b     WREG, 0x8f6
	lsr	w1,#4,w0	; hi nibble
    2788:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    278a:	f7 e8 b7    	mov.b     WREG, 0x8f7
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    278c:	de 49 a8    	bset.b    0x9de, #0x2
	inc.b	RXRD		; inc RD ptr (8-bit inc, to stay inside FIFO)
    278e:	be 69 ec    	inc.b     0x9be
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    2790:	de 49 a8    	bset.b    0x9de, #0x2

00002792 <calc_rcvd>:
calc_rcvd:
; calculate Received
	clr	w0		; to clear high byte
    2792:	00 00 eb    	clr.w     w0
	mov.b	RXWR,WREG
    2794:	bc c9 bf    	mov.b     0x9bc, WREG
	sub.b	RXRD,WREG	; RXRD-RXWR (byte mode, to stay in range 0000-00FF)
    2796:	be 49 b5    	sub.b     0x9be, WREG
	btsc	Flag2,#2	; handshaking flag (for FIFO ---> SerHigh:SerLow)
    2798:	de 49 af    	btsc.b    0x9de, #0x2
	inc	w0,w0		; plus char in Ser H:L (if any)
    279a:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    279c:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    279e:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    27a0:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    27a2:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	IEC0,#11   ; /    enable RX1 interrupt
    27a4:	99 60 a8    	bset.b    0x99, #0x3
	return
    27a6:	00 00 06    	return    

000027a8 <SFR_read_12>:
;	
;SFR_read_10:		; KeyStatus
;	disi	#4
;	mov.b	KeyStatus,WREG
;	mov.b	WREG,Ram+0	; write to R0
;	bclr	KeyStatus,#0
;	return
;	
SFR_read_12:		; KeyStatus
	disi	#4
    27a8:	04 00 fc    	disi      #0x4
	mov.b	KeyStatus,WREG
    27aa:	fc c8 bf    	mov.b     0x8fc, WREG
	mov.b	WREG,Ram+0	; write to R0
    27ac:	00 e8 b7    	mov.b     WREG, 0x800
	bclr	KeyStatus,#0
    27ae:	fc 08 a9    	bclr.b    0x8fc, #0x0
	return
    27b0:	00 00 06    	return    

000027b2 <SFR_read_15>:
;	
SFR_read_15:		; RND
	call	getrnd
    27b2:	88 26 02    	call      0x2688 <getrnd>
    27b4:	00 00 00 
	mov.b	WREG,Ram+0	; write to R0
    27b6:	00 e8 b7    	mov.b     WREG, 0x800

000027b8 <new_rnd>:
new_rnd:
	call	rnd
    27b8:	5e 26 02    	call      0x265e <rnd>
    27ba:	00 00 00 
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    27bc:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    27be:	00 00 06    	return    

000027c0 <def_U1BRG>:

; ---------------------------------------------------------------------------
def_U1BRG:		; set Baud Rate to 9600
	mov	#3,w0
    27c0:	30 00 20    	mov.w     #0x3, w0
	bra	set_U1BRG_from_w0
    27c2:	02 00 37    	bra       0x27c8 <set_U1BRG_from_w0>

000027c4 <set_U1BRG>:
set_U1BRG:		; restore the original Baud Rate
	mov.b	SerCtrl,WREG
    27c4:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    27c6:	70 00 b2    	and.w     #0x7, w0

000027c8 <set_U1BRG_from_w0>:
set_U1BRG_from_w0:	; in: w0,  out: U1BRG
	bclr	U1MODE,#15		; disable UART 1
    27c8:	99 e3 a9    	bclr.b    0x399, #0x7
	clr	TBLPAG
    27ca:	54 20 ef    	clr.w     0x54
	sl	w0,w0		; ×2
    27cc:	00 00 d0    	sl.w      w0, w0
	mov	#tbloffset(baud_tab),w1
    27ce:	81 7e 22    	mov.w     #0x27e8, w1
	add	w0,w1,w1
    27d0:	81 00 40    	add.w     w0, w1, w1
	tblrdl	[w1],w0
    27d2:	11 00 ba    	tblrdl.w  [w1], w0
	mov	w0,U1BRG
    27d4:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
    27d6:	99 e3 a8    	bset.b    0x399, #0x7
	nop
    27d8:	00 00 00    	nop       
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    27da:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    27dc:	9b 83 a8    	bset.b    0x39b, #0x4
	clr.b	Received
    27de:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    27e0:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    27e2:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    27e4:	f0 4d 88    	mov.w     w0, 0x9be
	return
    27e6:	00 00 06    	return    

000027e8 <baud_tab>:
    27e8:	04 0d 00    	nop       
    27ea:	82 06 00    	nop       
    27ec:	40 03 00    	nop       
    27ee:	a0 01 00    	nop       
    27f0:	cf 00 00    	nop       
    27f2:	67 00 00    	nop       
    27f4:	44 00 00    	nop       
    27f6:	22 00 00    	nop       

000027f8 <rxtx_to_rxtxpos>:
baud_tab:
	.word	3333-1	;  0.  1200
	.word	1667-1	;  1.  2400
	.word	833-1	;  2.  4800
	.word	417-1	;  3.  9600
	.word	208-1	;  4.  19200
	.word	104-1	;  5.  38400
	.word	69-1	;  6.  57600
	.word	35-1	;  7.  115200
; ---------------------------------------------------
rxtx_to_rxtxpos:
	btsc.b	WrFlags,#0	; WrFlags,#0: RxTxPos
    27f8:	f3 08 af    	btsc.b    0x8f3, #0x0
	bra	rxtx_to_io	; if RxTxPos=1
    27fa:	09 00 37    	bra       0x280e <rxtx_to_io>

000027fc <rxtx_to_sao>:
rxtx_to_sao:
; B7 input now (GP input)
	bclr	U1MODE,#15		; disable UART 1
    27fc:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	TRISB,#7
    27fe:	76 e6 a8    	bset.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to SAO connector
	mov	#26,w0		; RP26 PORT  (A0)... (0x3f to disable RX input)
    2800:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    2802:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    2804:	30 00 20    	mov.w     #0x3, w0
	mov.b	RPOR13+1	; ...to RP27 (A1)
    2806:	ef e7 bf    	mov.b     0x7ef
; disable old pin for Tx
	clr.b	RPOR3+1		; ...to RP7  (B7) (0x00 to return to default OUT port)
    2808:	db 67 ef    	clr.b     0x7db
	bclr	Flag2,#3	; #3 Previous RxTxPos
    280a:	de 69 a9    	bclr.b    0x9de, #0x3
	bra	skr_rxtx
    280c:	07 00 37    	bra       0x281c <skr_rxtx>

0000280e <rxtx_to_io>:
;----------------------------------------------------
rxtx_to_io:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
    280e:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
    2810:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
    2812:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    2814:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    2816:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
    2818:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
    281a:	de 69 a8    	bset.b    0x9de, #0x3

0000281c <skr_rxtx>:
skr_rxtx:
	bset	U1MODE,#15		; enable UART 1
    281c:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
    281e:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    2820:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    2822:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    2824:	f0 4d 88    	mov.w     w0, 0x9be
	return
    2826:	00 00 06    	return    

00002828 <leave_run_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_run_ept:
; save RUN variables to RUN Temp
	mov	Stack,w0
    2828:	50 49 80    	mov.w     0x92a, w0
	mov	w0,RunTempStack	; Stack
    282a:	b0 4a 88    	mov.w     w0, 0x956
	mov	w9,RunTempPMAddr; PC
    282c:	a9 4a 88    	mov.w     w9, 0x954
	mov.b	Page,WREG
    282e:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,RunTempPage ; Page
    2830:	58 e9 b7    	mov.b     WREG, 0x958
; save Run flags
	mov	Vflag,w0
    2832:	80 49 80    	mov.w     0x930, w0
	mov	w0,RunTempVflag
    2834:	d0 4a 88    	mov.w     w0, 0x95a
	mov	Zflag,w0
    2836:	70 49 80    	mov.w     0x92e, w0
	mov	w0,RunTempZflag
    2838:	e0 4a 88    	mov.w     w0, 0x95c
	mov	Cflag,w0
    283a:	60 49 80    	mov.w     0x92c, w0
	mov	w0,RunTempCflag
    283c:	f0 4a 88    	mov.w     w0, 0x95e
	mov	w14,RunTempw14
    283e:	1e 4b 88    	mov.w     w14, 0x962
	mov	w13,RunTempw13
    2840:	0d 4b 88    	mov.w     w13, 0x960
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    2842:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	pgm_ept
    2844:	01 00 37    	bra       0x2848 <pgm_ept>
	bra	ss_ept
    2846:	99 f7 37    	bra       0x177a <ss_ept>

00002848 <pgm_ept>:

pgm_ept:
	btss	Flag2,#12
    2848:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    284a:	d6 10 02    	call      0x10d6 <clr_ram>
    284c:	00 00 00 
	bset	Flag2,#12
    284e:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload PGM variables from PGM Temp
	clr	Stack		; Stack
    2850:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; Page 0
    2852:	f0 68 ef    	clr.b     0x8f0
	mov	PgmTempPMAddr,w9 ; PC
    2854:	29 4b 80    	mov.w     0x964, w9
	mov	#0b011101100,w0	; autorpt for Addr-, Addr+, Opcode, OperX, OperY
    2856:	c0 0e 20    	mov.w     #0xec, w0
	mov	w0,AutorptFlag
    2858:	60 4d 88    	mov.w     w0, 0x9ac
; PGM initialize
	mov	#3,w0
    285a:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode		; Mode
    285c:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    285e:	e0 29 ef    	clr.w     0x9e0
	clr	w11
    2860:	80 05 eb    	clr.w     w11
	clr	w12
    2862:	00 06 eb    	clr.w     w12
	clr	w13
    2864:	80 06 eb    	clr.w     w13
	clr	w14
    2866:	00 07 eb    	clr.w     w14
	clr	Vflag
    2868:	30 29 ef    	clr.w     0x930
	clr	Zflag
    286a:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    286c:	2c 29 ef    	clr.w     0x92c
	mov	#3,w0			; 3 = PGM
    286e:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode
    2870:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    2872:	dc 49 a8    	bset.b    0x9dc, #0x2
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    2874:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    2876:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    2878:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    287a:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000000100000000,w0	; set RUN
    287c:	00 10 20    	mov.w     #0x100, w0
	ior	A16
    287e:	ae 29 b7    	ior.w     0x9ae

00002880 <pgm_farm>:

pgm_farm:
	call	read12		; read new pgm word
    2880:	6c 29 02    	call      0x296c <read12>
    2882:	00 00 00 

00002884 <pgm_noread>:
pgm_noread:
	btss	Flag,#1		; #1 handshaking flag for buttons
    2884:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	pgm_noread
    2886:	fe ff 37    	bra       0x2884 <pgm_noread>
	bclr	Flag,#1
    2888:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    288a:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    288c:	65 00 e1    	cp.w      w0, #0x5
	ifc
    288e:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    2890:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    2892:	00 60 01    	bra       w0
; ...
	bra	leave_pgm_ept
    2894:	74 00 37    	bra       0x297e <leave_pgm_ept>
	bra	button_addr_set
    2896:	04 00 37    	bra       0x28a0 <button_addr_set>
	bra	button_addr_minus_pgm
    2898:	18 00 37    	bra       0x28ca <button_addr_minus_pgm>
	bra	button_addr_plus_pgm
    289a:	1d 00 37    	bra       0x28d6 <button_addr_plus_pgm>
	bra	button_dep
    289c:	22 00 37    	bra       0x28e2 <button_dep>
	bra	general_pgm_5
    289e:	63 00 37    	bra       0x2966 <general_pgm_5>

000028a0 <button_addr_set>:
;					ept 0: addr_set (in PGM mode)
button_addr_set:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28a0:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_addr_set	; if ALT addr set pressed
    28a2:	09 00 37    	bra       0x28b6 <alt_addr_set>
	mov	Opcode,w0
    28a4:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    28a6:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    28a8:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    28aa:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    28ac:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    28ae:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    28b0:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    28b2:	81 04 40    	add.w     w0, w1, w9
	bra	pgm_farm
    28b4:	e5 ff 37    	bra       0x2880 <pgm_farm>

000028b6 <alt_addr_set>:
;					ept 0: addr_set (in PGM mode)
alt_addr_set:
	inc2	w9,w2
    28b6:	09 81 e8    	inc2.w    w9, w2
	mov	#Rom+0x2000,w1	; end of Program Memory + 2
    28b8:	01 00 24    	mov.w     #0x4000, w1

000028ba <train2>:
train2:
	cp	w2,w1		; w9=current program pointer (non-incremented)
    28ba:	01 10 e1    	cp.w      w2, w1
	bra	nz,1f
    28bc:	02 00 3a    	bra       NZ, 0x28c2 <L118>
	clr	[--w2]		; last word in program = 0x000
    28be:	00 21 eb    	clr.w     [--w2]
	bra	adr_plus	; train finished
    28c0:	0c 00 37    	bra       0x28da <adr_plus>

000028c2 <L118>:
1:
	mov	[w2--],w0	; w0 = contents
    28c2:	22 00 78    	mov.w     [w2--], w0
	mov	w0,[w2]
    28c4:	00 09 78    	mov.w     w0, [w2]
	add	#4,w2
    28c6:	42 00 b0    	add.w     #0x4, w2
	bra	train2
    28c8:	f8 ff 37    	bra       0x28ba <train2>

000028ca <button_addr_minus_pgm>:
;					ept 1: addr_minus_pgm (in PGM mode)
button_addr_minus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28ca:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_minus_pgm	; if ALT addr minus pressed
    28cc:	27 00 37    	bra       0x291c <alt_minus_pgm>
	dec2	w9,w9		; decrement address
    28ce:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    28d0:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    28d2:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	pgm_farm
    28d4:	d5 ff 37    	bra       0x2880 <pgm_farm>

000028d6 <button_addr_plus_pgm>:
;					ept 2: addr_plus_pgm (in PGM mode)
button_addr_plus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28d6:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_plus_pgm	; if ALT addr plus pressed
    28d8:	1c 00 37    	bra       0x2912 <alt_plus_pgm>

000028da <adr_plus>:
adr_plus:
	inc2	w9,w9		; increment address
    28da:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    28dc:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    28de:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm	; test failed, some other key pressed
    28e0:	cf ff 37    	bra       0x2880 <pgm_farm>

000028e2 <button_dep>:
;					ept 3: dep (in PGM mode)
button_dep:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    28e2:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_dep		; if ALT DEP pressed
    28e4:	03 00 37    	bra       0x28ec <alt_dep>
	call	write12		; write new pgm word
    28e6:	04 29 02    	call      0x2904 <write12>
    28e8:	00 00 00 
	bra	adr_plus
    28ea:	f7 ff 37    	bra       0x28da <adr_plus>

000028ec <alt_dep>:
;		
alt_dep:
	mov	[w9],w2		; old value
    28ec:	19 01 78    	mov.w     [w9], w2
	call	write12		; *** write new pgm word
    28ee:	04 29 02    	call      0x2904 <write12>
    28f0:	00 00 00 
	mov	#Rom+0x1FFC,w1	; end of Program Memory - 2
    28f2:	c1 ff 23    	mov.w     #0x3ffc, w1

000028f4 <train1>:
train1:
	cp	w9,w1		; w9=current program pointer (non-incremented)
    28f4:	01 48 e1    	cp.w      w9, w1
	bra	nc,1f
    28f6:	02 00 39    	bra       NC, 0x28fc <L119>
	mov	w2,[++w1]
    28f8:	82 28 78    	mov.w     w2, [++w1]
	bra	adr_plus	; train finished
    28fa:	ef ff 37    	bra       0x28da <adr_plus>

000028fc <L119>:
1:
	mov	[w1++],w0	; w0 = contents
    28fc:	31 00 78    	mov.w     [w1++], w0
	mov	w0,[w1--]
    28fe:	80 10 78    	mov.w     w0, [w1--]
	dec2	w1,w1
    2900:	81 80 e9    	dec2.w    w1, w1
	bra	train1
    2902:	f8 ff 37    	bra       0x28f4 <train1>

00002904 <write12>:
;		
write12:
	mov	Opcode,w0
    2904:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    2906:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    2908:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    290a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    290c:	26 09 b7    	ior.w     0x926, WREG
	mov	w0,[w9]		; write program word
    290e:	80 0c 78    	mov.w     w0, [w9]
	return
    2910:	00 00 06    	return    

00002912 <alt_plus_pgm>:
;		
alt_plus_pgm:
	btss	KeyRotors+4,#0	; it's -ADDR debouncer
    2912:	82 09 ae    	btss.b    0x982, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    2914:	08 00 37    	bra       0x2926 <alt_both_pgm>
	call	find_last
    2916:	40 19 02    	call      0x1940 <find_last>
    2918:	00 00 00 
	bra	pgm_farm
    291a:	b2 ff 37    	bra       0x2880 <pgm_farm>

0000291c <alt_minus_pgm>:
;		
alt_minus_pgm:
	btss	KeyRotors+6,#0	; it's ADDR+ debouncer
    291c:	84 09 ae    	btss.b    0x984, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    291e:	03 00 37    	bra       0x2926 <alt_both_pgm>
	clr	Stack
    2920:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w9
    2922:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    2924:	ad ff 37    	bra       0x2880 <pgm_farm>

00002926 <alt_both_pgm>:
;				; "go addr 0" test	
alt_both_pgm:			; ALT both pressed
	mov	KeyRotors+0,w0
    2926:	f0 4b 80    	mov.w     0x97e, w0
	and	KeyRotors+2,WREG
    2928:	80 09 b6    	and.w     0x980, WREG
	mov	#KeyRotors+8,w1
    292a:	61 98 20    	mov.w     #0x986, w1
	mov	#14,w2
    292c:	e2 00 20    	mov.w     #0xe, w2

0000292e <L120>:
1:
	and	w0,[w1++],w0
    292e:	31 00 60    	and.w     w0, [w1++], w0
	dec	w2,w2
    2930:	02 01 e9    	dec.w     w2, w2
	bra	nz,1b
    2932:	fd ff 3a    	bra       NZ, 0x292e <L120>
	btss	w0,#0
    2934:	00 00 a6    	btss.w    w0, #0x0
	bra	pgm_farm	; some other key is pressed, ignore command
    2936:	a4 ff 37    	bra       0x2880 <pgm_farm>
; erase all data memory
	call	clr_ram
    2938:	d6 10 02    	call      0x10d6 <clr_ram>
    293a:	00 00 00 
	clr	Stack
    293c:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    293e:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    2940:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    2942:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    2944:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    2946:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    2948:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    294a:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    294c:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    294e:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    2950:	f8 27 02    	call      0x27f8 <rxtx_to_rxtxpos>
    2952:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    2954:	c4 27 02    	call      0x27c4 <set_U1BRG>
    2956:	00 00 00 
; erase all program memory
	clr	Stack
    2958:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w0
    295a:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x01000-1
    295c:	ff 0f 09    	repeat    #0xfff
	clr	[w0++]		; clr Rom
    295e:	00 18 eb    	clr.w     [w0++]
	clr.b	Page
    2960:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    2962:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    2964:	8d ff 37    	bra       0x2880 <pgm_farm>

00002966 <general_pgm_5>:

general_pgm_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    2966:	34 14 02    	call      0x1434 <general_key_3O>
    2968:	00 00 00 
	bra	pgm_noread
    296a:	8c ff 37    	bra       0x2884 <pgm_noread>

0000296c <read12>:
; ------------------------------
read12:
	mov	[w9],w0
    296c:	19 00 78    	mov.w     [w9], w0
	lsr	w0,#8,w1
    296e:	c8 00 de    	lsr.w     w0, #0x8, w1
	mov	w1,Opcode
    2970:	11 49 88    	mov.w     w1, 0x922
	lsr	w0,#4,w2
    2972:	44 01 de    	lsr.w     w0, #0x4, w2
	and	w2,#0x0F,w2
    2974:	6f 01 61    	and.w     w2, #0xf, w2
	mov	w2,OperX
    2976:	22 49 88    	mov.w     w2, 0x924
	and	w0,#0x0F,w0
    2978:	6f 00 60    	and.w     w0, #0xf, w0
	mov	w0,OperY
    297a:	30 49 88    	mov.w     w0, 0x926
	return
    297c:	00 00 06    	return    

0000297e <leave_pgm_ept>:

; -------------------------------------------------------------------------------

leave_pgm_ept:
; save PGM params
	mov	w9,PgmTempPMAddr ; PC
    297e:	29 4b 88    	mov.w     w9, 0x964
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    2980:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	alu_ept
    2982:	b2 f3 37    	bra       0x10e8 <alu_ept>
	bra	run_ept
    2984:	0f f8 37    	bra       0x19a4 <run_ept>

00002986 <T1Int>:
;***********************************************************************************
;****************************       T1 INTERRUPT       *****************************
;***********************************************************************************
T1Int:				; TIMER1 int, display & kbd 3.2 KHz
	push.s			; \
    2986:	00 a0 fe    	push.s    
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    2988:	0a c8 bf    	mov.b     0x80a, WREG
	btsc	WrFlags,#1	; I/O port select
    298a:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    298c:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    298e:	7a e6 b7    	mov.b     WREG, 0x67a
; split interrupt Dimmer timing to two timings (to give a total of 514)
	mov.b	Dimmer,WREG
    2990:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w0
    2992:	00 80 fb    	ze        w0, w0
	btsc	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    2994:	dd a9 af    	btsc.b    0x9dd, #0x5
	bra	aux_int		; aux_int only turns off LEDs, for dimming
    2996:	0e 04 37    	bra       0x31b4 <aux_int>
	bset	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    2998:	dd a9 a8    	bset.b    0x9dd, #0x5
; calculate exponential dimmer step
	mul.uu	w0,w0,w2	; w2 =   0,   1,   4,   9,  16...196, 225
    299a:	00 01 b8    	mul.uu    w0, w0, w2
	cp0	w2
    299c:	02 00 e0    	cp0.w     w2
	ifnz
    299e:	42 20 ae    	btss.b    0x42, #0x1
	add	#5,w2		; w2 =   0,   6,   9,  14,  21...201, 230
    29a0:	52 00 b0    	add.w     #0x5, w2
	add	#5,w2		; w2 =   5,  11,  14,  19,  26...206, 235
    29a2:	52 00 b0    	add.w     #0x5, w2
	sl	w2,w2		; w2 =  10,  22,  28,  38,  52...412, 470
    29a4:	02 01 d0    	sl.w      w2, w2
; mov #300,w2 ;(samo za snimanje 60 fps)
	mov	w2,PR1
    29a6:	92 0c 88    	mov.w     w2, 0x192
	mov	w2,PR1copy
    29a8:	12 4e 88    	mov.w     w2, 0x9c2
; automatic Leds and Matrix off when ALT pressed
	  mov	  #0b0011,w0
    29aa:	30 00 20    	mov.w     #0x3, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    29ac:	dc c9 af    	btsc.b    0x9dc, #0x6
	  and.b	  WrFlags
    29ae:	f3 68 b6    	and.b     0x8f3
; if 10 minutes countdown=0 then go to sleep
	inc	BlinkCount	; +
    29b0:	7c 29 ec    	inc.w     0x97c
	  btsc	  Flag,#14	  ; dim down in progress?
    29b2:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  count625
    29b4:	0e 00 37    	bra       0x29d2 <count625>
	  btsc	  Flag,#15	  ; dim up in progress?
    29b6:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  count625
    29b8:	0c 00 37    	bra       0x29d2 <count625>
	mov	BlinkCount,w0
    29ba:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x3F,w0	; 4 KHz / 0x03F = 62.5 Hz
    29bc:	f0 03 b2    	and.w     #0x3f, w0
	  ifz
    29be:	42 20 af    	btsc.b    0x42, #0x1
	  dec	  AutoOff_Hi	  ; 62.5 Hz decrement
    29c0:	b6 29 ed    	dec.w     0x9b6
	  bra	  nz,count625
    29c2:	07 00 3a    	bra       NZ, 0x29d2 <count625>
; if AutoOff_Hi started from 37500, then 10 minutes here
	  mov	  #37500,w0
    29c4:	c0 27 29    	mov.w     #0x927c, w0
	  mov	  w0,AutoOff_Hi	  ; new 10 min cycle started
    29c6:	b0 4d 88    	mov.w     w0, 0x9b6
; decrement 10 minutes countdown, if=0 then go to sleep 
	  dec.b	  AutoOff
    29c8:	f9 68 ed    	dec.b     0x8f9
	  bra	  nz,count625
    29ca:	03 00 3a    	bra       NZ, 0x29d2 <count625>
	  mov.b	  Dimmer,WREG
    29cc:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    29ce:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down request (AutoOff patience counter expired)
    29d0:	dd c9 a8    	bset.b    0x9dd, #0x6

000029d2 <count625>:
count625:
; inc main multiplex pointer
	inc	RowScan,WREG	; +
    29d2:	78 09 ec    	inc.w     0x978, WREG
	and	#0x0F,w0
    29d4:	f0 00 b2    	and.w     #0xf, w0
	mov	w0,RowScan	; RowScan = 0000...1111
    29d6:	c0 4b 88    	mov.w     w0, 0x978
; anode off
	clr.b	LATC		; LED anodes off
    29d8:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; LED anodes off
    29da:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode column
    29dc:	8f 06 a9    	bclr.b    0x68f, #0x0
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    29de:	dd 89 a9    	bclr.b    0x9dd, #0x4
; decoder service
	sl	w0,#7,w1	; RowScan 3, 2, 1, 0 ---> A10, A9, A8, A7
    29e0:	c7 00 dd    	sl.w      w0, #0x7, w1
	btsc	LATA,#1		; LATA,#1 is output for SAO (if it's not Tx)...
    29e2:	66 26 af    	btsc.b    0x666, #0x1
	bset	w1,#1		; ...restore it
    29e4:	01 10 a0    	bset.w    w1, #0x1
	mov	w1,LATA		; set decoder 74HC138 inputs
    29e6:	31 33 88    	mov.w     w1, 0x666
; A16 History/standard mode select
	  mov	  History_A16,w3
    29e8:	63 48 80    	mov.w     0x90c, w3
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    29ea:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	A16,w3
    29ec:	73 4d 80    	mov.w     0x9ae, w3
; main branch
	bra	w0		; main branch (w0=0...15)
    29ee:	00 60 01    	bra       w0
;...
	bra	cathode0
    29f0:	0f 00 37    	bra       0x2a10 <cathode0>
	bra	cathode1
    29f2:	3e 00 37    	bra       0x2a70 <cathode1>
	bra	cathode2
    29f4:	60 00 37    	bra       0x2ab6 <cathode2>
	bra	cathode3
    29f6:	7d 00 37    	bra       0x2af2 <cathode3>
	bra	cathode4
    29f8:	a6 00 37    	bra       0x2b46 <cathode4>
	bra	cathode5
    29fa:	ca 00 37    	bra       0x2b90 <cathode5>
	bra	cathode6
    29fc:	ee 00 37    	bra       0x2bda <cathode6>
	bra	cathode7
    29fe:	16 01 37    	bra       0x2c2c <cathode7>
	bra	cathode8
    2a00:	7d 01 37    	bra       0x2cfc <cathode8>
	bra	cathode9
    2a02:	b7 01 37    	bra       0x2d72 <cathode9>
	bra	cathode10
    2a04:	f4 01 37    	bra       0x2dee <cathode10>
	bra	cathode11
    2a06:	31 02 37    	bra       0x2e6a <cathode11>
	bra	cathode12
    2a08:	74 02 37    	bra       0x2ef2 <cathode12>
	bra	cathode13
    2a0a:	b1 02 37    	bra       0x2f6e <cathode13>
	bra	cathode14
    2a0c:	ee 02 37    	bra       0x2fea <cathode14>
	bra	cathode15
    2a0e:	3e 03 37    	bra       0x308c <cathode15>

00002a10 <cathode0>:

;------------------------------- MACRO -------------------------------
; Important Note for this Macro: 
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These 
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons, 
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and 
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every 
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second 
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.
.macro	keytest	keynum,AllowRpt1,AllowRpt2
; key connected to PORTA,#3 input
	btsc	BlinkCount,#4
	bra	6f		; if odd then skip
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2
	btsc	PORTA,#3
	bset	KeyRotors+\keynum*2,#0
	inc2	KeyRotors+\keynum*2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum,w0
	mov	w0,Just		; just pressed
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt1
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
6:
; key connected to PORTA,#4 input
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2+2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2+2
	btsc	PORTA,#4
	bset	KeyRotors+\keynum*2+2,#0
	inc2	KeyRotors+\keynum*2+2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum+1,w0
	mov	w0,Just		; code of "just pressed" key
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt2
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
7:
	and	Anypress	; bit 0 will be reset if any key still depressed
8:
.endm

;------------------------------- OPCODE BAR --------------------------- cathode 0
cathode0:
; spec test if any key pressed (needed for autorepeat)
	btsc	BlinkCount,#4
    2a10:	7c 89 af    	btsc.b    0x97c, #0x4
	bra	cont_cathode0	; test must be performed in every 2nd pass
    2a12:	0f 00 37    	bra       0x2a32 <cont_cathode0>
	btsts	Anypress,#0	; test AND SET bit 0 (will be Z if any key pressed)
    2a14:	a8 09 ac    	btsts.b   0x9a8, #0x0
	bra	nz,NoAutoRpt	; if no key was pressed
    2a16:	0c 00 3a    	bra       NZ, 0x2a30 <NoAutoRpt>
; at least 1 key was pressed
	btsc	AutorptCount,#15
    2a18:	ab e9 af    	btsc.b    0x9ab, #0x7
	bra	cont_cathode0	; if it's not set for counting (it's negative)
    2a1a:	0b 00 37    	bra       0x2a32 <cont_cathode0>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a1c:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	cont_cathode0	; if ALT pressed
    2a1e:	09 00 37    	bra       0x2a32 <cont_cathode0>
	dec	AutorptCount
    2a20:	aa 29 ed    	dec.w     0x9aa
	bra	nz,cont_cathode0 ; if not yet 0x0000
    2a22:	07 00 3a    	bra       NZ, 0x2a32 <cont_cathode0>
; AutorptCount just reached 0, reinitialize autorpt process
	mov	#KeyRotors,w0
    2a24:	e0 97 20    	mov.w     #0x97e, w0
	repeat	#18-1
    2a26:	11 00 09    	repeat    #0x11
	setm	[w0++]		; reenable "just" condition
    2a28:	00 98 eb    	setm.w    [w0++]
	mov	#autorpt_next,w0
    2a2a:	f0 00 20    	mov.w     #0xf, w0
	mov	w0,AutorptCount	; reinitialize autorpt process
    2a2c:	50 4d 88    	mov.w     w0, 0x9aa
	bra	cont_cathode0
    2a2e:	01 00 37    	bra       0x2a32 <cont_cathode0>

00002a30 <NoAutoRpt>:
NoAutoRpt:
	setm	AutorptCount	; forced -1 (only #autorpt_start allowed for writing)
    2a30:	aa a9 ef    	setm.w    0x9aa

00002a32 <cont_cathode0>:
cont_cathode0:
; extra anode 16
	btsc	w3,#b_clk_sch	; Extra bit 16: CLOCK (schematics) 
    2a32:	03 00 a7    	btsc.w    w3, #0x0
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2a34:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2a36:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2a38:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2a3a:	02 00 32    	bra       Z, 0x2a40 <L36>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a3c:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt0		; IF ALT pressed
    2a3e:	0e 00 37    	bra       0x2a5c <alt0>

00002a40 <L36>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2a40:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2a42:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#8,w1	  ; HISTORY mode
    2a44:	c8 08 de    	lsr.w     w1, #0x8, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2a46:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	Opcode,w1	; ***
    2a48:	11 49 80    	mov.w     0x922, w1
	mov	#0,w0
    2a4a:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2a4c:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#0	; 0 set = column Opcode blinks
    2a4e:	e0 09 ae    	btss.b    0x9e0, #0x0
	mov	#1,w0
    2a50:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a52:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2a54:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2a56:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2a58:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0a
    2a5a:	07 00 37    	bra       0x2a6a <go_disp0a>

00002a5c <alt0>:
alt0:				; IF ALU pressed
	mov.b	Sync,WREG	; if Mode > 0 (SS Run Pgm)
    2a5c:	f2 c8 bf    	mov.b     0x8f2, WREG
	    cp0	    Mode
    2a5e:	76 09 e2    	cp0.w     0x976
	    ifz
    2a60:	42 20 af    	btsc.b    0x42, #0x1
	    mov.b   Dimmer,WREG	; if Mode = 0 (ALU)
    2a62:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w1
    2a64:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2a66:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a68:	01 00 dd    	sl.w      w0, w1, w0

00002a6a <go_disp0a>:
go_disp0a:
	btsc	Flag,#3		; #3 self-check mode
    2a6a:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column1,w0
    2a6c:	40 4e 80    	mov.w     0x9c8, w0
	bra	disp_w0_noblank
    2a6e:	98 03 37    	bra       0x31a0 <disp_w0_noblank>

00002a70 <cathode1>:
;------------------------------- OPERAND X BAR ------------------------ cathode 1
cathode1:
; extra anode 16
	btsc	w3,#b_exr	; Extra bit 16: EXR (instruction set)
    2a70:	03 10 a7    	btsc.w    w3, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2a72:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2a74:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2a76:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2a78:	02 00 32    	bra       Z, 0x2a7e <L37>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2a7a:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt1		; IF ALT pressed
    2a7c:	0f 00 37    	bra       0x2a9c <alt1>

00002a7e <L37>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2a7e:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2a80:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#4,w1	  ; HISTORY mode
    2a82:	c4 08 de    	lsr.w     w1, #0x4, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2a84:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperX,w1	; ***
    2a86:	21 49 80    	mov.w     0x924, w1
	and	#0x0F,w1
    2a88:	f1 00 b2    	and.w     #0xf, w1
	mov	#0,w0
    2a8a:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2a8c:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#1	; 1 set = column Oper X blinks
    2a8e:	e0 29 ae    	btss.b    0x9e0, #0x1
	mov	#1,w0
    2a90:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2a92:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2a94:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2a96:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2a98:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0b
    2a9a:	0a 00 37    	bra       0x2ab0 <go_disp0b>

00002a9c <alt1>:
alt1:			; IF ALT pressed
	mov.b	Speed,WREG
    2a9c:	f1 c8 bf    	mov.b     0x8f1, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2a9e:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Speed,WREG
    2aa0:	14 c9 bf    	mov.b     0x914, WREG
	    cp0	    Mode
    2aa2:	76 09 e2    	cp0.w     0x976
	    bra	    nz,1f
    2aa4:	02 00 3a    	bra       NZ, 0x2aaa <L121>
	    mov.b   SerCtrl,WREG	; if Mode = 0 (ALU)
    2aa6:	f5 c8 bf    	mov.b     0x8f5, WREG
	    bclr.b  w0,#3		; spec case: Buad Rate takes only 3 bits
    2aa8:	00 34 a1    	bclr.b    w0, #0x3

00002aaa <L121>:
1:
	ze	w0,w1
    2aaa:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2aac:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2aae:	01 00 dd    	sl.w      w0, w1, w0

00002ab0 <go_disp0b>:
go_disp0b:
	btsc	Flag,#3		; #3 self-check mode
    2ab0:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column2,w0
    2ab2:	50 4e 80    	mov.w     0x9ca, w0
	bra	disp_w0
    2ab4:	73 03 37    	bra       0x319c <disp_w0>

00002ab6 <cathode2>:
;------------------------------- OPERAND Y BAR ------------------------ cathode 2
cathode2:
; extra anode 16
	btsc	w3,#b_clk_key	; Extra bit 16: CLOCK (schematic) 
    2ab6:	03 20 a7    	btsc.w    w3, #0x2
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ab8:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2aba:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2abc:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2abe:	02 00 32    	bra       Z, 0x2ac4 <L38>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2ac0:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt2pressed	; IF ALT pressed
    2ac2:	0b 00 37    	bra       0x2ada <alt2pressed>

00002ac4 <L38>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2ac4:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2ac6:	91 00 78    	mov.w     [w1], w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2ac8:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperY,w1
    2aca:	31 49 80    	mov.w     0x926, w1
	and	#0x0F,w1
    2acc:	f1 00 b2    	and.w     #0xf, w1
	mov	#1,w0
    2ace:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2ad0:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2ad2:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2ad4:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2ad6:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0c
    2ad8:	09 00 37    	bra       0x2aec <go_disp0c>

00002ada <alt2pressed>:
alt2pressed:		; IF DATA IN pressed
	mov.b	Page,WREG
    2ada:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2adc:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Page,WREG
    2ade:	10 c9 bf    	mov.b     0x910, WREG
	    cp0	    Mode
    2ae0:	76 09 e2    	cp0.w     0x976
	    ifz
    2ae2:	42 20 af    	btsc.b    0x42, #0x1
	    mov	    FlashAddr,w0 ; Alt pressed in ALU mode: get FlashAddr instead of OperY
    2ae4:	00 4e 80    	mov.w     0x9c0, w0
	ze	w0,w1
    2ae6:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2ae8:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2aea:	01 00 dd    	sl.w      w0, w1, w0

00002aec <go_disp0c>:
go_disp0c:
	btsc	Flag,#3		; #3 self-check mode
    2aec:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column3,w0
    2aee:	60 4e 80    	mov.w     0x9cc, w0
	bra	disp_w0
    2af0:	55 03 37    	bra       0x319c <disp_w0>

00002af2 <cathode3>:
;---------------------- SOURCE, PROG MEM ADDR ------------------------ cathode 3
cathode3:
; ALT key debouncer
	sl	KeyRotors+38
    2af2:	a4 29 d4    	sl.w      0x9a4
	btsc	PORTA,#2
    2af4:	64 46 af    	btsc.b    0x664, #0x2
	bset	KeyRotors+38,#0
    2af6:	a4 09 a8    	bset.b    0x9a4, #0x0
	inc.b	KeyRotors+38,WREG ; test if keynum = 0bxxxxxxxx11111111
    2af8:	a4 49 ec    	inc.b     0x9a4, WREG
	ifz
    2afa:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#6		; #6 set if ALT pressed (debounced)
    2afc:	dc c9 a9    	bclr.b    0x9dc, #0x6
	ifz
    2afe:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b00:	fc 68 a9    	bclr.b    0x8fc, #0x3
	cp0.b	KeyRotors+38	; test if keynum = 0bxxxxxxxx00000000
    2b02:	a4 49 e2    	cp0.b     0x9a4
	ifz
    2b04:	42 20 af    	btsc.b    0x42, #0x1
	bset	Flag,#6		; #6 set if ALT pressed (debounced)
    2b06:	dc c9 a8    	bset.b    0x9dc, #0x6
	ifz
    2b08:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b0a:	fc 68 a9    	bclr.b    0x8fc, #0x3
	btsc	Flag,#3		; #3 self-check mode
    2b0c:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in3		; no IN in self-check mode
    2b0e:	07 00 37    	bra       0x2b1e <no_in3>
; IN register service
	mov.b	PORTB,WREG
    2b10:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2b12:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2b14:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2b16:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2b18:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2b1a:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2b1c:	fb e8 b7    	mov.b     WREG, 0x8fb

00002b1e <no_in3>:
no_in3:
; extra anode 16
	btsc	w3,#b_noclk_sch ; Extra bit 16: INV CLOCK (schematic)
    2b1e:	03 30 a7    	btsc.w    w3, #0x3
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b20:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Rom,w1
    2b22:	01 00 22    	mov.w     #0x2000, w1
	  mov	  History_w9,w0	  ; HISTORY mode
    2b24:	10 48 80    	mov.w     0x902, w0
	  sub	  w0,w1,w0	  ; HISTORY mode
    2b26:	01 00 50    	sub.w     w0, w1, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    2b28:	dc c9 af    	btsc.b    0x9dc, #0x6
	  sl	  History_Ptr,WREG ; if ALT in History mode, then History_Ptr displayed
    2b2a:	1e 09 d4    	sl.w      0x91e, WREG
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b2c:	dc a9 ae    	btss.b    0x9dc, #0x5
	sub	w9,w1,w0
    2b2e:	01 80 54    	sub.w     w9, w1, w0
	lsr	w0,w1		; w1 = PC actual value
    2b30:	80 00 d1    	lsr.w     w0, w1
	  mov	  History_w12,w0  ; HISTORY mode
    2b32:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#12,w0	  ; HISTORY mode
    2b34:	4c 00 dd    	sl.w      w0, #0xc, w0
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b36:	dc a9 ae    	btss.b    0x9dc, #0x5
	sl	w12,#12,w0	; w12 = SOURCE (OperY) contents
    2b38:	4c 60 dd    	sl.w      w12, #0xc, w0
	    mov	    #0x0FFF,w3	    ; * * * * BUG FIX SEPT 21 2022
    2b3a:	f3 ff 20    	mov.w     #0xfff, w3
	    and	    w3,w1,w1	    ; * * * * BUG FIX SEPT 21 2022
    2b3c:	81 80 61    	and.w     w3, w1, w1
;	cp0	Mode
;	ifnz			; ProgMemAddr (w9) is not displayed in ALU mode
	ior	w1,w0,w0
    2b3e:	00 80 70    	ior.w     w1, w0, w0
	btsc	Flag,#3		; #3 self-check mode
    2b40:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row3,w0
    2b42:	70 4e 80    	mov.w     0x9ce, w0
	bra	disp_w0_noblank
    2b44:	2d 03 37    	bra       0x31a0 <disp_w0_noblank>

00002b46 <cathode4>:
;------------------------------- Vflag, ADDER, DEST ------------------- cathode 4
cathode4:
; extra anode 16
	btsc	w3,#b_data_inv	; Extra bit 16: DATA INVERSE (schematic) 
    2b46:	03 40 a7    	btsc.w    w3, #0x4
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b48:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b4a:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat4	  ; if HISTORY mode
    2b4c:	19 00 37    	bra       0x2b80 <History_cat4>
	mov	Vflag,w0
    2b4e:	80 49 80    	mov.w     0x930, w0
	btss	Stack,#2
    2b50:	2a 49 ae    	btss.b    0x92a, #0x2
	bra	1f
    2b52:	03 00 37    	bra       0x2b5a <L122>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2b54:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2b56:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2b58:	00 30 a0    	bset.w    w0, #0x3

00002b5a <L122>:
1:
	sl	w0,#8,w1	; 0000 SVVV 0000 0000
    2b5a:	c8 00 dd    	sl.w      w0, #0x8, w1
; Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2b5c:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2b5e:	00 80 75    	ior.w     w11, w0, w0

00002b60 <skr_cat4>:
skr_cat4:
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    2b60:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    2b62:	a2 4e 23    	mov.w     #0x34ea, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    2b64:	02 00 40    	add.w     w0, w2, w0
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2b66:	03 50 a7    	btsc.w    w3, #0x5
	inc2	w0,w0		; if Cin set
    2b68:	00 80 e8    	inc2.w    w0, w0
	push	TBLPAG	   ; \\
    2b6a:	54 00 f8    	push      0x54
	clr	TBLPAG
    2b6c:	54 20 ef    	clr.w     0x54
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    2b6e:	10 00 ba    	tblrdl.w  [w0], w0
	pop	TBLPAG	   ; //
    2b70:	54 00 f9    	pop       0x54
	and	#0x0FF,w0	; 0000 0000 AAAA CCCC
    2b72:	f0 0f b2    	and.w     #0xff, w0
	ior	w0,w1,w0	; 0000 SVVV AAAA CCCC
    2b74:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SVVV AAAA CCCC 0000
    2b76:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w11,w0	; SVVV AAAA CCCC DDDD (w11 = dest contents)
    2b78:	0b 00 70    	ior.w     w0, w11, w0
	btsc	Flag,#3		; #3 self-check mode
    2b7a:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row4,w0
    2b7c:	80 4e 80    	mov.w     0x9d0, w0
	bra	disp_w0
    2b7e:	0e 03 37    	bra       0x319c <disp_w0>

00002b80 <History_cat4>:
History_cat4:			  ; HISTORY mode ............................
	  mov	  History_Vflag,w0
    2b80:	b0 48 80    	mov.w     0x916, w0
	  btsc	  History_Stack,#2
    2b82:	1c 49 af    	btsc.b    0x91c, #0x2
	  bset	  w0,#3		  ; Stack LED bit
    2b84:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#8,w1	  ; 0000 SVVV 0000 0000
    2b86:	c8 00 dd    	sl.w      w0, #0x8, w1
  ; Adder Sum & Carry
	  mov	  History_w12,w0
    2b88:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#4,w0	  ; w0 = source × 16
    2b8a:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w11,WREG ; w0 = source × 16 + dest
    2b8c:	04 09 b7    	ior.w     0x904, WREG
	  bra	  skr_cat4
    2b8e:	e8 ff 37    	bra       0x2b60 <skr_cat4>

00002b90 <cathode5>:
;-------------------------------- Zflag, OR, AND, XOR ----------------- cathode 5
cathode5:
; extra anode 16
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2b90:	03 50 a7    	btsc.w    w3, #0x5
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b92:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b94:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat5
    2b96:	12 00 37    	bra       0x2bbc <History_cat5>
	mov	Zflag,w0	; 0000 0000 0000 0ZZZ
    2b98:	70 49 80    	mov.w     0x92e, w0
	btss	Stack,#1
    2b9a:	2a 29 ae    	btss.b    0x92a, #0x1
	bra	1f
    2b9c:	03 00 37    	bra       0x2ba4 <L123>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2b9e:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2ba0:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; 0000 0000 0000 SZZZ
    2ba2:	00 30 a0    	bset.w    w0, #0x3

00002ba4 <L123>:
1:
	sl	w0,#4,w0	; 0000 0000 SZZZ 0000
    2ba4:	44 00 dd    	sl.w      w0, #0x4, w0
; Logic OR, AND and XOR
	ior	w11,w12,w1
    2ba6:	8c 80 75    	ior.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 0000 SZZZ OOOO
    2ba8:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; 0000 SZZZ OOOO 0000
    2baa:	44 00 dd    	sl.w      w0, #0x4, w0
	and	w11,w12,w1
    2bac:	8c 80 65    	and.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 SZZZ OOOO AAAA
    2bae:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SZZZ OOOO AAAA 0000
    2bb0:	44 00 dd    	sl.w      w0, #0x4, w0
	xor	w11,w12,w1
    2bb2:	8c 80 6d    	xor.w     w11, w12, w1
	ior	w0,w1,w0	; SZZZ OOOO AAAA XXXX
    2bb4:	01 00 70    	ior.w     w0, w1, w0
	btsc	Flag,#3		; #3 self-check mode
    2bb6:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row5,w0
    2bb8:	90 4e 80    	mov.w     0x9d2, w0
	bra	disp_w0
    2bba:	f0 02 37    	bra       0x319c <disp_w0>

00002bbc <History_cat5>:
History_cat5:			  ; HISTORY mode ............................
	  mov	  History_Zflag,w0 ; 0000 0000 0000 0ZZZ
    2bbc:	c0 48 80    	mov.w     0x918, w0
	  btsc	  History_Stack,#1
    2bbe:	1c 29 af    	btsc.b    0x91c, #0x1
	  bset	  w0,#3		  ; 0000 0000 0000 SZZZ
    2bc0:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; 0000 0000 SZZZ 0000
    2bc2:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Logic OR, AND and XOR
	  mov	  History_w11,w2
    2bc4:	22 48 80    	mov.w     0x904, w2
	  mov	  History_w12,w3
    2bc6:	33 48 80    	mov.w     0x906, w3
	  ior	  w2,w3,w1
    2bc8:	83 00 71    	ior.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 0000 SZZZ OOOO
    2bca:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; 0000 SZZZ OOOO 0000
    2bcc:	44 00 dd    	sl.w      w0, #0x4, w0
	  and	  w2,w3,w1
    2bce:	83 00 61    	and.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 SZZZ OOOO AAAA
    2bd0:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; SZZZ OOOO AAAA 0000
    2bd2:	44 00 dd    	sl.w      w0, #0x4, w0
	  xor	  w2,w3,w1
    2bd4:	83 00 69    	xor.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; SZZZ OOOO AAAA XXXX
    2bd6:	01 00 70    	ior.w     w0, w1, w0
	  bra	  disp_w0
    2bd8:	e1 02 37    	bra       0x319c <disp_w0>

00002bda <cathode6>:
;-------------------------------- Cflag, ACCU OUT/TEMP/IN ------------- cathode 6
cathode6:
; test ON-OFF key
	sl	KeyRotors+36
    2bda:	a2 29 d4    	sl.w      0x9a2
	btsc	PORTC,#9
    2bdc:	8d 26 af    	btsc.b    0x68d, #0x1
	bset	KeyRotors+36,#0
    2bde:	a2 09 a8    	bset.b    0x9a2, #0x0
	inc2	KeyRotors+36,WREG ; test if keynum = 0bxxxxxxxx11111110
    2be0:	a2 89 ec    	inc2.w    0x9a2, WREG
	bra	nz,1f
    2be2:	07 00 3a    	bra       NZ, 0x2bf2 <L124>
; ON-OFF pressed
	  btsc	  Flag,#14	  ; dim down in progress?
    2be4:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  1f
    2be6:	05 00 37    	bra       0x2bf2 <L124>
	  btsc	  Flag,#15	  ; dim up in progress?
    2be8:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  1f
    2bea:	03 00 37    	bra       0x2bf2 <L124>
	  mov.b	  Dimmer,WREG
    2bec:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    2bee:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down MAIN REQUEST (key ON/OFF pressed)
    2bf0:	dd c9 a8    	bset.b    0x9dd, #0x6

00002bf2 <L124>:
1:
; extra anode 16
	btsc	w3,#b_cena	; Extra bit 16: C ENABLE (schematic) 
    2bf2:	03 60 a7    	btsc.w    w3, #0x6
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2bf4:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2bf6:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat6
    2bf8:	0f 00 37    	bra       0x2c18 <History_cat6>
	mov	Cflag,w0
    2bfa:	60 49 80    	mov.w     0x92c, w0
	btss	Stack,#0
    2bfc:	2a 09 ae    	btss.b    0x92a, #0x0
	bra	1f
    2bfe:	03 00 37    	bra       0x2c06 <L125>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2c00:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2c02:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2c04:	00 30 a0    	bset.w    w0, #0x3

00002c06 <L125>:
1:
	sl	w0,#4,w0	; xxxx xxxx SCCC 0000
    2c06:	44 00 dd    	sl.w      w0, #0x4, w0
; Accumulator OUT / TEMP / IN
	ior	w0,w14,w0	; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2c08:	0e 00 70    	ior.w     w0, w14, w0
	sl	w0,#4,w0	; xxxx SCCC OOOO 0000
    2c0a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	Atemp,WREG	; xxxx SCCC OOOO TTTT
    2c0c:	28 09 b7    	ior.w     0x928, WREG
	sl	w0,#4,w0	; SCCC OOOO TTTT 0000
    2c0e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w13,w0	; SCCC OOOO TTTT IIII (Accu In is w13)
    2c10:	0d 00 70    	ior.w     w0, w13, w0
	btsc	Flag,#3		; #3 self-check mode
    2c12:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row6,w0
    2c14:	a0 4e 80    	mov.w     0x9d4, w0
	bra	disp_w0
    2c16:	c2 02 37    	bra       0x319c <disp_w0>

00002c18 <History_cat6>:
History_cat6:			  ; HISTORY mode ............................
	  mov	  History_Cflag,w0
    2c18:	d0 48 80    	mov.w     0x91a, w0
	  btsc	  History_Stack,#0
    2c1a:	1c 09 af    	btsc.b    0x91c, #0x0
	  bset	  w0,#3		  ; Stack LED bit
    2c1c:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; xxxx xxxx SCCC 0000
    2c1e:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Accumulator OUT / TEMP / IN
	  ior	  History_w14,WREG ; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2c20:	0a 09 b7    	ior.w     0x90a, WREG
	  sl	  w0,#4,w0	  ; xxxx SCCC OOOO 0000
    2c22:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_Atemp,WREG ; xxxx SCCC OOOO TTTT
    2c24:	0e 09 b7    	ior.w     0x90e, WREG
	  sl	  w0,#4,w0	  ; SCCC OOOO TTTT 0000
    2c26:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w13,WREG ; SCCC OOOO TTTT IIII (Accu In is w13)
    2c28:	08 09 b7    	ior.w     0x908, WREG
	  bra	  disp_w0
    2c2a:	b8 02 37    	bra       0x319c <disp_w0>

00002c2c <cathode7>:
;-------------------------------- PAGE, OPCODE, OPERX, OPERY ---------- cathode 7
cathode7:
; test keys 16, 17
	keytest	16,7,8
    2c2c:	7c 89 af    	btsc.b    0x97c, #0x4
    2c2e:	1a 00 37    	bra       0x2c64 <L66>
    2c30:	9e 29 d4    	sl.w      0x99e
    2c32:	00 c0 2f    	mov.w     #0xfc00, w0
    2c34:	9e 29 b7    	ior.w     0x99e
    2c36:	64 66 af    	btsc.b    0x664, #0x3
    2c38:	9e 09 a8    	bset.b    0x99e, #0x0
    2c3a:	9e 89 ec    	inc2.w    0x99e, WREG
    2c3c:	2d 00 3a    	bra       NZ, 0x2c98 <L73>
    2c3e:	a8 29 b6    	and.w     0x9a8
    2c40:	00 01 20    	mov.w     #0x10, w0
    2c42:	30 4d 88    	mov.w     w0, 0x9a6
    2c44:	40 00 b1    	sub.w     #0x4, w0
    2c46:	42 00 ae    	btss.b    0x42, #0x0
    2c48:	00 00 20    	mov.w     #0x0, w0
    2c4a:	fd e8 b7    	mov.b     WREG, 0x8fd
    2c4c:	dc 29 a8    	bset.b    0x9dc, #0x1
    2c4e:	fc 08 a8    	bset.b    0x8fc, #0x0
    2c50:	f0 00 20    	mov.w     #0xf, w0
    2c52:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2c54:	c0 27 29    	mov.w     #0x927c, w0
    2c56:	b0 4d 88    	mov.w     w0, 0x9b6
    2c58:	ac e9 ae    	btss.b    0x9ac, #0x7
    2c5a:	1f 00 37    	bra       0x2c9a <L84>
    2c5c:	00 05 20    	mov.w     #0x50, w0
    2c5e:	ab e9 af    	btsc.b    0x9ab, #0x7
    2c60:	50 4d 88    	mov.w     w0, 0x9aa
    2c62:	1b 00 37    	bra       0x2c9a <L84>

00002c64 <L66>:
    2c64:	a0 29 d4    	sl.w      0x9a0
    2c66:	00 c0 2f    	mov.w     #0xfc00, w0
    2c68:	a0 29 b7    	ior.w     0x9a0
    2c6a:	64 86 af    	btsc.b    0x664, #0x4
    2c6c:	a0 09 a8    	bset.b    0x9a0, #0x0
    2c6e:	a0 89 ec    	inc2.w    0x9a0, WREG
    2c70:	13 00 3a    	bra       NZ, 0x2c98 <L73>
    2c72:	a8 29 b6    	and.w     0x9a8
    2c74:	10 01 20    	mov.w     #0x11, w0
    2c76:	30 4d 88    	mov.w     w0, 0x9a6
    2c78:	40 00 b1    	sub.w     #0x4, w0
    2c7a:	42 00 ae    	btss.b    0x42, #0x0
    2c7c:	00 00 20    	mov.w     #0x0, w0
    2c7e:	fd e8 b7    	mov.b     WREG, 0x8fd
    2c80:	dc 29 a8    	bset.b    0x9dc, #0x1
    2c82:	fc 08 a8    	bset.b    0x8fc, #0x0
    2c84:	f0 00 20    	mov.w     #0xf, w0
    2c86:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2c88:	c0 27 29    	mov.w     #0x927c, w0
    2c8a:	b0 4d 88    	mov.w     w0, 0x9b6
    2c8c:	ad 09 ae    	btss.b    0x9ad, #0x0
    2c8e:	05 00 37    	bra       0x2c9a <L84>
    2c90:	00 05 20    	mov.w     #0x50, w0
    2c92:	ab e9 af    	btsc.b    0x9ab, #0x7
    2c94:	50 4d 88    	mov.w     w0, 0x9aa
    2c96:	01 00 37    	bra       0x2c9a <L84>

00002c98 <L73>:
    2c98:	a8 29 b6    	and.w     0x9a8

00002c9a <L84>:
; extra anode 16
	btsc	w3,#b_sel	; Extra bit 16: SEL (bin/sel leds) 
    2c9a:	03 70 a7    	btsc.w    w3, #0x7
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2c9c:	dd 89 a8    	bset.b    0x9dd, #0x4
	  btsc	  Flag,#5	; #5 set in HISTORY mode
    2c9e:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat7
    2ca0:	1e 00 37    	bra       0x2cde <History_cat7>
	mov.b	Page,WREG	; xxxx xxxx xxxx PPPP
    2ca2:	f0 c8 bf    	mov.b     0x8f0, WREG
	sl	w0,#4,w0	; xxxx xxxx PPPP 0000
    2ca4:	44 00 dd    	sl.w      w0, #0x4, w0
	mov	Mode,w1
    2ca6:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2ca8:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2caa:	02 00 32    	bra       Z, 0x2cb0 <L39>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2cac:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	Alt7		; IF ALT pressed
    2cae:	06 00 37    	bra       0x2cbc <Alt7>

00002cb0 <L39>:
; anodes 0...15
3:
	ior	Opcode,WREG	; xxxx xxxx PPPP OOOO
    2cb0:	22 09 b7    	ior.w     0x922, WREG
	sl	w0,#4,w0	; xxxx PPPP OOOO 0000
    2cb2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG	; xxxx PPPP OOOO XXXX
    2cb4:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0	; PPPP OOOO XXXX 0000
    2cb6:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; PPPP OOOO XXXX YYYY
    2cb8:	26 09 b7    	ior.w     0x926, WREG
	bra	go_disp0d
    2cba:	07 00 37    	bra       0x2cca <go_disp0d>

00002cbc <Alt7>:
Alt7:			; IF ALT pressed (not history) (Sync Clock Page)
	cp0	Mode
    2cbc:	76 09 e2    	cp0.w     0x976
	bra	z,alt7alu
    2cbe:	08 00 32    	bra       Z, 0x2cd0 <alt7alu>
	ior.b	Sync,WREG	; xxxx xxxx PPPP SSSS
    2cc0:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0	; xxxx PPPP SSSS 0000
    2cc2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG	; xxxx PPPP SSSS SSSS
    2cc4:	f1 48 b7    	ior.b     0x8f1, WREG
	sl	w0,#4,w0	; PPPP SSSS SSSS 0000
    2cc6:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG	; PPPP SSSS SSSS PPPP
    2cc8:	f0 48 b7    	ior.b     0x8f0, WREG

00002cca <go_disp0d>:
go_disp0d:
	btsc	Flag,#3		; #3 self-check mode
    2cca:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row7,w0
    2ccc:	b0 4e 80    	mov.w     0x9d6, w0
	bra	disp_w0
    2cce:	66 02 37    	bra       0x319c <disp_w0>

00002cd0 <alt7alu>:
alt7alu:		; if ALT pressed in ALU mode (Dim Baud Flash)
	ior.b	Dimmer,WREG	; xxxx xxxx PPPP DDDD
    2cd0:	fe 48 b7    	ior.b     0x8fe, WREG
	sl	w0,#4,w0	; xxxx PPPP DDDD 0000
    2cd2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerCtrl,WREG	; xxxx PPPP DDDD EBBB
    2cd4:	f5 48 b7    	ior.b     0x8f5, WREG
	  bclr	  w0,#3		; spec case: Buad Rate takes only 3 bits
    2cd6:	00 30 a1    	bclr.w    w0, #0x3
	sl	w0,#4,w0	; PPPP DDDD 0BBB 0000
    2cd8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	FlashAddr,WREG	; PPPP DDDD 0BBB FFFF
    2cda:	c0 49 b7    	ior.b     0x9c0, WREG
	bra	disp_w0
    2cdc:	5f 02 37    	bra       0x319c <disp_w0>

00002cde <History_cat7>:
History_cat7:			  ; HISTORY mode ............................
	  btsc	  Flag,#6		; #6 set if ALT pressed (debounced)
    2cde:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  History_PageClockDim	; IF ALT pressed
    2ce0:	05 00 37    	bra       0x2cec <History_PageClockDim>
  ; anodes 0...15
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2ce2:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#12,w0		; PPPP 0000 0000 0000
    2ce4:	4c 00 dd    	sl.w      w0, #0xc, w0
	  mov	  History_w9,w1		; Program Memory Address
    2ce6:	11 48 80    	mov.w     0x902, w1
	  ior	  w0,[w1],w0		; PPPP CCCC XXXX YYYY
    2ce8:	11 00 70    	ior.w     w0, [w1], w0
	  bra	  disp_w0
    2cea:	58 02 37    	bra       0x319c <disp_w0>

00002cec <History_PageClockDim>:
History_PageClockDim:
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2cec:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#4,w0		; xxxx xxxx PPPP 0000
    2cee:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  Dimmer,WREG		; xxxx xxxx PPPP SSSS
    2cf0:	fe 48 b7    	ior.b     0x8fe, WREG
	  sl	  w0,#4,w0		; xxxx PPPP SSSS 0000
    2cf2:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Speed,WREG	; xxxx PPPP SSSS CCCC
    2cf4:	14 49 b7    	ior.b     0x914, WREG
	  sl	  w0,#4,w0		; PPPP SSSS CCCC 0000
    2cf6:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Page,WREG	; PPPP SSSS CCCC PPPP
    2cf8:	10 49 b7    	ior.b     0x910, WREG
	  bra	  disp_w0
    2cfa:	50 02 37    	bra       0x319c <disp_w0>

00002cfc <cathode8>:
;-------------------------------- MATRIX 0,1 -------------------------- cathode 8
cathode8:
; test keys 0, 1
	keytest	0,0,1
    2cfc:	7c 89 af    	btsc.b    0x97c, #0x4
    2cfe:	1a 00 37    	bra       0x2d34 <L67>
    2d00:	7e 29 d4    	sl.w      0x97e
    2d02:	00 c0 2f    	mov.w     #0xfc00, w0
    2d04:	7e 29 b7    	ior.w     0x97e
    2d06:	64 66 af    	btsc.b    0x664, #0x3
    2d08:	7e 09 a8    	bset.b    0x97e, #0x0
    2d0a:	7e 89 ec    	inc2.w    0x97e, WREG
    2d0c:	2d 00 3a    	bra       NZ, 0x2d68 <L74>
    2d0e:	a8 29 b6    	and.w     0x9a8
    2d10:	00 00 20    	mov.w     #0x0, w0
    2d12:	30 4d 88    	mov.w     w0, 0x9a6
    2d14:	40 00 b1    	sub.w     #0x4, w0
    2d16:	42 00 ae    	btss.b    0x42, #0x0
    2d18:	00 00 20    	mov.w     #0x0, w0
    2d1a:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d1c:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d1e:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d20:	f0 00 20    	mov.w     #0xf, w0
    2d22:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d24:	c0 27 29    	mov.w     #0x927c, w0
    2d26:	b0 4d 88    	mov.w     w0, 0x9b6
    2d28:	ac 09 ae    	btss.b    0x9ac, #0x0
    2d2a:	1f 00 37    	bra       0x2d6a <L85>
    2d2c:	00 05 20    	mov.w     #0x50, w0
    2d2e:	ab e9 af    	btsc.b    0x9ab, #0x7
    2d30:	50 4d 88    	mov.w     w0, 0x9aa
    2d32:	1b 00 37    	bra       0x2d6a <L85>

00002d34 <L67>:
    2d34:	80 29 d4    	sl.w      0x980
    2d36:	00 c0 2f    	mov.w     #0xfc00, w0
    2d38:	80 29 b7    	ior.w     0x980
    2d3a:	64 86 af    	btsc.b    0x664, #0x4
    2d3c:	80 09 a8    	bset.b    0x980, #0x0
    2d3e:	80 89 ec    	inc2.w    0x980, WREG
    2d40:	13 00 3a    	bra       NZ, 0x2d68 <L74>
    2d42:	a8 29 b6    	and.w     0x9a8
    2d44:	10 00 20    	mov.w     #0x1, w0
    2d46:	30 4d 88    	mov.w     w0, 0x9a6
    2d48:	40 00 b1    	sub.w     #0x4, w0
    2d4a:	42 00 ae    	btss.b    0x42, #0x0
    2d4c:	00 00 20    	mov.w     #0x0, w0
    2d4e:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d50:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d52:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d54:	f0 00 20    	mov.w     #0xf, w0
    2d56:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d58:	c0 27 29    	mov.w     #0x927c, w0
    2d5a:	b0 4d 88    	mov.w     w0, 0x9b6
    2d5c:	ac 29 ae    	btss.b    0x9ac, #0x1
    2d5e:	05 00 37    	bra       0x2d6a <L85>
    2d60:	00 05 20    	mov.w     #0x50, w0
    2d62:	ab e9 af    	btsc.b    0x9ab, #0x7
    2d64:	50 4d 88    	mov.w     w0, 0x9aa
    2d66:	01 00 37    	bra       0x2d6a <L85>

00002d68 <L74>:
    2d68:	a8 29 b6    	and.w     0x9a8

00002d6a <L85>:
; extra anode 16
	btsc	w3,#b_pgm	; Extra bit 16: PGM (led) 
    2d6a:	03 80 a7    	btsc.w    w3, #0x8
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2d6c:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+17,w1
    2d6e:	11 81 20    	mov.w     #0x811, w1
	bra	disp_matrix
    2d70:	d8 01 37    	bra       0x3122 <disp_matrix>

00002d72 <cathode9>:
;-------------------------------- MATRIX 2,3 -------------------------- cathode 9
cathode9:
; test keys 2, 3
	keytest 2,2,3
    2d72:	7c 89 af    	btsc.b    0x97c, #0x4
    2d74:	1a 00 37    	bra       0x2daa <L68>
    2d76:	82 29 d4    	sl.w      0x982
    2d78:	00 c0 2f    	mov.w     #0xfc00, w0
    2d7a:	82 29 b7    	ior.w     0x982
    2d7c:	64 66 af    	btsc.b    0x664, #0x3
    2d7e:	82 09 a8    	bset.b    0x982, #0x0
    2d80:	82 89 ec    	inc2.w    0x982, WREG
    2d82:	2d 00 3a    	bra       NZ, 0x2dde <L75>
    2d84:	a8 29 b6    	and.w     0x9a8
    2d86:	20 00 20    	mov.w     #0x2, w0
    2d88:	30 4d 88    	mov.w     w0, 0x9a6
    2d8a:	40 00 b1    	sub.w     #0x4, w0
    2d8c:	42 00 ae    	btss.b    0x42, #0x0
    2d8e:	00 00 20    	mov.w     #0x0, w0
    2d90:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d92:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d94:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d96:	f0 00 20    	mov.w     #0xf, w0
    2d98:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d9a:	c0 27 29    	mov.w     #0x927c, w0
    2d9c:	b0 4d 88    	mov.w     w0, 0x9b6
    2d9e:	ac 49 ae    	btss.b    0x9ac, #0x2
    2da0:	1f 00 37    	bra       0x2de0 <L86>
    2da2:	00 05 20    	mov.w     #0x50, w0
    2da4:	ab e9 af    	btsc.b    0x9ab, #0x7
    2da6:	50 4d 88    	mov.w     w0, 0x9aa
    2da8:	1b 00 37    	bra       0x2de0 <L86>

00002daa <L68>:
    2daa:	84 29 d4    	sl.w      0x984
    2dac:	00 c0 2f    	mov.w     #0xfc00, w0
    2dae:	84 29 b7    	ior.w     0x984
    2db0:	64 86 af    	btsc.b    0x664, #0x4
    2db2:	84 09 a8    	bset.b    0x984, #0x0
    2db4:	84 89 ec    	inc2.w    0x984, WREG
    2db6:	13 00 3a    	bra       NZ, 0x2dde <L75>
    2db8:	a8 29 b6    	and.w     0x9a8
    2dba:	30 00 20    	mov.w     #0x3, w0
    2dbc:	30 4d 88    	mov.w     w0, 0x9a6
    2dbe:	40 00 b1    	sub.w     #0x4, w0
    2dc0:	42 00 ae    	btss.b    0x42, #0x0
    2dc2:	00 00 20    	mov.w     #0x0, w0
    2dc4:	fd e8 b7    	mov.b     WREG, 0x8fd
    2dc6:	dc 29 a8    	bset.b    0x9dc, #0x1
    2dc8:	fc 08 a8    	bset.b    0x8fc, #0x0
    2dca:	f0 00 20    	mov.w     #0xf, w0
    2dcc:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2dce:	c0 27 29    	mov.w     #0x927c, w0
    2dd0:	b0 4d 88    	mov.w     w0, 0x9b6
    2dd2:	ac 69 ae    	btss.b    0x9ac, #0x3
    2dd4:	05 00 37    	bra       0x2de0 <L86>
    2dd6:	00 05 20    	mov.w     #0x50, w0
    2dd8:	ab e9 af    	btsc.b    0x9ab, #0x7
    2dda:	50 4d 88    	mov.w     w0, 0x9aa
    2ddc:	01 00 37    	bra       0x2de0 <L86>

00002dde <L75>:
    2dde:	a8 29 b6    	and.w     0x9a8

00002de0 <L86>:
; extra anode 16
	btss	w3,#b_run	; Extra bit 16: RUN (led) 
    2de0:	03 90 a6    	btss.w    w3, #0x9
	bra	1f
    2de2:	03 00 37    	bra       0x2dea <L126>
	btsc	BlinkFlag,#2	; 2 set = LED Run blinks
    2de4:	e0 49 af    	btsc.b    0x9e0, #0x2
	btss	BlinkCount,#9	; bit pos = blinking freq
    2de6:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2de8:	dd 89 a8    	bset.b    0x9dd, #0x4

00002dea <L126>:
1:
; anodes 0...15
	mov	#Ram+19,w1
    2dea:	31 81 20    	mov.w     #0x813, w1
	bra	disp_matrix
    2dec:	9a 01 37    	bra       0x3122 <disp_matrix>

00002dee <cathode10>:
;-------------------------------- MATRIX 4,5 -------------------------- cathode 10
cathode10:
; test keys 4, 5
	keytest 4,4,5
    2dee:	7c 89 af    	btsc.b    0x97c, #0x4
    2df0:	1a 00 37    	bra       0x2e26 <L69>
    2df2:	86 29 d4    	sl.w      0x986
    2df4:	00 c0 2f    	mov.w     #0xfc00, w0
    2df6:	86 29 b7    	ior.w     0x986
    2df8:	64 66 af    	btsc.b    0x664, #0x3
    2dfa:	86 09 a8    	bset.b    0x986, #0x0
    2dfc:	86 89 ec    	inc2.w    0x986, WREG
    2dfe:	2d 00 3a    	bra       NZ, 0x2e5a <L76>
    2e00:	a8 29 b6    	and.w     0x9a8
    2e02:	40 00 20    	mov.w     #0x4, w0
    2e04:	30 4d 88    	mov.w     w0, 0x9a6
    2e06:	40 00 b1    	sub.w     #0x4, w0
    2e08:	42 00 ae    	btss.b    0x42, #0x0
    2e0a:	00 00 20    	mov.w     #0x0, w0
    2e0c:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e0e:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e10:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e12:	f0 00 20    	mov.w     #0xf, w0
    2e14:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e16:	c0 27 29    	mov.w     #0x927c, w0
    2e18:	b0 4d 88    	mov.w     w0, 0x9b6
    2e1a:	ac 89 ae    	btss.b    0x9ac, #0x4
    2e1c:	1f 00 37    	bra       0x2e5c <L87>
    2e1e:	00 05 20    	mov.w     #0x50, w0
    2e20:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e22:	50 4d 88    	mov.w     w0, 0x9aa
    2e24:	1b 00 37    	bra       0x2e5c <L87>

00002e26 <L69>:
    2e26:	88 29 d4    	sl.w      0x988
    2e28:	00 c0 2f    	mov.w     #0xfc00, w0
    2e2a:	88 29 b7    	ior.w     0x988
    2e2c:	64 86 af    	btsc.b    0x664, #0x4
    2e2e:	88 09 a8    	bset.b    0x988, #0x0
    2e30:	88 89 ec    	inc2.w    0x988, WREG
    2e32:	13 00 3a    	bra       NZ, 0x2e5a <L76>
    2e34:	a8 29 b6    	and.w     0x9a8
    2e36:	50 00 20    	mov.w     #0x5, w0
    2e38:	30 4d 88    	mov.w     w0, 0x9a6
    2e3a:	40 00 b1    	sub.w     #0x4, w0
    2e3c:	42 00 ae    	btss.b    0x42, #0x0
    2e3e:	00 00 20    	mov.w     #0x0, w0
    2e40:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e42:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e44:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e46:	f0 00 20    	mov.w     #0xf, w0
    2e48:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e4a:	c0 27 29    	mov.w     #0x927c, w0
    2e4c:	b0 4d 88    	mov.w     w0, 0x9b6
    2e4e:	ac a9 ae    	btss.b    0x9ac, #0x5
    2e50:	05 00 37    	bra       0x2e5c <L87>
    2e52:	00 05 20    	mov.w     #0x50, w0
    2e54:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e56:	50 4d 88    	mov.w     w0, 0x9aa
    2e58:	01 00 37    	bra       0x2e5c <L87>

00002e5a <L76>:
    2e5a:	a8 29 b6    	and.w     0x9a8

00002e5c <L87>:
; extra anode 16
	btss	w3,#b_ss	; Extra bit 16: SS (led) 
    2e5c:	03 a0 a6    	btss.w    w3, #0xa
	bra	1f
    2e5e:	03 00 37    	bra       0x2e66 <L127>
	btsc	BlinkFlag,#3	; 3 set = LED SS blinks
    2e60:	e0 69 af    	btsc.b    0x9e0, #0x3
	btss	BlinkCount,#9	; blinking freq
    2e62:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2e64:	dd 89 a8    	bset.b    0x9dd, #0x4

00002e66 <L127>:
1:
; anodes 0...15
	mov	#Ram+21,w1
    2e66:	51 81 20    	mov.w     #0x815, w1
	bra	disp_matrix
    2e68:	5c 01 37    	bra       0x3122 <disp_matrix>

00002e6a <cathode11>:
;-------------------------------- MATRIX 6,7 -------------------------- cathode 11
cathode11:
	btsc	Flag,#3		; #3 self-check mode
    2e6a:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in4		; no IN in self-check mode
    2e6c:	07 00 37    	bra       0x2e7c <no_in4>
; IN register service
	mov.b	PORTB,WREG
    2e6e:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2e70:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2e72:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2e74:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2e76:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2e78:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2e7a:	fb e8 b7    	mov.b     WREG, 0x8fb

00002e7c <no_in4>:
no_in4:
; test keys 6, 7
	keytest 6,5,5
    2e7c:	7c 89 af    	btsc.b    0x97c, #0x4
    2e7e:	1a 00 37    	bra       0x2eb4 <L610>
    2e80:	8a 29 d4    	sl.w      0x98a
    2e82:	00 c0 2f    	mov.w     #0xfc00, w0
    2e84:	8a 29 b7    	ior.w     0x98a
    2e86:	64 66 af    	btsc.b    0x664, #0x3
    2e88:	8a 09 a8    	bset.b    0x98a, #0x0
    2e8a:	8a 89 ec    	inc2.w    0x98a, WREG
    2e8c:	2d 00 3a    	bra       NZ, 0x2ee8 <L77>
    2e8e:	a8 29 b6    	and.w     0x9a8
    2e90:	60 00 20    	mov.w     #0x6, w0
    2e92:	30 4d 88    	mov.w     w0, 0x9a6
    2e94:	40 00 b1    	sub.w     #0x4, w0
    2e96:	42 00 ae    	btss.b    0x42, #0x0
    2e98:	00 00 20    	mov.w     #0x0, w0
    2e9a:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e9c:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e9e:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ea0:	f0 00 20    	mov.w     #0xf, w0
    2ea2:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2ea4:	c0 27 29    	mov.w     #0x927c, w0
    2ea6:	b0 4d 88    	mov.w     w0, 0x9b6
    2ea8:	ac a9 ae    	btss.b    0x9ac, #0x5
    2eaa:	1f 00 37    	bra       0x2eea <L88>
    2eac:	00 05 20    	mov.w     #0x50, w0
    2eae:	ab e9 af    	btsc.b    0x9ab, #0x7
    2eb0:	50 4d 88    	mov.w     w0, 0x9aa
    2eb2:	1b 00 37    	bra       0x2eea <L88>

00002eb4 <L610>:
    2eb4:	8c 29 d4    	sl.w      0x98c
    2eb6:	00 c0 2f    	mov.w     #0xfc00, w0
    2eb8:	8c 29 b7    	ior.w     0x98c
    2eba:	64 86 af    	btsc.b    0x664, #0x4
    2ebc:	8c 09 a8    	bset.b    0x98c, #0x0
    2ebe:	8c 89 ec    	inc2.w    0x98c, WREG
    2ec0:	13 00 3a    	bra       NZ, 0x2ee8 <L77>
    2ec2:	a8 29 b6    	and.w     0x9a8
    2ec4:	70 00 20    	mov.w     #0x7, w0
    2ec6:	30 4d 88    	mov.w     w0, 0x9a6
    2ec8:	40 00 b1    	sub.w     #0x4, w0
    2eca:	42 00 ae    	btss.b    0x42, #0x0
    2ecc:	00 00 20    	mov.w     #0x0, w0
    2ece:	fd e8 b7    	mov.b     WREG, 0x8fd
    2ed0:	dc 29 a8    	bset.b    0x9dc, #0x1
    2ed2:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ed4:	f0 00 20    	mov.w     #0xf, w0
    2ed6:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2ed8:	c0 27 29    	mov.w     #0x927c, w0
    2eda:	b0 4d 88    	mov.w     w0, 0x9b6
    2edc:	ac a9 ae    	btss.b    0x9ac, #0x5
    2ede:	05 00 37    	bra       0x2eea <L88>
    2ee0:	00 05 20    	mov.w     #0x50, w0
    2ee2:	ab e9 af    	btsc.b    0x9ab, #0x7
    2ee4:	50 4d 88    	mov.w     w0, 0x9aa
    2ee6:	01 00 37    	bra       0x2eea <L88>

00002ee8 <L77>:
    2ee8:	a8 29 b6    	and.w     0x9a8

00002eea <L88>:
; extra anode 16
	btsc	w3,#b_alu	;  Extra bit 16:ALU (led) 
    2eea:	03 b0 a7    	btsc.w    w3, #0xb
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2eec:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+23,w1
    2eee:	71 81 20    	mov.w     #0x817, w1
	bra	disp_matrix
    2ef0:	18 01 37    	bra       0x3122 <disp_matrix>

00002ef2 <cathode12>:
;-------------------------------- MATRIX 8,9 -------------------------- cathode 12
cathode12:
; test keys 8, 9
	keytest 8,5,6
    2ef2:	7c 89 af    	btsc.b    0x97c, #0x4
    2ef4:	1a 00 37    	bra       0x2f2a <L611>
    2ef6:	8e 29 d4    	sl.w      0x98e
    2ef8:	00 c0 2f    	mov.w     #0xfc00, w0
    2efa:	8e 29 b7    	ior.w     0x98e
    2efc:	64 66 af    	btsc.b    0x664, #0x3
    2efe:	8e 09 a8    	bset.b    0x98e, #0x0
    2f00:	8e 89 ec    	inc2.w    0x98e, WREG
    2f02:	2d 00 3a    	bra       NZ, 0x2f5e <L78>
    2f04:	a8 29 b6    	and.w     0x9a8
    2f06:	80 00 20    	mov.w     #0x8, w0
    2f08:	30 4d 88    	mov.w     w0, 0x9a6
    2f0a:	40 00 b1    	sub.w     #0x4, w0
    2f0c:	42 00 ae    	btss.b    0x42, #0x0
    2f0e:	00 00 20    	mov.w     #0x0, w0
    2f10:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f12:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f14:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f16:	f0 00 20    	mov.w     #0xf, w0
    2f18:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f1a:	c0 27 29    	mov.w     #0x927c, w0
    2f1c:	b0 4d 88    	mov.w     w0, 0x9b6
    2f1e:	ac a9 ae    	btss.b    0x9ac, #0x5
    2f20:	1f 00 37    	bra       0x2f60 <L89>
    2f22:	00 05 20    	mov.w     #0x50, w0
    2f24:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f26:	50 4d 88    	mov.w     w0, 0x9aa
    2f28:	1b 00 37    	bra       0x2f60 <L89>

00002f2a <L611>:
    2f2a:	90 29 d4    	sl.w      0x990
    2f2c:	00 c0 2f    	mov.w     #0xfc00, w0
    2f2e:	90 29 b7    	ior.w     0x990
    2f30:	64 86 af    	btsc.b    0x664, #0x4
    2f32:	90 09 a8    	bset.b    0x990, #0x0
    2f34:	90 89 ec    	inc2.w    0x990, WREG
    2f36:	13 00 3a    	bra       NZ, 0x2f5e <L78>
    2f38:	a8 29 b6    	and.w     0x9a8
    2f3a:	90 00 20    	mov.w     #0x9, w0
    2f3c:	30 4d 88    	mov.w     w0, 0x9a6
    2f3e:	40 00 b1    	sub.w     #0x4, w0
    2f40:	42 00 ae    	btss.b    0x42, #0x0
    2f42:	00 00 20    	mov.w     #0x0, w0
    2f44:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f46:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f48:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f4a:	f0 00 20    	mov.w     #0xf, w0
    2f4c:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f4e:	c0 27 29    	mov.w     #0x927c, w0
    2f50:	b0 4d 88    	mov.w     w0, 0x9b6
    2f52:	ac c9 ae    	btss.b    0x9ac, #0x6
    2f54:	05 00 37    	bra       0x2f60 <L89>
    2f56:	00 05 20    	mov.w     #0x50, w0
    2f58:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f5a:	50 4d 88    	mov.w     w0, 0x9aa
    2f5c:	01 00 37    	bra       0x2f60 <L89>

00002f5e <L78>:
    2f5e:	a8 29 b6    	and.w     0x9a8

00002f60 <L89>:
; extra anode 16
	btss	w3,#b_carry	; Extra bit 16: CARRY (key)
    2f60:	03 c0 a6    	btss.w    w3, #0xc
	bra	1f
    2f62:	03 00 37    	bra       0x2f6a <L128>
	btsc	BlinkFlag,#4	; #4 = CARRY blinks
    2f64:	e0 89 af    	btsc.b    0x9e0, #0x4
	btss	BlinkCount,#9	; blinking freq
    2f66:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2f68:	dd 89 a8    	bset.b    0x9dd, #0x4

00002f6a <L128>:
1:
; anodes 0...15
	mov	#Ram+25,w1
    2f6a:	91 81 20    	mov.w     #0x819, w1
	bra	disp_matrix
    2f6c:	da 00 37    	bra       0x3122 <disp_matrix>

00002f6e <cathode13>:
;-------------------------------- MATRIX A,B -------------------------- cathode 13
cathode13:
; test keys 10, 11
	keytest 10,6,6
    2f6e:	7c 89 af    	btsc.b    0x97c, #0x4
    2f70:	1a 00 37    	bra       0x2fa6 <L612>
    2f72:	92 29 d4    	sl.w      0x992
    2f74:	00 c0 2f    	mov.w     #0xfc00, w0
    2f76:	92 29 b7    	ior.w     0x992
    2f78:	64 66 af    	btsc.b    0x664, #0x3
    2f7a:	92 09 a8    	bset.b    0x992, #0x0
    2f7c:	92 89 ec    	inc2.w    0x992, WREG
    2f7e:	2d 00 3a    	bra       NZ, 0x2fda <L79>
    2f80:	a8 29 b6    	and.w     0x9a8
    2f82:	a0 00 20    	mov.w     #0xa, w0
    2f84:	30 4d 88    	mov.w     w0, 0x9a6
    2f86:	40 00 b1    	sub.w     #0x4, w0
    2f88:	42 00 ae    	btss.b    0x42, #0x0
    2f8a:	00 00 20    	mov.w     #0x0, w0
    2f8c:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f8e:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f90:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f92:	f0 00 20    	mov.w     #0xf, w0
    2f94:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f96:	c0 27 29    	mov.w     #0x927c, w0
    2f98:	b0 4d 88    	mov.w     w0, 0x9b6
    2f9a:	ac c9 ae    	btss.b    0x9ac, #0x6
    2f9c:	1f 00 37    	bra       0x2fdc <L810>
    2f9e:	00 05 20    	mov.w     #0x50, w0
    2fa0:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fa2:	50 4d 88    	mov.w     w0, 0x9aa
    2fa4:	1b 00 37    	bra       0x2fdc <L810>

00002fa6 <L612>:
    2fa6:	94 29 d4    	sl.w      0x994
    2fa8:	00 c0 2f    	mov.w     #0xfc00, w0
    2faa:	94 29 b7    	ior.w     0x994
    2fac:	64 86 af    	btsc.b    0x664, #0x4
    2fae:	94 09 a8    	bset.b    0x994, #0x0
    2fb0:	94 89 ec    	inc2.w    0x994, WREG
    2fb2:	13 00 3a    	bra       NZ, 0x2fda <L79>
    2fb4:	a8 29 b6    	and.w     0x9a8
    2fb6:	b0 00 20    	mov.w     #0xb, w0
    2fb8:	30 4d 88    	mov.w     w0, 0x9a6
    2fba:	40 00 b1    	sub.w     #0x4, w0
    2fbc:	42 00 ae    	btss.b    0x42, #0x0
    2fbe:	00 00 20    	mov.w     #0x0, w0
    2fc0:	fd e8 b7    	mov.b     WREG, 0x8fd
    2fc2:	dc 29 a8    	bset.b    0x9dc, #0x1
    2fc4:	fc 08 a8    	bset.b    0x8fc, #0x0
    2fc6:	f0 00 20    	mov.w     #0xf, w0
    2fc8:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2fca:	c0 27 29    	mov.w     #0x927c, w0
    2fcc:	b0 4d 88    	mov.w     w0, 0x9b6
    2fce:	ac c9 ae    	btss.b    0x9ac, #0x6
    2fd0:	05 00 37    	bra       0x2fdc <L810>
    2fd2:	00 05 20    	mov.w     #0x50, w0
    2fd4:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fd6:	50 4d 88    	mov.w     w0, 0x9aa
    2fd8:	01 00 37    	bra       0x2fdc <L810>

00002fda <L79>:
    2fda:	a8 29 b6    	and.w     0x9a8

00002fdc <L810>:
; extra anode 16
	btss	w3,#b_save	; Extra bit 16: SAVE (key)
    2fdc:	03 d0 a6    	btss.w    w3, #0xd
	bra	1f
    2fde:	03 00 37    	bra       0x2fe6 <L129>
	btsc	BlinkFlag,#5	; #5 = SAVE blinks
    2fe0:	e0 a9 af    	btsc.b    0x9e0, #0x5
	btss	BlinkCount,#9	; blinking freq
    2fe2:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2fe4:	dd 89 a8    	bset.b    0x9dd, #0x4

00002fe6 <L129>:
1:
; anodes 0...15
	mov	#Ram+27,w1
    2fe6:	b1 81 20    	mov.w     #0x81b, w1
	bra	disp_matrix
    2fe8:	9c 00 37    	bra       0x3122 <disp_matrix>

00002fea <cathode14>:
;-------------------------------- MATRIX C,D -------------------------- cathode 14
cathode14:
	mov	BlinkCount,w0
    2fea:	e0 4b 80    	mov.w     0x97c, w0
	mov	#0b110000,w1	; dim down/up speed
    2fec:	01 03 20    	mov.w     #0x30, w1
	and	w0,w1,w0
    2fee:	01 00 60    	and.w     w0, w1, w0
	bra	nz,no_dim_up
    2ff0:	0f 00 3a    	bra       NZ, 0x3010 <no_dim_up>
; dim down \\\\\\\\\\\\\\\\\\\\\
	btss	Flag,#14	; #14 set if dim down in progress
    2ff2:	dd c9 ae    	btss.b    0x9dd, #0x6
	bra	no_dim_down
    2ff4:	05 00 37    	bra       0x3000 <no_dim_down>
	cp0.b	Dimmer
    2ff6:	fe 48 e2    	cp0.b     0x8fe
	ifz
    2ff8:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#14	; end of dim down
    2ffa:	dd c9 a9    	bclr.b    0x9dd, #0x6
	bra	z,enter_sleep	; GO SLEEP -------------------------------------->
    2ffc:	19 01 32    	bra       Z, 0x3230 <enter_sleep>
	dec.b	Dimmer
    2ffe:	fe 68 ed    	dec.b     0x8fe

00003000 <no_dim_down>:
no_dim_down:
; dim up ///////////////////////
	btss	Flag,#15	; #15 set if dim up in progress
    3000:	dd e9 ae    	btss.b    0x9dd, #0x7
	bra	no_dim_up
    3002:	06 00 37    	bra       0x3010 <no_dim_up>
	mov.b	Temp_Dimmer,WREG
    3004:	ba c9 bf    	mov.b     0x9ba, WREG
	cp.b	Dimmer		; Dimmer - Temp_Dimmer
    3006:	fe 48 e3    	cp.b      0x8fe
	ifc
    3008:	42 00 af    	btsc.b    0x42, #0x0
	bclr	Flag,#15	; end of dim up
    300a:	dd e9 a9    	bclr.b    0x9dd, #0x7
	ifnc
    300c:	42 00 ae    	btss.b    0x42, #0x0
	inc.b	Dimmer
    300e:	fe 68 ec    	inc.b     0x8fe

00003010 <no_dim_up>:
no_dim_up:
; test keys 12, 13
	keytest 12,6,7
    3010:	7c 89 af    	btsc.b    0x97c, #0x4
    3012:	1a 00 37    	bra       0x3048 <L613>
    3014:	96 29 d4    	sl.w      0x996
    3016:	00 c0 2f    	mov.w     #0xfc00, w0
    3018:	96 29 b7    	ior.w     0x996
    301a:	64 66 af    	btsc.b    0x664, #0x3
    301c:	96 09 a8    	bset.b    0x996, #0x0
    301e:	96 89 ec    	inc2.w    0x996, WREG
    3020:	2d 00 3a    	bra       NZ, 0x307c <L710>
    3022:	a8 29 b6    	and.w     0x9a8
    3024:	c0 00 20    	mov.w     #0xc, w0
    3026:	30 4d 88    	mov.w     w0, 0x9a6
    3028:	40 00 b1    	sub.w     #0x4, w0
    302a:	42 00 ae    	btss.b    0x42, #0x0
    302c:	00 00 20    	mov.w     #0x0, w0
    302e:	fd e8 b7    	mov.b     WREG, 0x8fd
    3030:	dc 29 a8    	bset.b    0x9dc, #0x1
    3032:	fc 08 a8    	bset.b    0x8fc, #0x0
    3034:	f0 00 20    	mov.w     #0xf, w0
    3036:	f9 e8 b7    	mov.b     WREG, 0x8f9
    3038:	c0 27 29    	mov.w     #0x927c, w0
    303a:	b0 4d 88    	mov.w     w0, 0x9b6
    303c:	ac c9 ae    	btss.b    0x9ac, #0x6
    303e:	1f 00 37    	bra       0x307e <L811>
    3040:	00 05 20    	mov.w     #0x50, w0
    3042:	ab e9 af    	btsc.b    0x9ab, #0x7
    3044:	50 4d 88    	mov.w     w0, 0x9aa
    3046:	1b 00 37    	bra       0x307e <L811>

00003048 <L613>:
    3048:	98 29 d4    	sl.w      0x998
    304a:	00 c0 2f    	mov.w     #0xfc00, w0
    304c:	98 29 b7    	ior.w     0x998
    304e:	64 86 af    	btsc.b    0x664, #0x4
    3050:	98 09 a8    	bset.b    0x998, #0x0
    3052:	98 89 ec    	inc2.w    0x998, WREG
    3054:	13 00 3a    	bra       NZ, 0x307c <L710>
    3056:	a8 29 b6    	and.w     0x9a8
    3058:	d0 00 20    	mov.w     #0xd, w0
    305a:	30 4d 88    	mov.w     w0, 0x9a6
    305c:	40 00 b1    	sub.w     #0x4, w0
    305e:	42 00 ae    	btss.b    0x42, #0x0
    3060:	00 00 20    	mov.w     #0x0, w0
    3062:	fd e8 b7    	mov.b     WREG, 0x8fd
    3064:	dc 29 a8    	bset.b    0x9dc, #0x1
    3066:	fc 08 a8    	bset.b    0x8fc, #0x0
    3068:	f0 00 20    	mov.w     #0xf, w0
    306a:	f9 e8 b7    	mov.b     WREG, 0x8f9
    306c:	c0 27 29    	mov.w     #0x927c, w0
    306e:	b0 4d 88    	mov.w     w0, 0x9b6
    3070:	ac e9 ae    	btss.b    0x9ac, #0x7
    3072:	05 00 37    	bra       0x307e <L811>
    3074:	00 05 20    	mov.w     #0x50, w0
    3076:	ab e9 af    	btsc.b    0x9ab, #0x7
    3078:	50 4d 88    	mov.w     w0, 0x9aa
    307a:	01 00 37    	bra       0x307e <L811>

0000307c <L710>:
    307c:	a8 29 b6    	and.w     0x9a8

0000307e <L811>:
; extra anode 16
	btss	w3,#b_load	; Extra bit 16: LOAD (key) 
    307e:	03 e0 a6    	btss.w    w3, #0xe
	bra	1f
    3080:	03 00 37    	bra       0x3088 <L130>
	btsc	BlinkFlag,#7	; #7 = LOAD blinks
    3082:	e0 e9 af    	btsc.b    0x9e0, #0x7
	btss	BlinkCount,#9	; blinking freq
    3084:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3086:	dd 89 a8    	bset.b    0x9dd, #0x4

00003088 <L130>:
1:
; anodes 0...15
	mov	#Ram+29,w1
    3088:	d1 81 20    	mov.w     #0x81d, w1
	bra	disp_matrix
    308a:	4b 00 37    	bra       0x3122 <disp_matrix>

0000308c <cathode15>:
;-------------------------------- MATRIX E,F -------------------------- cathode 15
cathode15:
; test keys 14, 15
	keytest 14,7,7
    308c:	7c 89 af    	btsc.b    0x97c, #0x4
    308e:	1a 00 37    	bra       0x30c4 <L614>
    3090:	9a 29 d4    	sl.w      0x99a
    3092:	00 c0 2f    	mov.w     #0xfc00, w0
    3094:	9a 29 b7    	ior.w     0x99a
    3096:	64 66 af    	btsc.b    0x664, #0x3
    3098:	9a 09 a8    	bset.b    0x99a, #0x0
    309a:	9a 89 ec    	inc2.w    0x99a, WREG
    309c:	2d 00 3a    	bra       NZ, 0x30f8 <L711>
    309e:	a8 29 b6    	and.w     0x9a8
    30a0:	e0 00 20    	mov.w     #0xe, w0
    30a2:	30 4d 88    	mov.w     w0, 0x9a6
    30a4:	40 00 b1    	sub.w     #0x4, w0
    30a6:	42 00 ae    	btss.b    0x42, #0x0
    30a8:	00 00 20    	mov.w     #0x0, w0
    30aa:	fd e8 b7    	mov.b     WREG, 0x8fd
    30ac:	dc 29 a8    	bset.b    0x9dc, #0x1
    30ae:	fc 08 a8    	bset.b    0x8fc, #0x0
    30b0:	f0 00 20    	mov.w     #0xf, w0
    30b2:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30b4:	c0 27 29    	mov.w     #0x927c, w0
    30b6:	b0 4d 88    	mov.w     w0, 0x9b6
    30b8:	ac e9 ae    	btss.b    0x9ac, #0x7
    30ba:	1f 00 37    	bra       0x30fa <L812>
    30bc:	00 05 20    	mov.w     #0x50, w0
    30be:	ab e9 af    	btsc.b    0x9ab, #0x7
    30c0:	50 4d 88    	mov.w     w0, 0x9aa
    30c2:	1b 00 37    	bra       0x30fa <L812>

000030c4 <L614>:
    30c4:	9c 29 d4    	sl.w      0x99c
    30c6:	00 c0 2f    	mov.w     #0xfc00, w0
    30c8:	9c 29 b7    	ior.w     0x99c
    30ca:	64 86 af    	btsc.b    0x664, #0x4
    30cc:	9c 09 a8    	bset.b    0x99c, #0x0
    30ce:	9c 89 ec    	inc2.w    0x99c, WREG
    30d0:	13 00 3a    	bra       NZ, 0x30f8 <L711>
    30d2:	a8 29 b6    	and.w     0x9a8
    30d4:	f0 00 20    	mov.w     #0xf, w0
    30d6:	30 4d 88    	mov.w     w0, 0x9a6
    30d8:	40 00 b1    	sub.w     #0x4, w0
    30da:	42 00 ae    	btss.b    0x42, #0x0
    30dc:	00 00 20    	mov.w     #0x0, w0
    30de:	fd e8 b7    	mov.b     WREG, 0x8fd
    30e0:	dc 29 a8    	bset.b    0x9dc, #0x1
    30e2:	fc 08 a8    	bset.b    0x8fc, #0x0
    30e4:	f0 00 20    	mov.w     #0xf, w0
    30e6:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30e8:	c0 27 29    	mov.w     #0x927c, w0
    30ea:	b0 4d 88    	mov.w     w0, 0x9b6
    30ec:	ac e9 ae    	btss.b    0x9ac, #0x7
    30ee:	05 00 37    	bra       0x30fa <L812>
    30f0:	00 05 20    	mov.w     #0x50, w0
    30f2:	ab e9 af    	btsc.b    0x9ab, #0x7
    30f4:	50 4d 88    	mov.w     w0, 0x9aa
    30f6:	01 00 37    	bra       0x30fa <L812>

000030f8 <L711>:
    30f8:	a8 29 b6    	and.w     0x9a8

000030fa <L812>:
; anykey ---> Flag,#11 test
	btss	BlinkCount,#4
    30fa:	7c 89 ae    	btss.b    0x97c, #0x4
	bra	1f		; if odd pass
    30fc:	07 00 37    	bra       0x310c <L131>
	bclr	Flag,#11	; #11 flag "any Key Pressed"
    30fe:	dd 69 a9    	bclr.b    0x9dd, #0x3
	btss	Anypress,#0	; bit 0 is reset if any key still depressed
    3100:	a8 09 ae    	btss.b    0x9a8, #0x0
	bset	Flag,#11	; #11 flag "any Key Pressed"
    3102:	dd 69 a8    	bset.b    0x9dd, #0x3
;	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
;	bset	Flag,#11	;WrFlags #11 flag "any Key Pressed"
	bclr.b	KeyStatus,#2	; user's flag "any key pressed"
    3104:	fc 48 a9    	bclr.b    0x8fc, #0x2
	btsc	Flag,#11	; #11 flag "any Key Pressed" (will be moved to KeyStatus,#2)
    3106:	dd 69 af    	btsc.b    0x9dd, #0x3
	bset.b	KeyStatus,#2	; user's flag "any key pressed"
    3108:	fc 48 a8    	bset.b    0x8fc, #0x2
	bra	2f
    310a:	08 00 37    	bra       0x311c <L28>

0000310c <L131>:
1:
; test if last key is still pressed (service KeyStatus,#1)
	bclr.b	KeyStatus,#1	; user's flag "last key pressed"
    310c:	fc 28 a9    	bclr.b    0x8fc, #0x1
	sl.b	KeyReg,WREG	; ×2
    310e:	fd 48 d4    	sl.b      0x8fd, WREG
	and	#0x1F,w0
    3110:	f0 01 b2    	and.w     #0x1f, w0
	bra	z,2f		; if last key = 0, 1, 2, 3, 4 (illegal keys)
    3112:	04 00 32    	bra       Z, 0x311c <L28>
	mov	#KeyRotors+8,w1
    3114:	61 98 20    	mov.w     #0x986, w1
	add	w0,w1,w0	; debouncer for the last pressed key
    3116:	01 00 40    	add.w     w0, w1, w0
	btss	[w0],#0
    3118:	10 00 a6    	btss.w    [w0], #0x0
	bset.b	KeyStatus,#1	; user's flag "last key pressed"
    311a:	fc 28 a8    	bset.b    0x8fc, #0x1

0000311c <L28>:
2:
; extra anode 16
	btsc	w3,#b_bin	; Extra bit 16: BIN (bin/sel leds) 
    311c:	03 f0 a7    	btsc.w    w3, #0xf
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    311e:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+31,w1
    3120:	f1 81 20    	mov.w     #0x81f, w1

00003122 <disp_matrix>:
disp_matrix:
  ; History cathodes 8...15 conditional setup
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    3122:	dc a9 ae    	btss.b    0x9dc, #0x5
	  bra	  regular_15
    3124:	09 00 37    	bra       0x3138 <regular_15>
  ; get bytes from unpacked history RAM pages
	  mov	  History_Visible,w1
    3126:	01 48 80    	mov.w     0x900, w1
	  btss	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    3128:	dc c9 ae    	btss.b    0x9dc, #0x6
	  add	  #16,w1	  ; address for hist RAM page 0 is History_Visible+16
    312a:	01 01 b0    	add.w     #0x10, w1
	  mov	  RowScan,w0
    312c:	c0 4b 80    	mov.w     0x978, w0
	  and	  #7,w0		  ; 8...15 ---> 0...7
    312e:	70 00 b2    	and.w     #0x7, w0
	  sl	  w0,w0		  ; ×2
    3130:	00 00 d0    	sl.w      w0, w0
	  add	  w0,w1,w1
    3132:	81 00 40    	add.w     w0, w1, w1
	  mov	  [w1],w0	  ; here's unpacked word ready for display ports
    3134:	11 00 78    	mov.w     [w1], w0
	  bra	  skr_15
    3136:	28 00 37    	bra       0x3188 <skr_15>

00003138 <regular_15>:
regular_15:
	mov.b	Page,WREG
    3138:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    313a:	dc c9 af    	btsc.b    0x9dc, #0x6
	  clr	  w0		  ; if ALT pressed, then page 0
    313c:	00 00 eb    	clr.w     w0
	ze	w0,w0
    313e:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; w0 = 16 × Page
    3140:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w0,w1,w1	; w1 = #Ram + (16×Page) + 31
    3142:	81 00 40    	add.w     w0, w1, w1
	sub	w1,#16,w2	; w2 = #Ram + (16×Page) + 15
    3144:	70 81 50    	sub.w     w1, #0x10, w2
; if >15 then wrap to 0
	mov	#Ram+255,w0
    3146:	f0 8f 20    	mov.w     #0x8ff, w0
	cp	w1,w0
    3148:	00 08 e1    	cp.w      w1, w0
	ifc
    314a:	42 00 af    	btsc.b    0x42, #0x0
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    314c:	01 10 b1    	sub.w     #0x100, w1
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    314e:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    3150:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    3152:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    3154:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; 0000 AAAA CCCC BBBB
    3156:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    3158:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2],w0	; AAAA CCCC BBBB DDDD
    315a:	12 40 70    	ior.b     w0, [w2], w0
; blank matrix in mode 0 and mode 3
	mov	Mode,w2
    315c:	b2 4b 80    	mov.w     0x976, w2
	cp0	w2
    315e:	02 00 e0    	cp0.w     w2
	bra	nz,1f		; if Mode not ALU
    3160:	10 00 3a    	bra       NZ, 0x3182 <L132>
; Mode = Dir
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    3162:	df 09 af    	btsc.b    0x9df, #0x0
	bra	3f
    3164:	08 00 37    	bra       0x3176 <L310>
; no buttons pressed yet (Ver/Rev mode)
	mov	RowScan,w2
    3166:	c2 4b 80    	mov.w     0x978, w2
	cp	w2,#13		; here are rows 10 and 11
    3168:	6d 10 e1    	cp.w      w2, #0xd
	ifz
    316a:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS1,w0		; if in Ver/Rev mode, show CHS
    316c:	c0 4e 80    	mov.w     0x9d8, w0
	cp	w2,#15		; here are rows 14 and 15
    316e:	6f 10 e1    	cp.w      w2, #0xf
	ifz
    3170:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS2,w0		; if in Ver/Rev mode, show CHS
    3172:	d0 4e 80    	mov.w     0x9da, w0
	bra	skr_15		; if no buttons pressed yet, show Ver/Rev
    3174:	09 00 37    	bra       0x3188 <skr_15>

00003176 <L310>:
3:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    3176:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	2f		; clear matrix data
    3178:	06 00 37    	bra       0x3186 <L29>
; ALT pressed in ALU mode, anodes 7-15 show Files occupancy
	sl	RowScan,WREG
    317a:	78 09 d4    	sl.w      0x978, WREG
	and	#0x0F,w0
    317c:	f0 00 b2    	and.w     #0xf, w0
	mov	#Files,w1
    317e:	61 96 20    	mov.w     #0x966, w1
	mov	[w0+w1],w0
    3180:	60 80 78    	mov.w     [w0+w1], w0

00003182 <L132>:
1:
	cp	w2,#3		; if Mode = 3 (Run)...
    3182:	63 10 e1    	cp.w      w2, #0x3
	ifz
    3184:	42 20 af    	btsc.b    0x42, #0x1

00003186 <L29>:
2:
	mov	#0,w0		; ...then clear matrix data
    3186:	00 00 20    	mov.w     #0x0, w0

00003188 <skr_15>:
; end of blank matrix in mode 0 and mode 3
skr_15:
; Final matrix anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    3188:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    318a:	dd 89 a9    	bclr.b    0x9dd, #0x4
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    318c:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    318e:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    3190:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATC	; LED anodes 0...7 set
    3192:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    3194:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    3196:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    3198:	7b e6 b7    	mov.b     WREG, 0x67b
	bra	t1exit
    319a:	09 00 37    	bra       0x31ae <t1exit>

0000319c <disp_w0>:
; ------------------------------------------------------
disp_w0:		; display service for cathodes 0...7
; Final LED anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    319c:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    319e:	dd 89 a9    	bclr.b    0x9dd, #0x4

000031a0 <disp_w0_noblank>:
disp_w0_noblank:
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    31a0:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    31a2:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    31a4:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATC	; LED anodes 0...7 set
    31a6:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    31a8:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    31aa:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    31ac:	7b e6 b7    	mov.b     WREG, 0x67b

000031ae <t1exit>:
; ------------------------------------------------------
t1exit:
; final exit from interrupt
	pop.s			; /
    31ae:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    31b0:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    31b2:	00 40 06    	retfie    

000031b4 <aux_int>:
; ------------------------------------------------------
aux_int:		; aux_int only turns off LEDs, for dimming
	bclr	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    31b4:	dd a9 a9    	bclr.b    0x9dd, #0x5
	clr	LATC		; all LEDS off (here's LATC,#8 also)
    31b6:	8e 26 ef    	clr.w     0x68e
	clr.b	LATB+1		; all LEDS off
    31b8:	7b 66 ef    	clr.b     0x67b

	mov	PR1copy,w0	; w0 =  10,  22,  28,  38,  52...412, 470
    31ba:	10 4e 80    	mov.w     0x9c2, w0
	mov	#475,w2
    31bc:	b2 1d 20    	mov.w     #0x1db, w2
	sub	w2,w0,w0
    31be:	00 00 51    	sub.w     w2, w0, w0
; mov #10,w0 ;(samo za snimanje 60 fps)
	mov	w0,PR1
    31c0:	90 0c 88    	mov.w     w0, 0x192

	pop.s			; /
    31c2:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    31c4:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    31c6:	00 40 06    	retfie    

000031c8 <T3Int>:

;***********************************************************************************
;****************************       T3 INTERRUPT       *****************************
;****************************       USER'S SYNC        *****************************
;***********************************************************************************
T3Int:				; TIMER 3 int, user's sync
	bset.b	RdFlags,#0	; #0 user's SYNC
    31c8:	f4 08 a8    	bset.b    0x8f4, #0x0
	nop			; * * *   MCU BUG FIX  ???   * * *
    31ca:	00 00 00    	nop       
	bclr	IFS0,#8		; clr int flag (skips this line without NOP)
    31cc:	89 00 a9    	bclr.b    0x89, #0x0
	retfie
    31ce:	00 40 06    	retfie    

000031d0 <U1RXInt>:

;***********************************************************************************
;***********************              RX1 INTERRUPT           **********************
;***********************************************************************************

; Character is received in U1RXREG
; read char and clear UART RX flag UXRDA
; if SerH:L is free, put it there and increment Received; finished
; if there is no room in FIFO, ignore all and exit (character is lost)
; else, put it at the end of FIFO (@WRPtr), inc WRPtr, calc Received

U1RXInt:			; RX1 interrupt
	push.s		   ; \
    31d0:	00 a0 fe    	push.s    
	mov	U1RXREG,w1	; <---- get received byte (this resets U1STAL,#URXDA)
    31d2:	f1 1c 80    	mov.w     0x39e, w1
	btsc	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    31d4:	de 49 af    	btsc.b    0x9de, #0x2
	bra	move2fifo
    31d6:	0a 00 37    	bra       0x31ec <move2fifo>
; move char to SerH:L
	lsr	w1,#4,w0
    31d8:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    31da:	f7 e8 b7    	mov.b     WREG, 0x8f7
	and	w1,#0x0F,w0
    31dc:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    31de:	f6 e8 b7    	mov.b     WREG, 0x8f6
	mov	#1,w0
    31e0:	10 00 20    	mov.w     #0x1, w0
	mov.b	WREG,Received
    31e2:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    31e4:	de 49 a8    	bset.b    0x9de, #0x2
	bclr	IFS0,#11	; clr int flag
    31e6:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    31e8:	00 80 fe    	pop.s     
	retfie
    31ea:	00 40 06    	retfie    

000031ec <move2fifo>:
move2fifo:		; move char to fifo
	mov	RXWR,w2
    31ec:	e2 4d 80    	mov.w     0x9bc, w2
	inc.b	w2,w0		; pre-inc RXWR (in byte mode, to wrap inside RX buffer)
    31ee:	02 40 e8    	inc.b     w2, w0
	cp.b	RXRD
    31f0:	be 49 e3    	cp.b      0x9be
	bra	nz,fifo_room	; if there's free place in FIFO, continue, else...
    31f2:	02 00 3a    	bra       NZ, 0x31f8 <fifo_room>
	bset.b	SerCtrl,#3	; ...set error flag...
    31f4:	f5 68 a8    	bset.b    0x8f5, #0x3
	bra	nochar		; ...and quit
    31f6:	0b 00 37    	bra       0x320e <nochar>

000031f8 <fifo_room>:
fifo_room:
	mov.b	w1,[w2]		; put char to FIFO
    31f8:	01 49 78    	mov.b     w1, [w2]
	inc.b	RXWR		; inc write ptr (in byte mode, to wrap inside RX byffer)
    31fa:	bc 69 ec    	inc.b     0x9bc
; Calculate Received
	mov	RXRD,WREG
    31fc:	be 89 bf    	mov.w     0x9be, WREG
	sub	RXWR,WREG	; RXWR-RXRD (byte mode, to stay in range 0000-00FF)
    31fe:	bc 09 b5    	sub.w     0x9bc, WREG
	ze	w0,w0
    3200:	00 80 fb    	ze        w0, w0
	inc	w0,w0		; as SerH:L is surely full
    3202:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    3204:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    3206:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    3208:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    320a:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    320c:	de 49 a8    	bset.b    0x9de, #0x2

0000320e <nochar>:
nochar:
	bclr	IFS0,#11	; clr int flag
    320e:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    3210:	00 80 fe    	pop.s     
	retfie
    3212:	00 40 06    	retfie    

00003214 <U1ErrInt>:

;***********************************************************************************
;***********************          RX1 ERROR INTERRUPT       **********************
;***********************************************************************************
U1ErrInt:			; U1EIE interrupt
	bclr	U1STA,#1	; clr err flag
    3214:	9a 23 a9    	bclr.b    0x39a, #0x1
	bclr	U1STA,#2	; clr err flag
    3216:	9a 43 a9    	bclr.b    0x39a, #0x2
	bclr	IFS4,#1
    3218:	90 20 a9    	bclr.b    0x90, #0x1
	retfie
    321a:	00 40 06    	retfie    

0000321c <U2RXInt>:

;***********************************************************************************
;***********************      CURREENTLY UNUSED INTERRUPTS     **********************
;***********************************************************************************
U2RXInt:			; RX2 interrupt
	bclr	IFS1,#14	; clr int flag
    321c:	8b c0 a9    	bclr.b    0x8b, #0x6
	retfie
    321e:	00 40 06    	retfie    

00003220 <INT2Int>:
;		
INT2Int:			; external INT2 interrupt
	bclr	IFS1,#13	; clr int flag
    3220:	8b a0 a9    	bclr.b    0x8b, #0x5
	retfie			; ---------->
    3222:	00 40 06    	retfie    

00003224 <U2ErrInt>:
;		
U2ErrInt:			; U2EIE interrupt
	bclr	U2STA,#1	; clr err flag
    3224:	b0 23 a9    	bclr.b    0x3b0, #0x1
	bclr	U2STA,#2	; clr err flag
    3226:	b0 43 a9    	bclr.b    0x3b0, #0x2
	bclr	IFS4,#2
    3228:	90 40 a9    	bclr.b    0x90, #0x2
	retfie
    322a:	00 40 06    	retfie    

0000322c <INT1Int>:

;***********************************************************************************
;***********************         EXTERNAL INT 1 SERVICE       **********************
;***********************************************************************************
INT1Int:		; ON/OFF button interrupt (shouldn't come here as INTCON2,#GIE ...
			; ...and IEC1,#4 are never ON at the same time, but just in case)
	bclr	IFS1,#4
    322c:	8a 80 a9    	bclr.b    0x8a, #0x4
	retfie
    322e:	00 40 06    	retfie    

00003230 <enter_sleep>:

;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZ                S L E E P               ZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

enter_sleep:		; set ports to lowest current consumption
			; be ready to wake up on EXT INT1 and enter sleep mode
			; After wake up, wait for button safely released and dim up
; peripheral and interrupt control bits
	bclr	INTCON2,#GIE	; global int disable
    3230:	83 e0 a9    	bclr.b    0x83, #0x7
	bclr	T1CON,#TON	; LED multiplex timer off
    3232:	95 e1 a9    	bclr.b    0x195, #0x7
	bclr	T2CON,#TON	; T2 timer off
    3234:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	bclr	T3CON,#TON	; T3 timer off
    3236:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	bclr	IEC0,#T1IE	; disable Timer 1 interrupt
    3238:	98 60 a9    	bclr.b    0x98, #0x3
	bclr	IEC0,#7		; disable Timer 2 interrupt
    323a:	98 e0 a9    	bclr.b    0x98, #0x7
	bclr	IEC0,#8		; disable Timer 3 interrupt
    323c:	99 00 a9    	bclr.b    0x99, #0x0
	bclr	IEC1,#4		; disable external interrupt
    323e:	9a 80 a9    	bclr.b    0x9a, #0x4
; LEDs off, I/O pins hi-z
	clr.b	LATB+1		; all LEDs off
    3240:	7b 66 ef    	clr.b     0x67b
	clr	LATC		; all LEDs off
    3242:	8e 26 ef    	clr.w     0x68e
	setm.b	TRISB+0		; connector ports hi-z
    3244:	76 e6 ef    	setm.b    0x676
	bset	TRISA,#1	; Tx on SAO also hi-z
    3246:	62 26 a8    	bset.b    0x662, #0x1
; wait for ON-OFF safely released and final wake initialization
	call	test_no_press	; wait for ON-OFF safely released
    3248:	84 32 02    	call      0x3284 <test_no_press>
    324a:	00 00 00 
	bclr	IFS1,#4		; clear interrupt flag to avoid self-triggering
    324c:	8a 80 a9    	bclr.b    0x8a, #0x4
	bset	INTCON2,#INT1EP	; interrupt on negative-going edge
    324e:	82 20 a8    	bset.b    0x82, #0x1
	bset	IEC1,#4		; enable external interrupt
    3250:	9a 80 a8    	bset.b    0x9a, #0x4
; SLEEP NOW    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	pwrsav	#0		; *  *   SLEEP   *  *  *  *  *  *  *  *  *  *  *  *  *
    3252:	00 40 fe    	pwrsav    #0x0
; GOOD MORNING    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	mov	#2,w0		; ×10 min autooff at wake-up
    3254:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
    3256:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
    3258:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    325a:	b0 4d 88    	mov.w     w0, 0x9b6
; restore I/O pins
	mov	#0xF0,w0	; bits 7654 = inputs, bits 3210 = outputs
    325c:	00 0f 20    	mov.w     #0xf0, w0
	mov.b	WREG,TRISB+0	; restore states of connector ports
    325e:	76 e6 b7    	mov.b     WREG, 0x676
	bclr	TRISA,#1	; Tx on SAO = output
    3260:	62 26 a9    	bclr.b    0x662, #0x1
	btsc.b	WrFlags,#0	; if UART is redirected to I/O connector, then... 
    3262:	f3 08 af    	btsc.b    0x8f3, #0x0
	bclr	TRISB,#7	; ...Tx on I/O connector = output
    3264:	76 e6 a9    	bclr.b    0x676, #0x7
; restore peripheral and interrupt control bits
	bclr	IEC1,#4		; disable external interrupt
    3266:	9a 80 a9    	bclr.b    0x9a, #0x4
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    3268:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    326a:	99 00 a8    	bset.b    0x99, #0x0
	bset	T1CON,#TON	; LED multiplex timer on
    326c:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON	; T2 timer on
    326e:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON	; T3 timer on
    3270:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	INTCON2,#GIE	; global int enable
    3272:	83 e0 a8    	bset.b    0x83, #0x7
; initialize key rotors and dim up
	mov	#KeyRotors,w1
    3274:	e1 97 20    	mov.w     #0x97e, w1
	push	RCOUNT		; \
    3276:	36 00 f8    	push      0x36
	repeat	#19-1
    3278:	12 00 09    	repeat    #0x12
	clr	[w1++]		; clear key debouncer rotors to ignore pre-pressed keys
    327a:	80 18 eb    	clr.w     [w1++]
	pop	RCOUNT		; /
    327c:	36 00 f9    	pop       0x36
	bset	Flag,#15	; dim up MAIN REQUEST
    327e:	dd e9 a8    	bset.b    0x9dd, #0x7
	goto	t1exit
    3280:	ae 31 04    	goto      0x31ae <t1exit>
    3282:	00 00 00 

00003284 <test_no_press>:
; wait for ON-OFF safely released (90 ms debouncer)
test_no_press:
	mov	#900,w0		; w0 × 0.1 ms verify period
    3284:	40 38 20    	mov.w     #0x384, w0

00003286 <L133>:
1:
	push	RCOUNT		; \
    3286:	36 00 f8    	push      0x36
	repeat	#1600-9
    3288:	37 06 09    	repeat    #0x637
	nop
    328a:	00 00 00    	nop       
	pop	RCOUNT		; /
    328c:	36 00 f9    	pop       0x36
	btss	PORTC,#9	; skip if ON-OFF key high
    328e:	8d 26 ae    	btss.b    0x68d, #0x1
	bra	test_no_press	; it's low, re-initialize the counter from the start
    3290:	f9 ff 37    	bra       0x3284 <test_no_press>
	dec	w0,w0
    3292:	00 00 e9    	dec.w     w0, w0
	bra	nz,1b		; 1 loop = 1600 t = 0.1 ms
    3294:	f8 ff 3a    	bra       NZ, 0x3286 <L133>
	return
    3296:	00 00 06    	return    

00003298 <clk_table>:
    3298:	09 00 00    	nop       
    329a:	00 00 00    	nop       
    329c:	4f 00 00    	nop       
    329e:	00 00 00    	nop       
    32a0:	0a 01 00    	nop       
    32a2:	00 00 00    	nop       
    32a4:	1f 03 00    	nop       
    32a6:	00 00 00    	nop       
    32a8:	6a 0a 00    	nop       
    32aa:	00 00 00    	nop       
    32ac:	3f 1f 00    	nop       
    32ae:	00 00 00    	nop       
    32b0:	7f 3e 00    	nop       
    32b2:	00 00 00    	nop       
    32b4:	3f 9c 00    	nop       
    32b6:	00 00 00    	nop       
    32b8:	0f 27 00    	nop       
    32ba:	10 00 00    	nop       
    32bc:	1f 4e 00    	nop       
    32be:	10 00 00    	nop       
    32c0:	69 18 00    	nop       
    32c2:	20 00 00    	nop       
    32c4:	d3 30 00    	nop       
    32c6:	20 00 00    	nop       
    32c8:	a7 61 00    	nop       
    32ca:	20 00 00    	nop       
    32cc:	08 3d 00    	nop       
    32ce:	30 00 00    	nop       
    32d0:	11 7a 00    	nop       
    32d2:	30 00 00    	nop       
    32d4:	23 f4 00    	nop       
    32d6:	30 00 00    	nop       

000032d8 <clk_table_high>:
    32d8:	09 00 00    	nop       
    32da:	00 00 00    	nop       
    32dc:	09 00 00    	nop       
    32de:	00 00 00    	nop       
    32e0:	09 00 00    	nop       
    32e2:	00 00 00    	nop       
    32e4:	4f 00 00    	nop       
    32e6:	00 00 00    	nop       
    32e8:	09 01 00    	nop       
    32ea:	00 00 00    	nop       
    32ec:	1f 03 00    	nop       
    32ee:	00 00 00    	nop       
    32f0:	3f 06 00    	nop       
    32f2:	00 00 00    	nop       
    32f4:	9f 0f 00    	nop       
    32f6:	00 00 00    	nop       
    32f8:	3f 1f 00    	nop       
    32fa:	00 00 00    	nop       
    32fc:	7f 3e 00    	nop       
    32fe:	00 00 00    	nop       
    3300:	3f 9c 00    	nop       
    3302:	00 00 00    	nop       
    3304:	0f 27 00    	nop       
    3306:	10 00 00    	nop       
    3308:	1f 4e 00    	nop       
    330a:	10 00 00    	nop       
    330c:	69 18 00    	nop       
    330e:	20 00 00    	nop       
    3310:	d3 30 00    	nop       
    3312:	20 00 00    	nop       
    3314:	a7 61 00    	nop       
    3316:	20 00 00    	nop       

00003318 <sync_table>:
    3318:	7f 3e 00    	nop       
    331a:	00 00 00    	nop       
    331c:	2a 68 00    	nop       
    331e:	00 00 00    	nop       
    3320:	3f 9c 00    	nop       
    3322:	00 00 00    	nop       
    3324:	ff f9 00    	nop       
    3326:	00 00 00    	nop       
    3328:	14 34 00    	nop       
    332a:	10 00 00    	nop       
    332c:	1f 4e 00    	nop       
    332e:	10 00 00    	nop       
    3330:	34 82 00    	nop       
    3332:	10 00 00    	nop       
    3334:	4f c3 00    	nop       
    3336:	10 00 00    	nop       
    3338:	0f 27 00    	nop       
    333a:	20 00 00    	nop       
    333c:	1a 41 00    	nop       
    333e:	20 00 00    	nop       
    3340:	a7 61 00    	nop       
    3342:	20 00 00    	nop       
    3344:	c2 a2 00    	nop       
    3346:	20 00 00    	nop       
    3348:	23 f4 00    	nop       
    334a:	20 00 00    	nop       
    334c:	a7 61 00    	nop       
    334e:	30 00 00    	nop       
    3350:	c2 a2 00    	nop       
    3352:	30 00 00    	nop       
    3354:	23 f4 00    	nop       
    3356:	30 00 00    	nop       

00003358 <sync_table_high>:
    3358:	3f 06 00    	nop       
    335a:	00 00 00    	nop       
    335c:	6a 0a 00    	nop       
    335e:	00 00 00    	nop       
    3360:	9f 0f 00    	nop       
    3362:	00 00 00    	nop       
    3364:	ff 18 00    	nop       
    3366:	00 00 00    	nop       
    3368:	34 05 00    	nop       
    336a:	10 00 00    	nop       
    336c:	cf 07 00    	nop       
    336e:	10 00 00    	nop       
    3370:	04 0d 00    	nop       
    3372:	10 00 00    	nop       
    3374:	87 13 00    	nop       
    3376:	10 00 00    	nop       
    3378:	e7 03 00    	nop       
    337a:	20 00 00    	nop       
    337c:	82 06 00    	nop       
    337e:	20 00 00    	nop       
    3380:	c3 09 00    	nop       
    3382:	20 00 00    	nop       
    3384:	46 10 00    	nop       
    3386:	20 00 00    	nop       
    3388:	69 18 00    	nop       
    338a:	20 00 00    	nop       
    338c:	c3 09 00    	nop       
    338e:	30 00 00    	nop       
    3390:	46 10 00    	nop       
    3392:	30 00 00    	nop       
    3394:	69 18 00    	nop       
    3396:	30 00 00    	nop       

00003398 <ss_history>:
; .equ	History,0x0B00	; FIFO buffer, space: 128 × 42 by = 5376 by = 0x1500 by		
;											

ss_history:
	cp0	Insert_Count_0		; if no history inserts...
    3398:	20 09 e2    	cp0.w     0x920
	bra	z,ss_farm		; ...then ignore and return
    339a:	1d f2 32    	bra       Z, 0x17d6 <ss_farm>
	bset	BlinkFlag,#3		; #3 set: LED SS blinks
    339c:	e0 69 a8    	bset.b    0x9e0, #0x3
	bset	Flag,#5			; #5 set: in HISTORY mode
    339e:	dc a9 a8    	bset.b    0x9dc, #0x5

000033a0 <history_pos_1>:
history_pos_1:
	mov	#1,w0
    33a0:	10 00 20    	mov.w     #0x1, w0
	mov	w0,History_Ptr
    33a2:	f0 48 88    	mov.w     w0, 0x91e

000033a4 <history_farm>:
history_farm:
	cp0	History_Ptr
    33a4:	1e 09 e2    	cp0.w     0x91e
	bra	z,history_exit
    33a6:	24 00 32    	bra       Z, 0x33f0 <history_exit>
	call	unpack_ptr		; unpack from History buffer, pos History_Ptr
    33a8:	8a 34 02    	call      0x348a <unpack_ptr>
    33aa:	00 00 00 

000033ac <wait_key_hist>:
wait_key_hist:				; <---------------
	btss	Flag,#1
    33ac:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	wait_key_hist
    33ae:	fe ff 37    	bra       0x33ac <wait_key_hist>
	bclr	Flag,#1
    33b0:	dc 29 a9    	bclr.b    0x9dc, #0x1

	mov	Just,w4
    33b2:	34 4d 80    	mov.w     0x9a6, w4
	cp	w4,#1
    33b4:	61 20 e1    	cp.w      w4, #0x1
	bra	z,history_pos_1		; key History again: go pos 1  ---------------->
    33b6:	f4 ff 32    	bra       Z, 0x33a0 <history_pos_1>
	cp	w4,#2
    33b8:	62 20 e1    	cp.w      w4, #0x2
	bra	nz,not_hist_minus
    33ba:	0d 00 3a    	bra       NZ, 0x33d6 <not_hist_minus>
;  - ADDR 				
	  inc	  History_Ptr		  ; ++
    33bc:	1e 29 ec    	inc.w     0x91e
	  mov	  History_Ptr,w0
    33be:	f0 48 80    	mov.w     0x91e, w0
	  mov	  Insert_Count_0,w2	  ; count of 24by packets inserted in History buffer from reset
    33c0:	02 49 80    	mov.w     0x920, w2
	  inc	  w2,w2
    33c2:	02 01 e8    	inc.w     w2, w2

	  cp	  w0,w2
    33c4:	02 00 e1    	cp.w      w0, w2
	  bra	  nc,1f			  ; if [History_Ptr] >= [Insert_Count_0] then...
    33c6:	04 00 39    	bra       NC, 0x33d0 <L134>
	  dec	  History_Ptr		  ; ...clip [history ptr] to [Insert_Count_0] max
    33c8:	1e 29 ed    	dec.w     0x91e
	  bset	  History_A16,#b_load	  ; ...and also LED ADDR+ ON
    33ca:	0d c9 a8    	bset.b    0x90d, #0x6

000033cc <L210>:
2:
	  btss	  KeyRotors+6,#0
    33cc:	84 09 ae    	btss.b    0x984, #0x0
	  bra	  2b			  ; loop and wait for key released
    33ce:	fe ff 37    	bra       0x33cc <L210>

000033d0 <L134>:
1:
	  call	  unpack_ptr		  ; UNPACK
    33d0:	8a 34 02    	call      0x348a <unpack_ptr>
    33d2:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    33d4:	e7 ff 37    	bra       0x33a4 <history_farm>

000033d6 <not_hist_minus>:
not_hist_minus:
	cp	w4,#3
    33d6:	63 20 e1    	cp.w      w4, #0x3
	bra	nz,not_hist_plus
    33d8:	09 00 3a    	bra       NZ, 0x33ec <not_hist_plus>
;  ADDR	+			
	  dec	  History_Ptr		  ; --
    33da:	1e 29 ed    	dec.w     0x91e
	  bra	  nz,1f			  ; if [History_Ptr] = 0 then...
    33dc:	04 00 3a    	bra       NZ, 0x33e6 <L135>
	  inc	  History_Ptr		  ; ...restore to 1, as history ptr can't reach 0
    33de:	1e 29 ec    	inc.w     0x91e
	  bset	  History_A16,#b_save	  ; ...and also LED ADDR- ON
    33e0:	0d a9 a8    	bset.b    0x90d, #0x5

000033e2 <L211>:
2:
	  btss	  KeyRotors+4,#0
    33e2:	82 09 ae    	btss.b    0x982, #0x0
	  bra	  2b			  ; loop and wait for key released
    33e4:	fe ff 37    	bra       0x33e2 <L211>

000033e6 <L135>:
1:
	  call	  unpack_ptr		  ; UNPACK
    33e6:	8a 34 02    	call      0x348a <unpack_ptr>
    33e8:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    33ea:	dc ff 37    	bra       0x33a4 <history_farm>

000033ec <not_hist_plus>:
not_hist_plus:
	cp	w4,#4
    33ec:	64 20 e1    	cp.w      w4, #0x4
	bra	nz,wait_key_hist	; no valid key hit, loop  ---------------->
    33ee:	de ff 3a    	bra       NZ, 0x33ac <wait_key_hist>

000033f0 <history_exit>:
history_exit:
	clr	History_Ptr
    33f0:	1e 29 ef    	clr.w     0x91e
	bra	ss_farm
    33f2:	f1 f1 37    	bra       0x17d6 <ss_farm>

000033f4 <insert>:

; -----------------------------------------------------------------------------------
; -----------------------------------------------------------------------------------

; --------------------------------------------------  PACK
; shift buffer up, pack and insert new 21 by (DO NOT USE w5...w15)
insert:			; insert Ram current, Ram page 0 and variables to start of History
; shift FIFO up, to make room for one packet (21 by)
	mov	#History+0x14FE-42,w1
    33f4:	41 fd 21    	mov.w     #0x1fd4, w1
	mov	#History+0x14FE,w2
    33f6:	e2 ff 21    	mov.w     #0x1ffe, w2
	repeat	#2667-1		; 127 × 42 = 5334 bytes = 2667 words to move
    33f8:	6a 0a 09    	repeat    #0xa6a
	mov	[w1--],[w2--]	; shift history buffer up
    33fa:	21 11 78    	mov.w     [w1--], [w2--]
	inc	Insert_Count_0
    33fc:	20 29 ec    	inc.w     0x920
	btsc	Insert_Count_0,#7
    33fe:	20 e9 af    	btsc.b    0x920, #0x7
	dec	Insert_Count_0
    3400:	20 29 ed    	dec.w     0x920

00003402 <pack>:
; pack proc variables and visible Ram to start of history buffer 22 bytes
pack:			; pack Ram current, Ram page 0 and variables to start of History
	mov	#History,w3	; w3 = history buffer physical address
    3402:	03 b0 20    	mov.w     #0xb00, w3
; --------------------------------------- 0...15 ----- STEP 1: page 0
	mov	#Ram+1,w2
    3404:	12 80 20    	mov.w     #0x801, w2
	add	w2,#16,w1
    3406:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    3408:	84 00 20    	mov.w     #0x8, w4

0000340a <pack_loop_1>:
pack_loop_1:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    340a:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    340c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    340e:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    3410:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    3412:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    3414:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    3416:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    3418:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    341a:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    341c:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    341e:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_1	; loop
    3420:	f4 ff 3a    	bra       NZ, 0x340a <pack_loop_1>
; -------------------------------------- 16...31 ----- STEP 2: current page
	mov	#Ram+1,w2
    3422:	12 80 20    	mov.w     #0x801, w2
	mov.b	Page,WREG
    3424:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    3426:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; ×16
    3428:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w2,w0,w2
    342a:	00 01 41    	add.w     w2, w0, w2
	add	w2,#16,w1
    342c:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    342e:	84 00 20    	mov.w     #0x8, w4
; if Page>15 then wrap to 0
	mov.b	Page,WREG
    3430:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    3432:	00 80 fb    	ze        w0, w0
	cp	w0,#15
    3434:	6f 00 e1    	cp.w      w0, #0xf
	ifz
    3436:	42 20 af    	btsc.b    0x42, #0x1
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    3438:	01 10 b1    	sub.w     #0x100, w1

0000343a <pack_loop_2>:
pack_loop_2:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    343a:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    343c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    343e:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    3440:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    3442:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    3444:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    3446:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    3448:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    344a:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    344c:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    344e:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_2	; loop
    3450:	f4 ff 3a    	bra       NZ, 0x343a <pack_loop_2>
; -------------------------------------- 32...35 ----- STEP 3: A16 and w9 (no pack)
	mov	A16,w0
    3452:	70 4d 80    	mov.w     0x9ae, w0
	mov	w0,[w3++]	; store
    3454:	80 19 78    	mov.w     w0, [w3++]
	mov	w9,[w3++]	; store
    3456:	89 19 78    	mov.w     w9, [w3++]
; ---------------------------------------- 36,37 ----- STEP 4: w11, w12, w13, w14
	mov	w11,w0
    3458:	0b 00 78    	mov.w     w11, w0
	sl	w0,#4,w0
    345a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w12,w0
    345c:	0c 40 70    	ior.b     w0, w12, w0
	sl	w0,#4,w0
    345e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w13,w0
    3460:	0d 40 70    	ior.b     w0, w13, w0
	sl	w0,#4,w0
    3462:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w14,w0
    3464:	0e 40 70    	ior.b     w0, w14, w0
	mov	w0,[w3++]	; store
    3466:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 38,39 ----- STEP 5: Atemp,Page,Sync,Speed
	mov	Atemp,w0
    3468:	40 49 80    	mov.w     0x928, w0
	sl	w0,#4,w0
    346a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG
    346c:	f0 48 b7    	ior.b     0x8f0, WREG
	sl	w0,#4,w0
    346e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Sync,WREG
    3470:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0
    3472:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG
    3474:	f1 48 b7    	ior.b     0x8f1, WREG
	mov	w0,[w3++]	; store
    3476:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 40,41 ----- STEP 6: V/Z/Cflag, Stack
	mov	Vflag,w0
    3478:	80 49 80    	mov.w     0x930, w0
	sl	w0,#3,w0
    347a:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Zflag,WREG
    347c:	2e 49 b7    	ior.b     0x92e, WREG
	sl	w0,#3,w0
    347e:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Cflag,WREG
    3480:	2c 49 b7    	ior.b     0x92c, WREG
	sl	w0,#3,w0
    3482:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Stack,WREG
    3484:	2a 49 b7    	ior.b     0x92a, WREG
	mov	w0,[w3++]	; store
    3486:	80 19 78    	mov.w     w0, [w3++]
; ----------------------------------------------------
	return
    3488:	00 00 06    	return    

0000348a <unpack_ptr>:
; ----------------------------------------------------  UNPACK
; unpack from History_Ptr
unpack_ptr:		; unpack using History_Ptr as input
	dec	History_Ptr,WREG
    348a:	1e 09 ed    	dec.w     0x91e, WREG
	mov	#42,w1
    348c:	a1 02 20    	mov.w     #0x2a, w1
	mul.uu	w0,w1,w0	; w0 × 42 ---> w0:w1
    348e:	01 00 b8    	mul.uu    w0, w1, w0
	mov	#History,w1
    3490:	01 b0 20    	mov.w     #0xb00, w1
	add	w0,w1,w2	; w2 = #History + 42 × (History_Ptr-1)
    3492:	01 01 40    	add.w     w0, w1, w2

00003494 <unpack>:
; unpack from history buffer [w2] 42 bytes to proc variables (Ram ---> History_Visible)
unpack:			; unpack using w2 as pointer
	mov	w2,History_Visible
    3494:	02 48 88    	mov.w     w2, 0x900
	add	#32,w2		; skip History Ram, only pointer was needed
    3496:	02 02 b0    	add.w     #0x20, w2
	mov	[w2++],w0	; Packet start + 32
    3498:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_A16
    349a:	60 48 88    	mov.w     w0, 0x90c
	mov	[w2++],w0	; Packet start + 34
    349c:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_w9
    349e:	10 48 88    	mov.w     w0, 0x902
	mov	[w2++],w0	; Packet start + 36
    34a0:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    34a2:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_w14
    34a4:	51 48 88    	mov.w     w1, 0x90a
	lsr	w0,#4,w1
    34a6:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    34a8:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w13
    34aa:	41 48 88    	mov.w     w1, 0x908
	lsr	w0,#8,w1
    34ac:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    34ae:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w12
    34b0:	31 48 88    	mov.w     w1, 0x906
	lsr	w0,#12,w1
    34b2:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    34b4:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w11
    34b6:	21 48 88    	mov.w     w1, 0x904
	mov	[w2++],w0	; Packet start + 38
    34b8:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    34ba:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_Speed
    34bc:	a1 48 88    	mov.w     w1, 0x914
	lsr	w0,#4,w1
    34be:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    34c0:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Sync
    34c2:	91 48 88    	mov.w     w1, 0x912
	lsr	w0,#8,w1
    34c4:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    34c6:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Page
    34c8:	81 48 88    	mov.w     w1, 0x910
	lsr	w0,#12,w1
    34ca:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    34cc:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Atemp
    34ce:	71 48 88    	mov.w     w1, 0x90e
	mov	[w2++],w0	; Packet start + 40
    34d0:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x07,w1
    34d2:	e7 00 60    	and.w     w0, #0x7, w1
	mov	w1,History_Stack
    34d4:	e1 48 88    	mov.w     w1, 0x91c
	lsr	w0,#3,w1
    34d6:	c3 00 de    	lsr.w     w0, #0x3, w1
	and	w1,#0x07,w1
    34d8:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Cflag
    34da:	d1 48 88    	mov.w     w1, 0x91a
	lsr	w0,#6,w1
    34dc:	c6 00 de    	lsr.w     w0, #0x6, w1
	and	w1,#0x07,w1
    34de:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Zflag
    34e0:	c1 48 88    	mov.w     w1, 0x918
	lsr	w0,#9,w1
    34e2:	c9 00 de    	lsr.w     w0, #0x9, w1
	and	w1,#0x07,w1
    34e4:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Vflag
    34e6:	b1 48 88    	mov.w     w1, 0x916
	return
    34e8:	00 00 06    	return    

000034ea <table_adder>:
    34ea:	00 02 00    	nop       
    34ec:	10 00 00    	nop       
    34ee:	10 00 00    	nop       
    34f0:	21 00 00    	nop       
    34f2:	20 00 00    	nop       
    34f4:	30 00 00    	nop       
    34f6:	30 00 00    	nop       
    34f8:	43 00 00    	nop       
    34fa:	40 00 00    	nop       
    34fc:	50 00 00    	nop       
    34fe:	50 00 00    	nop       
    3500:	61 00 00    	nop       
    3502:	60 00 00    	nop       
    3504:	70 00 00    	nop       
    3506:	70 00 00    	nop       
    3508:	87 04 00    	nop       
    350a:	80 00 00    	nop       
    350c:	90 00 00    	nop       
    350e:	90 00 00    	nop       
    3510:	a1 00 00    	nop       
    3512:	a0 00 00    	nop       
    3514:	b0 00 00    	nop       
    3516:	b0 00 00    	nop       
    3518:	c3 00 00    	nop       
    351a:	c0 00 00    	nop       
    351c:	d0 00 00    	nop       
    351e:	d0 00 00    	nop       
    3520:	e1 00 00    	nop       
    3522:	e0 00 00    	nop       
    3524:	f0 00 00    	nop       
    3526:	f0 00 00    	nop       
    3528:	0f 03 00    	nop       
    352a:	10 00 00    	nop       
    352c:	21 00 00    	nop       
    352e:	21 00 00    	nop       
    3530:	31 00 00    	nop       
    3532:	30 00 00    	nop       
    3534:	43 00 00    	nop       
    3536:	43 00 00    	nop       
    3538:	53 00 00    	nop       
    353a:	50 00 00    	nop       
    353c:	61 00 00    	nop       
    353e:	61 00 00    	nop       
    3540:	71 00 00    	nop       
    3542:	70 00 00    	nop       
    3544:	87 04 00    	nop       
    3546:	87 04 00    	nop       
    3548:	97 04 00    	nop       
    354a:	90 00 00    	nop       
    354c:	a1 00 00    	nop       
    354e:	a1 00 00    	nop       
    3550:	b1 00 00    	nop       
    3552:	b0 00 00    	nop       
    3554:	c3 00 00    	nop       
    3556:	c3 00 00    	nop       
    3558:	d3 00 00    	nop       
    355a:	d0 00 00    	nop       
    355c:	e1 00 00    	nop       
    355e:	e1 00 00    	nop       
    3560:	f1 00 00    	nop       
    3562:	f0 00 00    	nop       
    3564:	0f 03 00    	nop       
    3566:	0f 03 00    	nop       
    3568:	1f 01 00    	nop       
    356a:	20 00 00    	nop       
    356c:	30 00 00    	nop       
    356e:	30 00 00    	nop       
    3570:	43 00 00    	nop       
    3572:	42 00 00    	nop       
    3574:	52 00 00    	nop       
    3576:	52 00 00    	nop       
    3578:	63 00 00    	nop       
    357a:	60 00 00    	nop       
    357c:	70 00 00    	nop       
    357e:	70 00 00    	nop       
    3580:	87 04 00    	nop       
    3582:	86 04 00    	nop       
    3584:	96 04 00    	nop       
    3586:	96 04 00    	nop       
    3588:	a7 04 00    	nop       
    358a:	a0 00 00    	nop       
    358c:	b0 00 00    	nop       
    358e:	b0 00 00    	nop       
    3590:	c3 00 00    	nop       
    3592:	c2 00 00    	nop       
    3594:	d2 00 00    	nop       
    3596:	d2 00 00    	nop       
    3598:	e3 00 00    	nop       
    359a:	e0 00 00    	nop       
    359c:	f0 00 00    	nop       
    359e:	f0 00 00    	nop       
    35a0:	0f 03 00    	nop       
    35a2:	0e 03 00    	nop       
    35a4:	1e 01 00    	nop       
    35a6:	1e 01 00    	nop       
    35a8:	2f 01 00    	nop       
    35aa:	30 00 00    	nop       
    35ac:	43 00 00    	nop       
    35ae:	43 00 00    	nop       
    35b0:	53 00 00    	nop       
    35b2:	52 00 00    	nop       
    35b4:	63 00 00    	nop       
    35b6:	63 00 00    	nop       
    35b8:	73 00 00    	nop       
    35ba:	70 00 00    	nop       
    35bc:	87 04 00    	nop       
    35be:	87 04 00    	nop       
    35c0:	97 04 00    	nop       
    35c2:	96 04 00    	nop       
    35c4:	a7 04 00    	nop       
    35c6:	a7 04 00    	nop       
    35c8:	b7 04 00    	nop       
    35ca:	b0 00 00    	nop       
    35cc:	c3 00 00    	nop       
    35ce:	c3 00 00    	nop       
    35d0:	d3 00 00    	nop       
    35d2:	d2 00 00    	nop       
    35d4:	e3 00 00    	nop       
    35d6:	e3 00 00    	nop       
    35d8:	f3 00 00    	nop       
    35da:	f0 00 00    	nop       
    35dc:	0f 03 00    	nop       
    35de:	0f 03 00    	nop       
    35e0:	1f 01 00    	nop       
    35e2:	1e 01 00    	nop       
    35e4:	2f 01 00    	nop       
    35e6:	2f 01 00    	nop       
    35e8:	3f 01 00    	nop       
    35ea:	40 00 00    	nop       
    35ec:	50 00 00    	nop       
    35ee:	50 00 00    	nop       
    35f0:	61 00 00    	nop       
    35f2:	60 00 00    	nop       
    35f4:	70 00 00    	nop       
    35f6:	70 00 00    	nop       
    35f8:	87 04 00    	nop       
    35fa:	84 04 00    	nop       
    35fc:	94 04 00    	nop       
    35fe:	94 04 00    	nop       
    3600:	a5 04 00    	nop       
    3602:	a4 04 00    	nop       
    3604:	b4 04 00    	nop       
    3606:	b4 04 00    	nop       
    3608:	c7 04 00    	nop       
    360a:	c0 00 00    	nop       
    360c:	d0 00 00    	nop       
    360e:	d0 00 00    	nop       
    3610:	e1 00 00    	nop       
    3612:	e0 00 00    	nop       
    3614:	f0 00 00    	nop       
    3616:	f0 00 00    	nop       
    3618:	0f 03 00    	nop       
    361a:	0c 03 00    	nop       
    361c:	1c 01 00    	nop       
    361e:	1c 01 00    	nop       
    3620:	2d 01 00    	nop       
    3622:	2c 01 00    	nop       
    3624:	3c 01 00    	nop       
    3626:	3c 01 00    	nop       
    3628:	4f 01 00    	nop       
    362a:	50 00 00    	nop       
    362c:	61 00 00    	nop       
    362e:	61 00 00    	nop       
    3630:	71 00 00    	nop       
    3632:	70 00 00    	nop       
    3634:	87 04 00    	nop       
    3636:	87 04 00    	nop       
    3638:	97 04 00    	nop       
    363a:	94 04 00    	nop       
    363c:	a5 04 00    	nop       
    363e:	a5 04 00    	nop       
    3640:	b5 04 00    	nop       
    3642:	b4 04 00    	nop       
    3644:	c7 04 00    	nop       
    3646:	c7 04 00    	nop       
    3648:	d7 04 00    	nop       
    364a:	d0 00 00    	nop       
    364c:	e1 00 00    	nop       
    364e:	e1 00 00    	nop       
    3650:	f1 00 00    	nop       
    3652:	f0 00 00    	nop       
    3654:	0f 03 00    	nop       
    3656:	0f 03 00    	nop       
    3658:	1f 01 00    	nop       
    365a:	1c 01 00    	nop       
    365c:	2d 01 00    	nop       
    365e:	2d 01 00    	nop       
    3660:	3d 01 00    	nop       
    3662:	3c 01 00    	nop       
    3664:	4f 01 00    	nop       
    3666:	4f 01 00    	nop       
    3668:	5f 01 00    	nop       
    366a:	60 00 00    	nop       
    366c:	70 00 00    	nop       
    366e:	70 00 00    	nop       
    3670:	87 04 00    	nop       
    3672:	86 04 00    	nop       
    3674:	96 04 00    	nop       
    3676:	96 04 00    	nop       
    3678:	a7 04 00    	nop       
    367a:	a4 04 00    	nop       
    367c:	b4 04 00    	nop       
    367e:	b4 04 00    	nop       
    3680:	c7 04 00    	nop       
    3682:	c6 04 00    	nop       
    3684:	d6 04 00    	nop       
    3686:	d6 04 00    	nop       
    3688:	e7 04 00    	nop       
    368a:	e0 00 00    	nop       
    368c:	f0 00 00    	nop       
    368e:	f0 00 00    	nop       
    3690:	0f 03 00    	nop       
    3692:	0e 03 00    	nop       
    3694:	1e 01 00    	nop       
    3696:	1e 01 00    	nop       
    3698:	2f 01 00    	nop       
    369a:	2c 01 00    	nop       
    369c:	3c 01 00    	nop       
    369e:	3c 01 00    	nop       
    36a0:	4f 01 00    	nop       
    36a2:	4e 01 00    	nop       
    36a4:	5e 01 00    	nop       
    36a6:	5e 01 00    	nop       
    36a8:	6f 01 00    	nop       
    36aa:	70 00 00    	nop       
    36ac:	87 04 00    	nop       
    36ae:	87 04 00    	nop       
    36b0:	97 04 00    	nop       
    36b2:	96 04 00    	nop       
    36b4:	a7 04 00    	nop       
    36b6:	a7 04 00    	nop       
    36b8:	b7 04 00    	nop       
    36ba:	b4 04 00    	nop       
    36bc:	c7 04 00    	nop       
    36be:	c7 04 00    	nop       
    36c0:	d7 04 00    	nop       
    36c2:	d6 04 00    	nop       
    36c4:	e7 04 00    	nop       
    36c6:	e7 04 00    	nop       
    36c8:	f7 04 00    	nop       
    36ca:	f0 00 00    	nop       
    36cc:	0f 03 00    	nop       
    36ce:	0f 03 00    	nop       
    36d0:	1f 01 00    	nop       
    36d2:	1e 01 00    	nop       
    36d4:	2f 01 00    	nop       
    36d6:	2f 01 00    	nop       
    36d8:	3f 01 00    	nop       
    36da:	3c 01 00    	nop       
    36dc:	4f 01 00    	nop       
    36de:	4f 01 00    	nop       
    36e0:	5f 01 00    	nop       
    36e2:	5e 01 00    	nop       
    36e4:	6f 01 00    	nop       
    36e6:	6f 01 00    	nop       
    36e8:	7f 01 00    	nop       
    36ea:	80 00 00    	nop       
    36ec:	90 00 00    	nop       
    36ee:	90 00 00    	nop       
    36f0:	a1 00 00    	nop       
    36f2:	a0 00 00    	nop       
    36f4:	b0 00 00    	nop       
    36f6:	b0 00 00    	nop       
    36f8:	c3 00 00    	nop       
    36fa:	c0 00 00    	nop       
    36fc:	d0 00 00    	nop       
    36fe:	d0 00 00    	nop       
    3700:	e1 00 00    	nop       
    3702:	e0 00 00    	nop       
    3704:	f0 00 00    	nop       
    3706:	f0 00 00    	nop       
    3708:	0f 03 00    	nop       
    370a:	08 07 00    	nop       
    370c:	18 05 00    	nop       
    370e:	18 05 00    	nop       
    3710:	29 05 00    	nop       
    3712:	28 05 00    	nop       
    3714:	38 05 00    	nop       
    3716:	38 05 00    	nop       
    3718:	4b 05 00    	nop       
    371a:	48 05 00    	nop       
    371c:	58 05 00    	nop       
    371e:	58 05 00    	nop       
    3720:	69 05 00    	nop       
    3722:	68 05 00    	nop       
    3724:	78 05 00    	nop       
    3726:	78 05 00    	nop       
    3728:	8f 01 00    	nop       
    372a:	90 00 00    	nop       
    372c:	a1 00 00    	nop       
    372e:	a1 00 00    	nop       
    3730:	b1 00 00    	nop       
    3732:	b0 00 00    	nop       
    3734:	c3 00 00    	nop       
    3736:	c3 00 00    	nop       
    3738:	d3 00 00    	nop       
    373a:	d0 00 00    	nop       
    373c:	e1 00 00    	nop       
    373e:	e1 00 00    	nop       
    3740:	f1 00 00    	nop       
    3742:	f0 00 00    	nop       
    3744:	0f 03 00    	nop       
    3746:	0f 03 00    	nop       
    3748:	1f 01 00    	nop       
    374a:	18 05 00    	nop       
    374c:	29 05 00    	nop       
    374e:	29 05 00    	nop       
    3750:	39 05 00    	nop       
    3752:	38 05 00    	nop       
    3754:	4b 05 00    	nop       
    3756:	4b 05 00    	nop       
    3758:	5b 05 00    	nop       
    375a:	58 05 00    	nop       
    375c:	69 05 00    	nop       
    375e:	69 05 00    	nop       
    3760:	79 05 00    	nop       
    3762:	78 05 00    	nop       
    3764:	8f 01 00    	nop       
    3766:	8f 01 00    	nop       
    3768:	9f 01 00    	nop       
    376a:	a0 00 00    	nop       
    376c:	b0 00 00    	nop       
    376e:	b0 00 00    	nop       
    3770:	c3 00 00    	nop       
    3772:	c2 00 00    	nop       
    3774:	d2 00 00    	nop       
    3776:	d2 00 00    	nop       
    3778:	e3 00 00    	nop       
    377a:	e0 00 00    	nop       
    377c:	f0 00 00    	nop       
    377e:	f0 00 00    	nop       
    3780:	0f 03 00    	nop       
    3782:	0e 03 00    	nop       
    3784:	1e 01 00    	nop       
    3786:	1e 01 00    	nop       
    3788:	2f 01 00    	nop       
    378a:	28 05 00    	nop       
    378c:	38 05 00    	nop       
    378e:	38 05 00    	nop       
    3790:	4b 05 00    	nop       
    3792:	4a 05 00    	nop       
    3794:	5a 05 00    	nop       
    3796:	5a 05 00    	nop       
    3798:	6b 05 00    	nop       
    379a:	68 05 00    	nop       
    379c:	78 05 00    	nop       
    379e:	78 05 00    	nop       
    37a0:	8f 01 00    	nop       
    37a2:	8e 01 00    	nop       
    37a4:	9e 01 00    	nop       
    37a6:	9e 01 00    	nop       
    37a8:	af 01 00    	nop       
    37aa:	b0 00 00    	nop       
    37ac:	c3 00 00    	nop       
    37ae:	c3 00 00    	nop       
    37b0:	d3 00 00    	nop       
    37b2:	d2 00 00    	nop       
    37b4:	e3 00 00    	nop       
    37b6:	e3 00 00    	nop       
    37b8:	f3 00 00    	nop       
    37ba:	f0 00 00    	nop       
    37bc:	0f 03 00    	nop       
    37be:	0f 03 00    	nop       
    37c0:	1f 01 00    	nop       
    37c2:	1e 01 00    	nop       
    37c4:	2f 01 00    	nop       
    37c6:	2f 01 00    	nop       
    37c8:	3f 01 00    	nop       
    37ca:	38 05 00    	nop       
    37cc:	4b 05 00    	nop       
    37ce:	4b 05 00    	nop       
    37d0:	5b 05 00    	nop       
    37d2:	5a 05 00    	nop       
    37d4:	6b 05 00    	nop       
    37d6:	6b 05 00    	nop       
    37d8:	7b 05 00    	nop       
    37da:	78 05 00    	nop       
    37dc:	8f 01 00    	nop       
    37de:	8f 01 00    	nop       
    37e0:	9f 01 00    	nop       
    37e2:	9e 01 00    	nop       
    37e4:	af 01 00    	nop       
    37e6:	af 01 00    	nop       
    37e8:	bf 01 00    	nop       
    37ea:	c0 00 00    	nop       
    37ec:	d0 00 00    	nop       
    37ee:	d0 00 00    	nop       
    37f0:	e1 00 00    	nop       
    37f2:	e0 00 00    	nop       
    37f4:	f0 00 00    	nop       
    37f6:	f0 00 00    	nop       
    37f8:	0f 03 00    	nop       
    37fa:	0c 03 00    	nop       
    37fc:	1c 01 00    	nop       
    37fe:	1c 01 00    	nop       
    3800:	2d 01 00    	nop       
    3802:	2c 01 00    	nop       
    3804:	3c 01 00    	nop       
    3806:	3c 01 00    	nop       
    3808:	4f 01 00    	nop       
    380a:	48 05 00    	nop       
    380c:	58 05 00    	nop       
    380e:	58 05 00    	nop       
    3810:	69 05 00    	nop       
    3812:	68 05 00    	nop       
    3814:	78 05 00    	nop       
    3816:	78 05 00    	nop       
    3818:	8f 01 00    	nop       
    381a:	8c 01 00    	nop       
    381c:	9c 01 00    	nop       
    381e:	9c 01 00    	nop       
    3820:	ad 01 00    	nop       
    3822:	ac 01 00    	nop       
    3824:	bc 01 00    	nop       
    3826:	bc 01 00    	nop       
    3828:	cf 01 00    	nop       
    382a:	d0 00 00    	nop       
    382c:	e1 00 00    	nop       
    382e:	e1 00 00    	nop       
    3830:	f1 00 00    	nop       
    3832:	f0 00 00    	nop       
    3834:	0f 03 00    	nop       
    3836:	0f 03 00    	nop       
    3838:	1f 01 00    	nop       
    383a:	1c 01 00    	nop       
    383c:	2d 01 00    	nop       
    383e:	2d 01 00    	nop       
    3840:	3d 01 00    	nop       
    3842:	3c 01 00    	nop       
    3844:	4f 01 00    	nop       
    3846:	4f 01 00    	nop       
    3848:	5f 01 00    	nop       
    384a:	58 05 00    	nop       
    384c:	69 05 00    	nop       
    384e:	69 05 00    	nop       
    3850:	79 05 00    	nop       
    3852:	78 05 00    	nop       
    3854:	8f 01 00    	nop       
    3856:	8f 01 00    	nop       
    3858:	9f 01 00    	nop       
    385a:	9c 01 00    	nop       
    385c:	ad 01 00    	nop       
    385e:	ad 01 00    	nop       
    3860:	bd 01 00    	nop       
    3862:	bc 01 00    	nop       
    3864:	cf 01 00    	nop       
    3866:	cf 01 00    	nop       
    3868:	df 01 00    	nop       
    386a:	e0 00 00    	nop       
    386c:	f0 00 00    	nop       
    386e:	f0 00 00    	nop       
    3870:	0f 03 00    	nop       
    3872:	0e 03 00    	nop       
    3874:	1e 01 00    	nop       
    3876:	1e 01 00    	nop       
    3878:	2f 01 00    	nop       
    387a:	2c 01 00    	nop       
    387c:	3c 01 00    	nop       
    387e:	3c 01 00    	nop       
    3880:	4f 01 00    	nop       
    3882:	4e 01 00    	nop       
    3884:	5e 01 00    	nop       
    3886:	5e 01 00    	nop       
    3888:	6f 01 00    	nop       
    388a:	68 05 00    	nop       
    388c:	78 05 00    	nop       
    388e:	78 05 00    	nop       
    3890:	8f 01 00    	nop       
    3892:	8e 01 00    	nop       
    3894:	9e 01 00    	nop       
    3896:	9e 01 00    	nop       
    3898:	af 01 00    	nop       
    389a:	ac 01 00    	nop       
    389c:	bc 01 00    	nop       
    389e:	bc 01 00    	nop       
    38a0:	cf 01 00    	nop       
    38a2:	ce 01 00    	nop       
    38a4:	de 01 00    	nop       
    38a6:	de 01 00    	nop       
    38a8:	ef 01 00    	nop       
    38aa:	f0 00 00    	nop       
    38ac:	0f 03 00    	nop       
    38ae:	0f 03 00    	nop       
    38b0:	1f 01 00    	nop       
    38b2:	1e 01 00    	nop       
    38b4:	2f 01 00    	nop       
    38b6:	2f 01 00    	nop       
    38b8:	3f 01 00    	nop       
    38ba:	3c 01 00    	nop       
    38bc:	4f 01 00    	nop       
    38be:	4f 01 00    	nop       
    38c0:	5f 01 00    	nop       
    38c2:	5e 01 00    	nop       
    38c4:	6f 01 00    	nop       
    38c6:	6f 01 00    	nop       
    38c8:	7f 01 00    	nop       
    38ca:	78 05 00    	nop       
    38cc:	8f 01 00    	nop       
    38ce:	8f 01 00    	nop       
    38d0:	9f 01 00    	nop       
    38d2:	9e 01 00    	nop       
    38d4:	af 01 00    	nop       
    38d6:	af 01 00    	nop       
    38d8:	bf 01 00    	nop       
    38da:	bc 01 00    	nop       
    38dc:	cf 01 00    	nop       
    38de:	cf 01 00    	nop       
    38e0:	df 01 00    	nop       
    38e2:	de 01 00    	nop       
    38e4:	ef 01 00    	nop       
    38e6:	ef 01 00    	nop       
    38e8:	ff 01 00    	nop       
Disassembly of section .dinit:

000038ea <.dinit>:
    38ea:	00 08 00    	nop       
    38ec:	e2 01 00    	nop       
    38ee:	80 00 00    	nop       
    38f0:	00 00 00    	nop       
