
dist\default\production\Badge_firmware.production.elf:     file format elf32-pic30

Disassembly of section .ivt._ADC1Interrupt:

0000002e <.ivt._ADC1Interrupt>:
  2e:	b8 01 00    	nop       
Disassembly of section .ivt._AddressError:

00000006 <.ivt._AddressError>:
   6:	b8 01 00    	nop       
Disassembly of section .ivt._CCP1Interrupt:

00000092 <.ivt._CCP1Interrupt>:
  92:	b8 01 00    	nop       
Disassembly of section .ivt._CCP2Interrupt:

00000094 <.ivt._CCP2Interrupt>:
  94:	b8 01 00    	nop       
Disassembly of section .ivt._CCP3Interrupt:

000000d0 <__FSEC-0x2ae30>:
  d0:	b8 01 00    	nop       
Disassembly of section .ivt._CCP4Interrupt:

000000d2 <__FBSLIM-0x2ae3e>:
  d2:	b8 01 00    	nop       
Disassembly of section .ivt._CCT1Interrupt:

000000de <__FOSCSEL-0x2ae3a>:
  de:	b8 01 00    	nop       
Disassembly of section .ivt._CCT2Interrupt:

000000e0 <__FOSC-0x2ae3c>:
  e0:	b8 01 00    	nop       
Disassembly of section .ivt._CCT3Interrupt:

0000006a <__FWDT-0x2aeb6>:
  6a:	b8 01 00    	nop       
Disassembly of section .ivt._CCT4Interrupt:

0000006c <__FPOR-0x2aeb8>:
  6c:	b8 01 00    	nop       
Disassembly of section .ivt._CLC1Interrupt:

000000d4 <__FICD-0x2ae54>:
  d4:	b8 01 00    	nop       
Disassembly of section .ivt._CLC2Interrupt:

000000d6 <__FDEVOPT1-0x2ae56>:
  d6:	b8 01 00    	nop       
Disassembly of section .ivt._CRCInterrupt:

0000009a <.ivt._CRCInterrupt>:
  9a:	b8 01 00    	nop       
Disassembly of section .ivt._CTMUInterrupt:

000000ae <.ivt._CTMUInterrupt>:
  ae:	b8 01 00    	nop       
Disassembly of section .ivt._CompInterrupt:

00000038 <.ivt._CompInterrupt>:
  38:	b8 01 00    	nop       
Disassembly of section .ivt._DMA0Interrupt:

0000001c <.ivt._DMA0Interrupt>:
  1c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA1Interrupt:

00000030 <.ivt._DMA1Interrupt>:
  30:	b8 01 00    	nop       
Disassembly of section .ivt._DMA2Interrupt:

00000044 <.ivt._DMA2Interrupt>:
  44:	b8 01 00    	nop       
Disassembly of section .ivt._DMA3Interrupt:

0000005c <.ivt._DMA3Interrupt>:
  5c:	b8 01 00    	nop       
Disassembly of section .ivt._DMA4Interrupt:

00000070 <.ivt._DMA4Interrupt>:
  70:	b8 01 00    	nop       
Disassembly of section .ivt._DMA5Interrupt:

0000008e <.ivt._DMA5Interrupt>:
  8e:	b8 01 00    	nop       
Disassembly of section .ivt._ECCInterrupt:

000000ec <.ivt._ECCInterrupt>:
  ec:	b8 01 00    	nop       
Disassembly of section .ivt._FSTInterrupt:

000000e8 <.ivt._FSTInterrupt>:
  e8:	b8 01 00    	nop       
Disassembly of section .ivt._GeneralError:

00000010 <.ivt._GeneralError>:
  10:	b8 01 00    	nop       
Disassembly of section .ivt._I2C1BCInterrupt:

000000bc <.ivt._I2C1BCInterrupt>:
  bc:	b8 01 00    	nop       
Disassembly of section .ivt._I2C2BCInterrupt:

000000be <.ivt._I2C2BCInterrupt>:
  be:	b8 01 00    	nop       
Disassembly of section .ivt._I2C3BCInterrupt:

000000ee <.ivt._I2C3BCInterrupt>:
  ee:	b8 01 00    	nop       
Disassembly of section .ivt._IC1Interrupt:

00000016 <.ivt._IC1Interrupt>:
  16:	b8 01 00    	nop       
Disassembly of section .ivt._IC2Interrupt:

0000001e <.ivt._IC2Interrupt>:
  1e:	b8 01 00    	nop       
Disassembly of section .ivt._IC3Interrupt:

0000005e <.ivt._IC3Interrupt>:
  5e:	b8 01 00    	nop       
Disassembly of section .ivt._INT0Interrupt:

00000014 <.ivt._INT0Interrupt>:
  14:	b8 01 00    	nop       
Disassembly of section .ivt._INT1Interrupt:

0000003c <.ivt._INT1Interrupt>:
  3c:	b8 01 00    	nop       
Disassembly of section .ivt._INT2Interrupt:

0000004e <.ivt._INT2Interrupt>:
  4e:	b8 01 00    	nop       
Disassembly of section .ivt._INT3Interrupt:

0000007e <.ivt._INT3Interrupt>:
  7e:	b8 01 00    	nop       
Disassembly of section .ivt._INT4Interrupt:

00000080 <.ivt._INT4Interrupt>:
  80:	b8 01 00    	nop       
Disassembly of section .ivt._IOCInterrupt:

0000003a <.ivt._IOCInterrupt>:
  3a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt100:

000000dc <.ivt._Interrupt100>:
  dc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt103:

000000e2 <.ivt._Interrupt103>:
  e2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt104:

000000e4 <.ivt._Interrupt104>:
  e4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt105:

000000e6 <.ivt._Interrupt105>:
  e6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt107:

000000ea <.ivt._Interrupt107>:
  ea:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt111:

000000f2 <.ivt._Interrupt111>:
  f2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt112:

000000f4 <.ivt._Interrupt112>:
  f4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt113:

000000f6 <.ivt._Interrupt113>:
  f6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt114:

000000f8 <.ivt._Interrupt114>:
  f8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt115:

000000fa <.ivt._Interrupt115>:
  fa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt116:

000000fc <.ivt._Interrupt116>:
  fc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt21:

0000003e <.ivt._Interrupt21>:
  3e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt22:

00000040 <.ivt._Interrupt22>:
  40:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt23:

00000042 <.ivt._Interrupt23>:
  42:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt26:

00000048 <.ivt._Interrupt26>:
  48:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt27:

0000004a <.ivt._Interrupt27>:
  4a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt28:

0000004c <.ivt._Interrupt28>:
  4c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt34:

00000058 <.ivt._Interrupt34>:
  58:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt35:

0000005a <.ivt._Interrupt35>:
  5a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt38:

00000060 <.ivt._Interrupt38>:
  60:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt39:

00000062 <.ivt._Interrupt39>:
  62:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt40:

00000064 <.ivt._Interrupt40>:
  64:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt47:

00000072 <.ivt._Interrupt47>:
  72:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt48:

00000074 <.ivt._Interrupt48>:
  74:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt51:

0000007a <.ivt._Interrupt51>:
  7a:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt52:

0000007c <.ivt._Interrupt52>:
  7c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt55:

00000082 <.ivt._Interrupt55>:
  82:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt56:

00000084 <.ivt._Interrupt56>:
  84:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt57:

00000086 <.ivt._Interrupt57>:
  86:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt68:

0000009c <.ivt._Interrupt68>:
  9c:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt69:

0000009e <.ivt._Interrupt69>:
  9e:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt70:

000000a0 <.ivt._Interrupt70>:
  a0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt71:

000000a2 <.ivt._Interrupt71>:
  a2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt73:

000000a6 <.ivt._Interrupt73>:
  a6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt74:

000000a8 <.ivt._Interrupt74>:
  a8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt75:

000000aa <.ivt._Interrupt75>:
  aa:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt76:

000000ac <.ivt._Interrupt76>:
  ac:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt78:

000000b0 <.ivt._Interrupt78>:
  b0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt79:

000000b2 <.ivt._Interrupt79>:
  b2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt80:

000000b4 <.ivt._Interrupt80>:
  b4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt81:

000000b6 <.ivt._Interrupt81>:
  b6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt82:

000000b8 <.ivt._Interrupt82>:
  b8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt83:

000000ba <.ivt._Interrupt83>:
  ba:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt86:

000000c0 <.ivt._Interrupt86>:
  c0:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt87:

000000c2 <.ivt._Interrupt87>:
  c2:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt88:

000000c4 <.ivt._Interrupt88>:
  c4:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt89:

000000c6 <.ivt._Interrupt89>:
  c6:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt92:

000000cc <.ivt._Interrupt92>:
  cc:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt93:

000000ce <.ivt._Interrupt93>:
  ce:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt98:

000000d8 <.ivt._Interrupt98>:
  d8:	b8 01 00    	nop       
Disassembly of section .ivt._Interrupt99:

000000da <.ivt._Interrupt99>:
  da:	b8 01 00    	nop       
Disassembly of section .ivt._JTAGInterrupt:

000000fe <.ivt._JTAGInterrupt>:
  fe:	b8 01 00    	nop       
Disassembly of section .ivt._LVDInterrupt:

000000a4 <.ivt._LVDInterrupt>:
  a4:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C1Interrupt:

00000036 <.ivt._MI2C1Interrupt>:
  36:	b8 01 00    	nop       
Disassembly of section .ivt._MI2C2Interrupt:

00000078 <.ivt._MI2C2Interrupt>:
  78:	b8 01 00    	nop       
Disassembly of section .ivt._MathError:

0000000c <.ivt._MathError>:
   c:	b8 01 00    	nop       
Disassembly of section .ivt._NVMError:

00000008 <.ivt._NVMError>:
   8:	b8 01 00    	nop       
Disassembly of section .ivt._NVMInterrupt:

00000032 <.ivt._NVMInterrupt>:
  32:	b8 01 00    	nop       
Disassembly of section .ivt._OC1Interrupt:

00000018 <.ivt._OC1Interrupt>:
  18:	b8 01 00    	nop       
Disassembly of section .ivt._OC2Interrupt:

00000020 <.ivt._OC2Interrupt>:
  20:	b8 01 00    	nop       
Disassembly of section .ivt._OC3Interrupt:

00000046 <.ivt._OC3Interrupt>:
  46:	b8 01 00    	nop       
Disassembly of section .ivt._OC5Interrupt:

00000066 <.ivt._OC5Interrupt>:
  66:	b8 01 00    	nop       
Disassembly of section .ivt._OC6Interrupt:

00000068 <.ivt._OC6Interrupt>:
  68:	b8 01 00    	nop       
Disassembly of section .ivt._OscillatorFail:

00000004 <.ivt._OscillatorFail>:
   4:	b8 01 00    	nop       
Disassembly of section .ivt._PMPInterrupt:

0000006e <.ivt._PMPInterrupt>:
  6e:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCInterrupt:

00000090 <.ivt._RTCCInterrupt>:
  90:	b8 01 00    	nop       
Disassembly of section .ivt._RTCCTSInterrupt:

000000f0 <.ivt._RTCCTSInterrupt>:
  f0:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap5:

0000000e <.ivt._ReservedTrap5>:
   e:	b8 01 00    	nop       
Disassembly of section .ivt._ReservedTrap7:

00000012 <.ivt._ReservedTrap7>:
  12:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C1Interrupt:

00000034 <.ivt._SI2C1Interrupt>:
  34:	b8 01 00    	nop       
Disassembly of section .ivt._SI2C2Interrupt:

00000076 <.ivt._SI2C2Interrupt>:
  76:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1Interrupt:

00000026 <.ivt._SPI1Interrupt>:
  26:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1RXInterrupt:

00000088 <.ivt._SPI1RXInterrupt>:
  88:	b8 01 00    	nop       
Disassembly of section .ivt._SPI1TXInterrupt:

00000028 <.ivt._SPI1TXInterrupt>:
  28:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2Interrupt:

00000054 <.ivt._SPI2Interrupt>:
  54:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2RXInterrupt:

0000008a <.ivt._SPI2RXInterrupt>:
  8a:	b8 01 00    	nop       
Disassembly of section .ivt._SPI2TXInterrupt:

00000056 <.ivt._SPI2TXInterrupt>:
  56:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3Interrupt:

000000c8 <.ivt._SPI3Interrupt>:
  c8:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3RXInterrupt:

0000008c <.ivt._SPI3RXInterrupt>:
  8c:	b8 01 00    	nop       
Disassembly of section .ivt._SPI3TXInterrupt:

000000ca <.ivt._SPI3TXInterrupt>:
  ca:	b8 01 00    	nop       
Disassembly of section .ivt._StackError:

0000000a <.ivt._StackError>:
   a:	b8 01 00    	nop       
Disassembly of section .ivt._T2Interrupt:

00000022 <.ivt._T2Interrupt>:
  22:	b8 01 00    	nop       
Disassembly of section .ivt._U1TXInterrupt:

0000002c <.ivt._U1TXInterrupt>:
  2c:	b8 01 00    	nop       
Disassembly of section .ivt._U2TXInterrupt:

00000052 <.ivt._U2TXInterrupt>:
  52:	b8 01 00    	nop       
Disassembly of section .reset:

00000000 <.reset>:
   0:	04 02 04    	goto      0x204 <__reset>
   2:	00 00 00 
Disassembly of section .text:

00000100 <__long_indirect_call>:
 100:	8a 1f 78    	mov.w     w10, [w15++]
 102:	8b 1f 78    	mov.w     w11, [w15++]
 104:	00 00 06    	return    

00000106 <__data_init>:
 106:	a1 02 88    	mov.w     w1, 0x54
 108:	80 04 78    	mov.w     w0, w9
 10a:	00 00 eb    	clr.w     w0
 10c:	1f 00 37    	bra       0x14c <L41>

0000010e <L11>:
 10e:	e2 84 44    	add.w     w9, #0x2, w9
 110:	54 a0 b4    	addc.w    0x54
 112:	99 05 ba    	tblrdl.w  [w9], w11
 114:	e2 84 44    	add.w     w9, #0x2, w9
 116:	54 a0 b4    	addc.w    0x54
 118:	99 06 ba    	tblrdl.w  [w9], w13
 11a:	e2 84 44    	add.w     w9, #0x2, w9
 11c:	54 a0 b4    	addc.w    0x54
 11e:	00 06 eb    	clr.w     w12
 120:	47 6f de    	lsr.w     w13, #0x7, w14
 122:	fd 07 b2    	and.w     #0x7f, w13
 124:	ae 01 88    	mov.w     w14, 0x34
 126:	63 6c e1    	cp.b      w13, #0x3
 128:	03 00 3a    	bra       NZ, 0x130 <L21>
 12a:	ea ff 07    	rcall     0x100 <__long_indirect_call>
 12c:	00 00 eb    	clr.w     w0
 12e:	0e 00 37    	bra       0x14c <L41>

00000130 <L21>:
 130:	60 6c e1    	cp.b      w13, #0x0
 132:	08 00 3a    	bra       NZ, 0x144 <L22>

00000134 <L91>:
 134:	00 4d eb    	clr.b     [w10]
 136:	0a 05 e8    	inc.w     w10, w10
 138:	02 00 39    	bra       NC, 0x13e <L81>
 13a:	34 20 ec    	inc.w     0x34
 13c:	0a f0 a0    	bset.w    w10, #0xf

0000013e <L81>:
 13e:	8b 05 e9    	dec.w     w11, w11
 140:	f9 ff 3e    	bra       GTU, 0x134 <L91>
 142:	04 00 37    	bra       0x14c <L41>

00000144 <L22>:
 144:	61 68 e1    	cp.w      w13, #0x1
 146:	01 00 32    	bra       Z, 0x14a <L31>
 148:	00 86 eb    	setm.w    w12

0000014a <L31>:
 14a:	0b 00 07    	rcall     0x162 <L13> <__memcpyd3extended>

0000014c <L41>:
 14c:	19 c7 ba    	tblrdh.b  [w9], w14
 14e:	19 05 ba    	tblrdl.w  [w9], w10
 150:	0e 04 e0    	cp0.b     w14
 152:	03 00 3a    	bra       NZ, 0x15a <L12>
 154:	0a 00 e0    	cp0.w     w10
 156:	db ff 3a    	bra       NZ, 0x10e <L11>
 158:	00 00 06    	return    

0000015a <L12>:
 15a:	fe 07 b2    	and.w     #0x7f, w14
 15c:	ae 02 88    	mov.w     w14, 0x54
 15e:	8a 04 78    	mov.w     w10, w9
 160:	f5 ff 37    	bra       0x14c <L41>

00000162 <L13>:
 162:	0c d0 a3    	btst.c    w12, #0xd
 164:	e2 0f 4d    	addc.w    w10, #0x2, [w15]
 166:	1c 00 39    	bra       NC, 0x1a0 <L23>
 168:	89 02 78    	mov.w     w9, w5
 16a:	35 4d ba    	tblrdl.b  [w5++], [w10]
 16c:	0a 05 e8    	inc.w     w10, w10
 16e:	02 00 39    	bra       NC, 0x174 <L32>
 170:	34 20 ec    	inc.w     0x34
 172:	0a f0 a0    	bset.w    w10, #0xf

00000174 <L32>:
 174:	8b 05 e9    	dec.w     w11, w11
 176:	0f 00 32    	bra       Z, 0x196 <L42>
 178:	25 4d ba    	tblrdl.b  [w5--], [w10]
 17a:	0a 05 e8    	inc.w     w10, w10
 17c:	02 00 39    	bra       NC, 0x182 <L33>
 17e:	34 20 ec    	inc.w     0x34
 180:	0a f0 a0    	bset.w    w10, #0xf

00000182 <L33>:
 182:	8b 05 e9    	dec.w     w11, w11
 184:	08 00 32    	bra       Z, 0x196 <L42>
 186:	0c 00 e0    	cp0.w     w12
 188:	06 00 32    	bra       Z, 0x196 <L42>
 18a:	15 cd ba    	tblrdh.b  [w5], [w10]
 18c:	0a 05 e8    	inc.w     w10, w10
 18e:	02 00 39    	bra       NC, 0x194 <L34>
 190:	34 20 ec    	inc.w     0x34
 192:	0a f0 a0    	bset.w    w10, #0xf

00000194 <L34>:
 194:	8b 05 e9    	dec.w     w11, w11

00000196 <L42>:
 196:	89 84 e8    	inc2.w    w9, w9
 198:	54 a0 b4    	addc.w    0x54
 19a:	0b 00 e0    	cp0.w     w11
 19c:	e2 ff 3a    	bra       NZ, 0x162 <L13> <__memcpyd3extended>
 19e:	00 00 06    	return    

000001a0 <L23>:
 1a0:	99 02 ba    	tblrdl.w  [w9], w5
 1a2:	05 5d 78    	mov.b     w5, [w10++]
 1a4:	8b 05 e9    	dec.w     w11, w11
 1a6:	f7 ff 32    	bra       Z, 0x196 <L42>
 1a8:	c8 2a de    	lsr.w     w5, #0x8, w5
 1aa:	05 5d 78    	mov.b     w5, [w10++]
 1ac:	8b 05 e9    	dec.w     w11, w11
 1ae:	f3 ff 32    	bra       Z, 0x196 <L42>
 1b0:	0c 00 e0    	cp0.w     w12
 1b2:	f1 ff 32    	bra       Z, 0x196 <L42>
 1b4:	19 dd ba    	tblrdh.b  [w9], [w10++]
 1b6:	ee ff 37    	bra       0x194 <L34>

000001b8 <__DefaultInterrupt>:
 1b8:	00 40 da    	break     
 1ba:	00 00 fe    	reset     

000001bc <__crt_start_mode>:
 1bc:	00 00 05    	retlw.w   #0x0, w0
Disassembly of section __FSEC:

0002af00 <__FSEC>:
   2af00:	f6 fe 00    	nop       
Disassembly of section __FBSLIM:

0002af10 <__FBSLIM>:
   2af10:	fd ff 00    	nop       
Disassembly of section __FOSCSEL:

0002af18 <__FOSCSEL>:
   2af18:	89 ff 00    	nop       
Disassembly of section __FOSC:

0002af1c <__FOSC>:
   2af1c:	e3 ff 00    	nop       
Disassembly of section __FWDT:

0002af20 <__FWDT>:
   2af20:	9f b7 00    	nop       
Disassembly of section __FPOR:

0002af24 <__FPOR>:
   2af24:	fc ff 00    	nop       
Disassembly of section __FICD:

0002af28 <__FICD>:
   2af28:	df ff 00    	nop       
Disassembly of section __FDEVOPT1:

0002af2c <__FDEVOPT1>:
   2af2c:	e7 ff 00    	nop       
Disassembly of section .ivt._T1Interrupt:

0000001a <.ivt._T1Interrupt>:
  1a:	0e 10 00    	nop       
Disassembly of section .ivt._T3Interrupt:

00000024 <.ivt._T3Interrupt>:
  24:	12 10 00    	nop       
Disassembly of section .ivt._U1RXInterrupt:

0000002a <.ivt._U1RXInterrupt>:
  2a:	1e 10 00    	nop       
Disassembly of section .ivt._U1ErrInterrupt:

00000096 <.ivt._U1ErrInterrupt>:
  96:	22 10 00    	nop       
Disassembly of section .ivt._U2RXInterrupt:

00000050 <.ivt._U2RXInterrupt>:
  50:	26 10 00    	nop       
Disassembly of section .ivt._U2ErrInterrupt:

00000098 <.ivt._U2ErrInterrupt>:
  98:	2a 10 00    	nop       
Disassembly of section .text:

000001be <.L0>:
     1be:	ff ff 00    	nop       
     1c0:	ff ff 00    	nop       
     1c2:	ff ff 00    	nop       
     1c4:	ff ff 00    	nop       
     1c6:	ff ff 00    	nop       
     1c8:	ff ff 00    	nop       
     1ca:	ff ff 00    	nop       
     1cc:	ff ff 00    	nop       
     1ce:	ff ff 00    	nop       
     1d0:	ff ff 00    	nop       
     1d2:	ff ff 00    	nop       
     1d4:	ff ff 00    	nop       
     1d6:	ff ff 00    	nop       
     1d8:	ff ff 00    	nop       
     1da:	ff ff 00    	nop       
     1dc:	ff ff 00    	nop       
     1de:	ff ff 00    	nop       
     1e0:	ff ff 00    	nop       
     1e2:	ff ff 00    	nop       
     1e4:	ff ff 00    	nop       
     1e6:	ff ff 00    	nop       
     1e8:	ff ff 00    	nop       
     1ea:	ff ff 00    	nop       
     1ec:	ff ff 00    	nop       
     1ee:	ff ff 00    	nop       
     1f0:	ff ff 00    	nop       
     1f2:	ff ff 00    	nop       
     1f4:	ff ff 00    	nop       
     1f6:	ff ff 00    	nop       
     1f8:	ff ff 00    	nop       
     1fa:	ff ff 00    	nop       
     1fc:	ff ff 00    	nop       
     1fe:	ff ff 00    	nop       
     200:	42 4f 00    	nop       
     202:	4f 54 00    	nop       

00000204 <__reset>:
; boot segment
	.ascii	"BOOT"		; boot segment start
.global __reset
__reset:
	mov	#STACK_START,w15
     204:	0f 70 24    	mov.w     #0x4700, w15
	mov	#STACK_END,w0
     206:	e0 7f 24    	mov.w     #0x47fe, w0
	mov	w0,SPLIM 		; Stack Pointer Limit
     208:	00 01 88    	mov.w     w0, 0x20
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	call	initialize
     20a:	3c 02 02    	call      0x23c <initialize>
     20c:	00 00 00 
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
;------------------------------------------ clear RAM
	mov	#0x800,w0
     20e:	00 80 20    	mov.w     #0x800, w0
	repeat	#0x400-1
     210:	ff 03 09    	repeat    #0x3ff
	xor	w2,[w0++],w2
     212:	30 01 69    	xor.w     w2, [w0++], w2
	mov	w2,w3
     214:	82 01 78    	mov.w     w2, w3
	repeat	#0x1C00-1
     216:	ff 1b 09    	repeat    #0x1bff
	xor	w3,[w0++],w3
     218:	b0 81 69    	xor.w     w3, [w0++], w3
	mov	#0x800,w1
     21a:	01 80 20    	mov.w     #0x800, w1
	repeat 	#0x2000-1	;total 0x4000=16K bytes
     21c:	ff 1f 09    	repeat    #0x1fff
	clr	[w1++]
     21e:	80 18 eb    	clr.w     [w1++]
	mov	w2,Rndlo	; initialize Rnd Seed
     220:	22 4e 88    	mov.w     w2, 0x9c4
	and	w2,#0x0F,w0
     222:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	Wreg,Ram+0xFF	; Write Rnd value
     224:	ff e8 b7    	mov.b     WREG, 0x8ff
	mov	w3,Rndhi	; initialize Rnd Seed
     226:	33 4e 88    	mov.w     w3, 0x9c6
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
; ini AutoOff
	mov	#2,w0		; 2×10 min autooff at hard reset
     228:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
     22a:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
     22c:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
     22e:	b0 4d 88    	mov.w     w0, 0x9b6
; ini dimmer
	mov	#15,w0
     230:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Dimmer
     232:	fe e8 b7    	mov.b     WREG, 0x8fe
; check if button ALT depressed (self check button)
	btsc	PORTA,#2	; PORTA,#2 = ALT key
     234:	64 46 af    	btsc.b    0x664, #0x2
	bra	selfcheck_back	; if ALT not pressed
     236:	fb 06 37    	bra       0x102e <selfcheck_back>
	bra	boot_start
     238:	00 00 37    	bra       0x23a <boot_start>

0000023a <boot_start>:
;------------------------------------------------------------------------------------
;  NOTE: FIRMWARE IN THIS PAGE IS IN PROTECTED BOOT SEGMENT, AND CAN NOT BE MODIFIED 
;------------------------------------------------------------------------------------

boot_start:		bra	go_boot_start
     23a:	0e 00 37    	bra       0x258 <go_boot_start>

0000023c <initialize>:
initialize:		bra	boot_initialize
     23c:	91 01 37    	bra       0x560 <boot_initialize>

0000023e <set_decoder_to_w1>:
set_decoder_to_w1:	bra	boot_set_decoder_to_w1
     23e:	c4 01 37    	bra       0x5c8 <boot_set_decoder_to_w1>

00000240 <w0ms2>:
w0ms2:			bra	boot_w0ms2
     240:	e3 01 37    	bra       0x608 <boot_w0ms2>

00000242 <eecalc_addr_w0>:
eecalc_addr_w0:		bra	boot_eecalc_addr_w0
     242:	e7 01 37    	bra       0x612 <boot_eecalc_addr_w0>

00000244 <eesavew0>:
eesavew0:		bra	boot_eesavew0
     244:	f6 01 37    	bra       0x632 <boot_eesavew0>

00000246 <eeload>:
eeload:			bra	boot_eeload
     246:	25 02 37    	bra       0x692 <boot_eeload>

00000248 <eemeasure>:
eemeasure:		bra	boot_eemeasure
     248:	4e 02 37    	bra       0x6e6 <boot_eemeasure>

0000024a <eeburn_128>:
eeburn_128:		bra	boot_eeburn_128
     24a:	6b 02 37    	bra       0x722 <boot_eeburn_128>

0000024c <eeerase_1K>:
eeerase_1K:		bra	boot_eeerase_1K
     24c:	62 02 37    	bra       0x712 <boot_eeerase_1K>

0000024e <burn1k>:
burn1k:			bra	boot_burn1k
     24e:	98 02 37    	bra       0x780 <boot_burn1k>

00000250 <selfcheck>:
selfcheck:		bra	boot_selfcheck
     250:	24 00 37    	bra       0x29a <boot_selfcheck>

00000252 <bootload>:
bootload:		bra	boot_bootload
     252:	dd 00 37    	bra       0x40e <boot_bootload>

00000254 <key_save>:
key_save:		bra	boot_key_save
     254:	12 01 37    	bra       0x47a <boot_key_save>

00000256 <key_load>:
key_load:		bra	boot_key_load
     256:	37 01 37    	bra       0x4c6 <boot_key_load>

00000258 <go_boot_start>:

;------------------------------------------------------------------------
;--------------------     BOOT  START     -------------------------------
;------------------------------------------------------------------------

go_boot_start:
; **********************************************************************************	
; Note:											
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These	
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons,	
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and	
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every	
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second	
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.	
; **********************************************************************************	
; ALT pressed, initialize small debouncig area
	bclr	INTCON2,#GIE	; global interrupt disable
     258:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     25a:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     25c:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     25e:	84 e9 ef    	setm.b    0x984
; Check if some other key excl. Save and Load pressed (if so, don't allow spec mode)
	mov	#7,w1		; 7 = here are keys OperY1 and DataIn
     260:	71 00 20    	mov.w     #0x7, w1
	  call	  set_decoder_to_w1
     262:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     264:	00 00 00 
	btss	PORTA,#3
     266:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if OperY 1 pressed
     268:	e2 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     26a:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if DataIn pressed
     26c:	e0 06 37    	bra       0x102e <selfcheck_back>
	  call	  set_decoder_to_w1
     26e:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     270:	00 00 00 
	btss	PORTA,#3
     272:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Mode pressed
     274:	dc 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     276:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Carry pressed
     278:	da 06 37    	bra       0x102e <selfcheck_back>
	  call	  set_decoder_to_w1
     27a:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     27c:	00 00 00 
	btss	PORTA,#3
     27e:	64 66 ae    	btss.b    0x664, #0x3
	bra	key_save	; if Save pressed -----------> SAVE
     280:	e9 ff 37    	bra       0x254 <key_save>
	btss	PORTA,#4
     282:	64 86 ae    	btss.b    0x664, #0x4
	bra	key_load	; if Load pressed -----------> LOAD
     284:	e8 ff 37    	bra       0x256 <key_load>

	mov	#6,w2		; w2 loop count
     286:	62 00 20    	mov.w     #0x6, w2

00000288 <L61>:
6:			; \
	  call	  set_decoder_to_w1
     288:	3e 02 02    	call      0x23e <set_decoder_to_w1>
     28a:	00 00 00 
	btss	PORTA,#3
     28c:	64 66 ae    	btss.b    0x664, #0x3
	bra	selfcheck_back	; if Clock, Opcode4, etc... pressed
     28e:	cf 06 37    	bra       0x102e <selfcheck_back>
	btss	PORTA,#4
     290:	64 86 ae    	btss.b    0x664, #0x4
	bra	selfcheck_back	; if Opcode8, Opcode2, etc... pressed
     292:	cd 06 37    	bra       0x102e <selfcheck_back>
	dec	w2,w2
     294:	02 01 e9    	dec.w     w2, w2
	bra	nz,6b	; /
     296:	f8 ff 3a    	bra       NZ, 0x288 <L61>
	bra	selfcheck	; if ALT only pressed
     298:	db ff 37    	bra       0x250 <selfcheck>

0000029a <boot_selfcheck>:

; ----------------------------------------------------------------------
; -----------------------  S E L F   C H E C K  ------------------------
; ----------------------------------------------------------------------
boot_selfcheck:
	mov	#5,w0
     29a:	50 00 20    	mov.w     #0x5, w0
	mov	w0,Mode
     29c:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#3		; #3 self-check mode
     29e:	dc 69 a8    	bset.b    0x9dc, #0x3

	clr	TMR1
     2a0:	90 21 ef    	clr.w     0x190
	bset	T1CON,#TON	; LED multiplex timer on
     2a2:	95 e1 a8    	bset.b    0x195, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
     2a4:	98 60 a8    	bset.b    0x98, #0x3
	bset	INTCON2,#GIE	; global int enable
     2a6:	83 e0 a8    	bset.b    0x83, #0x7
; initialize pixels for self check
	mov	#0b0100100100100100,w0
     2a8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Column1
     2aa:	40 4e 88    	mov.w     w0, 0x9c8
	mov	#0b0010010010010010,w0
     2ac:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Column2
     2ae:	50 4e 88    	mov.w     w0, 0x9ca
	mov	#0b1001001001001001,w0
     2b0:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Column3
     2b2:	60 4e 88    	mov.w     w0, 0x9cc
	mov	#0b0010010010010010,w0
     2b4:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row3
     2b6:	70 4e 88    	mov.w     w0, 0x9ce
	mov	#0b0100100100100100,w0
     2b8:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row4
     2ba:	80 4e 88    	mov.w     w0, 0x9d0
	mov	#0b0010010010010010,w0
     2bc:	20 49 22    	mov.w     #0x2492, w0
	mov	w0,Row5
     2be:	90 4e 88    	mov.w     w0, 0x9d2
	mov	#0b0100100100100100,w0
     2c0:	40 92 24    	mov.w     #0x4924, w0
	mov	w0,Row6
     2c2:	a0 4e 88    	mov.w     w0, 0x9d4
	mov	#0b1001001001001001,w0
     2c4:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,Row7
     2c6:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b1001001001001001,w0
     2c8:	90 24 29    	mov.w     #0x9249, w0
	mov	w0,A16
     2ca:	70 4d 88    	mov.w     w0, 0x9ae

	mov	#0b010000001001,w0
     2cc:	90 40 20    	mov.w     #0x409, w0
	mov	w0,Ram+0
     2ce:	00 40 88    	mov.w     w0, 0x800
	mov	w0,Ram+6
     2d0:	30 40 88    	mov.w     w0, 0x806
	mov	w0,Ram+12
     2d2:	60 40 88    	mov.w     w0, 0x80c
	mov	w0,Ram+18
     2d4:	90 40 88    	mov.w     w0, 0x812
	mov	w0,Ram+24
     2d6:	c0 40 88    	mov.w     w0, 0x818
	mov	w0,Ram+30
     2d8:	f0 40 88    	mov.w     w0, 0x81e
	mov	#0b100100000010,w0
     2da:	20 90 20    	mov.w     #0x902, w0
	mov	w0,Ram+2
     2dc:	10 40 88    	mov.w     w0, 0x802
	mov	w0,Ram+8
     2de:	40 40 88    	mov.w     w0, 0x808
	mov	w0,Ram+14
     2e0:	70 40 88    	mov.w     w0, 0x80e
	mov	w0,Ram+20
     2e2:	a0 40 88    	mov.w     w0, 0x814
	mov	w0,Ram+26
     2e4:	d0 40 88    	mov.w     w0, 0x81a
	mov	#0b001000000100,w0
     2e6:	40 20 20    	mov.w     #0x204, w0
	mov	w0,Ram+4
     2e8:	20 40 88    	mov.w     w0, 0x804
	mov	w0,Ram+10
     2ea:	50 40 88    	mov.w     w0, 0x80a
	mov	w0,Ram+16
     2ec:	80 40 88    	mov.w     w0, 0x810
	mov	w0,Ram+22
     2ee:	b0 40 88    	mov.w     w0, 0x816
	mov	w0,Ram+28
     2f0:	e0 40 88    	mov.w     w0, 0x81c

000002f2 <self_check_loop>:
self_check_loop:
; STEP 1: WAIT ---------
	mov	BlinkCount,w0
     2f2:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x03FF,w0
     2f4:	f0 3f b2    	and.w     #0x3ff, w0
	bra	nz,self_check_loop
     2f6:	fd ff 3a    	bra       NZ, 0x2f2 <self_check_loop>

; STEP 2: SHIFT --------
.macro	rotate	variab,if,then
	lsr	\variab
	btsc	\variab,#\if
	bset	\variab,#\then
.endm
	rotate	Column1,0,15
     2f8:	c8 29 d5    	lsr.w     0x9c8
     2fa:	c8 09 af    	btsc.b    0x9c8, #0x0
     2fc:	c9 e9 a8    	bset.b    0x9c9, #0x7
	rotate	Column2,0,15
     2fe:	ca 29 d5    	lsr.w     0x9ca
     300:	ca 09 af    	btsc.b    0x9ca, #0x0
     302:	cb e9 a8    	bset.b    0x9cb, #0x7
	rotate	Column3,0,15
     304:	cc 29 d5    	lsr.w     0x9cc
     306:	cc 09 af    	btsc.b    0x9cc, #0x0
     308:	cd e9 a8    	bset.b    0x9cd, #0x7
	rotate	Row3,0,15
     30a:	ce 29 d5    	lsr.w     0x9ce
     30c:	ce 09 af    	btsc.b    0x9ce, #0x0
     30e:	cf e9 a8    	bset.b    0x9cf, #0x7
	rotate	Row4,0,15
     310:	d0 29 d5    	lsr.w     0x9d0
     312:	d0 09 af    	btsc.b    0x9d0, #0x0
     314:	d1 e9 a8    	bset.b    0x9d1, #0x7
	rotate	Row5,0,15
     316:	d2 29 d5    	lsr.w     0x9d2
     318:	d2 09 af    	btsc.b    0x9d2, #0x0
     31a:	d3 e9 a8    	bset.b    0x9d3, #0x7
	rotate	Row6,0,15
     31c:	d4 29 d5    	lsr.w     0x9d4
     31e:	d4 09 af    	btsc.b    0x9d4, #0x0
     320:	d5 e9 a8    	bset.b    0x9d5, #0x7
	rotate	Row7,0,15
     322:	d6 29 d5    	lsr.w     0x9d6
     324:	d6 09 af    	btsc.b    0x9d6, #0x0
     326:	d7 e9 a8    	bset.b    0x9d7, #0x7
	rotate	A16,6,15
     328:	ae 29 d5    	lsr.w     0x9ae
     32a:	ae c9 af    	btsc.b    0x9ae, #0x6
     32c:	af e9 a8    	bset.b    0x9af, #0x7
	bclr	A16,#2
     32e:	ae 49 a9    	bclr.b    0x9ae, #0x2
	btsc	A16,#12
     330:	af 89 af    	btsc.b    0x9af, #0x4
	bset	A16,#2
     332:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	rotate_ram
     334:	d4 05 02    	call      0x5d4 <rotate_ram>
     336:	00 00 00 

; any key pressed?
	btss	Flag,#1		; #1 handshaking flag for buttons
     338:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	self_check_loop	; no, loop ------------------------->
     33a:	db ff 37    	bra       0x2f2 <self_check_loop>

	setm	Column1
     33c:	c8 a9 ef    	setm.w    0x9c8
	setm	Column2
     33e:	ca a9 ef    	setm.w    0x9ca
	setm	Column3
     340:	cc a9 ef    	setm.w    0x9cc
	setm	Row3
     342:	ce a9 ef    	setm.w    0x9ce
	setm	Row4
     344:	d0 a9 ef    	setm.w    0x9d0
	setm	Row5
     346:	d2 a9 ef    	setm.w    0x9d2
	setm	Row6
     348:	d4 a9 ef    	setm.w    0x9d4
	mov	#0b1111000000000000,w0
     34a:	00 00 2f    	mov.w     #0xf000, w0
	mov	w0,Row7
     34c:	b0 4e 88    	mov.w     w0, 0x9d6
	mov	#0b0000000001111011,w0
     34e:	b0 07 20    	mov.w     #0x7b, w0
	mov	w0,A16
     350:	70 4d 88    	mov.w     w0, 0x9ae

00000352 <wait_still>:
wait_still:
; test if ASCII "BL"
	mov	Row7,w0
     352:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     354:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     356:	01 00 60    	and.w     w0, w1, w0
	mov	#0x024C,w1	; ASCII BL = 0x424C
     358:	c1 24 20    	mov.w     #0x24c, w1
	cp	w0,w1
     35a:	01 00 e1    	cp.w      w0, w1
	bra	nz,not_BL
     35c:	1a 00 3a    	bra       NZ, 0x392 <L11> <not_BL>
	btsc	A16,#b_carry	; carry   = bit 7 (should be 0)
     35e:	af 89 af    	btsc.b    0x9af, #0x4
	bra	not_BL
     360:	18 00 37    	bra       0x392 <L11> <not_BL>
	btss	A16,#b_save	; save    = bit 6 (should be 1)
     362:	af a9 ae    	btss.b    0x9af, #0x5
	bra	not_BL
     364:	16 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_load	; load    = bit 5 (should be 0)
     366:	af c9 af    	btsc.b    0x9af, #0x6
	bra	not_BL
     368:	14 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_clk_key	; clk_key = bit 4 (should be 0)
     36a:	ae 49 af    	btsc.b    0x9ae, #0x2
	bra	not_BL
     36c:	12 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_alu	; Mode field LEDs off?
     36e:	af 69 af    	btsc.b    0x9af, #0x3
	bra	not_BL
     370:	10 00 37    	bra       0x392 <L11> <not_BL>
	btsc	A16,#b_bin	; Data_In field LEDs off?
     372:	af e9 af    	btsc.b    0x9af, #0x7
	bra	not_BL
     374:	0e 00 37    	bra       0x392 <L11> <not_BL>

	clr	Column1
     376:	c8 29 ef    	clr.w     0x9c8
	clr	Column2
     378:	ca 29 ef    	clr.w     0x9ca
	clr	Column3
     37a:	cc 29 ef    	clr.w     0x9cc
	clr	Row3
     37c:	ce 29 ef    	clr.w     0x9ce
	clr	Row4
     37e:	d0 29 ef    	clr.w     0x9d0
	clr	Row5
     380:	d2 29 ef    	clr.w     0x9d2
	clr	Row6
     382:	d4 29 ef    	clr.w     0x9d4
	clr	Row7
     384:	d6 29 ef    	clr.w     0x9d6
	mov	#Ram,w0		; clr_ram
     386:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clr_ram (clear all exept SFR)
     388:	77 00 09    	repeat    #0x77
	clr	[w0++]		; clr_ram
     38a:	00 18 eb    	clr.w     [w0++]
	mov	#0b0110000000000000,w0	; only SAVE and LOAD are ON
     38c:	00 00 26    	mov.w     #0x6000, w0
	mov	w0,A16
     38e:	70 4d 88    	mov.w     w0, 0x9ae
	bra	bootload	; BOOTLOAD ------------------->
     390:	60 ff 37    	bra       0x252 <bootload>

00000392 <L11>:
not_BL:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
     392:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b		; no, loop ------------------------->
     394:	fe ff 37    	bra       0x392 <L11> <not_BL>
	bclr	Flag,#1		; #1 handshaking flag for buttons
     396:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	rotate_ram
     398:	d4 05 02    	call      0x5d4 <rotate_ram>
     39a:	00 00 00 
.macro		ct1	valct1
		mov	#0b\valct1,w0
		bra	cont_test1
.endm
.macro		ct2	valct2
		mov	#0b\valct2,w0
		bra	cont_test2
.endm
	mov	Just,w0
     39c:	30 4d 80    	mov.w     0x9a6, w0
	sl	w0,w0		; ×2
     39e:	00 00 d0    	sl.w      w0, w0
	bra	w0
     3a0:	00 60 01    	bra       w0
; ...
	ct1	0000111100000000	 ; mode
     3a2:	00 f0 20    	mov.w     #0xf00, w0
     3a4:	22 00 37    	bra       0x3ea <cont_test1>
	ct1	0001000000000000	 ; carry
     3a6:	00 00 21    	mov.w     #0x1000, w0
     3a8:	20 00 37    	bra       0x3ea <cont_test1>
	ct1	0010000000000000	 ; save
     3aa:	00 00 22    	mov.w     #0x2000, w0
     3ac:	1e 00 37    	bra       0x3ea <cont_test1>
	ct1	0100000000000000	 ; load
     3ae:	00 00 24    	mov.w     #0x4000, w0
     3b0:	1c 00 37    	bra       0x3ea <cont_test1>
	ct1	0000000000000100	 ; clock
     3b2:	40 00 20    	mov.w     #0x4, w0
     3b4:	1a 00 37    	bra       0x3ea <cont_test1>
	ct2	0000100000000000	 ; opcode 8
     3b6:	00 80 20    	mov.w     #0x800, w0
     3b8:	1a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000010000000000	 ; opcode 4
     3ba:	00 40 20    	mov.w     #0x400, w0
     3bc:	18 00 37    	bra       0x3ee <cont_test2>
	ct2	0000001000000000	 ; opcode 2
     3be:	00 20 20    	mov.w     #0x200, w0
     3c0:	16 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000100000000	 ; opcode 1
     3c2:	00 10 20    	mov.w     #0x100, w0
     3c4:	14 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000010000000	 ; oper X 8
     3c6:	00 08 20    	mov.w     #0x80, w0
     3c8:	12 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000001000000	 ; oper X 4
     3ca:	00 04 20    	mov.w     #0x40, w0
     3cc:	10 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000100000	 ; oper X 2
     3ce:	00 02 20    	mov.w     #0x20, w0
     3d0:	0e 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000010000	 ; oper X 1
     3d2:	00 01 20    	mov.w     #0x10, w0
     3d4:	0c 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000001000	 ; oper Y 8
     3d6:	80 00 20    	mov.w     #0x8, w0
     3d8:	0a 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000100	 ; oper Y 4
     3da:	40 00 20    	mov.w     #0x4, w0
     3dc:	08 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000010	 ; oper Y 2
     3de:	20 00 20    	mov.w     #0x2, w0
     3e0:	06 00 37    	bra       0x3ee <cont_test2>
	ct2	0000000000000001	 ; oper Y 1
     3e2:	10 00 20    	mov.w     #0x1, w0
     3e4:	04 00 37    	bra       0x3ee <cont_test2>
	ct1	1000000010000000	 ; DataIn 
     3e6:	00 08 28    	mov.w     #0x8080, w0
     3e8:	00 00 37    	bra       0x3ea <cont_test1>

000003ea <cont_test1>:
cont_test1:
	xor	A16
     3ea:	ae a9 b6    	xor.w     0x9ae
	bra	ctx
     3ec:	01 00 37    	bra       0x3f0 <ctx>

000003ee <cont_test2>:
cont_test2:
	xor	Row7
     3ee:	d6 a9 b6    	xor.w     0x9d6

000003f0 <ctx>:
ctx:
	mov	Row7,w0
     3f0:	b0 4e 80    	mov.w     0x9d6, w0
	mov	#0x0FFF,w1
     3f2:	f1 ff 20    	mov.w     #0xfff, w1
	and	w0,w1,w0
     3f4:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     3f6:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     3f8:	ac ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	A16,w0
     3fa:	70 4d 80    	mov.w     0x9ae, w0
	mov	#0b1111111110000100,w1
     3fc:	41 f8 2f    	mov.w     #0xff84, w1
	and	w0,w1,w0
     3fe:	01 00 60    	and.w     w0, w1, w0
	cp	w0,w1
     400:	01 00 e1    	cp.w      w0, w1
	bra	nz,wait_still	; not yet all keys tested
     402:	a7 ff 3a    	bra       NZ, 0x352 <wait_still>

	mov	#-2000,w0	; count 2000 = 500 ms
     404:	00 83 2f    	mov.w     #0xf830, w0
	mov	w0,BlinkCount
     406:	e0 4b 88    	mov.w     w0, 0x97c

00000408 <wait_Xs>:
wait_Xs:
	cp0	BlinkCount
     408:	7c 09 e2    	cp0.w     0x97c
	bra	nz,wait_Xs
     40a:	fe ff 3a    	bra       NZ, 0x408 <wait_Xs>
	reset
     40c:	00 00 fe    	reset     

0000040e <boot_bootload>:

;-----------------------------------------------------------------------------
;------------------------- BOOTLOAD ------------------------------------------
;-----------------------------------------------------------------------------

boot_bootload:
	bclr	INTCON2,#GIE	; global interrupt disable
     40e:	83 e0 a9    	bclr.b    0x83, #0x7
	setm.b	KeyRotors+0
     410:	7e e9 ef    	setm.b    0x97e
	setm.b	KeyRotors+4
     412:	82 e9 ef    	setm.b    0x982
	setm.b	KeyRotors+6
     414:	84 e9 ef    	setm.b    0x984

00000416 <L12>:
1:
	clr.b	LATC		; all LEDS off
     416:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     418:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode driver off
     41a:	8f 06 a9    	bclr.b    0x68f, #0x0
; led SAVE on
	mov	#0b1111100001111111,w0
     41c:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     41e:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     420:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     422:	66 26 b7    	ior.w     0x666
	bset	LATC,#8		; anode 17 on
     424:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000		; ON time 0.5 ms
     426:	40 1f 09    	repeat    #0x1f40
	nop
     428:	00 00 00    	nop       
; led LOAD on
	mov	#0b1111100001111111,w0
     42a:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     42c:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     42e:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     430:	66 26 b7    	ior.w     0x666
	repeat	#8000		; ON time 0.5 ms
     432:	40 1f 09    	repeat    #0x1f40
	nop
     434:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     436:	8f 06 a9    	bclr.b    0x68f, #0x0
; set decoder output 0 and wait 2 ms
	mov	#0b1111100001111111,w0
     438:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     43a:	66 26 b6    	and.w     0x666
	mov	#0b0000010000000000,w0	; 8 = buttons MODE and CARRY
     43c:	00 40 20    	mov.w     #0x400, w0
	ior	LATA		; decoder state = 8 (there is key MODE)
     43e:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     440:	80 3e 09    	repeat    #0x3e80
	nop
     442:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     444:	80 3e 09    	repeat    #0x3e80
	nop
     446:	00 00 00    	nop       
; debounce and test key MODE
	sl.b	KeyRotors+0
     448:	7e 69 d4    	sl.b      0x97e
	btsc	PORTA,#3
     44a:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+0,#0
     44c:	7e 09 a8    	bset.b    0x97e, #0x0
	ifz
     44e:	42 20 af    	btsc.b    0x42, #0x1
	reset			; if MODE pressed then suicide
     450:	00 00 fe    	reset     
; set decoder output 1 and wait 2 ms
	mov	#0b1111100001111111,w0
     452:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10 (decoder 138)
     454:	66 26 b6    	and.w     0x666
	mov	#0b0000010010000000,w0	; 9 = buttons SAVE and LOAD
     456:	00 48 20    	mov.w     #0x480, w0
	ior	LATA		; decoder state = 9 (there are keys SAVE and LOAD)
     458:	66 26 b7    	ior.w     0x666
	repeat	#16000		; 1 ms
     45a:	80 3e 09    	repeat    #0x3e80
	nop
     45c:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     45e:	80 3e 09    	repeat    #0x3e80
	nop
     460:	00 00 00    	nop       
; debounce and test key SAVE
	sl.b	KeyRotors+4
     462:	82 69 d4    	sl.b      0x982
	btsc	PORTA,#3
     464:	64 66 af    	btsc.b    0x664, #0x3
	bset.b	KeyRotors+4,#0
     466:	82 09 a8    	bset.b    0x982, #0x0
;	bra	z,key_save	; if SAVE pressed  (* THIS FUNCTION CANCELED *)
; debounce and test key LOAD
	sl.b	KeyRotors+6
     468:	84 69 d4    	sl.b      0x984
	btsc	PORTA,#4
     46a:	64 86 af    	btsc.b    0x664, #0x4
	bset.b	KeyRotors+6,#0
     46c:	84 09 a8    	bset.b    0x984, #0x0
	bra	z,key_load	; if LOAD pressed
     46e:	f3 fe 32    	bra       Z, 0x256 <key_load>
; wait 2 ms and loop 
	repeat	#16000		; 1 ms
     470:	80 3e 09    	repeat    #0x3e80
	nop
     472:	00 00 00    	nop       
	repeat	#16000		; 1 ms
     474:	80 3e 09    	repeat    #0x3e80
	nop
     476:	00 00 00    	nop       
	bra	1b
     478:	ce ff 37    	bra       0x416 <L12>

0000047a <boot_key_save>:

;--------------------------------------------------------------
boot_key_save:



; debounce (DO NOTHING) RESET signal 2 sec first
	btsc	Flag2,#9	; #9 set = last command LOAD
     47a:	df 29 af    	btsc.b    0x9df, #0x1
	bra	6f		; no debouncer for LOAD
     47c:	0e 00 37    	bra       0x49a <L62>

	mov	#0b1111100001111111,w0
     47e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     480:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     482:	00 68 20    	mov.w     #0x680, w0
	ior	LATA		; decoder state = 13 (there is led SAVE)
     484:	66 26 b7    	ior.w     0x666

	mov	#20,w1		; 2 sec debouncing (doing nothing, just blinking
     486:	41 01 20    	mov.w     #0x14, w1

00000488 <L13>:
1:
	bset	LATC,#8		; anode 17 on
     488:	8f 06 a8    	bset.b    0x68f, #0x0
	repeat	#8000-1		; led SAVE ON time	
     48a:	3f 1f 09    	repeat    #0x1f3f
	nop
     48c:	00 00 00    	nop       
	bclr	LATC,#8		; anode 17 off
     48e:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#80,w0		; led SAVE OFF timen 80 ms
     490:	00 05 20    	mov.w     #0x50, w0
	call	w0ms2
     492:	40 02 02    	call      0x240 <w0ms2>
     494:	00 00 00 

	dec	w1,w1
     496:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
     498:	f7 ff 3a    	bra       NZ, 0x488 <L13>

0000049a <L62>:
6:
; GO ON BOOT KEY_SAVE









	bset	Flag2,#6	; #6 EE pointers adjust to Boot
     49a:	de c9 a8    	bset.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load/save to/from the first half of Rom area
     49c:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
     49e:	df 29 a9    	bclr.b    0x9df, #0x1
	clr	w10		; w10 Flash Page, step 0x800
     4a0:	00 05 eb    	clr.w     w10

000004a2 <L91>:
9:			  ; \
	mov	w10,w0
     4a2:	0a 00 78    	mov.w     w10, w0
	call	eeload		; firmware 1 ---> Rom 1 (3K bytes + 1K dummy 0's)
     4a4:	46 02 02    	call      0x246 <eeload>
     4a6:	00 00 00 
	add	w10,#24,w0
     4a8:	78 00 45    	add.w     w10, #0x18, w0
	bset	Flag2,#7	; #7 EE load to second halve of Rom area
     4aa:	de e9 a8    	bset.b    0x9de, #0x7
	call	eeload		; firmware 2 ---> Rom 2 (3K bytes + 1K dummy 0's)
     4ac:	46 02 02    	call      0x246 <eeload>
     4ae:	00 00 00 

	mov	w10,w0
     4b0:	0a 00 78    	mov.w     w10, w0
	call	eesavew0	; Rom 2 ---> firmware 1 (3K bytes + 1K dummy 0's)
     4b2:	44 02 02    	call      0x244 <eesavew0>
     4b4:	00 00 00 
	add	w10,#24,w0
     4b6:	78 00 45    	add.w     w10, #0x18, w0
	bclr	Flag2,#7	; #7 EE save from first halve of Rom area
     4b8:	de e9 a9    	bclr.b    0x9de, #0x7
	call	eesavew0	; Rom 1 ---> firmware 2 (3K bytes + 1K dummy 0's)
     4ba:	44 02 02    	call      0x244 <eesavew0>
     4bc:	00 00 00 

	inc	w10,w10
     4be:	0a 05 e8    	inc.w     w10, w10
	cp	w10,#24
     4c0:	78 50 e1    	cp.w      w10, #0x18
	bra	nc,9b	  ;  /
     4c2:	ef ff 39    	bra       NC, 0x4a2 <L91>
	bra	bootload
     4c4:	c6 fe 37    	bra       0x252 <bootload>

000004c6 <boot_key_load>:

;--------------------------------------------------------------
boot_key_load:
	bset	Flag2,#6	; #6 EE subroutines adjust to Boot
     4c6:	de c9 a8    	bset.b    0x9de, #0x6
	bset	Flag2,#7	; #7 EE burn from 2nd halve of Rom area (start @ 0x3000)
     4c8:	de e9 a8    	bset.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
     4ca:	df 29 a8    	bset.b    0x9df, #0x1

; ------------------------------- DMA ------------------------------
; initialize DMA 0
	mov	#0b0000000000000000,w0	; Disabled, Fixed Priority
     4cc:	00 00 20    	mov.w     #0x0, w0
	mov	w0,DMACON		; Bit 15 = DMAEN (DMA Enable)
     4ce:	20 26 88    	mov.w     w0, 0x4c4
	mov	#0b0000001000010110,w0	; reload, SRC fixed, DST++, one-shot, byte mode
     4d0:	60 21 20    	mov.w     #0x216, w0
	mov	w0,DMACH0		; Bit 0: CHEN (Channel Enable)
     4d2:	60 26 88    	mov.w     w0, 0x4cc
	mov	#0b0100010100000000,w0	; Source is UART1 RX Interrupt
     4d4:	00 50 24    	mov.w     #0x4500, w0
	mov	w0,DMAINT0
     4d6:	70 26 88    	mov.w     w0, 0x4ce
	mov	#Rom,w0
     4d8:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMAL		; low limit
     4da:	40 26 88    	mov.w     w0, 0x4c8
	mov	#Rom+0x2000,w0
     4dc:	00 00 24    	mov.w     #0x4000, w0
	mov	w0,DMAH		; high limit
     4de:	50 26 88    	mov.w     w0, 0x4ca
	mov	#U1RXREG,w0
     4e0:	e0 39 20    	mov.w     #0x39e, w0
	mov	w0,DMASRC0	; Source address
     4e2:	80 26 88    	mov.w     w0, 0x4d0
	mov	#Rom,w0
     4e4:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,DMADST0	; Destination start address
     4e6:	90 26 88    	mov.w     w0, 0x4d2
	mov	#4096,w0
     4e8:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,DMACNT0	; RX block format (1024 instructions)
     4ea:	a0 26 88    	mov.w     w0, 0x4d4
	bset	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     4ec:	c5 e4 a8    	bset.b    0x4c5, #0x7
	bset	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     4ee:	cc 04 a8    	bset.b    0x4cc, #0x0
; initialize peripheral hardware and variables
	bclr	IEC0,#11	; disable RX1 interrupt
     4f0:	99 60 a9    	bclr.b    0x99, #0x3
	call	boot_rxtx_to_io2; RxTx directed to IO connector
     4f2:	ee 05 02    	call      0x5ee <boot_rxtx_to_io2>
     4f4:	00 00 00 
	mov	#0b1111100001111111,w0
     4f6:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     4f8:	66 26 b6    	and.w     0x666
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     4fa:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 14 (there is led LOAD)
     4fc:	66 26 b7    	ior.w     0x666
	clr	w8		; w8 = blink count (#4,#1) about 18 Hz (1 Hz, 8 Hz)
     4fe:	00 04 eb    	clr.w     w8
	mov	DMADST0,w14	; w14 = previous DMADST0
     500:	9e 26 80    	mov.w     0x4d2, w14
	mov	#50000,w13	; w13 = "DMADST changed" counter (0 when no RX data)
     502:	0d 35 2c    	mov.w     #0xc350, w13
	mov	#Rom,w0
     504:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1
     506:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve of Rom to 0xFFFF
     508:	00 98 eb    	setm.w    [w0++]
	mov	#0,w11		; Page burn pointer (×0x800)
     50a:	0b 00 20    	mov.w     #0x0, w11
; main BOOT loop
	mov	#23,w12		; max number of 4K packets (+1 non-complete at end)
     50c:	7c 01 20    	mov.w     #0x17, w12

0000050e <BootLoop>:
BootLoop:		 ; <------------------------------ bootload loop ~20t
	nop
     50e:	00 00 00    	nop       
; test if byte received (in that case set Flag2,#10 and initialize w13 counter)
	mov	DMADST0,w0	; Destination address
     510:	90 26 80    	mov.w     0x4d2, w0
	cp	w0,w14
     512:	0e 00 e1    	cp.w      w0, w14
	bra	z,equal_dst	; if byte not received in this cycle
     514:	03 00 32    	bra       Z, 0x51c <equal_dst>
; byte received, set Flag2,#10 and initialize w13 counter (patience meter)
	bset	Flag2,#10	; #8 set = 1st byte in Bootloader received
     516:	df 49 a8    	bset.b    0x9df, #0x2
	mov	w0,w14		; refresh previous DMADST0
     518:	00 07 78    	mov.w     w0, w14
	mov	#50000,w13
     51a:	0d 35 2c    	mov.w     #0xc350, w13

0000051c <equal_dst>:
equal_dst:
	btss	Flag2,#10	; #8 set = 1st byte in Bootloader received
     51c:	df 49 ae    	btss.b    0x9df, #0x2
	bra	noRXdata	; if no bytes received yet
     51e:	02 00 37    	bra       0x524 <noRXdata>
	dec	w13,w13		; patience counter
     520:	8d 06 e9    	dec.w     w13, w13
	bra	z,bl_lost_patience ; if end of reception (pause detected)
     522:	18 00 32    	bra       Z, 0x554 <bl_lost_patience>

00000524 <noRXdata>:
noRXdata:
	inc	w9,w9		; fast counter
     524:	89 04 e8    	inc.w     w9, w9
	ifz
     526:	42 20 af    	btsc.b    0x42, #0x1
	inc	w8,w8		; slow counter
     528:	08 04 e8    	inc.w     w8, w8
; fast or slow blinking
	mov	#0b0000000011110000,w0
     52a:	00 0f 20    	mov.w     #0xf0, w0
	and	w0,w9,w0
     52c:	09 00 60    	and.w     w0, w9, w0
	bra	nz,9f		; 15 of 16 cycles
     52e:	09 00 3a    	bra       NZ, 0x542 <L92>
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     530:	df 49 af    	btsc.b    0x9df, #0x2
	bra	2f		; if not 1st cycle (1st byte was received)
     532:	03 00 37    	bra       0x53a <L21>
	btss	w8,#3		; bit #4 (slow blinking)
     534:	08 30 a6    	btss.w    w8, #0x3
	bra	8f
     536:	03 00 37    	bra       0x53e <L81>
	bra	7f
     538:	05 00 37    	bra       0x544 <L71>

0000053a <L21>:
2:
	btss	w8,#0		; bit #1 (fast blinking)
     53a:	08 00 a6    	btss.w    w8, #0x0
	bra	9f
     53c:	02 00 37    	bra       0x542 <L92>

0000053e <L81>:
8:
	bset	LATC,#8		; LED LOAD on (1/16 duty cycle)
     53e:	8f 06 a8    	bset.b    0x68f, #0x0
	bra	7f
     540:	01 00 37    	bra       0x544 <L71>

00000542 <L92>:
9:
	bclr	LATC,#8		; LED LOAD off (15/16 duty cycle)
     542:	8f 06 a9    	bclr.b    0x68f, #0x0

00000544 <L71>:
7:
	btss	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     544:	ce a4 ae    	btss.b    0x4ce, #0x5
	bra	BootLoop ; ------------------------------> bootload loop
     546:	e3 ff 37    	bra       0x50e <BootLoop>
; Operation Completed, 1st halve of Rom received 4K bytes via UART
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     548:	ce a4 a9    	bclr.b    0x4ce, #0x5
	dec	w12,w12
     54a:	0c 06 e9    	dec.w     w12, w12
	bra	z,bl_lost_patience ; number of received bytes overflow
     54c:	03 00 32    	bra       Z, 0x554 <bl_lost_patience>
	call	burn1k		; burn 1 K block received
     54e:	4e 02 02    	call      0x24e <burn1k>
     550:	00 00 00 
	bra	BootLoop ; --------> bootload loop after one 1K instr segment written
     552:	dd ff 37    	bra       0x50e <BootLoop>

00000554 <bl_lost_patience>:
;------------------------
bl_lost_patience:
	bclr	DMAINT0,#DONEIF	; 1 = DMA Operation Completed Interrupt Flag
     554:	ce a4 a9    	bclr.b    0x4ce, #0x5
	bclr	DMACON,#15	; Bit 15 = DMAEN (DMA Enable)
     556:	c5 e4 a9    	bclr.b    0x4c5, #0x7
	bclr	DMACH0,#0	; Bit 0: CHEN (Channel Enable)
     558:	cc 04 a9    	bclr.b    0x4cc, #0x0
	call	burn1k		; burn last block received, even incomplete
     55a:	4e 02 02    	call      0x24e <burn1k>
     55c:	00 00 00 
	bra	bootload	; end of reception (pause detected)
     55e:	79 fe 37    	bra       0x252 <bootload>

00000560 <boot_initialize>:
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	
;  IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII	

boot_initialize:
	bclr	INTCON2,#GIE		; global int disable
     560:	83 e0 a9    	bclr.b    0x83, #0x7

; -------------------------------------	; --- oscilator -----------------------
	mov	#0b0000000100000000,w0	; FRC with PLL, /1, PLL always active
     562:	00 10 20    	mov.w     #0x100, w0
	mov	w0,CLKDIV
     564:	10 08 88    	mov.w     w0, 0x102

; -------------------------------------	; --- REMAPABLE PINS ------------------
	mov	#25,w0			; RP25 PORT_C9...
     566:	90 01 20    	mov.w     #0x19, w0
	mov.b	WREG,RPINR0+1		; ...to Ext_Int_1
     568:	91 e7 b7    	mov.b     WREG, 0x791

	mov	#26,w0			; RP26 PORT  (A0)... (0x3f to disable RX input)
     56a:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18		; ...to U1_RX
     56c:	b4 e7 b7    	mov.b     WREG, 0x7b4
;	mov	#6,w0			; RP6  PORT  (B6)...  (0x3f to disable RX input)
;	mov.b	WREG,RPINR18		; ...to U1_RX
; both pins can be Tx (why not?)
	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
     56e:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR13+1		; ...to RP27 (A1)
     570:	ef e7 b7    	mov.b     WREG, 0x7ef
;	mov	#3,w0			; #3=U1_TX...     (0x00 to return to default OUT port)
;	mov.b	WREG,RPOR3+1		; ...to RP7  (B7)

; -------------------------------------	; --- TIMERS --------------------------
	mov	#0b0010000000010000,w0	; stops in sleep mode, prescaler = 1:8
     572:	00 01 22    	mov.w     #0x2010, w0
	mov	w0,T1CON		; TIMER 1 = 3300 Hz (display matrix rfsh)
     574:	a0 0c 88    	mov.w     w0, 0x194
	mov	#514-40-1,w0		; heartbeat def period 16M/8/514=3888Hz, /16=243Hz
     576:	90 1d 20    	mov.w     #0x1d9, w0
	mov	w0,PR1
     578:	90 0c 88    	mov.w     w0, 0x192

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (CLOCK period)
     57a:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T2CON		; TIMER 2 = instruction clock (no interrupt, IFS0,#7 only!)
     57c:	00 0d 88    	mov.w     w0, 0x1a0
	mov	#10-1,w0		; instruction def period
     57e:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR2
     580:	e0 0c 88    	mov.w     w0, 0x19c

	mov	#0b0010000000000000,w0	; prescaler bits 5,4 (SYNC period)
     582:	00 00 22    	mov.w     #0x2000, w0
	mov	w0,T3CON		; TIMER 3 = user's sync (interrupt only sets RdFlags,#0)
     584:	10 0d 88    	mov.w     w0, 0x1a2
	mov	#10-1,w0		; sync def period
     586:	90 00 20    	mov.w     #0x9, w0
	mov	w0,PR3
     588:	f0 0c 88    	mov.w     w0, 0x19e

; -------------------------------------	; --- UART -----------------------------
	mov	#0b0010100000001000,w0	; BRGH=1, UART disabled, RTS/CTS disabled, BRGH set
     58a:	80 80 22    	mov.w     #0x2808, w0
	mov	w0,U1MODE		; UART1 je za infrared
     58c:	c0 1c 88    	mov.w     w0, 0x398
	mov	#0b0000000000000000,w0	; TX idle mode = high
     58e:	00 00 20    	mov.w     #0x0, w0
	mov	w0,U1STAL
     590:	d0 1c 88    	mov.w     w0, 0x39a
	mov	#417-1,w0		; 16 M / 4 / 417 = 9600 Baud
     592:	00 1a 20    	mov.w     #0x1a0, w0
	mov	w0,U1BRG
     594:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
     596:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#URXEN		; enable RX 1 (must be after UART enable)
     598:	9b 83 a8    	bset.b    0x39b, #0x4
	bset	U1STAL,#UTXEN		; enable TX 1 (must be after UART enable)
     59a:	9b 43 a8    	bset.b    0x39b, #0x2

; ------------------------------------- ; --- INTERRUPTS -----------------------
	bclr	RCON,#SWDTEN		; disable WDT
     59c:	10 a1 a9    	bclr.b    0x110, #0x5
	bset	INTCON1,#NSTDIS		; disable interrupt nesting
     59e:	81 e0 a8    	bset.b    0x81, #0x7

; -------------------------------------	; --- PORTS ----------------------------
	clr	ANSA
     5a0:	6a 26 ef    	clr.w     0x66a
	clr	ANSB
     5a2:	7e 26 ef    	clr.w     0x67e
	clr	ANSC
     5a4:	92 26 ef    	clr.w     0x692

	mov	#0b0000000000011100,w0	; pull-ups
     5a6:	c0 01 20    	mov.w     #0x1c, w0
	mov	w0,IOCPUA
     5a8:	90 33 88    	mov.w     w0, 0x672
	mov	#0b0000001000000000,w0	; pull-ups
     5aa:	00 20 20    	mov.w     #0x200, w0
	mov	w0,IOCPUC
     5ac:	d0 34 88    	mov.w     w0, 0x69a

	mov	#0b0000000000000110,w0
     5ae:	60 00 20    	mov.w     #0x6, w0
	mov	w0,LATA
     5b0:	30 33 88    	mov.w     w0, 0x666
	mov	#0b0000000011110000,w0
     5b2:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,LATB
     5b4:	d0 33 88    	mov.w     w0, 0x67a
	mov	#0b0000000000000000,w0
     5b6:	00 00 20    	mov.w     #0x0, w0
	mov	w0,LATC
     5b8:	70 34 88    	mov.w     w0, 0x68e
	mov	#0b0000000000011101,w0
     5ba:	d0 01 20    	mov.w     #0x1d, w0
	mov	w0,TRISA
     5bc:	10 33 88    	mov.w     w0, 0x662
	mov	#0b0000000011110000,w0
     5be:	00 0f 20    	mov.w     #0xf0, w0
	mov	w0,TRISB
     5c0:	b0 33 88    	mov.w     w0, 0x676
	mov	#0b0000001000000000,w0
     5c2:	00 20 20    	mov.w     #0x200, w0
	mov	w0,TRISC
     5c4:	50 34 88    	mov.w     w0, 0x68a
	return
     5c6:	00 00 06    	return    

000005c8 <boot_set_decoder_to_w1>:

;------------------------------------------------------------------------------------
;-----------------------------  S U B S  --------------------------------------------
;------------------------------------------------------------------------------------

boot_set_decoder_to_w1:
	mov	#0b1111100001111111,w0
     5c8:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     5ca:	66 26 b6    	and.w     0x666
	sl	w1,#7,w0
     5cc:	47 08 dd    	sl.w      w1, #0x7, w0
	ior	LATA		; decoder state is at LATA,#7...#10 control
     5ce:	66 26 b7    	ior.w     0x666
	inc	w1,w1
     5d0:	81 00 e8    	inc.w     w1, w1
	return
     5d2:	00 00 06    	return    

000005d4 <rotate_ram>:

rotate_ram:
	mov	#0x0F0F,w0
     5d4:	f0 f0 20    	mov.w     #0xf0f, w0
	mov	#Ram+0,w1
     5d6:	01 80 20    	mov.w     #0x800, w1
	mov	#16,w2
     5d8:	02 01 20    	mov.w     #0x10, w2

000005da <L22>:
2:
	lsr	[w1],[w1]	; (skips this line without NOP)
     5da:	91 08 d1    	lsr.w     [w1], [w1]
	btsc	[w1],#0
     5dc:	11 00 a7    	btsc.w    [w1], #0x0
	bset	[w1],#3
     5de:	11 30 a0    	bset.w    [w1], #0x3
	btsc	[w1],#8
     5e0:	11 80 a7    	btsc.w    [w1], #0x8
	bset	[w1],#11
     5e2:	11 b0 a0    	bset.w    [w1], #0xb
	and	w0,[w1],[w1++]
     5e4:	91 18 60    	and.w     w0, [w1], [w1++]
	nop			; * * *   MCU BUG FIX  ???   * * *
     5e6:	00 00 00    	nop       
	dec	w2,w2
     5e8:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b
     5ea:	f7 ff 3a    	bra       NZ, 0x5da <L22>
	return
     5ec:	00 00 06    	return    

000005ee <boot_rxtx_to_io2>:

;										
;-------
boot_rxtx_to_io2:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
     5ee:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
     5f0:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
     5f2:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
     5f4:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
     5f6:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
     5f8:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
     5fa:	de 69 a8    	bset.b    0x9de, #0x3
	bset	U1MODE,#15		; enable UART 1
     5fc:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
     5fe:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
     600:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
     602:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
     604:	f0 4d 88    	mov.w     w0, 0x9be
	return
     606:	00 00 06    	return    

00000608 <boot_w0ms2>:
;------------------------------------------------------------------------
boot_w0ms2:
	repeat	#16000-1
     608:	7f 3e 09    	repeat    #0x3e7f
	nop
     60a:	00 00 00    	nop       
	dec	w0,w0
     60c:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms2
     60e:	18 fe 3a    	bra       NZ, 0x240 <w0ms2>
	return
     610:	00 00 06    	return    

00000612 <boot_eecalc_addr_w0>:

;-----------------------------------------------------------------------------
;----------------------                              -------------------------
;----------------------        EE SUBROUTINES        -------------------------
;----------------------                              -------------------------
;-----------------------------------------------------------------------------

boot_eecalc_addr_w0:	; USER PROGRAM SAVE/LOAD (8K=0x2000 by blocks, 0x1A000...)
			; w0 × 0x1000 + 0x1A000 ----> w6:w7 (end must be < 2AFFE)
			; one record 0x1000 bytes, start 0x1A000, end 0x2A000
	btsc	Flag2,#6	; #6 EE subroutines adjust to Boot
     612:	de c9 af    	btsc.b    0x9de, #0x6
	bra	eecalc_page
     614:	07 00 37    	bra       0x624 <eecalc_page>
	mov	#0x1000,w1
     616:	01 00 21    	mov.w     #0x1000, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x1000
     618:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0xA000,w0
     61a:	00 00 2a    	mov.w     #0xa000, w0
	mov	#0x0001,w1	; w0:w1 = 0x0001:A000 start of 1st flash save block
     61c:	11 00 20    	mov.w     #0x1, w1
	add	w6,w0,w6
     61e:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     620:	81 83 4b    	addc.w    w7, w1, w7
	return
     622:	00 00 06    	return    

00000624 <eecalc_page>:
;-----------------------
eecalc_page:		; BOOTLOAD (4K=0x800 by blocks, 0x1000,0x1800...)
			; w0 × 0x800 + 0x1000 ---> w6:w7 (one record 0x800 = 2K by)
			; w0 = page, 0...23 (for Firmware Backup, w0 = 24...47)
	mov	#0x800,w1
     624:	01 80 20    	mov.w     #0x800, w1
	mul.uu	w0,w1,w6	; w6:w7 = FlashAddr × 0x800
     626:	01 03 b8    	mul.uu    w0, w1, w6
	mov	#0x1000,w0
     628:	00 00 21    	mov.w     #0x1000, w0
	mov	#0x0000,w1	; w0:w1 = 0x0000:1000 start of 1st flash save block
     62a:	01 00 20    	mov.w     #0x0, w1
	add	w6,w0,w6
     62c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,w1,w7
     62e:	81 83 4b    	addc.w    w7, w1, w7
	return
     630:	00 00 06    	return    

00000632 <boot_eesavew0>:
;----------------------------------------------------------------------------------
boot_eesavew0:		; data (@Rom) ----> flash w0
	call	eecalc_addr_w0
     632:	42 02 02    	call      0x242 <eecalc_addr_w0>
     634:	00 00 00 
	bclr	INTCON2,#GIE	; global int disable
     636:	83 e0 a9    	bclr.b    0x83, #0x7
	clr.b	LATC		; all LEDS off
     638:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; all LEDS off
     63a:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; anode 17 off
     63c:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#0b1111100001111111,w0
     63e:	f0 87 2f    	mov.w     #0xf87f, w0
	and	LATA		; clear LATA bits 7 8 9 10
     640:	66 26 b6    	and.w     0x666
	mov	#0b0000011010000000,w0	; 13 = LED SAVE
     642:	00 68 20    	mov.w     #0x680, w0
	btsc	Flag2,#9	; #9 set = last command LOAD
     644:	df 29 af    	btsc.b    0x9df, #0x1
	mov	#0b0000011100000000,w0	; 14 = LED LOAD
     646:	00 70 20    	mov.w     #0x700, w0
	ior	LATA		; decoder state = 13 or 14 (there is led SAVE or LOAD)
     648:	66 26 b7    	ior.w     0x666
	push.d	w6	   ; \    w6, w7
     64a:	86 9f be    	mov.d     w6, [w15++]
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     64c:	4c 02 02    	call      0x24c <eeerase_1K>
     64e:	00 00 00 
	btss	Flag2,#6	; only one page for BOOT !
     650:	de c9 ae    	btss.b    0x9de, #0x6
	call	eeerase_1K	; erase block of 1K instructions (2K user pgm bytes + 1K high)
     652:	4c 02 02    	call      0x24c <eeerase_1K>
     654:	00 00 00 
	pop.d	w6	   ; /    w6, w7
     656:	4f 03 be    	mov.d     [--w15], w6
	mov	#Rom,w2
     658:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE save from 2nd halve of Rom area (starting at 0x3000)
     65a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     65c:	02 00 23    	mov.w     #0x3000, w2
	mov	#16,w8		; 16× for User's Program Save (4K chunks)
     65e:	08 01 20    	mov.w     #0x10, w8
	btsc	Flag2,#6
     660:	de c9 af    	btsc.b    0x9de, #0x6
	mov	#8,w8		; only 8× for BOOT ! (2K chunks)
     662:	88 00 20    	mov.w     #0x8, w8

00000664 <L82>:
8:                        ; <----------
	call	eeburn_128	; burn
     664:	4a 02 02    	call      0x24a <eeburn_128>
     666:	00 00 00 
	btss	Flag2,#6	; #6 EE Boot
     668:	de c9 ae    	btss.b    0x9de, #0x6
	btsc	Flag2,#10	; #8 set = 1st byte in Bootloader received
     66a:	df 49 af    	btsc.b    0x9df, #0x2
	bset	LATC,#8		; anode 17 on
     66c:	8f 06 a8    	bset.b    0x68f, #0x0

	inc	Dummy
     66e:	b0 29 ec    	inc.w     0x9b0
	mov	Dummy,w0
     670:	80 4d 80    	mov.w     0x9b0, w0
	and	#15,w0
     672:	f0 00 b2    	and.w     #0xf, w0
	bra	nz,7f
     674:	02 00 3a    	bra       NZ, 0x67a <L72>

	repeat	#8000-1		; led SAVE ON time	
     676:	3f 1f 09    	repeat    #0x1f3f
	nop
     678:	00 00 00    	nop       

0000067a <L72>:
7:
	bclr	LATC,#8		; anode 17 off
     67a:	8f 06 a9    	bclr.b    0x68f, #0x0
	mov	#5,w0		; led SAVE OFF time	
     67c:	50 00 20    	mov.w     #0x5, w0
	call	w0ms2
     67e:	40 02 02    	call      0x240 <w0ms2>
     680:	00 00 00 
	dec.b	w8,w8
     682:	08 44 e9    	dec.b     w8, w8
	bra	nz,8b     ; ---------->
     684:	ef ff 3a    	bra       NZ, 0x664 <L82>
	clr	TBLPAG
     686:	54 20 ef    	clr.w     0x54
	btss	Flag2,#6	; #6 EE Boot mode
     688:	de c9 ae    	btss.b    0x9de, #0x6
	bset	INTCON2,#GIE	; global int enable
     68a:	83 e0 a8    	bset.b    0x83, #0x7
	mov	#0x1000,w0
     68c:	00 00 21    	mov.w     #0x1000, w0
	mov	w0,NVMCON
     68e:	00 3b 88    	mov.w     w0, 0x760
	return
     690:	00 00 06    	return    

00000692 <boot_eeload>:

;---------------------------------------------------------------------------
boot_eeload:		; flash (w0×0x1000+0x1A000 or w0×0x800+0x1000) --> data (Rom or Rom+0x1000)
	call	eecalc_addr_w0
     692:	42 02 02    	call      0x242 <eecalc_addr_w0>
     694:	00 00 00 
	mov	w7,TBLPAG
     696:	a7 02 88    	mov.w     w7, 0x54
	mov	#Rom,w2
     698:	02 00 22    	mov.w     #0x2000, w2
	btsc	Flag2,#7	; #7 EE load to second halve of Rom area (start at 0x3000)
     69a:	de e9 af    	btsc.b    0x9de, #0x7
	mov	#Rom+0x1000,w2
     69c:	02 00 23    	mov.w     #0x3000, w2
	btsc	Flag2,#6
     69e:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_read_bootload
     6a0:	13 00 37    	bra       0x6c8 <case_read_bootload>
	mov	#0x800,w3	; 2048×24 bits for User's Program Load
     6a2:	03 80 20    	mov.w     #0x800, w3

000006a4 <L31>:
3:			;  <---- RD WR ----------------------------------
	tblrdh.b [w6],w1	; 8    w1 = high 2n xxxx xxxx BA98 ba98	
     6a4:	96 c0 ba    	tblrdh.b  [w6], w1
	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6a6:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6a8:	00 80 fd    	swap.w    w0
	mov.b	w1,w0		;      w0 = low by  7654 3210 BA98 ba98	
     6aa:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF ba98 (complemented data)
     6ac:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF ba98 7654 3210	
     6ae:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 1st program word		
     6b0:	00 19 78    	mov.w     w0, [w2++]

	tblrdl.b [w6++],w0	; 8    w0 = low by  xxxx xxxx 7654 3210	
     6b2:	36 40 ba    	tblrdl.b  [w6++], w0
	swap	w0		;      w0 = low by  7654 3210 xxxx xxxx	
     6b4:	00 80 fd    	swap.w    w0
	swap.b	w1		;      w1 = high 2n xxxx xxxx ba98 BA98	
     6b6:	01 c0 fd    	swap.b    w1
	mov.b	w1,w0		;      w0 = low by  7654 3210 ba98 BA98	
     6b8:	01 40 78    	mov.b     w1, w0
	ior.b	#0xF0,w0	;      w0 = low by  7654 3210 FFFF BA98 (complemented data)
     6ba:	00 4f b3    	ior.b     #0xf0, w0
	swap	w0		;      w0 = low by  FFFF BA98 7654 3210	
     6bc:	00 80 fd    	swap.w    w0
	mov	w0,[w2++]	;   12	 write 2nd program word		
     6be:	00 19 78    	mov.w     w0, [w2++]

	dec	w3,w3
     6c0:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; ---------------------------------------------->
     6c2:	f0 ff 3a    	bra       NZ, 0x6a4 <L31>
	clr	TBLPAG
     6c4:	54 20 ef    	clr.w     0x54
	return
     6c6:	00 00 06    	return    

000006c8 <case_read_bootload>:
;			
case_read_bootload:
	mov	#0x400,w3	; only 1024×24 bits for Boot !
     6c8:	03 40 20    	mov.w     #0x400, w3

000006ca <L32>:
3:			; \
	tblrdh.b [w6],w1	; read bits 16-23
     6ca:	96 c0 ba    	tblrdh.b  [w6], w1
	nop
     6cc:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 0-7
     6ce:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d0:	00 00 00    	nop       
	tblrdl.b [w6++],[w2++]	; bits 8-15
     6d2:	36 59 ba    	tblrdl.b  [w6++], [w2++]
	nop
     6d4:	00 00 00    	nop       
	mov.b	w1,[w2++]	; write bits 16-23
     6d6:	01 59 78    	mov.b     w1, [w2++]
	nop
     6d8:	00 00 00    	nop       
	clr.b	[w2++]		; skip 4th dummy byte
     6da:	00 59 eb    	clr.b     [w2++]
	nop
     6dc:	00 00 00    	nop       
	dec	w3,w3
     6de:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	; /
     6e0:	f4 ff 3a    	bra       NZ, 0x6ca <L32>
	clr	TBLPAG
     6e2:	54 20 ef    	clr.w     0x54
	return
     6e4:	00 00 06    	return    

000006e6 <boot_eemeasure>:

;-------------------------------
boot_eemeasure:		; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
     6e6:	de c9 a9    	bclr.b    0x9de, #0x6
	call	eecalc_addr_w0	; w6:w7
     6e8:	42 02 02    	call      0x242 <eecalc_addr_w0>
     6ea:	00 00 00 
	mov	w7,TBLPAG
     6ec:	a7 02 88    	mov.w     w7, 0x54
	mov	#0x8,w3		; w3 loop counter, 8 steps, 0x200 words = 1 bit ea
     6ee:	83 00 20    	mov.w     #0x8, w3
	mov	#0,w2		; w2 measured occupance (8 bits)
     6f0:	02 00 20    	mov.w     #0x0, w2

000006f2 <L33>:
3:			   ; \
	mov	#0x100,w4	; w4 inner loop counter
     6f2:	04 10 20    	mov.w     #0x100, w4
	setm	w1
     6f4:	80 80 eb    	setm.w    w1

000006f6 <L41>:
4:			   ; \\
	tblrdh.b [w6],w0	; w1 = high 2n xxxx xxxx BA98 ba98
     6f6:	16 c0 ba    	tblrdh.b  [w6], w0
	and.b	w1,w0,w1
     6f8:	80 c0 60    	and.b     w1, w0, w1
	tblrdl [w6++],w0	; w0 = low by  7654 3210 7654 3210
     6fa:	36 00 ba    	tblrdl.w  [w6++], w0
	and	w1,w0,w1
     6fc:	80 80 60    	and.w     w1, w0, w1
	dec	w4,w4
     6fe:	04 02 e9    	dec.w     w4, w4
	bra	nz,4b	   ; //
     700:	fa ff 3a    	bra       NZ, 0x6f6 <L41>
	sl	w2,w2
     702:	02 01 d0    	sl.w      w2, w2
	inc	w1,w1
     704:	81 00 e8    	inc.w     w1, w1
	ifnz
     706:	42 20 ae    	btss.b    0x42, #0x1
	bset	w2,#0
     708:	02 00 a0    	bset.w    w2, #0x0
	dec	w3,w3
     70a:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b	   ; /
     70c:	f2 ff 3a    	bra       NZ, 0x6f2 <L33>
	clr	TBLPAG
     70e:	54 20 ef    	clr.w     0x54
	return
     710:	00 00 06    	return    

00000712 <boot_eeerase_1K>:

; ------------------------------ PAGE ERASE -----------------------------
boot_eeerase_1K:	; erase block of 1K instructions (2K user pgm bytes + 1K high)
	mov	#0x5003,w0
     712:	30 00 25    	mov.w     #0x5003, w0
	mov	w0,NVMCON
     714:	00 3b 88    	mov.w     w0, 0x760
; Load the address of the page to be erased into the NVMADR register pair
	mov	w6,NVMADR
     716:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     718:	27 3b 88    	mov.w     w7, 0x764
	mov	#0x800,w0
     71a:	00 80 20    	mov.w     #0x800, w0
	add	w6,w0,w6
     71c:	00 03 43    	add.w     w6, w0, w6
	addc	w7,#0,w7
     71e:	e0 83 4b    	addc.w    w7, #0x0, w7
; Set the WR bit
	bra	eeiniseq_128
     720:	17 00 37    	bra       0x750 <eeiniseq_128>

00000722 <boot_eeburn_128>:

; ------------------------------- ROW BURN ------------------------------
boot_eeburn_128:	; burn row of 128 instructions, source ptr w2, dest w6:w7
; Set NVMCON for 128 instruction words (256 user pgm words), rd ptr w2, wr ptr w6:w7
	mov	#0x5002,w0
     722:	20 00 25    	mov.w     #0x5002, w0
	mov	w0,NVMCON
     724:	00 3b 88    	mov.w     w0, 0x760
; Set the NVMADRU/NVMADR reg pair to starting address
	mov	w6,NVMADR
     726:	16 3b 88    	mov.w     w6, 0x762
	mov	w7,NVMADRU
     728:	27 3b 88    	mov.w     w7, 0x764
	add	#256,w6		; prepare for the next row programming
     72a:	06 10 b0    	add.w     #0x100, w6
	addc	w7,#0,w7
     72c:	e0 83 4b    	addc.w    w7, #0x0, w7
; Initialize the TBLPAG register for writing to the latches
	mov	#0xfa,w0	; pgm latches are mapped at 0xFA0000-0xFA00FE
     72e:	a0 0f 20    	mov.w     #0xfa, w0
	mov	w0,TBLPAG
     730:	a0 02 88    	mov.w     w0, 0x54
	clr	w1		; low address
     732:	80 00 eb    	clr.w     w1
; Set up write data address pointer, W2 point to data in RAM
	mov	#128,w3		; loop counter
     734:	03 08 20    	mov.w     #0x80, w3
	btsc	Flag2,#6	; #6 EE Boot
     736:	de c9 af    	btsc.b    0x9de, #0x6
	bra	case_boot
     738:	18 00 37    	bra       0x76a <L42> <case_boot>

0000073a <L34>:
3:			; read 8+4+8+4 data bits, write 8+8+8 bits to latches
			;	 rd wr				
	tblwtl.b [w2++],[w1++]	; 8 8  [w1] = low by  7654 3210
     73a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	ze	[w2++],w4	; 4    w4 = 0000 0000 xxxx ba98
     73c:	32 82 fb    	ze        [w2++], w4
	and	#0x0F,w4	;      w4 = 0000 0000 0000 ba98
     73e:	f4 00 b2    	and.w     #0xf, w4
	tblwtl.b [w2++],[w1--]	; 8 8  [w1] = mid by  7654 3210
     740:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	ze	[w2++],w5	; 4    w5 = 0000 0000 xxxx BA98
     742:	b2 82 fb    	ze        [w2++], w5
	sl	w5,#4,w5	;      w4 = 0000 xxxx BA98 0000
     744:	c4 2a dd    	sl.w      w5, #0x4, w5
	ior	w4,w5,w4	;      w4 = 0000 xxxx BA98 ba98 (low word=low nib)
     746:	05 02 72    	ior.w     w4, w5, w4
	tblwth.b w4,[w1]	;   8  [w1] = high 2n BA98 ba98
     748:	84 c8 bb    	tblwth.b  w4, [w1]
	inc2	w1,w1
     74a:	81 80 e8    	inc2.w    w1, w1
	dec	w3,w3
     74c:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b
     74e:	f5 ff 3a    	bra       NZ, 0x73a <L34>

00000750 <eeiniseq_128>:
; Set the WR bit
eeiniseq_128:
	disi	#5		; DI for next 5 instructions
     750:	05 00 fc    	disi      #0x5
	mov.b	#0x55,w0
     752:	50 c5 b3    	mov.b     #0x55, w0
	mov	w0,NVMKEY	; Write the 1st key
     754:	30 3b 88    	mov.w     w0, 0x766
	mov.b	#0xAA,w0
     756:	a0 ca b3    	mov.b     #0xaa, w0
	mov	w0,NVMKEY	; Write the 2nd key
     758:	30 3b 88    	mov.w     w0, 0x766
	bset	NVMCON,#WR	; Start the programming sequence
     75a:	61 e7 a8    	bset.b    0x761, #0x7
	...
	nop			; Required delay
	nop			; Required delay
	nop			; Required delay
	btsc	NVMCON,#15	; and wait for it to be completed
     762:	61 e7 af    	btsc.b    0x761, #0x7

00000764 <L0>:
	bra	$-2
     764:	fe ff 37    	bra       0x762
	clr	TBLPAG
     766:	54 20 ef    	clr.w     0x54
	return
     768:	00 00 06    	return    

0000076a <L42>:
;	
case_boot:
4:			; read 8+8+8 data bits + skip, write 8+8+8 bits to latches
	tblwtl.b [w2++],[w1++]	; bits 0-7
     76a:	b2 58 bb    	tblwtl.b  [w2++], [w1++]
	nop
     76c:	00 00 00    	nop       
	tblwtl.b [w2++],[w1--]	; bits 8-15
     76e:	b2 50 bb    	tblwtl.b  [w2++], [w1--]
	nop
     770:	00 00 00    	nop       
	tblwth.b [w2++],[w1]	; bits 16-23
     772:	b2 c8 bb    	tblwth.b  [w2++], [w1]
	nop
     774:	00 00 00    	nop       
	inc2	w1,w1		; write ptr +2
     776:	81 80 e8    	inc2.w    w1, w1
	inc	w2,w2		; skip 4th dummy byte
     778:	02 01 e8    	inc.w     w2, w2
	dec	w3,w3
     77a:	83 01 e9    	dec.w     w3, w3
	bra	nz,4b
     77c:	f6 ff 3a    	bra       NZ, 0x76a <L42> <case_boot>
; Set the WR bit
	bra	eeiniseq_128
     77e:	e8 ff 37    	bra       0x750 <eeiniseq_128>

00000780 <boot_burn1k>:
;------------------------------------------------------------------------
boot_burn1k:		; burn 1K instructions, 3K bytes + 1K dummy 0's
	mov	#Rom,w0
     780:	00 00 22    	mov.w     #0x2000, w0
	mov	#Rom+0x1000,w1
     782:	01 00 23    	mov.w     #0x3000, w1
	repeat	#0x800-1	; 2048 ×
     784:	ff 07 09    	repeat    #0x7ff
	mov	[w0++],[w1++]	; move 4K bytes from Rom 1st halve to 2nd halve
     786:	b0 18 78    	mov.w     [w0++], [w1++]
	mov	#Rom,w0
     788:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x800-1	; 2048 ×
     78a:	ff 07 09    	repeat    #0x7ff
	setm	[w0++]		; clear	1st halve
     78c:	00 98 eb    	setm.w    [w0++]
	mov	w11,w0
     78e:	0b 00 78    	mov.w     w11, w0
	call	eesavew0	; burn 1024 instructions (×24 bits) from Rom 2nd halve
     790:	44 02 02    	call      0x244 <eesavew0>
     792:	00 00 00 
	inc	w11,w11
     794:	8b 05 e8    	inc.w     w11, w11
	return
     796:	00 00 06    	return    
     798:	ff ff 00    	nop       
     79a:	ff ff 00    	nop       
     79c:	ff ff 00    	nop       
     79e:	ff ff 00    	nop       
     7a0:	ff ff 00    	nop       
     7a2:	ff ff 00    	nop       
     7a4:	ff ff 00    	nop       
     7a6:	ff ff 00    	nop       
     7a8:	ff ff 00    	nop       
     7aa:	ff ff 00    	nop       
     7ac:	ff ff 00    	nop       
     7ae:	ff ff 00    	nop       
     7b0:	ff ff 00    	nop       
     7b2:	ff ff 00    	nop       
     7b4:	ff ff 00    	nop       
     7b6:	ff ff 00    	nop       
     7b8:	ff ff 00    	nop       
     7ba:	ff ff 00    	nop       
     7bc:	ff ff 00    	nop       
     7be:	ff ff 00    	nop       
     7c0:	ff ff 00    	nop       
     7c2:	ff ff 00    	nop       
     7c4:	ff ff 00    	nop       
     7c6:	ff ff 00    	nop       
     7c8:	ff ff 00    	nop       
     7ca:	ff ff 00    	nop       
     7cc:	ff ff 00    	nop       
     7ce:	ff ff 00    	nop       
     7d0:	ff ff 00    	nop       
     7d2:	ff ff 00    	nop       
     7d4:	ff ff 00    	nop       
     7d6:	ff ff 00    	nop       
     7d8:	ff ff 00    	nop       
     7da:	ff ff 00    	nop       
     7dc:	ff ff 00    	nop       
     7de:	ff ff 00    	nop       
     7e0:	ff ff 00    	nop       
     7e2:	ff ff 00    	nop       
     7e4:	ff ff 00    	nop       
     7e6:	ff ff 00    	nop       
     7e8:	ff ff 00    	nop       
     7ea:	ff ff 00    	nop       
     7ec:	ff ff 00    	nop       
     7ee:	ff ff 00    	nop       
     7f0:	ff ff 00    	nop       
     7f2:	ff ff 00    	nop       
     7f4:	ff ff 00    	nop       
     7f6:	ff ff 00    	nop       
     7f8:	ff ff 00    	nop       
     7fa:	ff ff 00    	nop       
     7fc:	ff ff 00    	nop       
     7fe:	ff ff 00    	nop       
     800:	ff ff 00    	nop       
     802:	ff ff 00    	nop       
     804:	ff ff 00    	nop       
     806:	ff ff 00    	nop       
     808:	ff ff 00    	nop       
     80a:	ff ff 00    	nop       
     80c:	ff ff 00    	nop       
     80e:	ff ff 00    	nop       
     810:	ff ff 00    	nop       
     812:	ff ff 00    	nop       
     814:	ff ff 00    	nop       
     816:	ff ff 00    	nop       
     818:	ff ff 00    	nop       
     81a:	ff ff 00    	nop       
     81c:	ff ff 00    	nop       
     81e:	ff ff 00    	nop       
     820:	ff ff 00    	nop       
     822:	ff ff 00    	nop       
     824:	ff ff 00    	nop       
     826:	ff ff 00    	nop       
     828:	ff ff 00    	nop       
     82a:	ff ff 00    	nop       
     82c:	ff ff 00    	nop       
     82e:	ff ff 00    	nop       
     830:	ff ff 00    	nop       
     832:	ff ff 00    	nop       
     834:	ff ff 00    	nop       
     836:	ff ff 00    	nop       
     838:	ff ff 00    	nop       
     83a:	ff ff 00    	nop       
     83c:	ff ff 00    	nop       
     83e:	ff ff 00    	nop       
     840:	ff ff 00    	nop       
     842:	ff ff 00    	nop       
     844:	ff ff 00    	nop       
     846:	ff ff 00    	nop       
     848:	ff ff 00    	nop       
     84a:	ff ff 00    	nop       
     84c:	ff ff 00    	nop       
     84e:	ff ff 00    	nop       
     850:	ff ff 00    	nop       
     852:	ff ff 00    	nop       
     854:	ff ff 00    	nop       
     856:	ff ff 00    	nop       
     858:	ff ff 00    	nop       
     85a:	ff ff 00    	nop       
     85c:	ff ff 00    	nop       
     85e:	ff ff 00    	nop       
     860:	ff ff 00    	nop       
     862:	ff ff 00    	nop       
     864:	ff ff 00    	nop       
     866:	ff ff 00    	nop       
     868:	ff ff 00    	nop       
     86a:	ff ff 00    	nop       
     86c:	ff ff 00    	nop       
     86e:	ff ff 00    	nop       
     870:	ff ff 00    	nop       
     872:	ff ff 00    	nop       
     874:	ff ff 00    	nop       
     876:	ff ff 00    	nop       
     878:	ff ff 00    	nop       
     87a:	ff ff 00    	nop       
     87c:	ff ff 00    	nop       
     87e:	ff ff 00    	nop       
     880:	ff ff 00    	nop       
     882:	ff ff 00    	nop       
     884:	ff ff 00    	nop       
     886:	ff ff 00    	nop       
     888:	ff ff 00    	nop       
     88a:	ff ff 00    	nop       
     88c:	ff ff 00    	nop       
     88e:	ff ff 00    	nop       
     890:	ff ff 00    	nop       
     892:	ff ff 00    	nop       
     894:	ff ff 00    	nop       
     896:	ff ff 00    	nop       
     898:	ff ff 00    	nop       
     89a:	ff ff 00    	nop       
     89c:	ff ff 00    	nop       
     89e:	ff ff 00    	nop       
     8a0:	ff ff 00    	nop       
     8a2:	ff ff 00    	nop       
     8a4:	ff ff 00    	nop       
     8a6:	ff ff 00    	nop       
     8a8:	ff ff 00    	nop       
     8aa:	ff ff 00    	nop       
     8ac:	ff ff 00    	nop       
     8ae:	ff ff 00    	nop       
     8b0:	ff ff 00    	nop       
     8b2:	ff ff 00    	nop       
     8b4:	ff ff 00    	nop       
     8b6:	ff ff 00    	nop       
     8b8:	ff ff 00    	nop       
     8ba:	ff ff 00    	nop       
     8bc:	ff ff 00    	nop       
     8be:	ff ff 00    	nop       
     8c0:	ff ff 00    	nop       
     8c2:	ff ff 00    	nop       
     8c4:	ff ff 00    	nop       
     8c6:	ff ff 00    	nop       
     8c8:	ff ff 00    	nop       
     8ca:	ff ff 00    	nop       
     8cc:	ff ff 00    	nop       
     8ce:	ff ff 00    	nop       
     8d0:	ff ff 00    	nop       
     8d2:	ff ff 00    	nop       
     8d4:	ff ff 00    	nop       
     8d6:	ff ff 00    	nop       
     8d8:	ff ff 00    	nop       
     8da:	ff ff 00    	nop       
     8dc:	ff ff 00    	nop       
     8de:	ff ff 00    	nop       
     8e0:	ff ff 00    	nop       
     8e2:	ff ff 00    	nop       
     8e4:	ff ff 00    	nop       
     8e6:	ff ff 00    	nop       
     8e8:	ff ff 00    	nop       
     8ea:	ff ff 00    	nop       
     8ec:	ff ff 00    	nop       
     8ee:	ff ff 00    	nop       
     8f0:	ff ff 00    	nop       
     8f2:	ff ff 00    	nop       
     8f4:	ff ff 00    	nop       
     8f6:	ff ff 00    	nop       
     8f8:	ff ff 00    	nop       
     8fa:	ff ff 00    	nop       
     8fc:	ff ff 00    	nop       
     8fe:	ff ff 00    	nop       
     900:	ff ff 00    	nop       
     902:	ff ff 00    	nop       
     904:	ff ff 00    	nop       
     906:	ff ff 00    	nop       
     908:	ff ff 00    	nop       
     90a:	ff ff 00    	nop       
     90c:	ff ff 00    	nop       
     90e:	ff ff 00    	nop       
     910:	ff ff 00    	nop       
     912:	ff ff 00    	nop       
     914:	ff ff 00    	nop       
     916:	ff ff 00    	nop       
     918:	ff ff 00    	nop       
     91a:	ff ff 00    	nop       
     91c:	ff ff 00    	nop       
     91e:	ff ff 00    	nop       
     920:	ff ff 00    	nop       
     922:	ff ff 00    	nop       
     924:	ff ff 00    	nop       
     926:	ff ff 00    	nop       
     928:	ff ff 00    	nop       
     92a:	ff ff 00    	nop       
     92c:	ff ff 00    	nop       
     92e:	ff ff 00    	nop       
     930:	ff ff 00    	nop       
     932:	ff ff 00    	nop       
     934:	ff ff 00    	nop       
     936:	ff ff 00    	nop       
     938:	ff ff 00    	nop       
     93a:	ff ff 00    	nop       
     93c:	ff ff 00    	nop       
     93e:	ff ff 00    	nop       
     940:	ff ff 00    	nop       
     942:	ff ff 00    	nop       
     944:	ff ff 00    	nop       
     946:	ff ff 00    	nop       
     948:	ff ff 00    	nop       
     94a:	ff ff 00    	nop       
     94c:	ff ff 00    	nop       
     94e:	ff ff 00    	nop       
     950:	ff ff 00    	nop       
     952:	ff ff 00    	nop       
     954:	ff ff 00    	nop       
     956:	ff ff 00    	nop       
     958:	ff ff 00    	nop       
     95a:	ff ff 00    	nop       
     95c:	ff ff 00    	nop       
     95e:	ff ff 00    	nop       
     960:	ff ff 00    	nop       
     962:	ff ff 00    	nop       
     964:	ff ff 00    	nop       
     966:	ff ff 00    	nop       
     968:	ff ff 00    	nop       
     96a:	ff ff 00    	nop       
     96c:	ff ff 00    	nop       
     96e:	ff ff 00    	nop       
     970:	ff ff 00    	nop       
     972:	ff ff 00    	nop       
     974:	ff ff 00    	nop       
     976:	ff ff 00    	nop       
     978:	ff ff 00    	nop       
     97a:	ff ff 00    	nop       
     97c:	ff ff 00    	nop       
     97e:	ff ff 00    	nop       
     980:	ff ff 00    	nop       
     982:	ff ff 00    	nop       
     984:	ff ff 00    	nop       
     986:	ff ff 00    	nop       
     988:	ff ff 00    	nop       
     98a:	ff ff 00    	nop       
     98c:	ff ff 00    	nop       
     98e:	ff ff 00    	nop       
     990:	ff ff 00    	nop       
     992:	ff ff 00    	nop       
     994:	ff ff 00    	nop       
     996:	ff ff 00    	nop       
     998:	ff ff 00    	nop       
     99a:	ff ff 00    	nop       
     99c:	ff ff 00    	nop       
     99e:	ff ff 00    	nop       
     9a0:	ff ff 00    	nop       
     9a2:	ff ff 00    	nop       
     9a4:	ff ff 00    	nop       
     9a6:	ff ff 00    	nop       
     9a8:	ff ff 00    	nop       
     9aa:	ff ff 00    	nop       
     9ac:	ff ff 00    	nop       
     9ae:	ff ff 00    	nop       
     9b0:	ff ff 00    	nop       
     9b2:	ff ff 00    	nop       
     9b4:	ff ff 00    	nop       
     9b6:	ff ff 00    	nop       
     9b8:	ff ff 00    	nop       
     9ba:	ff ff 00    	nop       
     9bc:	ff ff 00    	nop       
     9be:	ff ff 00    	nop       
     9c0:	ff ff 00    	nop       
     9c2:	ff ff 00    	nop       
     9c4:	ff ff 00    	nop       
     9c6:	ff ff 00    	nop       
     9c8:	ff ff 00    	nop       
     9ca:	ff ff 00    	nop       
     9cc:	ff ff 00    	nop       
     9ce:	ff ff 00    	nop       
     9d0:	ff ff 00    	nop       
     9d2:	ff ff 00    	nop       
     9d4:	ff ff 00    	nop       
     9d6:	ff ff 00    	nop       
     9d8:	ff ff 00    	nop       
     9da:	ff ff 00    	nop       
     9dc:	ff ff 00    	nop       
     9de:	ff ff 00    	nop       
     9e0:	ff ff 00    	nop       
     9e2:	ff ff 00    	nop       
     9e4:	ff ff 00    	nop       
     9e6:	ff ff 00    	nop       
     9e8:	ff ff 00    	nop       
     9ea:	ff ff 00    	nop       
     9ec:	ff ff 00    	nop       
     9ee:	ff ff 00    	nop       
     9f0:	ff ff 00    	nop       
     9f2:	ff ff 00    	nop       
     9f4:	ff ff 00    	nop       
     9f6:	ff ff 00    	nop       
     9f8:	ff ff 00    	nop       
     9fa:	ff ff 00    	nop       
     9fc:	ff ff 00    	nop       
     9fe:	ff ff 00    	nop       
     a00:	ff ff 00    	nop       
     a02:	ff ff 00    	nop       
     a04:	ff ff 00    	nop       
     a06:	ff ff 00    	nop       
     a08:	ff ff 00    	nop       
     a0a:	ff ff 00    	nop       
     a0c:	ff ff 00    	nop       
     a0e:	ff ff 00    	nop       
     a10:	ff ff 00    	nop       
     a12:	ff ff 00    	nop       
     a14:	ff ff 00    	nop       
     a16:	ff ff 00    	nop       
     a18:	ff ff 00    	nop       
     a1a:	ff ff 00    	nop       
     a1c:	ff ff 00    	nop       
     a1e:	ff ff 00    	nop       
     a20:	ff ff 00    	nop       
     a22:	ff ff 00    	nop       
     a24:	ff ff 00    	nop       
     a26:	ff ff 00    	nop       
     a28:	ff ff 00    	nop       
     a2a:	ff ff 00    	nop       
     a2c:	ff ff 00    	nop       
     a2e:	ff ff 00    	nop       
     a30:	ff ff 00    	nop       
     a32:	ff ff 00    	nop       
     a34:	ff ff 00    	nop       
     a36:	ff ff 00    	nop       
     a38:	ff ff 00    	nop       
     a3a:	ff ff 00    	nop       
     a3c:	ff ff 00    	nop       
     a3e:	ff ff 00    	nop       
     a40:	ff ff 00    	nop       
     a42:	ff ff 00    	nop       
     a44:	ff ff 00    	nop       
     a46:	ff ff 00    	nop       
     a48:	ff ff 00    	nop       
     a4a:	ff ff 00    	nop       
     a4c:	ff ff 00    	nop       
     a4e:	ff ff 00    	nop       
     a50:	ff ff 00    	nop       
     a52:	ff ff 00    	nop       
     a54:	ff ff 00    	nop       
     a56:	ff ff 00    	nop       
     a58:	ff ff 00    	nop       
     a5a:	ff ff 00    	nop       
     a5c:	ff ff 00    	nop       
     a5e:	ff ff 00    	nop       
     a60:	ff ff 00    	nop       
     a62:	ff ff 00    	nop       
     a64:	ff ff 00    	nop       
     a66:	ff ff 00    	nop       
     a68:	ff ff 00    	nop       
     a6a:	ff ff 00    	nop       
     a6c:	ff ff 00    	nop       
     a6e:	ff ff 00    	nop       
     a70:	ff ff 00    	nop       
     a72:	ff ff 00    	nop       
     a74:	ff ff 00    	nop       
     a76:	ff ff 00    	nop       
     a78:	ff ff 00    	nop       
     a7a:	ff ff 00    	nop       
     a7c:	ff ff 00    	nop       
     a7e:	ff ff 00    	nop       
     a80:	ff ff 00    	nop       
     a82:	ff ff 00    	nop       
     a84:	ff ff 00    	nop       
     a86:	ff ff 00    	nop       
     a88:	ff ff 00    	nop       
     a8a:	ff ff 00    	nop       
     a8c:	ff ff 00    	nop       
     a8e:	ff ff 00    	nop       
     a90:	ff ff 00    	nop       
     a92:	ff ff 00    	nop       
     a94:	ff ff 00    	nop       
     a96:	ff ff 00    	nop       
     a98:	ff ff 00    	nop       
     a9a:	ff ff 00    	nop       
     a9c:	ff ff 00    	nop       
     a9e:	ff ff 00    	nop       
     aa0:	ff ff 00    	nop       
     aa2:	ff ff 00    	nop       
     aa4:	ff ff 00    	nop       
     aa6:	ff ff 00    	nop       
     aa8:	ff ff 00    	nop       
     aaa:	ff ff 00    	nop       
     aac:	ff ff 00    	nop       
     aae:	ff ff 00    	nop       
     ab0:	ff ff 00    	nop       
     ab2:	ff ff 00    	nop       
     ab4:	ff ff 00    	nop       
     ab6:	ff ff 00    	nop       
     ab8:	ff ff 00    	nop       
     aba:	ff ff 00    	nop       
     abc:	ff ff 00    	nop       
     abe:	ff ff 00    	nop       
     ac0:	ff ff 00    	nop       
     ac2:	ff ff 00    	nop       
     ac4:	ff ff 00    	nop       
     ac6:	ff ff 00    	nop       
     ac8:	ff ff 00    	nop       
     aca:	ff ff 00    	nop       
     acc:	ff ff 00    	nop       
     ace:	ff ff 00    	nop       
     ad0:	ff ff 00    	nop       
     ad2:	ff ff 00    	nop       
     ad4:	ff ff 00    	nop       
     ad6:	ff ff 00    	nop       
     ad8:	ff ff 00    	nop       
     ada:	ff ff 00    	nop       
     adc:	ff ff 00    	nop       
     ade:	ff ff 00    	nop       
     ae0:	ff ff 00    	nop       
     ae2:	ff ff 00    	nop       
     ae4:	ff ff 00    	nop       
     ae6:	ff ff 00    	nop       
     ae8:	ff ff 00    	nop       
     aea:	ff ff 00    	nop       
     aec:	ff ff 00    	nop       
     aee:	ff ff 00    	nop       
     af0:	ff ff 00    	nop       
     af2:	ff ff 00    	nop       
     af4:	ff ff 00    	nop       
     af6:	ff ff 00    	nop       
     af8:	ff ff 00    	nop       
     afa:	ff ff 00    	nop       
     afc:	ff ff 00    	nop       
     afe:	ff ff 00    	nop       
     b00:	ff ff 00    	nop       
     b02:	ff ff 00    	nop       
     b04:	ff ff 00    	nop       
     b06:	ff ff 00    	nop       
     b08:	ff ff 00    	nop       
     b0a:	ff ff 00    	nop       
     b0c:	ff ff 00    	nop       
     b0e:	ff ff 00    	nop       
     b10:	ff ff 00    	nop       
     b12:	ff ff 00    	nop       
     b14:	ff ff 00    	nop       
     b16:	ff ff 00    	nop       
     b18:	ff ff 00    	nop       
     b1a:	ff ff 00    	nop       
     b1c:	ff ff 00    	nop       
     b1e:	ff ff 00    	nop       
     b20:	ff ff 00    	nop       
     b22:	ff ff 00    	nop       
     b24:	ff ff 00    	nop       
     b26:	ff ff 00    	nop       
     b28:	ff ff 00    	nop       
     b2a:	ff ff 00    	nop       
     b2c:	ff ff 00    	nop       
     b2e:	ff ff 00    	nop       
     b30:	ff ff 00    	nop       
     b32:	ff ff 00    	nop       
     b34:	ff ff 00    	nop       
     b36:	ff ff 00    	nop       
     b38:	ff ff 00    	nop       
     b3a:	ff ff 00    	nop       
     b3c:	ff ff 00    	nop       
     b3e:	ff ff 00    	nop       
     b40:	ff ff 00    	nop       
     b42:	ff ff 00    	nop       
     b44:	ff ff 00    	nop       
     b46:	ff ff 00    	nop       
     b48:	ff ff 00    	nop       
     b4a:	ff ff 00    	nop       
     b4c:	ff ff 00    	nop       
     b4e:	ff ff 00    	nop       
     b50:	ff ff 00    	nop       
     b52:	ff ff 00    	nop       
     b54:	ff ff 00    	nop       
     b56:	ff ff 00    	nop       
     b58:	ff ff 00    	nop       
     b5a:	ff ff 00    	nop       
     b5c:	ff ff 00    	nop       
     b5e:	ff ff 00    	nop       
     b60:	ff ff 00    	nop       
     b62:	ff ff 00    	nop       
     b64:	ff ff 00    	nop       
     b66:	ff ff 00    	nop       
     b68:	ff ff 00    	nop       
     b6a:	ff ff 00    	nop       
     b6c:	ff ff 00    	nop       
     b6e:	ff ff 00    	nop       
     b70:	ff ff 00    	nop       
     b72:	ff ff 00    	nop       
     b74:	ff ff 00    	nop       
     b76:	ff ff 00    	nop       
     b78:	ff ff 00    	nop       
     b7a:	ff ff 00    	nop       
     b7c:	ff ff 00    	nop       
     b7e:	ff ff 00    	nop       
     b80:	ff ff 00    	nop       
     b82:	ff ff 00    	nop       
     b84:	ff ff 00    	nop       
     b86:	ff ff 00    	nop       
     b88:	ff ff 00    	nop       
     b8a:	ff ff 00    	nop       
     b8c:	ff ff 00    	nop       
     b8e:	ff ff 00    	nop       
     b90:	ff ff 00    	nop       
     b92:	ff ff 00    	nop       
     b94:	ff ff 00    	nop       
     b96:	ff ff 00    	nop       
     b98:	ff ff 00    	nop       
     b9a:	ff ff 00    	nop       
     b9c:	ff ff 00    	nop       
     b9e:	ff ff 00    	nop       
     ba0:	ff ff 00    	nop       
     ba2:	ff ff 00    	nop       
     ba4:	ff ff 00    	nop       
     ba6:	ff ff 00    	nop       
     ba8:	ff ff 00    	nop       
     baa:	ff ff 00    	nop       
     bac:	ff ff 00    	nop       
     bae:	ff ff 00    	nop       
     bb0:	ff ff 00    	nop       
     bb2:	ff ff 00    	nop       
     bb4:	ff ff 00    	nop       
     bb6:	ff ff 00    	nop       
     bb8:	ff ff 00    	nop       
     bba:	ff ff 00    	nop       
     bbc:	ff ff 00    	nop       
     bbe:	ff ff 00    	nop       
     bc0:	ff ff 00    	nop       
     bc2:	ff ff 00    	nop       
     bc4:	ff ff 00    	nop       
     bc6:	ff ff 00    	nop       
     bc8:	ff ff 00    	nop       
     bca:	ff ff 00    	nop       
     bcc:	ff ff 00    	nop       
     bce:	ff ff 00    	nop       
     bd0:	ff ff 00    	nop       
     bd2:	ff ff 00    	nop       
     bd4:	ff ff 00    	nop       
     bd6:	ff ff 00    	nop       
     bd8:	ff ff 00    	nop       
     bda:	ff ff 00    	nop       
     bdc:	ff ff 00    	nop       
     bde:	ff ff 00    	nop       
     be0:	ff ff 00    	nop       
     be2:	ff ff 00    	nop       
     be4:	ff ff 00    	nop       
     be6:	ff ff 00    	nop       
     be8:	ff ff 00    	nop       
     bea:	ff ff 00    	nop       
     bec:	ff ff 00    	nop       
     bee:	ff ff 00    	nop       
     bf0:	ff ff 00    	nop       
     bf2:	ff ff 00    	nop       
     bf4:	ff ff 00    	nop       
     bf6:	ff ff 00    	nop       
     bf8:	ff ff 00    	nop       
     bfa:	ff ff 00    	nop       
     bfc:	ff ff 00    	nop       
     bfe:	ff ff 00    	nop       
     c00:	ff ff 00    	nop       
     c02:	ff ff 00    	nop       
     c04:	ff ff 00    	nop       
     c06:	ff ff 00    	nop       
     c08:	ff ff 00    	nop       
     c0a:	ff ff 00    	nop       
     c0c:	ff ff 00    	nop       
     c0e:	ff ff 00    	nop       
     c10:	ff ff 00    	nop       
     c12:	ff ff 00    	nop       
     c14:	ff ff 00    	nop       
     c16:	ff ff 00    	nop       
     c18:	ff ff 00    	nop       
     c1a:	ff ff 00    	nop       
     c1c:	ff ff 00    	nop       
     c1e:	ff ff 00    	nop       
     c20:	ff ff 00    	nop       
     c22:	ff ff 00    	nop       
     c24:	ff ff 00    	nop       
     c26:	ff ff 00    	nop       
     c28:	ff ff 00    	nop       
     c2a:	ff ff 00    	nop       
     c2c:	ff ff 00    	nop       
     c2e:	ff ff 00    	nop       
     c30:	ff ff 00    	nop       
     c32:	ff ff 00    	nop       
     c34:	ff ff 00    	nop       
     c36:	ff ff 00    	nop       
     c38:	ff ff 00    	nop       
     c3a:	ff ff 00    	nop       
     c3c:	ff ff 00    	nop       
     c3e:	ff ff 00    	nop       
     c40:	ff ff 00    	nop       
     c42:	ff ff 00    	nop       
     c44:	ff ff 00    	nop       
     c46:	ff ff 00    	nop       
     c48:	ff ff 00    	nop       
     c4a:	ff ff 00    	nop       
     c4c:	ff ff 00    	nop       
     c4e:	ff ff 00    	nop       
     c50:	ff ff 00    	nop       
     c52:	ff ff 00    	nop       
     c54:	ff ff 00    	nop       
     c56:	ff ff 00    	nop       
     c58:	ff ff 00    	nop       
     c5a:	ff ff 00    	nop       
     c5c:	ff ff 00    	nop       
     c5e:	ff ff 00    	nop       
     c60:	ff ff 00    	nop       
     c62:	ff ff 00    	nop       
     c64:	ff ff 00    	nop       
     c66:	ff ff 00    	nop       
     c68:	ff ff 00    	nop       
     c6a:	ff ff 00    	nop       
     c6c:	ff ff 00    	nop       
     c6e:	ff ff 00    	nop       
     c70:	ff ff 00    	nop       
     c72:	ff ff 00    	nop       
     c74:	ff ff 00    	nop       
     c76:	ff ff 00    	nop       
     c78:	ff ff 00    	nop       
     c7a:	ff ff 00    	nop       
     c7c:	ff ff 00    	nop       
     c7e:	ff ff 00    	nop       
     c80:	ff ff 00    	nop       
     c82:	ff ff 00    	nop       
     c84:	ff ff 00    	nop       
     c86:	ff ff 00    	nop       
     c88:	ff ff 00    	nop       
     c8a:	ff ff 00    	nop       
     c8c:	ff ff 00    	nop       
     c8e:	ff ff 00    	nop       
     c90:	ff ff 00    	nop       
     c92:	ff ff 00    	nop       
     c94:	ff ff 00    	nop       
     c96:	ff ff 00    	nop       
     c98:	ff ff 00    	nop       
     c9a:	ff ff 00    	nop       
     c9c:	ff ff 00    	nop       
     c9e:	ff ff 00    	nop       
     ca0:	ff ff 00    	nop       
     ca2:	ff ff 00    	nop       
     ca4:	ff ff 00    	nop       
     ca6:	ff ff 00    	nop       
     ca8:	ff ff 00    	nop       
     caa:	ff ff 00    	nop       
     cac:	ff ff 00    	nop       
     cae:	ff ff 00    	nop       
     cb0:	ff ff 00    	nop       
     cb2:	ff ff 00    	nop       
     cb4:	ff ff 00    	nop       
     cb6:	ff ff 00    	nop       
     cb8:	ff ff 00    	nop       
     cba:	ff ff 00    	nop       
     cbc:	ff ff 00    	nop       
     cbe:	ff ff 00    	nop       
     cc0:	ff ff 00    	nop       
     cc2:	ff ff 00    	nop       
     cc4:	ff ff 00    	nop       
     cc6:	ff ff 00    	nop       
     cc8:	ff ff 00    	nop       
     cca:	ff ff 00    	nop       
     ccc:	ff ff 00    	nop       
     cce:	ff ff 00    	nop       
     cd0:	ff ff 00    	nop       
     cd2:	ff ff 00    	nop       
     cd4:	ff ff 00    	nop       
     cd6:	ff ff 00    	nop       
     cd8:	ff ff 00    	nop       
     cda:	ff ff 00    	nop       
     cdc:	ff ff 00    	nop       
     cde:	ff ff 00    	nop       
     ce0:	ff ff 00    	nop       
     ce2:	ff ff 00    	nop       
     ce4:	ff ff 00    	nop       
     ce6:	ff ff 00    	nop       
     ce8:	ff ff 00    	nop       
     cea:	ff ff 00    	nop       
     cec:	ff ff 00    	nop       
     cee:	ff ff 00    	nop       
     cf0:	ff ff 00    	nop       
     cf2:	ff ff 00    	nop       
     cf4:	ff ff 00    	nop       
     cf6:	ff ff 00    	nop       
     cf8:	ff ff 00    	nop       
     cfa:	ff ff 00    	nop       
     cfc:	ff ff 00    	nop       
     cfe:	ff ff 00    	nop       
     d00:	ff ff 00    	nop       
     d02:	ff ff 00    	nop       
     d04:	ff ff 00    	nop       
     d06:	ff ff 00    	nop       
     d08:	ff ff 00    	nop       
     d0a:	ff ff 00    	nop       
     d0c:	ff ff 00    	nop       
     d0e:	ff ff 00    	nop       
     d10:	ff ff 00    	nop       
     d12:	ff ff 00    	nop       
     d14:	ff ff 00    	nop       
     d16:	ff ff 00    	nop       
     d18:	ff ff 00    	nop       
     d1a:	ff ff 00    	nop       
     d1c:	ff ff 00    	nop       
     d1e:	ff ff 00    	nop       
     d20:	ff ff 00    	nop       
     d22:	ff ff 00    	nop       
     d24:	ff ff 00    	nop       
     d26:	ff ff 00    	nop       
     d28:	ff ff 00    	nop       
     d2a:	ff ff 00    	nop       
     d2c:	ff ff 00    	nop       
     d2e:	ff ff 00    	nop       
     d30:	ff ff 00    	nop       
     d32:	ff ff 00    	nop       
     d34:	ff ff 00    	nop       
     d36:	ff ff 00    	nop       
     d38:	ff ff 00    	nop       
     d3a:	ff ff 00    	nop       
     d3c:	ff ff 00    	nop       
     d3e:	ff ff 00    	nop       
     d40:	ff ff 00    	nop       
     d42:	ff ff 00    	nop       
     d44:	ff ff 00    	nop       
     d46:	ff ff 00    	nop       
     d48:	ff ff 00    	nop       
     d4a:	ff ff 00    	nop       
     d4c:	ff ff 00    	nop       
     d4e:	ff ff 00    	nop       
     d50:	ff ff 00    	nop       
     d52:	ff ff 00    	nop       
     d54:	ff ff 00    	nop       
     d56:	ff ff 00    	nop       
     d58:	ff ff 00    	nop       
     d5a:	ff ff 00    	nop       
     d5c:	ff ff 00    	nop       
     d5e:	ff ff 00    	nop       
     d60:	ff ff 00    	nop       
     d62:	ff ff 00    	nop       
     d64:	ff ff 00    	nop       
     d66:	ff ff 00    	nop       
     d68:	ff ff 00    	nop       
     d6a:	ff ff 00    	nop       
     d6c:	ff ff 00    	nop       
     d6e:	ff ff 00    	nop       
     d70:	ff ff 00    	nop       
     d72:	ff ff 00    	nop       
     d74:	ff ff 00    	nop       
     d76:	ff ff 00    	nop       
     d78:	ff ff 00    	nop       
     d7a:	ff ff 00    	nop       
     d7c:	ff ff 00    	nop       
     d7e:	ff ff 00    	nop       
     d80:	ff ff 00    	nop       
     d82:	ff ff 00    	nop       
     d84:	ff ff 00    	nop       
     d86:	ff ff 00    	nop       
     d88:	ff ff 00    	nop       
     d8a:	ff ff 00    	nop       
     d8c:	ff ff 00    	nop       
     d8e:	ff ff 00    	nop       
     d90:	ff ff 00    	nop       
     d92:	ff ff 00    	nop       
     d94:	ff ff 00    	nop       
     d96:	ff ff 00    	nop       
     d98:	ff ff 00    	nop       
     d9a:	ff ff 00    	nop       
     d9c:	ff ff 00    	nop       
     d9e:	ff ff 00    	nop       
     da0:	ff ff 00    	nop       
     da2:	ff ff 00    	nop       
     da4:	ff ff 00    	nop       
     da6:	ff ff 00    	nop       
     da8:	ff ff 00    	nop       
     daa:	ff ff 00    	nop       
     dac:	ff ff 00    	nop       
     dae:	ff ff 00    	nop       
     db0:	ff ff 00    	nop       
     db2:	ff ff 00    	nop       
     db4:	ff ff 00    	nop       
     db6:	ff ff 00    	nop       
     db8:	ff ff 00    	nop       
     dba:	ff ff 00    	nop       
     dbc:	ff ff 00    	nop       
     dbe:	ff ff 00    	nop       
     dc0:	ff ff 00    	nop       
     dc2:	ff ff 00    	nop       
     dc4:	ff ff 00    	nop       
     dc6:	ff ff 00    	nop       
     dc8:	ff ff 00    	nop       
     dca:	ff ff 00    	nop       
     dcc:	ff ff 00    	nop       
     dce:	ff ff 00    	nop       
     dd0:	ff ff 00    	nop       
     dd2:	ff ff 00    	nop       
     dd4:	ff ff 00    	nop       
     dd6:	ff ff 00    	nop       
     dd8:	ff ff 00    	nop       
     dda:	ff ff 00    	nop       
     ddc:	ff ff 00    	nop       
     dde:	ff ff 00    	nop       
     de0:	ff ff 00    	nop       
     de2:	ff ff 00    	nop       
     de4:	ff ff 00    	nop       
     de6:	ff ff 00    	nop       
     de8:	ff ff 00    	nop       
     dea:	ff ff 00    	nop       
     dec:	ff ff 00    	nop       
     dee:	ff ff 00    	nop       
     df0:	ff ff 00    	nop       
     df2:	ff ff 00    	nop       
     df4:	ff ff 00    	nop       
     df6:	ff ff 00    	nop       
     df8:	ff ff 00    	nop       
     dfa:	ff ff 00    	nop       
     dfc:	ff ff 00    	nop       
     dfe:	ff ff 00    	nop       
     e00:	ff ff 00    	nop       
     e02:	ff ff 00    	nop       
     e04:	ff ff 00    	nop       
     e06:	ff ff 00    	nop       
     e08:	ff ff 00    	nop       
     e0a:	ff ff 00    	nop       
     e0c:	ff ff 00    	nop       
     e0e:	ff ff 00    	nop       
     e10:	ff ff 00    	nop       
     e12:	ff ff 00    	nop       
     e14:	ff ff 00    	nop       
     e16:	ff ff 00    	nop       
     e18:	ff ff 00    	nop       
     e1a:	ff ff 00    	nop       
     e1c:	ff ff 00    	nop       
     e1e:	ff ff 00    	nop       
     e20:	ff ff 00    	nop       
     e22:	ff ff 00    	nop       
     e24:	ff ff 00    	nop       
     e26:	ff ff 00    	nop       
     e28:	ff ff 00    	nop       
     e2a:	ff ff 00    	nop       
     e2c:	ff ff 00    	nop       
     e2e:	ff ff 00    	nop       
     e30:	ff ff 00    	nop       
     e32:	ff ff 00    	nop       
     e34:	ff ff 00    	nop       
     e36:	ff ff 00    	nop       
     e38:	ff ff 00    	nop       
     e3a:	ff ff 00    	nop       
     e3c:	ff ff 00    	nop       
     e3e:	ff ff 00    	nop       
     e40:	ff ff 00    	nop       
     e42:	ff ff 00    	nop       
     e44:	ff ff 00    	nop       
     e46:	ff ff 00    	nop       
     e48:	ff ff 00    	nop       
     e4a:	ff ff 00    	nop       
     e4c:	ff ff 00    	nop       
     e4e:	ff ff 00    	nop       
     e50:	ff ff 00    	nop       
     e52:	ff ff 00    	nop       
     e54:	ff ff 00    	nop       
     e56:	ff ff 00    	nop       
     e58:	ff ff 00    	nop       
     e5a:	ff ff 00    	nop       
     e5c:	ff ff 00    	nop       
     e5e:	ff ff 00    	nop       
     e60:	ff ff 00    	nop       
     e62:	ff ff 00    	nop       
     e64:	ff ff 00    	nop       
     e66:	ff ff 00    	nop       
     e68:	ff ff 00    	nop       
     e6a:	ff ff 00    	nop       
     e6c:	ff ff 00    	nop       
     e6e:	ff ff 00    	nop       
     e70:	ff ff 00    	nop       
     e72:	ff ff 00    	nop       
     e74:	ff ff 00    	nop       
     e76:	ff ff 00    	nop       
     e78:	ff ff 00    	nop       
     e7a:	ff ff 00    	nop       
     e7c:	ff ff 00    	nop       
     e7e:	ff ff 00    	nop       
     e80:	ff ff 00    	nop       
     e82:	ff ff 00    	nop       
     e84:	ff ff 00    	nop       
     e86:	ff ff 00    	nop       
     e88:	ff ff 00    	nop       
     e8a:	ff ff 00    	nop       
     e8c:	ff ff 00    	nop       
     e8e:	ff ff 00    	nop       
     e90:	ff ff 00    	nop       
     e92:	ff ff 00    	nop       
     e94:	ff ff 00    	nop       
     e96:	ff ff 00    	nop       
     e98:	ff ff 00    	nop       
     e9a:	ff ff 00    	nop       
     e9c:	ff ff 00    	nop       
     e9e:	ff ff 00    	nop       
     ea0:	ff ff 00    	nop       
     ea2:	ff ff 00    	nop       
     ea4:	ff ff 00    	nop       
     ea6:	ff ff 00    	nop       
     ea8:	ff ff 00    	nop       
     eaa:	ff ff 00    	nop       
     eac:	ff ff 00    	nop       
     eae:	ff ff 00    	nop       
     eb0:	ff ff 00    	nop       
     eb2:	ff ff 00    	nop       
     eb4:	ff ff 00    	nop       
     eb6:	ff ff 00    	nop       
     eb8:	ff ff 00    	nop       
     eba:	ff ff 00    	nop       
     ebc:	ff ff 00    	nop       
     ebe:	ff ff 00    	nop       
     ec0:	ff ff 00    	nop       
     ec2:	ff ff 00    	nop       
     ec4:	ff ff 00    	nop       
     ec6:	ff ff 00    	nop       
     ec8:	ff ff 00    	nop       
     eca:	ff ff 00    	nop       
     ecc:	ff ff 00    	nop       
     ece:	ff ff 00    	nop       
     ed0:	ff ff 00    	nop       
     ed2:	ff ff 00    	nop       
     ed4:	ff ff 00    	nop       
     ed6:	ff ff 00    	nop       
     ed8:	ff ff 00    	nop       
     eda:	ff ff 00    	nop       
     edc:	ff ff 00    	nop       
     ede:	ff ff 00    	nop       
     ee0:	ff ff 00    	nop       
     ee2:	ff ff 00    	nop       
     ee4:	ff ff 00    	nop       
     ee6:	ff ff 00    	nop       
     ee8:	ff ff 00    	nop       
     eea:	ff ff 00    	nop       
     eec:	ff ff 00    	nop       
     eee:	ff ff 00    	nop       
     ef0:	ff ff 00    	nop       
     ef2:	ff ff 00    	nop       
     ef4:	ff ff 00    	nop       
     ef6:	ff ff 00    	nop       
     ef8:	ff ff 00    	nop       
     efa:	ff ff 00    	nop       
     efc:	ff ff 00    	nop       
     efe:	ff ff 00    	nop       
     f00:	ff ff 00    	nop       
     f02:	ff ff 00    	nop       
     f04:	ff ff 00    	nop       
     f06:	ff ff 00    	nop       
     f08:	ff ff 00    	nop       
     f0a:	ff ff 00    	nop       
     f0c:	ff ff 00    	nop       
     f0e:	ff ff 00    	nop       
     f10:	ff ff 00    	nop       
     f12:	ff ff 00    	nop       
     f14:	ff ff 00    	nop       
     f16:	ff ff 00    	nop       
     f18:	ff ff 00    	nop       
     f1a:	ff ff 00    	nop       
     f1c:	ff ff 00    	nop       
     f1e:	ff ff 00    	nop       
     f20:	ff ff 00    	nop       
     f22:	ff ff 00    	nop       
     f24:	ff ff 00    	nop       
     f26:	ff ff 00    	nop       
     f28:	ff ff 00    	nop       
     f2a:	ff ff 00    	nop       
     f2c:	ff ff 00    	nop       
     f2e:	ff ff 00    	nop       
     f30:	ff ff 00    	nop       
     f32:	ff ff 00    	nop       
     f34:	ff ff 00    	nop       
     f36:	ff ff 00    	nop       
     f38:	ff ff 00    	nop       
     f3a:	ff ff 00    	nop       
     f3c:	ff ff 00    	nop       
     f3e:	ff ff 00    	nop       
     f40:	ff ff 00    	nop       
     f42:	ff ff 00    	nop       
     f44:	ff ff 00    	nop       
     f46:	ff ff 00    	nop       
     f48:	ff ff 00    	nop       
     f4a:	ff ff 00    	nop       
     f4c:	ff ff 00    	nop       
     f4e:	ff ff 00    	nop       
     f50:	ff ff 00    	nop       
     f52:	ff ff 00    	nop       
     f54:	ff ff 00    	nop       
     f56:	ff ff 00    	nop       
     f58:	ff ff 00    	nop       
     f5a:	ff ff 00    	nop       
     f5c:	ff ff 00    	nop       
     f5e:	ff ff 00    	nop       
     f60:	ff ff 00    	nop       
     f62:	ff ff 00    	nop       
     f64:	ff ff 00    	nop       
     f66:	ff ff 00    	nop       
     f68:	ff ff 00    	nop       
     f6a:	ff ff 00    	nop       
     f6c:	ff ff 00    	nop       
     f6e:	ff ff 00    	nop       
     f70:	ff ff 00    	nop       
     f72:	ff ff 00    	nop       
     f74:	ff ff 00    	nop       
     f76:	ff ff 00    	nop       
     f78:	ff ff 00    	nop       
     f7a:	ff ff 00    	nop       
     f7c:	ff ff 00    	nop       
     f7e:	ff ff 00    	nop       
     f80:	ff ff 00    	nop       
     f82:	ff ff 00    	nop       
     f84:	ff ff 00    	nop       
     f86:	ff ff 00    	nop       
     f88:	ff ff 00    	nop       
     f8a:	ff ff 00    	nop       
     f8c:	ff ff 00    	nop       
     f8e:	ff ff 00    	nop       
     f90:	ff ff 00    	nop       
     f92:	ff ff 00    	nop       
     f94:	ff ff 00    	nop       
     f96:	ff ff 00    	nop       
     f98:	ff ff 00    	nop       
     f9a:	ff ff 00    	nop       
     f9c:	ff ff 00    	nop       
     f9e:	ff ff 00    	nop       
     fa0:	ff ff 00    	nop       
     fa2:	ff ff 00    	nop       
     fa4:	ff ff 00    	nop       
     fa6:	ff ff 00    	nop       
     fa8:	ff ff 00    	nop       
     faa:	ff ff 00    	nop       
     fac:	ff ff 00    	nop       
     fae:	ff ff 00    	nop       
     fb0:	ff ff 00    	nop       
     fb2:	ff ff 00    	nop       
     fb4:	ff ff 00    	nop       
     fb6:	ff ff 00    	nop       
     fb8:	ff ff 00    	nop       
     fba:	ff ff 00    	nop       
     fbc:	ff ff 00    	nop       
     fbe:	ff ff 00    	nop       
     fc0:	ff ff 00    	nop       
     fc2:	ff ff 00    	nop       
     fc4:	ff ff 00    	nop       
     fc6:	ff ff 00    	nop       
     fc8:	ff ff 00    	nop       
     fca:	ff ff 00    	nop       
     fcc:	ff ff 00    	nop       
     fce:	ff ff 00    	nop       
     fd0:	ff ff 00    	nop       
     fd2:	ff ff 00    	nop       
     fd4:	ff ff 00    	nop       
     fd6:	ff ff 00    	nop       
     fd8:	ff ff 00    	nop       
     fda:	ff ff 00    	nop       
     fdc:	ff ff 00    	nop       
     fde:	ff ff 00    	nop       
     fe0:	ff ff 00    	nop       
     fe2:	ff ff 00    	nop       
     fe4:	ff ff 00    	nop       
     fe6:	ff ff 00    	nop       
     fe8:	ff ff 00    	nop       
     fea:	ff ff 00    	nop       
     fec:	ff ff 00    	nop       
     fee:	ff ff 00    	nop       
     ff0:	ff ff 00    	nop       
     ff2:	ff ff 00    	nop       
     ff4:	ff ff 00    	nop       
     ff6:	ff ff 00    	nop       
     ff8:	ff ff 00    	nop       
     ffa:	ff ff 00    	nop       
     ffc:	ff ff 00    	nop       
     ffe:	ff ff 00    	nop       
    1000:	47 45 00    	nop       
    1002:	4e 53 00    	nop       

00001004 <ver_data>:
    1004:	01 00 00    	nop       
    1006:	01 00 00    	nop       
    1008:	18 00 00    	nop       
    100a:	08 00 00    	nop       
    100c:	0d 00 00    	nop       

0000100e <__T1Interrupt>:
;   * * * * *   DON'T MODIFY ANYTHING HERE BEFORE 0X1000, THIS IS BOOTLOADER AREA!!!
	.include	"Boot.inc"
	.include	"flash.inc"

;											
;				0 x 1 0 0 0    (physical)				
;_______________________________________________________________________________________
	.org	0x1000-0x1BE, 0xFF	;   * * *   0x1000 (fill 0xFF's)
; general segment
	.ascii	"GENS"		; general segment start
; Ver/Rev/Year/Month/Day
ver_data:
	.word	Ver
	.word	Rev
	.word	Year
	.word	Month
	.word	Day
; IVT 
.global __T1Interrupt		; must be @ 0x1000
__T1Interrupt:
	goto	T1Int
    100e:	16 2a 04    	goto      0x2a16 <T1Int>
    1010:	00 00 00 

00001012 <__T3Interrupt>:
.global __T3Interrupt		; must be @ 0x1004
__T3Interrupt:
	goto	T3Int
    1012:	58 32 04    	goto      0x3258 <T3Int>
    1014:	00 00 00 

00001016 <_INT1Interrupt>:
.global	_INT1Interrupt		; must be @ 0x1008
_INT1Interrupt:
	goto	INT1Int
    1016:	bc 32 04    	goto      0x32bc <INT1Int>
    1018:	00 00 00 

0000101a <_INT2Interrupt>:
.global	_INT2Interrupt		; must be @ 0x100C
_INT2Interrupt:
	goto	INT2Int
    101a:	b0 32 04    	goto      0x32b0 <INT2Int>
    101c:	00 00 00 

0000101e <__U1RXInterrupt>:
.global __U1RXInterrupt		; must be @ 0x1010
__U1RXInterrupt:
	goto	U1RXInt
    101e:	60 32 04    	goto      0x3260 <U1RXInt>
    1020:	00 00 00 

00001022 <__U1ErrInterrupt>:
.global __U1ErrInterrupt	; must be @ 0x1014
__U1ErrInterrupt:
	goto	U1ErrInt
    1022:	a4 32 04    	goto      0x32a4 <U1ErrInt>
    1024:	00 00 00 

00001026 <__U2RXInterrupt>:
.global __U2RXInterrupt		; must be @ 0x1018
__U2RXInterrupt:
	goto	U2RXInt
    1026:	ac 32 04    	goto      0x32ac <U2RXInt>
    1028:	00 00 00 

0000102a <__U2ErrInterrupt>:
.global __U2ErrInterrupt	; must be @ 0x101C
__U2ErrInterrupt:
	goto	U2ErrInt
    102a:	b4 32 04    	goto      0x32b4 <U2ErrInt>
    102c:	00 00 00 

0000102e <selfcheck_back>:

; **********************************************************************

selfcheck_back:
; ini Mode specific params
	mov	#Ram+11,w8
    102e:	b8 80 20    	mov.w     #0x80b, w8
	mov	#Rom,w9
    1030:	09 00 22    	mov.w     #0x2000, w9
	mov	w9,SSTempPMAddr
    1032:	29 4a 88    	mov.w     w9, 0x944
	mov	w9,RunTempPMAddr
    1034:	a9 4a 88    	mov.w     w9, 0x954
	mov	#Ram,w10
    1036:	0a 80 20    	mov.w     #0x800, w10
	clr	w11
    1038:	80 05 eb    	clr.w     w11
	clr	w12
    103a:	00 06 eb    	clr.w     w12
	clr	w13
    103c:	80 06 eb    	clr.w     w13
	clr	w14
    103e:	00 07 eb    	clr.w     w14
	mov	w9,History_w9
    1040:	19 48 88    	mov.w     w9, 0x902
; ini Rx FIFO
	mov	#RX_buf,w0
    1042:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1044:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1046:	f0 4d 88    	mov.w     w0, 0x9be
; ini function LEDs on Cathode 17
	mov	#0b0000100010001000,w0	; ALU def (Set ALU, SEL, -CLK)
    1048:	80 88 20    	mov.w     #0x888, w0
	mov	w0,A16
    104a:	70 4d 88    	mov.w     w0, 0x9ae
; ini SFR
	mov	#3,w0
    104c:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,SerCtrl
    104e:	f5 e8 b7    	mov.b     WREG, 0x8f5
	call	def_U1BRG
    1050:	50 28 02    	call      0x2850 <def_U1BRG>
    1052:	00 00 00 
	call	rxtx_to_rxtxpos
    1054:	88 28 02    	call      0x2888 <rxtx_to_rxtxpos>
    1056:	00 00 00 
	call	show_vrymd
    1058:	44 11 02    	call      0x1144 <show_vrymd>
    105a:	00 00 00 
; show CHS in the middle of matrix
	mov	#0,w1
    105c:	01 00 20    	mov.w     #0x0, w1
	mov	#0x1000/2,w2
    105e:	02 80 20    	mov.w     #0x800, w2
	mov	#CHS1,w4	; point w4 to CHS1
    1060:	84 9d 20    	mov.w     #0x9d8, w4
	call	get_chs
    1062:	2e 11 02    	call      0x112e <get_chs>
    1064:	00 00 00 
; show CHS in the bottom of matrix
	mov	#0x1000,w1
    1066:	01 00 21    	mov.w     #0x1000, w1
	mov	#tbloffset(pgm_end)-0x1000,w2
    1068:	62 28 23    	mov.w     #0x3286, w2
	lsr	w2,w2		; /2
    106a:	02 01 d1    	lsr.w     w2, w2
	mov	#CHS2,w4	; point w4 to CHS2
    106c:	a4 9d 20    	mov.w     #0x9da, w4
	call	get_chs
    106e:	2e 11 02    	call      0x112e <get_chs>
    1070:	00 00 00 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Transfer program HAMLET
	clr	TBLPAG
    1072:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(display),w0
    1074:	40 a3 23    	mov.w     #0x3a34, w0
; code @ 0x000
	mov	#Rom,w2
    1076:	02 00 22    	mov.w     #0x2000, w2

00001078 <L1>:
0:
	tblrdl	[w0++],w1
    1078:	b0 00 ba    	tblrdl.w  [w0++], w1
	btsc	w1,#15
    107a:	01 f0 a7    	btsc.w    w1, #0xf
	bra	1f
    107c:	02 00 37    	bra       0x1082 <L14>
	mov	w1,[w2++]
    107e:	01 19 78    	mov.w     w1, [w2++]
	bra	0b
    1080:	fb ff 37    	bra       0x1078 <L1>

00001082 <L14>:
1:
; char gen @ 0x100
	mov	#tbloffset(chargen),w0
    1082:	a0 ae 23    	mov.w     #0x3aea, w0
	mov	#Rom+2*0x100,w2
    1084:	02 20 22    	mov.w     #0x2200, w2

00001086 <L23>:
2:
	tblrdl	[w0++],w1
    1086:	b0 00 ba    	tblrdl.w  [w0++], w1
	btsc	w1,#15
    1088:	01 f0 a7    	btsc.w    w1, #0xf
	bra	1f
    108a:	02 00 37    	bra       0x1090 <L15>
	mov	w1,[w2++]
    108c:	01 19 78    	mov.w     w1, [w2++]
	bra	2b
    108e:	fb ff 37    	bra       0x1086 <L23>

00001090 <L15>:
1:
; text @ 0x500
	mov	#tbloffset(disptext),w0
    1090:	c0 26 24    	mov.w     #0x426c, w0
	mov	#Rom+2*0x500,w2		; adr 0x500
    1092:	02 a0 22    	mov.w     #0x2a00, w2
	mov	#0xE0,w4		; RET code
    1094:	04 0e 20    	mov.w     #0xe0, w4

00001096 <L24>:
2:
	tblrdl.b [w0++],w1
    1096:	b0 40 ba    	tblrdl.b  [w0++], w1
	tblrdl.b [w0],w5
    1098:	90 42 ba    	tblrdl.b  [w0], w5
	and.b	w5,w1,w5
    109a:	81 c2 62    	and.b     w5, w1, w5
	inc.b	w5,w5
    109c:	85 42 e8    	inc.b     w5, w5
	bra	z,1f
    109e:	08 00 32    	bra       Z, 0x10b0 <L16>

	and	w1,#0x0F,w3
    10a0:	ef 81 60    	and.w     w1, #0xf, w3
	ior	w3,w4,w3
    10a2:	84 81 71    	ior.w     w3, w4, w3
	mov	w3,[w2++]
    10a4:	03 19 78    	mov.w     w3, [w2++]
	lsr	w1,#4,w3
    10a6:	c4 09 de    	lsr.w     w1, #0x4, w3
	and	w3,#0x0F,w3
    10a8:	ef 81 61    	and.w     w3, #0xf, w3
	ior	w3,w4,w3
    10aa:	84 81 71    	ior.w     w3, w4, w3
	mov	w3,[w2++]
    10ac:	03 19 78    	mov.w     w3, [w2++]
	bra	2b
    10ae:	f3 ff 37    	bra       0x1096 <L24>

000010b0 <L16>:
1:
	mov	#0x00EF,w5		; RET F
    10b0:	f5 0e 20    	mov.w     #0xef, w5
	mov	w5,[w2++]		; text terminator
    10b2:	05 19 78    	mov.w     w5, [w2++]
	mov	w5,[w2++]		; text terminator
    10b4:	05 19 78    	mov.w     w5, [w2++]
; save it to flash 14
	call	com_rom
    10b6:	88 14 02    	call      0x1488 <com_rom>
    10b8:	00 00 00 
	mov	#14,w0
    10ba:	e0 00 20    	mov.w     #0xe, w0
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    10bc:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    10be:	de e9 a9    	bclr.b    0x9de, #0x7
	call	eesavew0	; EEsave on record 14
    10c0:	44 02 02    	call      0x244 <eesavew0>
    10c2:	00 00 00 
	call	com_rom
    10c4:	88 14 02    	call      0x1488 <com_rom>
    10c6:	00 00 00 
	mov	#Rom,w0
    10c8:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x01000-1
    10ca:	ff 0f 09    	repeat    #0xfff
	clr	[w0++]		; clr Rom
    10cc:	00 18 eb    	clr.w     [w0++]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Transfer program UART DISP
	mov	#tbloffset(serial_disp),w0
    10ce:	a0 97 23    	mov.w     #0x397a, w0
; code @ 0x000
	mov	#Rom,w2
    10d0:	02 00 22    	mov.w     #0x2000, w2

000010d2 <L2>:
0:
	tblrdl	[w0++],w1
    10d2:	b0 00 ba    	tblrdl.w  [w0++], w1
	btsc	w1,#15
    10d4:	01 f0 a7    	btsc.w    w1, #0xf
	bra	1f
    10d6:	02 00 37    	bra       0x10dc <L17>
	mov	w1,[w2++]
    10d8:	01 19 78    	mov.w     w1, [w2++]
	bra	0b
    10da:	fb ff 37    	bra       0x10d2 <L2>

000010dc <L17>:
1:
; char gen @ 0x100
	mov	#tbloffset(chargen),w0
    10dc:	a0 ae 23    	mov.w     #0x3aea, w0
	mov	#Rom+2*0x100,w2
    10de:	02 20 22    	mov.w     #0x2200, w2

000010e0 <L25>:
2:
	tblrdl	[w0++],w1
    10e0:	b0 00 ba    	tblrdl.w  [w0++], w1
	btsc	w1,#15
    10e2:	01 f0 a7    	btsc.w    w1, #0xf
	bra	1f
    10e4:	02 00 37    	bra       0x10ea <L18>
	mov	w1,[w2++]
    10e6:	01 19 78    	mov.w     w1, [w2++]
	bra	2b
    10e8:	fb ff 37    	bra       0x10e0 <L25>

000010ea <L18>:
1:
; save it to flash 13
	call	com_rom
    10ea:	88 14 02    	call      0x1488 <com_rom>
    10ec:	00 00 00 
	mov	#13,w0
    10ee:	d0 00 20    	mov.w     #0xd, w0
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    10f0:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    10f2:	de e9 a9    	bclr.b    0x9de, #0x7
	call	eesavew0	; EEsave on seg 13
    10f4:	44 02 02    	call      0x244 <eesavew0>
    10f6:	00 00 00 
	call	com_rom
    10f8:	88 14 02    	call      0x1488 <com_rom>
    10fa:	00 00 00 
	mov	#Rom,w0
    10fc:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x01000-1
    10fe:	ff 0f 09    	repeat    #0xfff
	clr	[w0++]		; clr Rom
    1100:	00 18 eb    	clr.w     [w0++]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	bset	Flag2,#4	; #4 set when initialized
    1102:	de 89 a8    	bset.b    0x9de, #0x4
	call	peek_flash	; record flash occupance  (37 ms)
    1104:	d0 17 02    	call      0x17d0 <peek_flash>
    1106:	00 00 00 
; -----------------------------
; ini perif
	clr	TMR1
    1108:	90 21 ef    	clr.w     0x190
	clr	TMR2
    110a:	96 21 ef    	clr.w     0x196
	clr	TMR3
    110c:	9a 21 ef    	clr.w     0x19a
	bset	T1CON,#TON	; LED multiplex timer on
    110e:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON
    1110:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON
    1112:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    1114:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    1116:	99 00 a8    	bset.b    0x99, #0x0
	bset	IEC0,#11	; enable RX1 interrupt
    1118:	99 60 a8    	bset.b    0x99, #0x3
	bset	IEC4,#1		; enable RX1 Error Interrupt
    111a:	a0 20 a8    	bset.b    0xa0, #0x1
	bset	INTCON2,#GIE	; global interrupt enable
    111c:	83 e0 a8    	bset.b    0x83, #0x7

0000111e <main_farm>:

;------------------------------------------------------------------------
;------------------------------------------------------------------------
;---------------------------   F A R M   --------------------------------
;------------------------------------------------------------------------
;------------------------------------------------------------------------

main_farm:
	bra	alu_ept
    111e:	2c 00 37    	bra       0x1178 <alu_ept>

00001120 <txword>:

;											
txword:				; TX w0_low, w0_high
	call	txbyte
    1120:	26 11 02    	call      0x1126 <txbyte>
    1122:	00 00 00 
	swap	w0
    1124:	00 80 fd    	swap.w    w0

00001126 <txbyte>:
txbyte:				; TX w0
	btsc	U1STA,#UTXBF
    1126:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	txbyte
    1128:	fe ff 37    	bra       0x1126 <txbyte>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    112a:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    112c:	00 00 06    	return    

0000112e <get_chs>:

;											
get_chs:		; pointer w1, length (in words) w2, CHS in w3 on exit, wr ptr w4
	clr	w3
    112e:	80 01 eb    	clr.w     w3

00001130 <chs_loop>:
chs_loop:
	tblrdh.b [w1],w0
    1130:	11 c0 ba    	tblrdh.b  [w1], w0
	ze	w0,w0
    1132:	00 80 fb    	ze        w0, w0
	add	w0,w3,w3
    1134:	83 01 40    	add.w     w0, w3, w3
	tblrdl	[w1++],w0
    1136:	31 00 ba    	tblrdl.w  [w1++], w0
	add	w0,w3,w3
    1138:	83 01 40    	add.w     w0, w3, w3
	dec	w2,w2
    113a:	02 01 e9    	dec.w     w2, w2
	bra	nz,chs_loop
    113c:	f9 ff 3a    	bra       NZ, 0x1130 <chs_loop>
; CHS is in w3
	swap	w3	; because display routine shows in little endian, should be big
    113e:	03 80 fd    	swap.w    w3
	mov	w3,[w4]
    1140:	03 0a 78    	mov.w     w3, [w4]
	return
    1142:	00 00 06    	return    

00001144 <show_vrymd>:

;-----------------------
show_vrymd:	; show Ver/Rev/Year/Month/Day
	mov	#Ram+0,w1
    1144:	01 80 20    	mov.w     #0x800, w1
	mov	#tbloffset(ver_data),w3
    1146:	43 00 21    	mov.w     #0x1004, w3
	call	vrymd
    1148:	58 11 02    	call      0x1158 <vrymd>
    114a:	00 00 00 
	call	vrymd
    114c:	58 11 02    	call      0x1158 <vrymd>
    114e:	00 00 00 
	call	vrymd
    1150:	58 11 02    	call      0x1158 <vrymd>
    1152:	00 00 00 
	call	vrymd
    1154:	58 11 02    	call      0x1158 <vrymd>
    1156:	00 00 00 

00001158 <vrymd>:
vrymd:			; Ver / Rev / Year / Month / Day
	tblrdl	[w3++],w2
    1158:	33 01 ba    	tblrdl.w  [w3++], w2
	and	w2,#0xF,w0
    115a:	6f 00 61    	and.w     w2, #0xf, w0
	mov.b	w0,[w1]
    115c:	80 48 78    	mov.b     w0, [w1]
	lsr	w2,#4,w0
    115e:	44 10 de    	lsr.w     w2, #0x4, w0
	mov.b	w0,[w1+16]
    1160:	80 50 98    	mov.b     w0, [w1+16]
	inc	w1,w1
    1162:	81 00 e8    	inc.w     w1, w1
	return
    1164:	00 00 06    	return    

00001166 <clr_ram>:
;-----------------------
clr_ram:
	mov	#Ram,w0
    1166:	00 80 20    	mov.w     #0x800, w0
	repeat	#120-1		; clear all exept SFR
    1168:	77 00 09    	repeat    #0x77
	clr	[w0++]
    116a:	00 18 eb    	clr.w     [w0++]
	return
    116c:	00 00 06    	return    

0000116e <w0ms>:
;------------------------------------------------------------------------
w0ms:
	repeat	#16000-1
    116e:	7f 3e 09    	repeat    #0x3e7f
	nop
    1170:	00 00 00    	nop       
	dec	w0,w0
    1172:	00 00 e9    	dec.w     w0, w0
	bra	nz,w0ms
    1174:	fc ff 3a    	bra       NZ, 0x116e <w0ms>
	return
    1176:	00 00 06    	return    

00001178 <alu_ept>:

alu_ept:	; <-------------------------------------------
; prepare A16 (set ALU and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    1178:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    117a:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000100000001000,w0	; set ALU and -CLK
    117c:	80 80 20    	mov.w     #0x808, w0
	ior	A16
    117e:	ae 29 b7    	ior.w     0x9ae
; restore ALU params
	mov	AluTempOpcode,w0
    1180:	90 49 80    	mov.w     0x932, w0
	mov	w0,Opcode	; Opcode
    1182:	10 49 88    	mov.w     w0, 0x922
	mov	AluTempOperX,w0
    1184:	a0 49 80    	mov.w     0x934, w0
	mov	w0,OperX	; OperX
    1186:	20 49 88    	mov.w     w0, 0x924
	mov	AluTempOperY,w0
    1188:	b0 49 80    	mov.w     0x936, w0
	mov	w0,OperY	; OperY
    118a:	30 49 88    	mov.w     w0, 0x926
	mov	AluTempAtemp,w0
    118c:	c0 49 80    	mov.w     0x938, w0
	mov	w0,Atemp	; Accu temp
    118e:	40 49 88    	mov.w     w0, 0x928
	mov	AluTempw14,w14	; Accu Out
    1190:	ee 49 80    	mov.w     0x93c, w14
	mov	AluTempw13,w13	; Accu In
    1192:	dd 49 80    	mov.w     0x93a, w13
; repair all blinking (non-existing) combinations
	mov	#8,w1
    1194:	81 00 20    	mov.w     #0x8, w1
	mov	Opcode,WREG	; affects Z flag
    1196:	22 89 bf    	mov.w     0x922, WREG
	bra	z,eight_bit_opc	; if eight bit opcode
    1198:	04 00 32    	bra       Z, 0x11a2 <eight_bit_opc>
	cp	w0,#9
    119a:	69 00 e1    	cp.w      w0, #0x9
	ifc			; if Opcode >= 9...
    119c:	42 00 af    	btsc.b    0x42, #0x0
	mov	w1,Opcode	; ...then fix it to 8
    119e:	11 49 88    	mov.w     w1, 0x922
	bra	fixed
    11a0:	09 00 37    	bra       0x11b4 <fixed>

000011a2 <eight_bit_opc>:
eight_bit_opc:
	mov	#2,w1
    11a2:	21 00 20    	mov.w     #0x2, w1
	mov	OperX,w0
    11a4:	20 49 80    	mov.w     0x924, w0
	cp	w0,#2		; 2 = INC RY, legal instruction
    11a6:	62 00 e1    	cp.w      w0, #0x2
	bra	z,fixed
    11a8:	05 00 32    	bra       Z, 0x11b4 <fixed>
	cp	w0,#3		; 3 = DEC RY, legal instruction
    11aa:	63 00 e1    	cp.w      w0, #0x3
	bra	z,fixed
    11ac:	03 00 32    	bra       Z, 0x11b4 <fixed>
	cp	w0,#13		; 13 = RRC RY, legal instruction
    11ae:	6d 00 e1    	cp.w      w0, #0xd
	ifnz
    11b0:	42 20 ae    	btss.b    0x42, #0x1
	mov	w1,OperX	; if unlegal, fix it to 2
    11b2:	21 49 88    	mov.w     w1, 0x924

000011b4 <fixed>:
fixed:
; restore ALU flags
	mov	AluTempVflag,w0
    11b4:	f0 49 80    	mov.w     0x93e, w0
	mov	w0,Vflag
    11b6:	80 49 88    	mov.w     w0, 0x930
	mov	AluTempZflag,w0
    11b8:	00 4a 80    	mov.w     0x940, w0
	mov	w0,Zflag
    11ba:	70 49 88    	mov.w     w0, 0x92e
	mov	AluTempCflag,w0
    11bc:	10 4a 80    	mov.w     0x942, w0
	mov	w0,Cflag
    11be:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    11c0:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    11c2:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    11c4:	af 89 a8    	bset.b    0x9af, #0x4
; initialize ALU
	clr	Mode			; 0 = ALU
    11c6:	76 29 ef    	clr.w     0x976
	clr	BlinkFlag
    11c8:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    11ca:	54 20 ef    	clr.w     0x54
	mov	w9,PgmTempPMAddr
    11cc:	29 4b 88    	mov.w     w9, 0x964
	clr.b	Page
    11ce:	f0 68 ef    	clr.b     0x8f0
	clr	Stack
    11d0:	2a 29 ef    	clr.w     0x92a
	clr	w9
    11d2:	80 04 eb    	clr.w     w9
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    11d4:	dc 49 a8    	bset.b    0x9dc, #0x2
	mov	#1,w0
    11d6:	10 00 20    	mov.w     #0x1, w0
	cp0.b	Speed
    11d8:	f1 48 e2    	cp0.b     0x8f1
	ifz
    11da:	42 20 af    	btsc.b    0x42, #0x1
	mov.b	WREG,Speed
    11dc:	f1 e8 b7    	mov.b     WREG, 0x8f1
	mov	#0b011100000,w0	; autorpt for Opcode, OperX, OperY
    11de:	00 0e 20    	mov.w     #0xe0, w0
	mov	w0,AutorptFlag
    11e0:	60 4d 88    	mov.w     w0, 0x9ac

000011e2 <alu_farm>:
;------------------------------
alu_farm:			; <------------
	bset	IEC0,#11	; enable RX1 interrupt
    11e2:	99 60 a8    	bset.b    0x99, #0x3
; IN register service
	mov	#PORTB,w0
    11e4:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    11e6:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    11e8:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    11ea:	0b e8 b7    	mov.b     WREG, 0x80b
; read instruction opcode
	mov	Opcode,w0	; read instruction opcode here...
    11ec:	10 49 80    	mov.w     0x922, w0
	mov	OperX,w11	; ...or here
    11ee:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12
    11f0:	3c 49 80    	mov.w     0x926, w12
	cp0	w0		; w0 = Opcode
    11f2:	00 00 e0    	cp0.w     w0
	bra	z,jpt_8alu	; if it's 8-bit opcode
    11f4:	12 00 32    	bra       Z, 0x121a <jpt_8alu>
	mov	#OperX,w7	; default result write address
    11f6:	47 92 20    	mov.w     #0x924, w7
; w0 = table pos
	bra	w0
    11f8:	00 60 01    	bra       w0
;jp table
	bra	alu_cmd	   ; impossible instruction
    11fa:	27 00 37    	bra       0x124a <alu_cmd> <alu_wait_key>
	bra	alu_A1	   ; ADD  RX,RY
    11fc:	af 02 37    	bra       0x175c <alu_A1>
	bra	alu_A2	   ; ADC  RX,RY
    11fe:	b3 02 37    	bra       0x1766 <alu_A2>
	bra	alu_A3	   ; SUB  RX,RY
    1200:	b7 02 37    	bra       0x1770 <alu_A3>
	bra	alu_A4	   ; SBB  RX,RY
    1202:	bb 02 37    	bra       0x177a <alu_A4>
	bra	alu_A5	   ; OR   RX,RY
    1204:	bf 02 37    	bra       0x1784 <alu_A5>
	bra	alu_A6	   ; AND  RX,RY
    1206:	c3 02 37    	bra       0x178e <alu_A6>
	bra	alu_A7	   ; XOR  RX,RY
    1208:	c7 02 37    	bra       0x1798 <alu_A7>
	bra	alu_A8	   ; MOV  RX,RY
    120a:	cb 02 37    	bra       0x17a2 <alu_A8>
	bra	alu_blink1 ; MOV  RX,RY   (non-existing in ALU mode)
    120c:	18 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; MOV  RX,N    (non-existing in ALU mode)
    120e:	17 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; MOV  [XY],R0 (non-existing in ALU mode)
    1210:	16 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[XY] (non-existing in ALU mode)
    1212:	15 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; MOV  [NN],R0 (non-existing in ALU mode)
    1214:	14 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; MOV  R0,[NN] (non-existing in ALU mode)
    1216:	13 00 37    	bra       0x123e <alu_blink1>
	bra	alu_blink1 ; JR   NN      (non-existing in ALU mode)
    1218:	12 00 37    	bra       0x123e <alu_blink1>

0000121a <jpt_8alu>:

jpt_8alu:
	mov	#Dummy,w7	; default result write address (R0 = Accu in)
    121a:	07 9b 20    	mov.w     #0x9b0, w7
; w0 = table pos
	bra	w11
    121c:	0b 60 01    	bra       w11
;jp table
	bra	alu_blink2   ; CP   R0,N    (uses R0)
    121e:	12 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; ADD  R0,N    (uses R0)
    1220:	11 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_G2	     ; INC  RY
    1222:	c4 02 37    	bra       0x17ac <alu_G2>
	bra	alu_G3	     ; DEC  RY
    1224:	c9 02 37    	bra       0x17b8 <alu_G3>
	bra	alu_blink2   ; DSZ  RY      (non-existing in ALU mode)
    1226:	0e 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; OR   R0,N    (uses R0)
    1228:	0d 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; AND  R0,N    (uses R0)
    122a:	0c 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; XOR  R0,N    (uses R0)
    122c:	0b 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; EXR  N       (non-existing in ALU mode)
    122e:	0a 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; BIT  RG,M    (uses R0)
    1230:	09 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; BSET RG,M    (uses R0)
    1232:	08 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; BCLR RG,M    (uses R0)
    1234:	07 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; BTG  RG,M    (uses R0)
    1236:	06 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_G13	     ; RRC  RY
    1238:	c5 02 37    	bra       0x17c4 <alu_G13>
	bra	alu_blink2   ; RET  RY,N    (non-existing in ALU mode)
    123a:	04 00 37    	bra       0x1244 <alu_blink2>
	bra	alu_blink2   ; SKIP F,M     (non-existing in ALU mode)
    123c:	03 00 37    	bra       0x1244 <alu_blink2>

0000123e <alu_blink1>:
;...
; --------------------------------------------------------------------

alu_blink1:			; if non-existent, instruction column 1 should blink
	bset	BlinkFlag,#0
    123e:	e0 09 a8    	bset.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1240:	e0 29 a9    	bclr.b    0x9e0, #0x1
	bra	alu_wait_key
    1242:	03 00 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001244 <alu_blink2>:
alu_blink2:			; if non-existent, instruction column 2 should blink
	bclr	BlinkFlag,#0
    1244:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bset	BlinkFlag,#1
    1246:	e0 29 a8    	bset.b    0x9e0, #0x1
	bra	alu_wait_key
    1248:	00 00 37    	bra       0x124a <alu_cmd> <alu_wait_key>

0000124a <alu_cmd>:

;-------------------------------
alu_cmd:			; w11 = Transfer Flag
alu_wait_key:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    124a:	dc c9 af    	btsc.b    0x9dc, #0x6
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    124c:	df 09 a8    	bset.b    0x9df, #0x0
	mov	#PORTB,w0
    124e:	80 67 20    	mov.w     #0x678, w0
	ze	[w0],w0
    1250:	10 80 fb    	ze        [w0], w0
	lsr	w0,#4,w0
    1252:	44 00 de    	lsr.w     w0, #0x4, w0
	mov.b	WREG,Ram+11	; IN register
    1254:	0b e8 b7    	mov.b     WREG, 0x80b

	btss	Flag,#1		; #1 handshaking flag for buttons
    1256:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	alu_wait_key
    1258:	f8 ff 37    	bra       0x124a <alu_cmd> <alu_wait_key>
	bclr	Flag,#1
    125a:	dc 29 a9    	bclr.b    0x9dc, #0x1
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    125c:	df 09 af    	btsc.b    0x9df, #0x0
	bra	not_first
    125e:	08 00 37    	bra       0x1270 <not_first>
; first keypress, clear Ver/Rev
	bset	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    1260:	df 09 a8    	bset.b    0x9df, #0x0
	clr	Ram+0x00
    1262:	00 28 ef    	clr.w     0x800
	clr	Ram+0x02
    1264:	02 28 ef    	clr.w     0x802
	clr	Ram+0x04
    1266:	04 28 ef    	clr.w     0x804
	clr	Ram+0x10
    1268:	10 28 ef    	clr.w     0x810
	clr	Ram+0x12
    126a:	12 28 ef    	clr.w     0x812
	clr	Ram+0x14
    126c:	14 28 ef    	clr.w     0x814
	bra	alu_wait_key
    126e:	ed ff 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001270 <not_first>:
not_first:
	bclr	BlinkFlag,#5	; switch off "SAVE blink" flag
    1270:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bclr	BlinkFlag,#7	; switch off "LOAD blink" flag
    1272:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	mov	Just,w0
    1274:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1276:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1278:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    127a:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    127c:	00 60 01    	bra       w0
; jump table FOR BUTTONS
	bra	leave_alu_ept	; -------> next mode (Single Step)
    127e:	b2 02 37    	bra       0x17e4 <leave_alu_ept>
	bra	button_CARRY
    1280:	04 00 37    	bra       0x128a <button_CARRY>
	bra	button_SAVE
    1282:	05 00 37    	bra       0x128e <button_SAVE>
	bra	button_LOAD
    1284:	6a 00 37    	bra       0x135a <button_LOAD>
	bra	button_CLOCK
    1286:	f3 00 37    	bra       0x146e <button_CLOCK>
	bra	general_alu_5
    1288:	05 01 37    	bra       0x1494 <general_alu_5>

0000128a <button_CARRY>:

; button entry points
; -----------------------------------------------------------------
button_CARRY:
	btg	A16,#b_carry
    128a:	af 89 aa    	btg.b     0x9af, #0x4
	bra	alu_farm
    128c:	aa ff 37    	bra       0x11e2 <alu_farm>

0000128e <button_SAVE>:

; -----------------------------------------------------------------
; TX format:
; Header 00 FF 00 FF A5 C3
; file length (word count, 16-bit length, low byte first)
; message body (words, low byte first)
; checksum (16-bit sum of FILE LENGTH WORD plus MESSAGE BODY words, low byte first)

button_SAVE:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    128e:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    1290:	de e9 a9    	bclr.b    0x9de, #0x7
	bclr	Flag2,#9	; #9 clr = last command SAVE
    1292:	df 29 a9    	bclr.b    0x9df, #0x1
	bset	A16,#b_save	; led SAVE on
    1294:	af a9 a8    	bset.b    0x9af, #0x5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1296:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	save2tx		; ALT not pressed: save to serial port
    1298:	05 00 37    	bra       0x12a4 <save2tx>
; ALT pressed: save to Flash
	mov	FlashAddr,w0
    129a:	00 4e 80    	mov.w     0x9c0, w0
	cp	w0,#15
    129c:	6f 00 e1    	cp.w      w0, #0xf
	bra	nc,save2flash	; save to flash, loc 0...14
    129e:	3e 00 39    	bra       NC, 0x131c <save2flash>
	bclr	A16,#b_save	; led SAVE off
    12a0:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	alu_farm
    12a2:	9f ff 37    	bra       0x11e2 <alu_farm>

000012a4 <save2tx>:
save2tx:		; save to serial port
; save to serial port TX
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    12a4:	9e 28 02    	call      0x289e <rxtx_to_io>
    12a6:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    12a8:	50 28 02    	call      0x2850 <def_U1BRG>
    12aa:	00 00 00 
; measure the file length first
	mov	#0x1000,w5	; file length countdown (in words)
    12ac:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom+0x1FFE,w3	; pointer backwards from the last program memory word
    12ae:	e3 ff 23    	mov.w     #0x3ffe, w3

000012b0 <L51>:
5:
	cp0	[w3--]		; test if word contains data
    12b0:	23 00 e0    	cp0.w     [w3--]
	bra	nz,6f		; if found meaningful content >0000
    12b2:	0a 00 3a    	bra       NZ, 0x12c8 <L63>
	dec	w5,w5
    12b4:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    12b6:	fc ff 3a    	bra       NZ, 0x12b0 <L51>
	bset	A16,#b_save	; LED SAVE on
    12b8:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    12ba:	e0 a9 a8    	bset.b    0x9e0, #0x5

000012bc <waitany1>:
waitany1:
	btss	Flag,#1		; #1 = "key pressed" flag
    12bc:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany1
    12be:	fe ff 37    	bra       0x12bc <waitany1>
	bclr	Flag,#1		; #1 = "key pressed" flag
    12c0:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    12c2:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    12c4:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    12c6:	40 00 37    	bra       0x1348 <saveload_exit>

000012c8 <L63>:
6:				; found >0000
; send header 00 FF 00 FF A5 C3 
	mov	#0xFF00,w0
    12c8:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    12ca:	20 11 02    	call      0x1120 <txword>
    12cc:	00 00 00 
	mov	#0xFF00,w0
    12ce:	00 f0 2f    	mov.w     #0xff00, w0
	call	txword		; ----> TX header 00 FF
    12d0:	20 11 02    	call      0x1120 <txword>
    12d2:	00 00 00 
	mov	#0xC3A5,w0
    12d4:	50 3a 2c    	mov.w     #0xc3a5, w0
	call	txword		; ----> TX header A5 C3
    12d6:	20 11 02    	call      0x1120 <txword>
    12d8:	00 00 00 
; send file length w5 (in words)
	bset	A16,#b_save	; "SAVE" LED on
    12da:	af a9 a8    	bset.b    0x9af, #0x5
	mov	w5,w4		; w4 CHS
    12dc:	05 02 78    	mov.w     w5, w4
	lsr	w5,#2,w2	; w2 file length/4, will be used in taskbar calculation
    12de:	42 29 de    	lsr.w     w5, #0x2, w2
	ifz
    12e0:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    12e2:	12 00 20    	mov.w     #0x1, w2
	mov	w5,w0
    12e4:	05 00 78    	mov.w     w5, w0
	call	txword		; ----> TX record length in words 16-bit (little endian)
    12e6:	20 11 02    	call      0x1120 <txword>
    12e8:	00 00 00 
	mov	#Rom,w3		; program memory pointer from the beginning
    12ea:	03 00 22    	mov.w     #0x2000, w3

000012ec <L52>:
; send message body (pointer w3, length w5)
5:			  ; \
	mov	[w3++],w0	; read word from program memory
    12ec:	33 00 78    	mov.w     [w3++], w0
	add	w4,w0,w4	; update CHS
    12ee:	00 02 42    	add.w     w4, w0, w4
	call	txword		; ----> TX data 16-bit (little endian, hi byte 0000xxxx)
    12f0:	20 11 02    	call      0x1120 <txword>
    12f2:	00 00 00 
; taskbar ------
	sl	w5,#3,w6	; w6 = w5 × 8
    12f4:	43 2b dd    	sl.w      w5, #0x3, w6
	repeat	#17
    12f6:	11 00 09    	repeat    #0x11
	div.u	w6,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    12f8:	02 83 d8    	div.uw    w6, w2
	cp	w0,#31
    12fa:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    12fc:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    12fe:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    1300:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    1302:	f1 ff 2f    	mov.w     #0xffff, w1
	sl	w1,w0,w1
    1304:	80 08 dd    	sl.w      w1, w0, w1
	mov	w1,Taskbar
    1306:	c1 4d 88    	mov.w     w1, 0x9b8

	dec	w5,w5
    1308:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b	  ; /
    130a:	f0 ff 3a    	bra       NZ, 0x12ec <L52>
; send checksum
	mov	w4,w0
    130c:	04 00 78    	mov.w     w4, w0
	call	txword		; ----> TX CHS 16-bit (little endian)
    130e:	20 11 02    	call      0x1120 <txword>
    1310:	00 00 00 
	mov	#140,w0
    1312:	c0 08 20    	mov.w     #0x8c, w0
	call	w0ms		; give some time to send the whole queue
    1314:	6e 11 02    	call      0x116e <w0ms>
    1316:	00 00 00 
; finale
	bclr	A16,#b_save	; "SAVE" LED off
    1318:	af a9 a9    	bclr.b    0x9af, #0x5
	bra	saveload_exit
    131a:	16 00 37    	bra       0x1348 <saveload_exit>

0000131c <save2flash>:

save2flash:		; save to flash
	mov	#0x1000,w5	; file length countdown (in words)
    131c:	05 00 21    	mov.w     #0x1000, w5
	mov	#Rom,w3		; pointer
    131e:	03 00 22    	mov.w     #0x2000, w3

00001320 <L53>:
5:
	cp0	[w3++]		; test if word contains data
    1320:	33 00 e0    	cp0.w     [w3++]
	bra	nz,6f		; if found meaningful content >0000
    1322:	0a 00 3a    	bra       NZ, 0x1338 <L64>
	dec	w5,w5
    1324:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    1326:	fc ff 3a    	bra       NZ, 0x1320 <L53>
	bset	A16,#b_save	; LED SAVE on
    1328:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; LED SAVE blinks = Nothing to save
    132a:	e0 a9 a8    	bset.b    0x9e0, #0x5

0000132c <waitany2>:
waitany2:
	btss	Flag,#1		; #1 = "key pressed" flag
    132c:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	waitany2
    132e:	fe ff 37    	bra       0x132c <waitany2>
	bclr	Flag,#1		; #1 = "key pressed" flag
    1330:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	A16,#b_save	; LED SAVE off
    1332:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; no blink
    1334:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	saveload_exit	; nothing to save
    1336:	08 00 37    	bra       0x1348 <saveload_exit>

00001338 <L64>:
6:			; found meaningful content >0000
	call	com_rom
    1338:	88 14 02    	call      0x1488 <com_rom>
    133a:	00 00 00 
	mov	FlashAddr,w0
    133c:	00 4e 80    	mov.w     0x9c0, w0
	call	eesavew0	; EEsave
    133e:	44 02 02    	call      0x244 <eesavew0>
    1340:	00 00 00 
	call	com_rom
    1342:	88 14 02    	call      0x1488 <com_rom>
    1344:	00 00 00 
	bclr	A16,#b_save
    1346:	af a9 a9    	bclr.b    0x9af, #0x5

00001348 <saveload_exit>:
saveload_exit:
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxPos
    1348:	88 28 02    	call      0x2888 <rxtx_to_rxtxpos>
    134a:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    134c:	54 28 02    	call      0x2854 <set_U1BRG>
    134e:	00 00 00 
	clr	Taskbar
    1350:	b8 29 ef    	clr.w     0x9b8
	bclr	Flag,#1		; reset handshaking flag for buttons (ignore it during save!)
    1352:	dc 29 a9    	bclr.b    0x9dc, #0x1
	call	peek_flash	; record flash occupance  (37 ms)
    1354:	d0 17 02    	call      0x17d0 <peek_flash>
    1356:	00 00 00 
	bra	alu_farm
    1358:	44 ff 37    	bra       0x11e2 <alu_farm>

0000135a <button_LOAD>:

; ---------------------------------------------------------------------------------------

button_LOAD:
	bclr	Flag2,#6	; #6 EE subroutines adjust to Boot
    135a:	de c9 a9    	bclr.b    0x9de, #0x6
	bclr	Flag2,#7	; #7 EE load to second halve of Rom area (starting at 0x3000)
    135c:	de e9 a9    	bclr.b    0x9de, #0x7
	bset	Flag2,#9	; #9 set = last command LOAD
    135e:	df 29 a8    	bset.b    0x9df, #0x1
	bset	A16,#b_load	; LED on
    1360:	af c9 a8    	bset.b    0x9af, #0x6
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    1362:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	nc,ALTload	; if ALT pressed: load from Flash
    1364:	56 00 39    	bra       NC, 0x1412 <ALTload>

00001366 <LoadFromRx>:
LoadFromRx:		; load from serial port
	bclr	IEC0,#11	; disable RX1 interrupt
    1366:	99 60 a9    	bclr.b    0x99, #0x3
	  call	  rxtx_to_io	  ; RxTx directed to IO connector
    1368:	9e 28 02    	call      0x289e <rxtx_to_io>
    136a:	00 00 00 
	  call	  def_U1BRG	  ; BRG = 9600
    136c:	50 28 02    	call      0x2850 <def_U1BRG>
    136e:	00 00 00 

00001370 <L65>:
; synchronize to header A5 C3
6:
	call	rxbyte_20s	; <---------- first RX attempt (timeout 20 sec)
    1370:	3c 14 02    	call      0x143c <rxbyte_20s>
    1372:	00 00 00 
	bra	c,rx_patience_1	; if patience lost or keypress
    1374:	49 00 31    	bra       C, 0x1408 <rx_patience_1>
	mov	#16,w5		; 16 attempts before giving up
    1376:	05 01 20    	mov.w     #0x10, w5

00001378 <L54>:
5:
	call	rxbyte_4s	; <---------- attempt to RX header 1 (A5) (timeout 4 sec)
    1378:	40 14 02    	call      0x1440 <rxbyte_4s>
    137a:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    137c:	5b 00 31    	bra       C, 0x1434 <rx_patience>
	sub	#0xA5,w0
    137e:	50 0a b1    	sub.w     #0xa5, w0
	bra	z,found_header_a5
    1380:	04 00 32    	bra       Z, 0x138a <found_header_a5>
	dec	w5,w5
    1382:	85 02 e9    	dec.w     w5, w5
	bra	nz,5b
    1384:	f9 ff 3a    	bra       NZ, 0x1378 <L54>
	mov	#0,w0
    1386:	00 00 20    	mov.w     #0x0, w0
	bra	rx_patience	; giving up after 16 attempts to recognize header
    1388:	55 00 37    	bra       0x1434 <rx_patience>

0000138a <found_header_a5>:
found_header_a5:
	call	rxbyte_500ms	; <---------- RX header 2 (C3)
    138a:	44 14 02    	call      0x1444 <rxbyte_500ms>
    138c:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    138e:	52 00 31    	bra       C, 0x1434 <rx_patience>
	sub	#0xC3,w0
    1390:	30 0c b1    	sub.w     #0xc3, w0
	bra	nz,6b		; one more chance
    1392:	ee ff 3a    	bra       NZ, 0x1370 <L65>
; header A5 C3 recognized, now get file length (low byte first)
	call	rxbyte_500ms	; <---------- RX file length low
    1394:	44 14 02    	call      0x1444 <rxbyte_500ms>
    1396:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    1398:	4d 00 31    	bra       C, 0x1434 <rx_patience>
	ze	w0,w3		; w3 first low byte (file length low)
    139a:	80 81 fb    	ze        w0, w3
	call	rxbyte_500ms	; <---------- RX file length high
    139c:	44 14 02    	call      0x1444 <rxbyte_500ms>
    139e:	00 00 00 
	bra	c,rx_patience	; patience lost or keypress
    13a0:	49 00 31    	bra       C, 0x1434 <rx_patience>
	sl	w0,#8,w0	; high byte go high
    13a2:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w3,w3	; w3 file length (in words)
    13a4:	83 01 70    	ior.w     w0, w3, w3
	mov	w3,w5		; w5 = CHS
    13a6:	83 02 78    	mov.w     w3, w5
	lsr	w3,#2,w2	; w2 file length/4, will be used in taskbar calculation
    13a8:	42 19 de    	lsr.w     w3, #0x2, w2
	ifz
    13aa:	42 20 af    	btsc.b    0x42, #0x1
	mov	#1,w2		; avoid  divide by zero
    13ac:	12 00 20    	mov.w     #0x1, w2
	bra	z,only_timeout	; zero length - file too short (LOAD blinks)
    13ae:	44 00 32    	bra       Z, 0x1438 <only_timeout>
	mov	#0x1001,w1	; max length+1 (number of words!)
    13b0:	11 00 21    	mov.w     #0x1001, w1
	cp	w3,w1
    13b2:	01 18 e1    	cp.w      w3, w1
	bra	c,only_timeout	; file too long (LOAD blinks)
    13b4:	41 00 31    	bra       C, 0x1438 <only_timeout>
; receive message body
	mov	#Rom,w6		; write pointer
    13b6:	06 00 22    	mov.w     #0x2000, w6

000013b8 <L35>:
3:			; <-------- RX loop
	call	rxbyte_500ms	; <---------- RX message body low
    13b8:	44 14 02    	call      0x1444 <rxbyte_500ms>
    13ba:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    13bc:	3b 00 31    	bra       C, 0x1434 <rx_patience>
	ze	w0,w4
    13be:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX message body high
    13c0:	44 14 02    	call      0x1444 <rxbyte_500ms>
    13c2:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    13c4:	37 00 31    	bra       C, 0x1434 <rx_patience>
	sl	w0,#8,w0	; high byte go high
    13c6:	48 00 dd    	sl.w      w0, #0x8, w0
	ior	w0,w4,w0
    13c8:	04 00 70    	ior.w     w0, w4, w0
	mov	w0,[w6++]	; WRITE RECEIVED WORD
    13ca:	00 1b 78    	mov.w     w0, [w6++]
	add	w0,w5,w5	; update CHS
    13cc:	85 02 40    	add.w     w0, w5, w5

; taskbar ------
	sl	w3,#3,w1	; w1 = w5 × 8
    13ce:	c3 18 dd    	sl.w      w3, #0x3, w1
	repeat	#17
    13d0:	11 00 09    	repeat    #0x11
	div.u	w1,w2		; w0:w1 (at transmit preogress, w0 decreases from 32 to 0)
    13d2:	82 80 d8    	div.uw    w1, w2
	cp	w0,#31
    13d4:	7f 00 e1    	cp.w      w0, #0x1f
	ifc
    13d6:	42 00 af    	btsc.b    0x42, #0x0
	mov	#31,w0		; clip w0 to 0...31
    13d8:	f0 01 20    	mov.w     #0x1f, w0
	lsr	w0,w0
    13da:	00 00 d1    	lsr.w     w0, w0
	mov	#0xFFFF,w1
    13dc:	f1 ff 2f    	mov.w     #0xffff, w1
	lsr	w1,w0,w1	; taskbar progress  UP ---> DOWN
    13de:	80 08 de    	lsr.w     w1, w0, w1
	mov	w1,Taskbar
    13e0:	c1 4d 88    	mov.w     w1, 0x9b8
	dec	w3,w3
    13e2:	83 01 e9    	dec.w     w3, w3
	bra	nz,3b		; loop
    13e4:	e9 ff 3a    	bra       NZ, 0x13b8 <L35>
; receive checksum
	call	rxbyte_500ms	; <---------- RX CHS low
    13e6:	44 14 02    	call      0x1444 <rxbyte_500ms>
    13e8:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    13ea:	24 00 31    	bra       C, 0x1434 <rx_patience>
	ze	w0,w4
    13ec:	00 82 fb    	ze        w0, w4
	call	rxbyte_500ms	; <---------- RX CHS high
    13ee:	44 14 02    	call      0x1444 <rxbyte_500ms>
    13f0:	00 00 00 
	bra	c,rx_patience	; if patience lost or keypress
    13f2:	20 00 31    	bra       C, 0x1434 <rx_patience>
	swap	w0
    13f4:	00 80 fd    	swap.w    w0
	ior	w0,w4,w0
    13f6:	04 00 70    	ior.w     w0, w4, w0
	cp	w0,w5		; received CHS - calculated CHS
    13f8:	05 00 e1    	cp.w      w0, w5
	bra	nz,rx_patience	; CHS does not match!
    13fa:	1c 00 3a    	bra       NZ, 0x1434 <rx_patience>

000013fc <fill00>:
; RX finished, fill 00s to the end (pointer w6)
fill00:
	btsc	w6,#14		; #14 will be set when w6 reaches 0x4000
    13fc:	06 e0 a7    	btsc.w    w6, #0xe
	bra	filled
    13fe:	02 00 37    	bra       0x1404 <filled>
	clr.b	[w6++]
    1400:	00 5b eb    	clr.b     [w6++]
	bra	fill00
    1402:	fc ff 37    	bra       0x13fc <fill00>

00001404 <filled>:
filled:
	bclr	A16,#b_load
    1404:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit	; -----> RX LOAD FINISHED
    1406:	a0 ff 37    	bra       0x1348 <saveload_exit>

00001408 <rx_patience_1>:

;								
rx_patience_1:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0
    1408:	00 00 e0    	cp0.w     w0
	bra	z,only_timeout	; if no key pressed or gave up after 16 attempts to recognize header
    140a:	16 00 32    	bra       Z, 0x1438 <only_timeout>
	bclr	A16,#b_load	; LED LOAD off
    140c:	af c9 a9    	bclr.b    0x9af, #0x6
	bclr	BlinkFlag,#7	; no blinking
    140e:	e0 e9 a9    	bclr.b    0x9e0, #0x7
	bra	saveload_exit	; key pressed, just exit
    1410:	9b ff 37    	bra       0x1348 <saveload_exit>

00001412 <ALTload>:

;			
ALTload:		; ALT pressed, load from Flash
	bset	A16,#b_load
    1412:	af c9 a8    	bset.b    0x9af, #0x6
	call	com_rom
    1414:	88 14 02    	call      0x1488 <com_rom>
    1416:	00 00 00 
	mov	#15,w0
    1418:	f0 00 20    	mov.w     #0xf, w0
	cp.b	FlashAddr
    141a:	c0 49 e3    	cp.b      0x9c0
	ifnz
    141c:	42 20 ae    	btss.b    0x42, #0x1
	call	eesavew0	; just in case, saved on record 15
    141e:	44 02 02    	call      0x244 <eesavew0>
    1420:	00 00 00 
	call	com_rom
    1422:	88 14 02    	call      0x1488 <com_rom>
    1424:	00 00 00 

	mov	FlashAddr,w0
    1426:	00 4e 80    	mov.w     0x9c0, w0
	call	eeload
    1428:	46 02 02    	call      0x246 <eeload>
    142a:	00 00 00 
	call	com_rom
    142c:	88 14 02    	call      0x1488 <com_rom>
    142e:	00 00 00 
	bclr	A16,#b_load
    1430:	af c9 a9    	bclr.b    0x9af, #0x6
	bra	saveload_exit
    1432:	8a ff 37    	bra       0x1348 <saveload_exit>

00001434 <rx_patience>:
;			
rx_patience:		; jumps here if timeout or any key pressed during waiting for RX
	cp0	w0		; w0=0 if no key pressed
    1434:	00 00 e0    	cp0.w     w0
	ifnz			; if key pressed, then LED LOAD blinks = TIMEOUT
    1436:	42 20 ae    	btss.b    0x42, #0x1

00001438 <only_timeout>:
only_timeout:
	bset	BlinkFlag,#7	; LED LOAD blinks = TIMEOUT
    1438:	e0 e9 a8    	bset.b    0x9e0, #0x7
	bra	saveload_exit	; regular exit
    143a:	86 ff 37    	bra       0x1348 <saveload_exit>

0000143c <rxbyte_20s>:

;											
rxbyte_20s:		; RX byte ---> w0 (NC), patience 20s (C set if pat lost)
	mov	#20000,w1	; patience 20 s
    143c:	01 e2 24    	mov.w     #0x4e20, w1
	bra	1f
    143e:	03 00 37    	bra       0x1446 <L19>

00001440 <rxbyte_4s>:
rxbyte_4s:		; RX byte ---> w0 (NC), patience 4s (C set if pat lost)
	mov	#4000,w1	; patience 4 s
    1440:	01 fa 20    	mov.w     #0xfa0, w1
	bra	1f
    1442:	01 00 37    	bra       0x1446 <L19>

00001444 <rxbyte_500ms>:
rxbyte_500ms:		; RX byte ---> w0 (NC), patience 500 ms (C set if pat lost)
	mov	#500,w1		; patience 500 ms
    1444:	41 1f 20    	mov.w     #0x1f4, w1

00001446 <L19>:
1:
	mov	#2240,w0	; inner loop 1 ms
    1446:	00 8c 20    	mov.w     #0x8c0, w0

00001448 <L26>:
2:
	btsc	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    1448:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	button_press_rx	; if button pressed
    144a:	0d 00 37    	bra       0x1466 <button_press_rx>
	btsc	U1STAL,#URXDA	; bit set if RX data available
    144c:	9a 03 af    	btsc.b    0x39a, #0x0
	bra	rx_arrived_2
    144e:	07 00 37    	bra       0x145e <rx_arrived_2>
	dec	w0,w0
    1450:	00 00 e9    	dec.w     w0, w0
	bra	nz,2b		; loop 7t × 2240 = 15680t = 1 ms (INT time estimated)
    1452:	fa ff 3a    	bra       NZ, 0x1448 <L26>
	dec	w1,w1
    1454:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b		; loop 1 ms × 500 = 500 ms
    1456:	f7 ff 3a    	bra       NZ, 0x1446 <L19>
;patience_lost
	mov	#0,w0		; flag no keys pressed (only timeout)
    1458:	00 00 20    	mov.w     #0x0, w0
	setc			; Carry set = NOT OK
    145a:	42 00 a8    	bset.b    0x42, #0x0
	return
    145c:	00 00 06    	return    

0000145e <rx_arrived_2>:
;				
rx_arrived_2:
	mov.b	U1RXREG,WREG	; <---- get received byte (this resets U1STAL,#URXDA)
    145e:	9e c3 bf    	mov.b     0x39e, WREG
	ze	w0,w0
    1460:	00 80 fb    	ze        w0, w0
	clrc
    1462:	42 00 a9    	bclr.b    0x42, #0x0
	return
    1464:	00 00 06    	return    

00001466 <button_press_rx>:
;				
button_press_rx:
	bclr	Flag,#1		; #1 handshaking flag for buttons, set when any key pressed
    1466:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	#1,w0		; flag key pressed (not timeout)
    1468:	10 00 20    	mov.w     #0x1, w0
	setc			; Carry set = NOT OK
    146a:	42 00 a8    	bset.b    0x42, #0x0
	return
    146c:	00 00 06    	return    

0000146e <button_CLOCK>:
; -----------------------------------------------------------------
button_CLOCK:
	mov	#3,w0
    146e:	30 00 20    	mov.w     #0x3, w0
	and	BlinkFlag,WREG
    1470:	e0 09 b6    	and.w     0x9e0, WREG
	bra	nz,alu_farm	; no execution if the instruction is illegal
    1472:	b7 fe 3a    	bra       NZ, 0x11e2 <alu_farm>

	bset	A16,#b_clk_key	; set CLK key
    1474:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w11 bits to decide flag transfer
    1476:	40 15 02    	call      0x1540 <transfer1>
    1478:	00 00 00 

0000147a <L110>:
1:
	inc	KeyRotors+8,WREG
    147a:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,1b		; if not yet 0x11111111
    147c:	fe ff 3a    	bra       NZ, 0x147a <L110>
	bclr	A16,#b_clk_key
    147e:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w11 bits to decide flag transfer
    1480:	24 16 02    	call      0x1624 <transfer2>
    1482:	00 00 00 

	mov.b	w13,[w7]	; write result to destination
    1484:	8d 4b 78    	mov.b     w13, [w7]
	bra	alu_farm
    1486:	ad fe 37    	bra       0x11e2 <alu_farm>

00001488 <com_rom>:

; **********************************************************************************************
com_rom:		; complement Rom 0x1800 bytes
	mov	#Rom,w2
    1488:	02 00 22    	mov.w     #0x2000, w2
	mov	#0x1000,w1
    148a:	01 00 21    	mov.w     #0x1000, w1

0000148c <L111>:
1:
	com	[w2],[w2++]
    148c:	12 99 ea    	com.w     [w2], [w2++]
	dec	w1,w1
    148e:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    1490:	fd ff 3a    	bra       NZ, 0x148c <L111>
	return
    1492:	00 00 06    	return    

00001494 <general_alu_5>:

; --------------------------------------------------------------------------------------
; buttons Opcode - OperX - OperY - DataIn						
; --------------------------------------------------------------------------------------

general_alu_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	alu_key_3
    1494:	9a 14 02    	call      0x149a <alu_key_3>
    1496:	00 00 00 
	bra	alu_farm
    1498:	a4 fe 37    	bra       0x11e2 <alu_farm>

0000149a <alu_key_3>:
; ------------------------------
alu_key_3:		; Opcode-OperX-OperY --- Dim-Dummy-FlashAddr
	mov	#Opcode,w3
    149a:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    149c:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    149e:	65 92 20    	mov.w     #0x926, w5
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    14a0:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    14a2:	1b 00 37    	bra       0x14da <general>
	mov	#Dimmer,w3
    14a4:	e3 8f 20    	mov.w     #0x8fe, w3
	mov	#SerCtrl,w4
    14a6:	54 8f 20    	mov.w     #0x8f5, w4
	bclr.b	[w4],#3		; spec case: Buad Rate can't be greater than 7
    14a8:	14 34 a1    	bclr.b    [w4], #0x3
	mov	#FlashAddr,w5
    14aa:	05 9c 20    	mov.w     #0x9c0, w5
	call	general
    14ac:	da 14 02    	call      0x14da <general>
    14ae:	00 00 00 
	bclr.b	SerCtrl,#3	; spec case: Buad Rate can't be greater than 7
    14b0:	f5 68 a9    	bclr.b    0x8f5, #0x3
	mov.b	SerCtrl,WREG
    14b2:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    14b4:	70 00 b2    	and.w     #0x7, w0
	call	set_U1BRG_from_w0	; set new Baud Rate
    14b6:	58 28 02    	call      0x2858 <set_U1BRG_from_w0>
    14b8:	00 00 00 
	return
    14ba:	00 00 06    	return    

000014bc <limited_key_3>:
limited_key_3:		; can't affect pgm data, only Dim Clock Page
	mov	#Dummy,w3
    14bc:	03 9b 20    	mov.w     #0x9b0, w3
	mov	#Dummy,w4
    14be:	04 9b 20    	mov.w     #0x9b0, w4
	mov	#Dummy,w5
    14c0:	05 9b 20    	mov.w     #0x9b0, w5
	bra	uni_key
    14c2:	03 00 37    	bra       0x14ca <uni_key>

000014c4 <general_key_3O>:
general_key_3O:
	mov	#Opcode,w3
    14c4:	23 92 20    	mov.w     #0x922, w3
	mov	#OperX,w4
    14c6:	44 92 20    	mov.w     #0x924, w4
	mov	#OperY,w5
    14c8:	65 92 20    	mov.w     #0x926, w5

000014ca <uni_key>:
uni_key:
	mov	Mode,w0		; *** if PGM mode (disable 12 keys)
    14ca:	b0 4b 80    	mov.w     0x976, w0
	cp.b	w0,#3		; *** if PGM mode (disable 12 keys)
    14cc:	63 04 e1    	cp.b      w0, #0x3
	bra	z,general	; *** if PGM mode (disable 12 keys)
    14ce:	05 00 32    	bra       Z, 0x14da <general>

	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    14d0:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	general		; if ALT not pressed
    14d2:	03 00 37    	bra       0x14da <general>
	mov	#Sync,w3
    14d4:	23 8f 20    	mov.w     #0x8f2, w3
	mov	#Speed,w4
    14d6:	14 8f 20    	mov.w     #0x8f1, w4
	mov	#Page,w5
    14d8:	05 8f 20    	mov.w     #0x8f0, w5

000014da <general>:
general:
; is it key 5...8?
	mov	Just,w0
    14da:	30 4d 80    	mov.w     0x9a6, w0
	sub	#5,w0
    14dc:	50 00 b1    	sub.w     #0x5, w0
	cp	w0,#4
    14de:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    14e0:	0d 00 39    	bra       NC, 0x14fc <key0_3>
; is it key 9...12?
	mov	w4,w3
    14e2:	84 01 78    	mov.w     w4, w3
	sub	#4,w0
    14e4:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    14e6:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    14e8:	09 00 39    	bra       NC, 0x14fc <key0_3>
; is it key 13...16?
	mov	w5,w3
    14ea:	85 01 78    	mov.w     w5, w3
	sub	#4,w0
    14ec:	40 00 b1    	sub.w     #0x4, w0
	cp	w0,#4
    14ee:	64 00 e1    	cp.w      w0, #0x4
	bra	nc,key0_3
    14f0:	05 00 39    	bra       NC, 0x14fc <key0_3>
; then it must be key 17 = Data In
	btg	A16,#b_bin
    14f2:	af e9 aa    	btg.b     0x9af, #0x7
	bclr	A16,#b_sel
    14f4:	ae e9 a9    	bclr.b    0x9ae, #0x7
	btss	A16,#b_bin
    14f6:	af e9 ae    	btss.b    0x9af, #0x7
	bset	A16,#b_sel
    14f8:	ae e9 a8    	bset.b    0x9ae, #0x7
	return
    14fa:	00 00 06    	return    

000014fc <key0_3>:
; -------- 
key0_3:
	btss	A16,#b_bin
    14fc:	af e9 ae    	btss.b    0x9af, #0x7
	bra	its_sel
    14fe:	0d 00 37    	bra       0x151a <its_sel>
; it's binary mode here
	cp0	w0
    1500:	00 00 e0    	cp0.w     w0
	ifz
    1502:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#3		; key 8 in binary mode
    1504:	13 34 a2    	btg.b     [w3], #0x3
	cp	w0,#1
    1506:	61 00 e1    	cp.w      w0, #0x1
	ifz
    1508:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#2		; key 4 in binary mode
    150a:	13 24 a2    	btg.b     [w3], #0x2
	cp	w0,#2
    150c:	62 00 e1    	cp.w      w0, #0x2
	ifz
    150e:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#1		; key 2 in binary mode
    1510:	13 14 a2    	btg.b     [w3], #0x1
	cp	w0,#3
    1512:	63 00 e1    	cp.w      w0, #0x3
	ifz
    1514:	42 20 af    	btsc.b    0x42, #0x1
	btg.b	[w3],#0		; key 1 in binary mode
    1516:	13 04 a2    	btg.b     [w3], #0x0
	return
    1518:	00 00 06    	return    

0000151a <its_sel>:
its_sel:
	ze	[w3],w4
    151a:	13 82 fb    	ze        [w3], w4
	cp0	w0
    151c:	00 00 e0    	cp0.w     w0
	ifz
    151e:	42 20 af    	btsc.b    0x42, #0x1
	sub	#4,w4		; key ---- in select mode
    1520:	44 00 b1    	sub.w     #0x4, w4
	cp	w0,#1
    1522:	61 00 e1    	cp.w      w0, #0x1
	ifz
    1524:	42 20 af    	btsc.b    0x42, #0x1
	dec	w4,w4		; key - in select mode
    1526:	04 02 e9    	dec.w     w4, w4
	cp	w0,#2
    1528:	62 00 e1    	cp.w      w0, #0x2
	ifz
    152a:	42 20 af    	btsc.b    0x42, #0x1
	inc	w4,w4		; key + in select mode
    152c:	04 02 e8    	inc.w     w4, w4
	cp	w0,#3
    152e:	63 00 e1    	cp.w      w0, #0x3
	ifz
    1530:	42 20 af    	btsc.b    0x42, #0x1
	add	#4,w4		; key ++++ in select mode
    1532:	44 00 b0    	add.w     #0x4, w4
; clip w3 to 0...15
	btsc	w4,#15		; if w4<0...
    1534:	04 f0 a7    	btsc.w    w4, #0xf
	clr	w4		; ...then w4=0
    1536:	00 02 eb    	clr.w     w4
	btsc	w4,#4		; if w4>15...
    1538:	04 40 a7    	btsc.w    w4, #0x4
	mov	#15,w4		; ...then w4=15
    153a:	f4 00 20    	mov.w     #0xf, w4
	mov.b	w4,[w3]
    153c:	84 49 78    	mov.b     w4, [w3]
	return
    153e:	00 00 06    	return    

00001540 <transfer1>:

; --------------------------------------------------------------------------------------
; Transfers through Accu and Flags  In - Temp - Out					
; --------------------------------------------------------------------------------------
transfer1:		; in the first clock semiphase or when STEP is depressed
	bclr	A16,#b_noclk_sch
    1540:	ae 69 a9    	bclr.b    0x9ae, #0x3
	bset	A16,#b_clk_sch	; set CLK schematic
    1542:	ae 09 a8    	bset.b    0x9ae, #0x0
	bra	w6
    1544:	06 60 01    	bra       w6
;...
	return			; no transfers if w6=0000
    1546:	00 00 06    	return    
	bra	n0001
    1548:	0e 00 37    	bra       0x1566 <n0001>
	bra	n0010
    154a:	0f 00 37    	bra       0x156a <n0010>
	bra	n0011
    154c:	12 00 37    	bra       0x1572 <n0011>
	bra	n0100
    154e:	16 00 37    	bra       0x157c <n0100>
	bra	n0101
    1550:	19 00 37    	bra       0x1584 <n0101>
	bra	n0110
    1552:	1d 00 37    	bra       0x158e <n0110>
	bra	n0111
    1554:	23 00 37    	bra       0x159c <n0111>
	bra	n1000
    1556:	2a 00 37    	bra       0x15ac <n1000>
	bra	n1001
    1558:	2d 00 37    	bra       0x15b4 <n1001>
	bra	n1010
    155a:	31 00 37    	bra       0x15be <n1010>
	bra	n1011
    155c:	37 00 37    	bra       0x15cc <n1011>
	bra	n1100
    155e:	3e 00 37    	bra       0x15dc <n1100>
	bra	n1101
    1560:	44 00 37    	bra       0x15ea <n1101>
	bra	n1110
    1562:	4b 00 37    	bra       0x15fa <n1110>
	bra	n1111
    1564:	54 00 37    	bra       0x160e <n1111>

00001566 <n0001>:
; -------------------
n0001:
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1566:	4d 49 88    	mov.w     w13, 0x928
	return
    1568:	00 00 06    	return    

0000156a <n0010>:
n0010:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    156a:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    156c:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    156e:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    1570:	00 00 06    	return    

00001572 <n0011>:
n0011:
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1572:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1574:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1576:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1578:	4d 49 88    	mov.w     w13, 0x928
	return
    157a:	00 00 06    	return    

0000157c <n0100>:
n0100:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    157c:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    157e:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1580:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    1582:	00 00 06    	return    

00001584 <n0101>:
n0101:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1584:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1586:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1588:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    158a:	4d 49 88    	mov.w     w13, 0x928
	return
    158c:	00 00 06    	return    

0000158e <n0110>:
n0110:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    158e:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1590:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1592:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1594:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1596:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    1598:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    159a:	00 00 06    	return    

0000159c <n0111>:
n0111:
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    159c:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    159e:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    15a0:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    15a2:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    15a4:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    15a6:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    15a8:	4d 49 88    	mov.w     w13, 0x928
	return
    15aa:	00 00 06    	return    

000015ac <n1000>:
n1000:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15ac:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15ae:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15b0:	30 29 a8    	bset.b    0x930, #0x1
	return
    15b2:	00 00 06    	return    

000015b4 <n1001>:
n1001:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15b4:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15b6:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15b8:	30 29 a8    	bset.b    0x930, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    15ba:	4d 49 88    	mov.w     w13, 0x928
	return
    15bc:	00 00 06    	return    

000015be <n1010>:
n1010:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15be:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15c0:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15c2:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    15c4:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    15c6:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    15c8:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    15ca:	00 00 06    	return    

000015cc <n1011>:
n1011:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15cc:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15ce:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15d0:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    15d2:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    15d4:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    15d6:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    15d8:	4d 49 88    	mov.w     w13, 0x928
	return
    15da:	00 00 06    	return    

000015dc <n1100>:

n1100:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15dc:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15de:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15e0:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    15e2:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    15e4:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    15e6:	2e 29 a8    	bset.b    0x92e, #0x1
	return
    15e8:	00 00 06    	return    

000015ea <n1101>:
n1101:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15ea:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15ec:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15ee:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    15f0:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    15f2:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    15f4:	2e 29 a8    	bset.b    0x92e, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    15f6:	4d 49 88    	mov.w     w13, 0x928
	return
    15f8:	00 00 06    	return    

000015fa <n1110>:
n1110:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    15fa:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    15fc:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    15fe:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1600:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1602:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1604:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    1606:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    1608:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    160a:	2c 29 a8    	bset.b    0x92c, #0x1
	return
    160c:	00 00 06    	return    

0000160e <n1111>:
n1111:
	bclr	Vflag,#1	; 3 transfer OVF in to OVF temp
    160e:	30 29 a9    	bclr.b    0x930, #0x1
	btsc	Vflag,#0
    1610:	30 09 af    	btsc.b    0x930, #0x0
	bset	Vflag,#1
    1612:	30 29 a8    	bset.b    0x930, #0x1
	bclr	Zflag,#1	; 2 transfer ZERO in to ZERO temp
    1614:	2e 29 a9    	bclr.b    0x92e, #0x1
	btsc	Zflag,#0
    1616:	2e 09 af    	btsc.b    0x92e, #0x0
	bset	Zflag,#1
    1618:	2e 29 a8    	bset.b    0x92e, #0x1
	bclr	Cflag,#1	; 1 transfer CARRY in to CARRY temp
    161a:	2c 29 a9    	bclr.b    0x92c, #0x1
	btsc	Cflag,#0
    161c:	2c 09 af    	btsc.b    0x92c, #0x0
	bset	Cflag,#1
    161e:	2c 29 a8    	bset.b    0x92c, #0x1
	mov	w13,Atemp	; 0 transfer ACCU in to ACCU temp
    1620:	4d 49 88    	mov.w     w13, 0x928
	return
    1622:	00 00 06    	return    

00001624 <transfer2>:
;-----------------------------------------------------------------------------------

transfer2:		; in the second clack semiphase or when STEP is released
	bclr	A16,#b_clk_sch
    1624:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch ; set NOCLK schematic
    1626:	ae 69 a8    	bset.b    0x9ae, #0x3
	bra	w6
    1628:	06 60 01    	bra       w6
;...
	return
    162a:	00 00 06    	return    
	bra	z0001
    162c:	0e 00 37    	bra       0x164a <z0001>
	bra	z0010
    162e:	0f 00 37    	bra       0x164e <z0010>
	bra	z0011
    1630:	15 00 37    	bra       0x165c <z0011>
	bra	z0100
    1632:	1c 00 37    	bra       0x166c <z0100>
	bra	z0101
    1634:	1f 00 37    	bra       0x1674 <z0101>
	bra	z0110
    1636:	23 00 37    	bra       0x167e <z0110>
	bra	z0111
    1638:	2c 00 37    	bra       0x1692 <z0111>
	bra	z1000
    163a:	36 00 37    	bra       0x16a8 <z1000>
	bra	z1001
    163c:	3c 00 37    	bra       0x16b6 <z1001>
	bra	z1010
    163e:	43 00 37    	bra       0x16c6 <z1010>
	bra	z1011
    1640:	49 00 37    	bra       0x16d4 <z1011>
	bra	z1100
    1642:	56 00 37    	bra       0x16f0 <z1100>
	bra	z1101
    1644:	5f 00 37    	bra       0x1704 <z1101>
	bra	z1110
    1646:	69 00 37    	bra       0x171a <z1110>
	bra	z1111
    1648:	78 00 37    	bra       0x173a <z1111>

0000164a <z0001>:
; -------------------
z0001:
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    164a:	4e 49 80    	mov.w     0x928, w14
	return
    164c:	00 00 06    	return    

0000164e <z0010>:
z0010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    164e:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1650:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1652:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1654:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1656:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1658:	af 89 a8    	bset.b    0x9af, #0x4
	return
    165a:	00 00 06    	return    

0000165c <z0011>:
z0011:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    165c:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    165e:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1660:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1662:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1664:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1666:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1668:	4e 49 80    	mov.w     0x928, w14
	return
    166a:	00 00 06    	return    

0000166c <z0100>:
z0100:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    166c:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    166e:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1670:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    1672:	00 00 06    	return    

00001674 <z0101>:
z0101:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1674:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1676:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1678:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    167a:	4e 49 80    	mov.w     0x928, w14
	return
    167c:	00 00 06    	return    

0000167e <z0110>:
z0110:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    167e:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1680:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1682:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1684:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    1686:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1688:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    168a:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    168c:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    168e:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1690:	00 00 06    	return    

00001692 <z0111>:
z0111:
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1692:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1694:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1696:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    1698:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    169a:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    169c:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    169e:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16a0:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16a2:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    16a4:	4e 49 80    	mov.w     0x928, w14
	return
    16a6:	00 00 06    	return    

000016a8 <z1000>:
z1000:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16a8:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16aa:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16ac:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16ae:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16b0:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16b2:	f4 28 a8    	bset.b    0x8f4, #0x1
	return
    16b4:	00 00 06    	return    

000016b6 <z1001>:
z1001:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16b6:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16b8:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16ba:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16bc:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16be:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16c0:	f4 28 a8    	bset.b    0x8f4, #0x1
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    16c2:	4e 49 80    	mov.w     0x928, w14
	return
    16c4:	00 00 06    	return    

000016c6 <z1010>:
z1010:
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    16c6:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    16c8:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16ca:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16cc:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16ce:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16d0:	af 89 a8    	bset.b    0x9af, #0x4
	return
    16d2:	00 00 06    	return    

000016d4 <z1011>:
z1011:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16d4:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16d6:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16d8:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16da:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16dc:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16de:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    16e0:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    16e2:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    16e4:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    16e6:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    16e8:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    16ea:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    16ec:	4e 49 80    	mov.w     0x928, w14
	return
    16ee:	00 00 06    	return    

000016f0 <z1100>:
z1100:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    16f0:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    16f2:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    16f4:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16f6:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    16f8:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    16fa:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    16fc:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    16fe:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1700:	2e 49 a8    	bset.b    0x92e, #0x2
	return
    1702:	00 00 06    	return    

00001704 <z1101>:
z1101:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    1704:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    1706:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    1708:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    170a:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    170c:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    170e:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1710:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1712:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    1714:	2e 49 a8    	bset.b    0x92e, #0x2
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1716:	4e 49 80    	mov.w     0x928, w14
	return
    1718:	00 00 06    	return    

0000171a <z1110>:
z1110:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    171a:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    171c:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    171e:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1720:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1722:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1724:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1726:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1728:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    172a:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    172c:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    172e:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1730:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1732:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1734:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1736:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1738:	00 00 06    	return    

0000173a <z1111>:
z1111:
	bclr	Vflag,#2	; 3 transfer overflow temp to overflow out...
    173a:	30 49 a9    	bclr.b    0x930, #0x2
	btsc	Vflag,#1
    173c:	30 29 af    	btsc.b    0x930, #0x1
	bset	Vflag,#2
    173e:	30 49 a8    	bset.b    0x930, #0x2
	bclr.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1740:	f4 28 a9    	bclr.b    0x8f4, #0x1
	btsc	Vflag,#1	; 3 ...and to readable V flag pos
    1742:	30 29 af    	btsc.b    0x930, #0x1
	bset.b	RdFlags,#1	; 3 ...and to readable V flag pos
    1744:	f4 28 a8    	bset.b    0x8f4, #0x1
	bclr	Zflag,#2	; 2 transfer zero temp to zero out...
    1746:	2e 49 a9    	bclr.b    0x92e, #0x2
	btsc	Zflag,#1
    1748:	2e 29 af    	btsc.b    0x92e, #0x1
	bset	Zflag,#2
    174a:	2e 49 a8    	bset.b    0x92e, #0x2
	bclr	Cflag,#2	; 1 transfer carry temp to Carry out...
    174c:	2c 49 a9    	bclr.b    0x92c, #0x2
	btsc	Cflag,#1
    174e:	2c 29 af    	btsc.b    0x92c, #0x1
	bset	Cflag,#2
    1750:	2c 49 a8    	bset.b    0x92c, #0x2
	bclr	A16,#b_carry	; 1 ...and to Carry button LED
    1752:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2	; 1 ...and to Carry button LED
    1754:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry	; 1 ...and to Carry button LED
    1756:	af 89 a8    	bset.b    0x9af, #0x4
	mov	Atemp,w14	; 0 transfer ACCU data to ouptput
    1758:	4e 49 80    	mov.w     0x928, w14
	return
    175a:	00 00 06    	return    

0000175c <alu_A1>:

; ----------------------------------------------------------   INSTRUCTIONS  -----

alu_A1:			; ADD  RX,RY
	bclr	BlinkFlag,#0
    175c:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    175e:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_1
    1760:	a4 1e 02    	call      0x1ea4 <dir_4_1>
    1762:	00 00 00 
	bra	alu_cmd
    1764:	72 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001766 <alu_A2>:
alu_A2:			; ADC  RX,RY
	bclr	BlinkFlag,#0
    1766:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1768:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_2
    176a:	0c 1f 02    	call      0x1f0c <dir_4_2>
    176c:	00 00 00 
	bra	alu_cmd
    176e:	6d fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001770 <alu_A3>:
alu_A3:			; SUB  RX,RY
	bclr	BlinkFlag,#0
    1770:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1772:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_3
    1774:	6a 1f 02    	call      0x1f6a <dir_4_3>
    1776:	00 00 00 
	bra	alu_cmd
    1778:	68 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

0000177a <alu_A4>:
alu_A4:			; SBB  RX,RY
	bclr	BlinkFlag,#0
    177a:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    177c:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_4
    177e:	c0 1f 02    	call      0x1fc0 <dir_4_4>
    1780:	00 00 00 
	bra	alu_cmd
    1782:	63 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001784 <alu_A5>:
alu_A5:			; OR   RX,RY
	bclr	BlinkFlag,#0
    1784:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1786:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_5
    1788:	24 20 02    	call      0x2024 <dir_4_5>
    178a:	00 00 00 
	bra	alu_cmd
    178c:	5e fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

0000178e <alu_A6>:
alu_A6:			; AND  RX,RY
	bclr	BlinkFlag,#0
    178e:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    1790:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_6
    1792:	60 20 02    	call      0x2060 <dir_4_6>
    1794:	00 00 00 
	bra	alu_cmd
    1796:	59 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

00001798 <alu_A7>:
alu_A7:			; XOR  RX,RY
	bclr	BlinkFlag,#0
    1798:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    179a:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_7
    179c:	92 20 02    	call      0x2092 <dir_4_7>
    179e:	00 00 00 
	bra	alu_cmd
    17a0:	54 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

000017a2 <alu_A8>:
alu_A8:			; MOV  RX,RY
	bclr	BlinkFlag,#0
    17a2:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    17a4:	e0 29 a9    	bclr.b    0x9e0, #0x1
	call	dir_4_8
    17a6:	c4 20 02    	call      0x20c4 <dir_4_8>
    17a8:	00 00 00 
	bra	alu_cmd
    17aa:	4f fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

000017ac <alu_G2>:
;-----------------------
;alu_G0:			; CP    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_0
;	bra	alu_cmd
;alu_G1:			; ADD   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_1
;	bra	alu_cmd
alu_G2:			; INC   RY
	bclr	BlinkFlag,#0
    17ac:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    17ae:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    17b0:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_2
    17b2:	d4 22 02    	call      0x22d4 <dir_8_2>
    17b4:	00 00 00 
	bra	alu_cmd
    17b6:	49 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

000017b8 <alu_G3>:
alu_G3:			; DEC   RY
	bclr	BlinkFlag,#0
    17b8:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    17ba:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    17bc:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_3
    17be:	54 23 02    	call      0x2354 <dir_8_3>
    17c0:	00 00 00 
	bra	alu_cmd
    17c2:	43 fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

000017c4 <alu_G13>:
;alu_G5:			; OR    R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_5
;	bra	alu_cmd
;alu_G6:			; AND   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_6
;	bra	alu_cmd
;alu_G7:			; XOR   R0,N
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;	mov	w14,w11
;	call	dir_8_7
;	bra	alu_cmd
;alu_G9:			; BIT   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+11,w7	; register read address = IN port
;	call	dir_8_9
;	bra	alu_cmd
;alu_G10:		; BSET  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_10
;	bra	alu_cmd
;alu_G11:		; BCLR  RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_11
;	bra	alu_cmd
;alu_G12:		; BTG   RG,M
;	bclr	BlinkFlag,#0
;	bclr	BlinkFlag,#1
;; adjust register address
;	mov	#WREG14,w7	; result write address = Accu
;	and	w12,#0x0C,w0	; bits 3,2 = register
;	cp	w0,#0x0C
;	ifz
;	mov	#Ram+10,w7	; register read/write address = OUT port
;	call	dir_8_12
;	bra	alu_cmd
alu_G13:		; RRC   RY
	bclr	BlinkFlag,#0
    17c4:	e0 09 a9    	bclr.b    0x9e0, #0x0
	bclr	BlinkFlag,#1
    17c6:	e0 29 a9    	bclr.b    0x9e0, #0x1
	mov	#OperY,w7	; result write address
    17c8:	67 92 20    	mov.w     #0x926, w7
	call	dir_8_13
    17ca:	ea 25 02    	call      0x25ea <dir_8_13>
    17cc:	00 00 00 
	bra	alu_cmd
    17ce:	3d fd 37    	bra       0x124a <alu_cmd> <alu_wait_key>

000017d0 <peek_flash>:

; --------------------------------------------------------------------

peek_flash:		; measure all 16 Flash occupancies, write to Files (16×1 by) 37 ms
	mov	#Files,w5	; wr ptr
    17d0:	65 96 20    	mov.w     #0x966, w5
	mov	#0,w8		; loop count and record count
    17d2:	08 00 20    	mov.w     #0x0, w8

000017d4 <L83>:
8:
	mov	w8,w0
    17d4:	08 00 78    	mov.w     w8, w0
	call	eemeasure	; occupance of w0 (0...15), output w2 bits #7...#0  (2.3 ms)
    17d6:	48 02 02    	call      0x248 <eemeasure>
    17d8:	00 00 00 
	mov.b	w2,[w5++]
    17da:	82 5a 78    	mov.b     w2, [w5++]
	inc	w8,w8
    17dc:	08 04 e8    	inc.w     w8, w8
	btss	w8,#4
    17de:	08 40 a6    	btss.w    w8, #0x4
	bra	8b
    17e0:	f9 ff 37    	bra       0x17d4 <L83>
	return
    17e2:	00 00 06    	return    

000017e4 <leave_alu_ept>:

; --------------------------------------------------------------------
; --------------------------------------------------------------------
; --------------------------------------------------------------------

leave_alu_ept:
; save ALU variables to ALU Temp
	mov	Opcode,w0
    17e4:	10 49 80    	mov.w     0x922, w0
	mov	w0,AluTempOpcode ; Opcode
    17e6:	90 49 88    	mov.w     w0, 0x932
	mov	OperX,w0
    17e8:	20 49 80    	mov.w     0x924, w0
	mov	w0,AluTempOperX	; OperX
    17ea:	a0 49 88    	mov.w     w0, 0x934
	mov	OperY,w0
    17ec:	30 49 80    	mov.w     0x926, w0
	mov	w0,AluTempOperY	; OperY
    17ee:	b0 49 88    	mov.w     w0, 0x936
	mov	Atemp,w0
    17f0:	40 49 80    	mov.w     0x928, w0
	mov	w0,AluTempAtemp	; Accu temp
    17f2:	c0 49 88    	mov.w     w0, 0x938
	mov	w14,AluTempw14	; Accu out
    17f4:	ee 49 88    	mov.w     w14, 0x93c
	mov	w13,AluTempw13	; Accu in
    17f6:	dd 49 88    	mov.w     w13, 0x93a
; save Alu flags
	mov	Vflag,w0
    17f8:	80 49 80    	mov.w     0x930, w0
	mov	w0,AluTempVflag
    17fa:	f0 49 88    	mov.w     w0, 0x93e
	mov	Zflag,w0
    17fc:	70 49 80    	mov.w     0x92e, w0
	mov	w0,AluTempZflag
    17fe:	00 4a 88    	mov.w     w0, 0x940
	mov	Cflag,w0
    1800:	60 49 80    	mov.w     0x92c, w0
	mov	w0,AluTempCflag
    1802:	10 4a 88    	mov.w     w0, 0x942
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1804:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_ept
    1806:	01 00 37    	bra       0x180a <ss_ept>
	bra	pgm_ept
    1808:	67 08 37    	bra       0x28d8 <pgm_ept>

0000180a <ss_ept>:

ss_ept:
	btss	Flag2,#12
    180a:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    180c:	66 11 02    	call      0x1166 <clr_ram>
    180e:	00 00 00 
	bset	Flag2,#12
    1810:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload SS variables from RUN Temp
	mov	SSTempPage,w0
    1812:	30 4a 80    	mov.w     0x946, w0
	mov.b	WREG,Page	; Page
    1814:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	SSTempStack,w0
    1816:	40 4a 80    	mov.w     0x948, w0
	mov	w0,Stack	; Stack
    1818:	50 49 88    	mov.w     w0, 0x92a
	mov	SSTempPMAddr,w9	; PC
    181a:	29 4a 80    	mov.w     0x944, w9
	mov	SSTempw14,w14
    181c:	9e 4a 80    	mov.w     0x952, w14
	mov	SSTempw13,w13
    181e:	8d 4a 80    	mov.w     0x950, w13
; restore SS flags
	mov	SSTempVflag,w0
    1820:	50 4a 80    	mov.w     0x94a, w0
	mov	w0,Vflag
    1822:	80 49 88    	mov.w     w0, 0x930
	mov	SSTempZflag,w0
    1824:	60 4a 80    	mov.w     0x94c, w0
	mov	w0,Zflag
    1826:	70 49 88    	mov.w     w0, 0x92e
	mov	SSTempCflag,w0
    1828:	70 4a 80    	mov.w     0x94e, w0
	mov	w0,Cflag
    182a:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    182c:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    182e:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    1830:	af 89 a8    	bset.b    0x9af, #0x4
; SS initialize
	mov	#1,w0		; 1 = SS
    1832:	10 00 20    	mov.w     #0x1, w0
	mov	w0,Mode		; Mode
    1834:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    1836:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    1838:	54 20 ef    	clr.w     0x54
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    183a:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    183c:	df 69 a8    	bset.b    0x9df, #0x3
	mov	SSTempPMAddr,w9 ; const
    183e:	29 4a 80    	mov.w     0x944, w9
	mov	#Ram,w10	; const
    1840:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    1842:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    1844:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    1846:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b011111100,w0	; autorpt allow flag: #0-4=keys1-5, #5=keys6-9,
    1848:	c0 0f 20    	mov.w     #0xfc, w0
	mov	w0,AutorptFlag	; #6=keys10-13, #7=keys14-17, #8=key18
    184a:	60 4d 88    	mov.w     w0, 0x9ac
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    184c:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    184e:	00 07 eb    	clr.w     w14
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1850:	de a9 a9    	bclr.b    0x9de, #0x5
; prepare A16 (set SS and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    1852:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    1854:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000010000001000,w0	; set SS and -CLK
    1856:	80 40 20    	mov.w     #0x408, w0
	ior	A16
    1858:	ae 29 b7    	ior.w     0x9ae
;	
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    185a:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    185c:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    185e:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    1860:	9b 83 a8    	bset.b    0x39b, #0x4
	bclr	Flag,#9		; possible write to SFR area
    1862:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10	; possible read from SFR area
    1864:	dd 49 a9    	bclr.b    0x9dd, #0x2

00001866 <ss_farm>:
; ------------------------------
ss_farm:
	bclr	Flag,#5		; #5 set: in HISTORY mode
    1866:	dc a9 a9    	bclr.b    0x9dc, #0x5
	bclr	BlinkFlag,#3	; #3 set: LED SS blinks
    1868:	e0 69 a9    	bclr.b    0x9e0, #0x3
	call	read12
    186a:	fc 29 02    	call      0x29fc <read12>
    186c:	00 00 00 
; check if Stack Error occured
	btss	Flag2,#5	; #5 Fatal Stack Error
    186e:	de a9 ae    	btss.b    0x9de, #0x5
	bra	no_SS_StackErr
    1870:	09 00 37    	bra       0x1884 <no_SS_StackErr> <ss_noread>
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    1872:	e0 c9 a8    	bset.b    0x9e0, #0x6

00001874 <L112>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    1874:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    1876:	02 00 37    	bra       0x187c <L27>
	btss	Flag,#1		; #1 handshaking flag for buttons
    1878:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    187a:	fc ff 37    	bra       0x1874 <L112>

0000187c <L27>:
2:
	bclr	Flag,#1
    187c:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    187e:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    1880:	2a 29 ef    	clr.w     0x92a
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1882:	de a9 a9    	bclr.b    0x9de, #0x5

00001884 <no_SS_StackErr>:
;	call	clr_ram
no_SS_StackErr:
ss_noread:
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    1884:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    1886:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    1888:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    188a:	7a e6 b7    	mov.b     WREG, 0x67a

	bclr	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    188c:	dc 89 a9    	bclr.b    0x9dc, #0x4
	mov	OperX,w11	; w11 = OperX
    188e:	2b 49 80    	mov.w     0x924, w11
	mov	OperY,w12	; w12 = OperY
    1890:	3c 49 80    	mov.w     0x926, w12
	mov	Opcode,w0	; w0 = Opcode
    1892:	10 49 80    	mov.w     0x922, w0
	and	#0x0F,w0
    1894:	f0 00 b2    	and.w     #0xf, w0
	bra	z,group8runb	; ---------> 8-bit opcode
    1896:	32 00 32    	bra       Z, 0x18fc <group8runb>
; w0 = instruction
	mul.uu	w0,#3,w0
    1898:	63 00 b8    	mul.uu    w0, #0x3, w0
	bra	w0
    189a:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0		; non-existing instruction
	callSS	ind_4_1		; ADD  RX,RY
    18a2:	96 1e 02    	call      0x1e96 <ind_4_1>
    18a4:	00 00 00 
    18a6:	5c 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_2		; ADC  RX,RY
    18a8:	fe 1e 02    	call      0x1efe <ind_4_2>
    18aa:	00 00 00 
    18ac:	59 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_3		; SUB  RX,RY
    18ae:	5c 1f 02    	call      0x1f5c <ind_4_3>
    18b0:	00 00 00 
    18b2:	56 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_4		; SBB  RX,RY
    18b4:	b2 1f 02    	call      0x1fb2 <ind_4_4>
    18b6:	00 00 00 
    18b8:	53 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_5		; OR   RX,RY
    18ba:	16 20 02    	call      0x2016 <ind_4_5>
    18bc:	00 00 00 
    18be:	50 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_6		; AND  RX,RY
    18c0:	52 20 02    	call      0x2052 <ind_4_6>
    18c2:	00 00 00 
    18c4:	4d 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_7		; XOR  RX,RY
    18c6:	84 20 02    	call      0x2084 <ind_4_7>
    18c8:	00 00 00 
    18ca:	4a 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_8		; MOV  RX,RY
    18cc:	b6 20 02    	call      0x20b6 <ind_4_8>
    18ce:	00 00 00 
    18d0:	47 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_9		; MOV  RX,N (TEST PCL)
    18d2:	f0 20 02    	call      0x20f0 <ind_4_9>
    18d4:	00 00 00 
    18d6:	44 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_10	; MOV  [XY],R0
    18d8:	24 21 02    	call      0x2124 <ind_4_10>
    18da:	00 00 00 
    18dc:	41 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_11	; MOV  R0,[XY]
    18de:	5a 21 02    	call      0x215a <ind_4_11>
    18e0:	00 00 00 
    18e2:	3e 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_12	; MOV  [NN],R0
    18e4:	92 21 02    	call      0x2192 <ind_4_12>
    18e6:	00 00 00 
    18e8:	3b 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_13	; MOV  R0,[NN]
    18ea:	c4 21 02    	call      0x21c4 <ind_4_13>
    18ec:	00 00 00 
    18ee:	38 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_14	; MOV  PC,NN
    18f0:	f8 21 02    	call      0x21f8 <ind_4_14>
    18f2:	00 00 00 
    18f4:	35 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_4_15	; JR   NN
    18f6:	18 22 02    	call      0x2218 <ind_4_15>
    18f8:	00 00 00 
    18fa:	32 00 37    	bra       0x1960 <L113> <ss_cont>

000018fc <group8runb>:
;...
group8runb:
; w0 = instruction
	mul.uu	w11,#3,w0
    18fc:	63 58 b8    	mul.uu    w11, #0x3, w0
	bra	w0
    18fe:	00 60 01    	bra       w0
;jp table
	callSS	ind_8_0		; CP   R0,N
    1900:	34 22 02    	call      0x2234 <ind_8_0>
    1902:	00 00 00 
    1904:	2d 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_1		; ADD  R0,N
    1906:	80 22 02    	call      0x2280 <ind_8_1>
    1908:	00 00 00 
    190a:	2a 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_2		; INC  RY (TEST PCL)
    190c:	d0 22 02    	call      0x22d0 <ind_8_2>
    190e:	00 00 00 
    1910:	27 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_3		; DEC  RY (TEST PCL)
    1912:	50 23 02    	call      0x2350 <ind_8_3>
    1914:	00 00 00 
    1916:	24 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_4		; DSZ  RY
    1918:	ce 23 02    	call      0x23ce <ind_8_4>
    191a:	00 00 00 
    191c:	21 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_5		; OR   R0,N
    191e:	0a 24 02    	call      0x240a <ind_8_5>
    1920:	00 00 00 
    1922:	1e 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_6		; AND  R0,N
    1924:	54 24 02    	call      0x2454 <ind_8_6>
    1926:	00 00 00 
    1928:	1b 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_7		; XOR  R0,N
    192a:	8e 24 02    	call      0x248e <ind_8_7>
    192c:	00 00 00 
    192e:	18 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_8		; EXR  N
    1930:	d4 24 02    	call      0x24d4 <ind_8_8>
    1932:	00 00 00 
    1934:	15 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_9		; BIT  RG,M
    1936:	0a 25 02    	call      0x250a <ind_8_9>
    1938:	00 00 00 
    193a:	12 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_10	; BSET RG,M
    193c:	4c 25 02    	call      0x254c <ind_8_10>
    193e:	00 00 00 
    1940:	0f 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_11	; BCLR RG,M
    1942:	7c 25 02    	call      0x257c <ind_8_11>
    1944:	00 00 00 
    1946:	0c 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_12	; BTG  RG,M
    1948:	ae 25 02    	call      0x25ae <ind_8_12>
    194a:	00 00 00 
    194c:	09 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_13	; RRC  RY
    194e:	de 25 02    	call      0x25de <ind_8_13>
    1950:	00 00 00 
    1952:	06 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_14	; RET  R0,N
    1954:	20 26 02    	call      0x2620 <ind_8_14>
    1956:	00 00 00 
    1958:	03 00 37    	bra       0x1960 <L113> <ss_cont>
	callSS	ind_8_15	; SKIP F,M
    195a:	4c 26 02    	call      0x264c <ind_8_15>
    195c:	00 00 00 
    195e:	00 00 37    	bra       0x1960 <L113> <ss_cont>

00001960 <L113>:
;..............................................
ss_cont:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    1960:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1962:	fe ff 37    	bra       0x1960 <L113> <ss_cont>
	bclr	Flag,#1
    1964:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1966:	30 4d 80    	mov.w     0x9a6, w0
; test if Rnd has to be invoked
	cp.b	w0,#17		; Data In
    1968:	71 04 e1    	cp.b      w0, #0x11
	bra	nz,9f		; if not key Data In
    196a:	06 00 3a    	bra       NZ, 0x1978 <L93>
	mov	Page,w0
    196c:	80 47 80    	mov.w     0x8f0, w0
	cp.b	w0,#0x0F
    196e:	6f 04 e1    	cp.b      w0, #0xf
	ifz			; if Page=15
    1970:	42 20 af    	btsc.b    0x42, #0x1
	call	new_rnd
    1972:	48 28 02    	call      0x2848 <new_rnd>
    1974:	00 00 00 
	mov	Just,w0
    1976:	30 4d 80    	mov.w     0x9a6, w0

00001978 <L93>:
9:
; continue
	cp	w0,#5
    1978:	65 00 e1    	cp.w      w0, #0x5
	ifc
    197a:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    197c:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    197e:	00 60 01    	bra       w0
; ...
	bra	leave_ss_ept		; mode ++
    1980:	47 00 37    	bra       0x1a10 <leave_ss_ept>
	bra	button_ss_history	; ss_history
    1982:	04 00 37    	bra       0x198c <button_ss_history>
	bra	button_ss_addr_minus	; ss_addr_minus
    1984:	0c 00 37    	bra       0x199e <button_ss_addr_minus>
	bra	button_ss_addr_plus	; ss_addr_plus
    1986:	11 00 37    	bra       0x19aa <button_ss_addr_plus>
	bra	button_ss_step		; ss_step
    1988:	2b 00 37    	bra       0x19e0 <button_ss_step>
	bra	button_ss_key5plus
    198a:	06 00 37    	bra       0x1998 <button_ss_key5plus>

0000198c <button_ss_history>:
;				
button_ss_history:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    198c:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	ss_history		; ss_history ------>
    198e:	4c 0d 37    	bra       0x3428 <ss_history>
	btg	A16,#b_carry
    1990:	af 89 aa    	btg.b     0x9af, #0x4
	call	read12
    1992:	fc 29 02    	call      0x29fc <read12>
    1994:	00 00 00 
	bra	ss_noread
    1996:	76 ff 37    	bra       0x1884 <no_SS_StackErr> <ss_noread>

00001998 <button_ss_key5plus>:
;				
button_ss_key5plus:
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    1998:	c4 14 02    	call      0x14c4 <general_key_3O>
    199a:	00 00 00 
	bra	ss_noread
    199c:	73 ff 37    	bra       0x1884 <no_SS_StackErr> <ss_noread>

0000199e <button_ss_addr_minus>:
; --------------------------------------------------
button_ss_addr_minus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    199e:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adr000_ss	; if alt-ADR minus pressed
    19a0:	0a 00 37    	bra       0x19b6 <adr000_ss>
	dec2	w9,w9		; decrement address
    19a2:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    19a4:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    19a6:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	ss_farm
    19a8:	5e ff 37    	bra       0x1866 <ss_farm>

000019aa <button_ss_addr_plus>:
; -----------
button_ss_addr_plus:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    19aa:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	adrFFF_ss	; if alt-ADR plus pressed
    19ac:	0c 00 37    	bra       0x19c6 <adrFFF_ss>

000019ae <ss_adr_plus>:
ss_adr_plus:
	inc2	w9,w9		; increment address
    19ae:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    19b0:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    19b2:	09 00 22    	mov.w     #0x2000, w9
	bra	ss_farm
    19b4:	58 ff 37    	bra       0x1866 <ss_farm>

000019b6 <adr000_ss>:
;		
adr000_ss:
	clr	Stack
    19b6:	2a 29 ef    	clr.w     0x92a
	clr.b	Page
    19b8:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    19ba:	09 00 22    	mov.w     #0x2000, w9
	call	clr_ram
    19bc:	66 11 02    	call      0x1166 <clr_ram>
    19be:	00 00 00 
	call	read12
    19c0:	fc 29 02    	call      0x29fc <read12>
    19c2:	00 00 00 
	bra	ss_noread
    19c4:	5f ff 37    	bra       0x1884 <no_SS_StackErr> <ss_noread>

000019c6 <adrFFF_ss>:
;		
adrFFF_ss:
	call	find_last
    19c6:	d0 19 02    	call      0x19d0 <find_last>
    19c8:	00 00 00 
	call	read12
    19ca:	fc 29 02    	call      0x29fc <read12>
    19cc:	00 00 00 
	bra	ss_noread
    19ce:	5a ff 37    	bra       0x1884 <no_SS_StackErr> <ss_noread>

000019d0 <find_last>:
;		
find_last:
	mov	#Rom+0x2000,w9	; pointer on top of pgm mem
    19d0:	09 00 24    	mov.w     #0x4000, w9
	mov	#0x1000,w1	; loop count
    19d2:	01 00 21    	mov.w     #0x1000, w1

000019d4 <L114>:
1:
	cp0	[--w9]
    19d4:	49 00 e0    	cp0.w     [--w9]
	ifnz
    19d6:	42 20 ae    	btss.b    0x42, #0x1
	return
    19d8:	00 00 06    	return    
	dec	w1,w1
    19da:	81 00 e9    	dec.w     w1, w1
	bra	nz,1b
    19dc:	fb ff 3a    	bra       NZ, 0x19d4 <L114>
	return
    19de:	00 00 06    	return    

000019e0 <button_ss_step>:

; ------------------------------------------------
button_ss_step:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    19e0:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	final_ss_step	; if not ALT, then simple ss_step
    19e2:	09 00 37    	bra       0x19f6 <final_ss_step>
; address set from Opc/OperX/OperY
	mov	Opcode,w0
    19e4:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    19e6:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    19e8:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    19ea:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    19ec:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    19ee:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    19f0:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    19f2:	81 04 40    	add.w     w0, w1, w9
	bra	ss_farm
    19f4:	38 ff 37    	bra       0x1866 <ss_farm>

000019f6 <final_ss_step>:
;		
final_ss_step:
	call	insert		; shift buffer up, pack and insert new 32 by (used 28, spare 4)
    19f6:	84 34 02    	call      0x3484 <insert>
    19f8:	00 00 00 
; w6 = flags to affect
	bset	A16,#b_clk_key	; set CLK key
    19fa:	ae 49 a8    	bset.b    0x9ae, #0x2
	call	transfer1	; uses w6 bits to decide flag transfer
    19fc:	40 15 02    	call      0x1540 <transfer1>
    19fe:	00 00 00 

00001a00 <L28>:
2:				; wait for key STEP released
	inc	KeyRotors+8,WREG
    1a00:	86 09 ec    	inc.w     0x986, WREG
	bra	nz,2b		; if not yet 0x1111111111111111
    1a02:	fe ff 3a    	bra       NZ, 0x1a00 <L28>
	bclr	A16,#b_clk_key
    1a04:	ae 49 a9    	bclr.b    0x9ae, #0x2
	call	transfer2	; uses w6 bits to decide flag transfer
    1a06:	24 16 02    	call      0x1624 <transfer2>
    1a08:	00 00 00 
	call	ins_part_2	; INSTRUCTION PART 2
    1a0a:	bc 1d 02    	call      0x1dbc <ins_part_2>
    1a0c:	00 00 00 
	bra	ss_farm		; LOOP -------------------------------------->
    1a0e:	2b ff 37    	bra       0x1866 <ss_farm>

00001a10 <leave_ss_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_ss_ept:
	clr	BlinkFlag
    1a10:	e0 29 ef    	clr.w     0x9e0
	clr	TBLPAG
    1a12:	54 20 ef    	clr.w     0x54
; save SS variables to SS Temp
	mov.b	Page,WREG
    1a14:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,SSTempPage	; Page
    1a16:	46 e9 b7    	mov.b     WREG, 0x946
	mov	Stack,w0
    1a18:	50 49 80    	mov.w     0x92a, w0
	mov	w0,SSTempStack	; Stack
    1a1a:	40 4a 88    	mov.w     w0, 0x948
	mov	w9,SSTempPMAddr	; PC
    1a1c:	29 4a 88    	mov.w     w9, 0x944
	mov	w14,SSTempw14
    1a1e:	9e 4a 88    	mov.w     w14, 0x952
	mov	w13,SSTempw13
    1a20:	8d 4a 88    	mov.w     w13, 0x950
; save SS flags
	mov	Vflag,w0
    1a22:	80 49 80    	mov.w     0x930, w0
	mov	w0,SSTempVflag
    1a24:	50 4a 88    	mov.w     w0, 0x94a
	mov	Zflag,w0
    1a26:	70 49 80    	mov.w     0x92e, w0
	mov	w0,SSTempZflag
    1a28:	60 4a 88    	mov.w     w0, 0x94c
	mov	Cflag,w0
    1a2a:	60 49 80    	mov.w     0x92c, w0
	mov	w0,SSTempCflag
    1a2c:	70 4a 88    	mov.w     w0, 0x94e
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    1a2e:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	run_ept
    1a30:	01 00 37    	bra       0x1a34 <run_ept>
	bra	alu_ept
    1a32:	a2 fb 37    	bra       0x1178 <alu_ept>

00001a34 <run_ept>:
; #2 set: Transfer Zero flag after this instruction
; #3 set: Transfer Overflow flag after this instruction

run_ept:
	btss	Flag2,#12
    1a34:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    1a36:	66 11 02    	call      0x1166 <clr_ram>
    1a38:	00 00 00 
	bset	Flag2,#12
    1a3a:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload RUN variables from RUN Temp
	mov	RunTempPMAddr,w9 ; PC
    1a3c:	a9 4a 80    	mov.w     0x954, w9
	mov	RunTempStack,w0
    1a3e:	b0 4a 80    	mov.w     0x956, w0
	mov	w0,Stack
    1a40:	50 49 88    	mov.w     w0, 0x92a
	mov	RunTempPage,w0
    1a42:	c0 4a 80    	mov.w     0x958, w0
	mov.b	WREG,Page	; restore Page
    1a44:	f0 e8 b7    	mov.b     WREG, 0x8f0
	mov	RunTempw14,w14
    1a46:	1e 4b 80    	mov.w     0x962, w14
	mov	RunTempw13,w13
    1a48:	0d 4b 80    	mov.w     0x960, w13
; restore RUN flags
	mov	RunTempVflag,w0
    1a4a:	d0 4a 80    	mov.w     0x95a, w0
	mov	w0,Vflag
    1a4c:	80 49 88    	mov.w     w0, 0x930
	mov	RunTempZflag,w0
    1a4e:	e0 4a 80    	mov.w     0x95c, w0
	mov	w0,Zflag
    1a50:	70 49 88    	mov.w     w0, 0x92e
	mov	RunTempCflag,w0
    1a52:	f0 4a 80    	mov.w     0x95e, w0
	mov	w0,Cflag
    1a54:	60 49 88    	mov.w     w0, 0x92c
	bclr	A16,#b_carry
    1a56:	af 89 a9    	bclr.b    0x9af, #0x4
	btsc	Cflag,#2
    1a58:	2c 49 af    	btsc.b    0x92c, #0x2
	bset	A16,#b_carry
    1a5a:	af 89 a8    	bset.b    0x9af, #0x4
; RUN initialize
	mov	#2,w0		; 2 = RUN
    1a5c:	20 00 20    	mov.w     #0x2, w0
	mov	w0,Mode
    1a5e:	b0 4b 88    	mov.w     w0, 0x976
	mov	#0,w0		; default speed 0 (max)
    1a60:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    1a62:	98 26 02    	call      0x2698 <set_T2_from_w0>
    1a64:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    1a66:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    1a68:	ca 26 02    	call      0x26ca <set_T3_from_w0>
    1a6a:	00 00 00 
	mov	#Ram,w10	; const
    1a6c:	0a 80 20    	mov.w     #0x800, w10
	mov	#Ram+0x0B,w8	; const
    1a6e:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    1a70:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; const
    1a72:	b8 8f 20    	mov.w     #0x8fb, w8
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    1a74:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    1a76:	60 4d 88    	mov.w     w0, 0x9ac
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    1a78:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#5		; #5 set in HISTORY mode
    1a7a:	dc a9 a9    	bclr.b    0x9dc, #0x5
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    1a7c:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    1a7e:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    1a80:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    1a82:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000001000001000,w0	; set RUN and -CLK
    1a84:	80 20 20    	mov.w     #0x208, w0
	ior	A16
    1a86:	ae 29 b7    	ior.w     0x9ae

	bclr	Flag,#9
    1a88:	dd 29 a9    	bclr.b    0x9dd, #0x1
	bclr	Flag,#10
    1a8a:	dd 49 a9    	bclr.b    0x9dd, #0x2

00001a8c <run_wait_key>:
run_wait_key:		; outside pgm execution
	bclr	Flag2,#1	; #1 program Runs 
    1a8c:	de 29 a9    	bclr.b    0x9de, #0x1
	bclr	A16,#b_clk_key	; LED RUN off
    1a8e:	ae 49 a9    	bclr.b    0x9ae, #0x2

00001a90 <L115>:
1:
	bclr	Flag,#3		; #3 set = no RAM matrix display
    1a90:	dc 69 a9    	bclr.b    0x9dc, #0x3
	btss	Flag,#1		; #1 handshaking flag for buttons
    1a92:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1a94:	fd ff 37    	bra       0x1a90 <L115>
	bclr	Flag,#1
    1a96:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1a98:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1a9a:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1a9c:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1a9e:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1aa0:	00 60 01    	bra       w0
; ...
	bra	leave_run_ept	; mode ++
    1aa2:	0a 07 37    	bra       0x28b8 <leave_run_ept>
	bra	run_wait_key	; run_fast
    1aa4:	f3 ff 37    	bra       0x1a8c <run_wait_key>
	bra	run_wait_key	; run_pause
    1aa6:	f2 ff 37    	bra       0x1a8c <run_wait_key>
	bra	run_wait_key	; run_break
    1aa8:	f1 ff 37    	bra       0x1a8c <run_wait_key>
	bra	run_run
    1aaa:	08 00 37    	bra       0x1abc <run_run>
	bra	run_keys_5
    1aac:	00 00 37    	bra       0x1aae <run_keys_5>

00001aae <run_keys_5>:
;				
run_keys_5:
; 13 buttons OPCODE 8... DATA IN
	call	limited_key_3	; can't affect pgm data, only Sync Clock Page
    1aae:	bc 14 02    	call      0x14bc <limited_key_3>
    1ab0:	00 00 00 
	call	set_T2_from_Speed
    1ab2:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    1ab4:	00 00 00 
	call	set_T3_from_Sync
    1ab6:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    1ab8:	00 00 00 
	bra	run_wait_key
    1aba:	e8 ff 37    	bra       0x1a8c <run_wait_key>

00001abc <run_run>:

; ------------------------------------------------
run_run:
	bclr	U1MODE,#15	; disable UART 1 to clear queue and error flags
    1abc:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	U1MODE,#15	; enable UART 1
    1abe:	99 e3 a8    	bset.b    0x399, #0x7
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    1ac0:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    1ac2:	9b 83 a8    	bset.b    0x39b, #0x4

	bclr	BlinkFlag,#2	; 2 set = LED Run blinks
    1ac4:	e0 49 a9    	bclr.b    0x9e0, #0x2
	mov	#RX_buf,w0
    1ac6:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    1ac8:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    1aca:	f0 4d 88    	mov.w     w0, 0x9be
	bset	Flag2,#1	; #1 program Runs 
    1acc:	de 29 a8    	bset.b    0x9de, #0x1
	mov	#0b000000000,w0	; no autorpt in runtime
    1ace:	00 00 20    	mov.w     #0x0, w0
	mov	w0,AutorptFlag
    1ad0:	60 4d 88    	mov.w     w0, 0x9ac
	bset	A16,#b_clk_key	 ; LED RUN on
    1ad2:	ae 49 a8    	bset.b    0x9ae, #0x2
	bclr	A16,#b_carry
    1ad4:	af 89 a9    	bclr.b    0x9af, #0x4
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1ad6:	de a9 a9    	bclr.b    0x9de, #0x5
	mov	#Rom,w9
    1ad8:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1ada:	fc 29 02    	call      0x29fc <read12>
    1adc:	00 00 00 
	call	clr_ram
    1ade:	66 11 02    	call      0x1166 <clr_ram>
    1ae0:	00 00 00 
	clr	Stack
    1ae2:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    1ae4:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    1ae6:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    1ae8:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1aea:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1aec:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1aee:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1af0:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1af2:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1af4:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1af6:	88 28 02    	call      0x2888 <rxtx_to_rxtxpos>
    1af8:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1afa:	54 28 02    	call      0x2854 <set_U1BRG>
    1afc:	00 00 00 
	call	read12		; READ 12
    1afe:	fc 29 02    	call      0x29fc <read12>
    1b00:	00 00 00 

00001b02 <run_farm>:
run_farm:
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    1b02:	0a c8 bf    	mov.b     0x80a, WREG
	btsc.b	WrFlags,#1	; I/O port select
    1b04:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    1b06:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    1b08:	7a e6 b7    	mov.b     WREG, 0x67a
; check if Stack Error occured
	btsc	Flag2,#5	; #5 Fatal Stack Error
    1b0a:	de a9 af    	btsc.b    0x9de, #0x5
	bra	Run_StackErr
    1b0c:	18 01 37    	bra       0x1d3e <Run_StackErr>
; check if runtime key pressed
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1b0e:	dc 89 a9    	bclr.b    0x9dc, #0x4
	btsc	Flag,#1		; #1 handshaking flag for buttons
    1b10:	dc 29 af    	btsc.b    0x9dc, #0x1
	bra	runtime_key_0	; key pressed during pgm execution
    1b12:	d0 00 37    	bra       0x1cb4 <runtime_key_0>

00001b14 <runtime_back_0>:
runtime_back_0:
	bclr	Flag2,#11	; #11 = previous Flag,#2
    1b14:	df 69 a9    	bclr.b    0x9df, #0x3
	btsc	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    1b16:	dc 49 af    	btsc.b    0x9dc, #0x2
	bset	Flag2,#11	; #11 = previous Flag,#2
    1b18:	df 69 a8    	bset.b    0x9df, #0x3
; [PC] ---> w12,OperY, w11,OperX, w0,Opcode
	mov	[w9],w0		; read instruction
    1b1a:	19 00 78    	mov.w     [w9], w0
	and	w0,#0x0F,w12
    1b1c:	6f 06 60    	and.w     w0, #0xf, w12
	mov	w12,OperY	; w12 = OperY
    1b1e:	3c 49 88    	mov.w     w12, 0x926
	lsr	w0,#4,w11
    1b20:	c4 05 de    	lsr.w     w0, #0x4, w11
	and	w11,#0x0F,w11
    1b22:	ef 85 65    	and.w     w11, #0xf, w11
	mov	w11,OperX	; w11 = OperX
    1b24:	2b 49 88    	mov.w     w11, 0x924
	lsr	w0,#8,w0
    1b26:	48 00 de    	lsr.w     w0, #0x8, w0
	mov	w0,Opcode	; w0 = Opcode
    1b28:	10 49 88    	mov.w     w0, 0x922
	bra	z,group8run	; ---------> 8-bit opcode
    1b2a:	62 00 32    	bra       Z, 0x1bf0 <group8run>
; table jump, w0 = instruction
	mul.uu	w0,#6,w0
    1b2c:	66 00 b8    	mul.uu    w0, #0x6, w0
	bra	w0		; execution step 1 (4-bit opcode)
    1b2e:	00 60 01    	bra       w0
	...
;jp table
	.word	0,0,0,0,0,0	; non-existing instruction
	callRUN	ind_4_1		; ADD  RX,RY
    1b3c:	96 1e 02    	call      0x1e96 <ind_4_1>
    1b3e:	00 00 00 
    1b40:	df 69 af    	btsc.b    0x9df, #0x3
    1b42:	9c 1d 02    	call      0x1d9c <run_cont>
    1b44:	00 00 00 
    1b46:	dd ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_2		; ADC  RX,RY
    1b48:	fe 1e 02    	call      0x1efe <ind_4_2>
    1b4a:	00 00 00 
    1b4c:	df 69 af    	btsc.b    0x9df, #0x3
    1b4e:	9c 1d 02    	call      0x1d9c <run_cont>
    1b50:	00 00 00 
    1b52:	d7 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_3		; SUB  RX,RY
    1b54:	5c 1f 02    	call      0x1f5c <ind_4_3>
    1b56:	00 00 00 
    1b58:	df 69 af    	btsc.b    0x9df, #0x3
    1b5a:	9c 1d 02    	call      0x1d9c <run_cont>
    1b5c:	00 00 00 
    1b5e:	d1 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_4		; SBB  RX,RY
    1b60:	b2 1f 02    	call      0x1fb2 <ind_4_4>
    1b62:	00 00 00 
    1b64:	df 69 af    	btsc.b    0x9df, #0x3
    1b66:	9c 1d 02    	call      0x1d9c <run_cont>
    1b68:	00 00 00 
    1b6a:	cb ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_5		; OR   RX,RY
    1b6c:	16 20 02    	call      0x2016 <ind_4_5>
    1b6e:	00 00 00 
    1b70:	df 69 af    	btsc.b    0x9df, #0x3
    1b72:	9c 1d 02    	call      0x1d9c <run_cont>
    1b74:	00 00 00 
    1b76:	c5 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_6		; AND  RX,RY
    1b78:	52 20 02    	call      0x2052 <ind_4_6>
    1b7a:	00 00 00 
    1b7c:	df 69 af    	btsc.b    0x9df, #0x3
    1b7e:	9c 1d 02    	call      0x1d9c <run_cont>
    1b80:	00 00 00 
    1b82:	bf ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_7		; XOR  RX,RY
    1b84:	84 20 02    	call      0x2084 <ind_4_7>
    1b86:	00 00 00 
    1b88:	df 69 af    	btsc.b    0x9df, #0x3
    1b8a:	9c 1d 02    	call      0x1d9c <run_cont>
    1b8c:	00 00 00 
    1b8e:	b9 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_8		; MOV  RX,RY (TEST PCL)
    1b90:	b6 20 02    	call      0x20b6 <ind_4_8>
    1b92:	00 00 00 
    1b94:	df 69 af    	btsc.b    0x9df, #0x3
    1b96:	9c 1d 02    	call      0x1d9c <run_cont>
    1b98:	00 00 00 
    1b9a:	b3 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_9		; MOV  RX,N (TEST PCL)
    1b9c:	f0 20 02    	call      0x20f0 <ind_4_9>
    1b9e:	00 00 00 
    1ba0:	df 69 af    	btsc.b    0x9df, #0x3
    1ba2:	9c 1d 02    	call      0x1d9c <run_cont>
    1ba4:	00 00 00 
    1ba6:	ad ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_10	; MOV  [XY],R0
    1ba8:	24 21 02    	call      0x2124 <ind_4_10>
    1baa:	00 00 00 
    1bac:	df 69 af    	btsc.b    0x9df, #0x3
    1bae:	9c 1d 02    	call      0x1d9c <run_cont>
    1bb0:	00 00 00 
    1bb2:	a7 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_11	; MOV  R0,[XY]
    1bb4:	5a 21 02    	call      0x215a <ind_4_11>
    1bb6:	00 00 00 
    1bb8:	df 69 af    	btsc.b    0x9df, #0x3
    1bba:	9c 1d 02    	call      0x1d9c <run_cont>
    1bbc:	00 00 00 
    1bbe:	a1 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_12	; MOV  [NN],R0
    1bc0:	92 21 02    	call      0x2192 <ind_4_12>
    1bc2:	00 00 00 
    1bc4:	df 69 af    	btsc.b    0x9df, #0x3
    1bc6:	9c 1d 02    	call      0x1d9c <run_cont>
    1bc8:	00 00 00 
    1bca:	9b ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_13	; MOV  R0,[NN]
    1bcc:	c4 21 02    	call      0x21c4 <ind_4_13>
    1bce:	00 00 00 
    1bd0:	df 69 af    	btsc.b    0x9df, #0x3
    1bd2:	9c 1d 02    	call      0x1d9c <run_cont>
    1bd4:	00 00 00 
    1bd6:	95 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_14	; MOV  PC,NN
    1bd8:	f8 21 02    	call      0x21f8 <ind_4_14>
    1bda:	00 00 00 
    1bdc:	df 69 af    	btsc.b    0x9df, #0x3
    1bde:	9c 1d 02    	call      0x1d9c <run_cont>
    1be0:	00 00 00 
    1be2:	8f ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_4_15	; JR   NN
    1be4:	18 22 02    	call      0x2218 <ind_4_15>
    1be6:	00 00 00 
    1be8:	df 69 af    	btsc.b    0x9df, #0x3
    1bea:	9c 1d 02    	call      0x1d9c <run_cont>
    1bec:	00 00 00 
    1bee:	89 ff 37    	bra       0x1b02 <run_farm>

00001bf0 <group8run>:
;...
group8run:
; table jump, w0 = instruction
	mul.uu	w11,#6,w0
    1bf0:	66 58 b8    	mul.uu    w11, #0x6, w0
	bra	w0		; execution step 1 (8-bit opcode)
    1bf2:	00 60 01    	bra       w0
;jp table
	callRUN	ind_8_0		; CP   R0,N
    1bf4:	34 22 02    	call      0x2234 <ind_8_0>
    1bf6:	00 00 00 
    1bf8:	df 69 af    	btsc.b    0x9df, #0x3
    1bfa:	9c 1d 02    	call      0x1d9c <run_cont>
    1bfc:	00 00 00 
    1bfe:	81 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_1		; ADD  R0,N
    1c00:	80 22 02    	call      0x2280 <ind_8_1>
    1c02:	00 00 00 
    1c04:	df 69 af    	btsc.b    0x9df, #0x3
    1c06:	9c 1d 02    	call      0x1d9c <run_cont>
    1c08:	00 00 00 
    1c0a:	7b ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_2		; INC  RY (TEST PCL)
    1c0c:	d0 22 02    	call      0x22d0 <ind_8_2>
    1c0e:	00 00 00 
    1c10:	df 69 af    	btsc.b    0x9df, #0x3
    1c12:	9c 1d 02    	call      0x1d9c <run_cont>
    1c14:	00 00 00 
    1c16:	75 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_3		; DEC  RY (TEST PCL)
    1c18:	50 23 02    	call      0x2350 <ind_8_3>
    1c1a:	00 00 00 
    1c1c:	df 69 af    	btsc.b    0x9df, #0x3
    1c1e:	9c 1d 02    	call      0x1d9c <run_cont>
    1c20:	00 00 00 
    1c22:	6f ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_4		; DSZ  RY
    1c24:	ce 23 02    	call      0x23ce <ind_8_4>
    1c26:	00 00 00 
    1c28:	df 69 af    	btsc.b    0x9df, #0x3
    1c2a:	9c 1d 02    	call      0x1d9c <run_cont>
    1c2c:	00 00 00 
    1c2e:	69 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_5		; OR   R0,N
    1c30:	0a 24 02    	call      0x240a <ind_8_5>
    1c32:	00 00 00 
    1c34:	df 69 af    	btsc.b    0x9df, #0x3
    1c36:	9c 1d 02    	call      0x1d9c <run_cont>
    1c38:	00 00 00 
    1c3a:	63 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_6		; AND  R0,N
    1c3c:	54 24 02    	call      0x2454 <ind_8_6>
    1c3e:	00 00 00 
    1c40:	df 69 af    	btsc.b    0x9df, #0x3
    1c42:	9c 1d 02    	call      0x1d9c <run_cont>
    1c44:	00 00 00 
    1c46:	5d ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_7		; XOR  R0,N
    1c48:	8e 24 02    	call      0x248e <ind_8_7>
    1c4a:	00 00 00 
    1c4c:	df 69 af    	btsc.b    0x9df, #0x3
    1c4e:	9c 1d 02    	call      0x1d9c <run_cont>
    1c50:	00 00 00 
    1c52:	57 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_8		; EXR  N
    1c54:	d4 24 02    	call      0x24d4 <ind_8_8>
    1c56:	00 00 00 
    1c58:	df 69 af    	btsc.b    0x9df, #0x3
    1c5a:	9c 1d 02    	call      0x1d9c <run_cont>
    1c5c:	00 00 00 
    1c5e:	51 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_9		; BIT  RG,M
    1c60:	0a 25 02    	call      0x250a <ind_8_9>
    1c62:	00 00 00 
    1c64:	df 69 af    	btsc.b    0x9df, #0x3
    1c66:	9c 1d 02    	call      0x1d9c <run_cont>
    1c68:	00 00 00 
    1c6a:	4b ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_10	; BSET RG,M
    1c6c:	4c 25 02    	call      0x254c <ind_8_10>
    1c6e:	00 00 00 
    1c70:	df 69 af    	btsc.b    0x9df, #0x3
    1c72:	9c 1d 02    	call      0x1d9c <run_cont>
    1c74:	00 00 00 
    1c76:	45 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_11	; BCLR RG,M
    1c78:	7c 25 02    	call      0x257c <ind_8_11>
    1c7a:	00 00 00 
    1c7c:	df 69 af    	btsc.b    0x9df, #0x3
    1c7e:	9c 1d 02    	call      0x1d9c <run_cont>
    1c80:	00 00 00 
    1c82:	3f ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_12	; BTG  RG,M
    1c84:	ae 25 02    	call      0x25ae <ind_8_12>
    1c86:	00 00 00 
    1c88:	df 69 af    	btsc.b    0x9df, #0x3
    1c8a:	9c 1d 02    	call      0x1d9c <run_cont>
    1c8c:	00 00 00 
    1c8e:	39 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_13	; RRC  RY
    1c90:	de 25 02    	call      0x25de <ind_8_13>
    1c92:	00 00 00 
    1c94:	df 69 af    	btsc.b    0x9df, #0x3
    1c96:	9c 1d 02    	call      0x1d9c <run_cont>
    1c98:	00 00 00 
    1c9a:	33 ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_14	; RET  R0,N
    1c9c:	20 26 02    	call      0x2620 <ind_8_14>
    1c9e:	00 00 00 
    1ca0:	df 69 af    	btsc.b    0x9df, #0x3
    1ca2:	9c 1d 02    	call      0x1d9c <run_cont>
    1ca4:	00 00 00 
    1ca6:	2d ff 37    	bra       0x1b02 <run_farm>
	callRUN	ind_8_15	; SKIP F,M
    1ca8:	4c 26 02    	call      0x264c <ind_8_15>
    1caa:	00 00 00 
    1cac:	df 69 af    	btsc.b    0x9df, #0x3
    1cae:	9c 1d 02    	call      0x1d9c <run_cont>
    1cb0:	00 00 00 
    1cb2:	27 ff 37    	bra       0x1b02 <run_farm>

00001cb4 <runtime_key_0>:
;...
; #######################################################################################

runtime_key_0:
	mov	#0,w0
    1cb4:	00 00 20    	mov.w     #0x0, w0

00001cb6 <runtime_key>:
runtime_key:			; key pressed during pgm execution (don't trash w5-w15!)
	mov	w0,BackIndex
    1cb6:	a0 4d 88    	mov.w     w0, 0x9b4
	bclr	Flag,#1
    1cb8:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1cba:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1cbc:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1cbe:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1cc0:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1cc2:	00 60 01    	bra       w0
; ...
	bra	runtime_back_X	; runtime mode (just ignore)
    1cc4:	0b 00 37    	bra       0x1cdc <runtime_back_X>
	bra	runtime_fast 	; runtime fast 
    1cc6:	04 00 37    	bra       0x1cd0 <runtime_fast>
	bra	runtime_pause	; runtime pause
    1cc8:	18 00 37    	bra       0x1cfa <runtime_pause>
	bra	runtime_break	; runtime break
    1cca:	41 00 37    	bra       0x1d4e <runtime_break>
	bra	runtime_back_X	; runtime run (just ignore)
    1ccc:	07 00 37    	bra       0x1cdc <runtime_back_X>
	bra	runtime_keys_5
    1cce:	0c 00 37    	bra       0x1ce8 <runtime_keys_5>

00001cd0 <runtime_fast>:
;...............................
runtime_fast:			; runtime FAST
	btg	Flag2,#0	; #0 Run Fast toggler (1=fast)
    1cd0:	de 09 aa    	btg.b     0x9de, #0x0
	btg	BlinkFlag,#2	; 2 set = LED Run blinks
    1cd2:	e0 49 aa    	btg.b     0x9e0, #0x2
	call	set_T2_from_Speed
    1cd4:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    1cd6:	00 00 00 
	call	set_T3_from_Sync
    1cd8:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    1cda:	00 00 00 

00001cdc <runtime_back_X>:
;...
runtime_back_X:		; uses BackIndex to return exactly where it came from
	mov	BackIndex,w0
    1cdc:	a0 4d 80    	mov.w     0x9b4, w0
	cp0	w0
    1cde:	00 00 e0    	cp0.w     w0
	bra	z,runtime_back_0 ; if [BackIndex] = 0
    1ce0:	19 ff 32    	bra       Z, 0x1b14 <runtime_back_0>
	dec	w0,w0
    1ce2:	00 00 e9    	dec.w     w0, w0
	bra	z,runtime_back_1 ; if [BackIndex] = 1
    1ce4:	5e 00 32    	bra       Z, 0x1da2 <runtime_back_1>
	bra	runtime_back_2	 ; if [BackIndex] = 2
    1ce6:	65 00 37    	bra       0x1db2 <runtime_back_2>

00001ce8 <runtime_keys_5>:
;				
runtime_keys_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1ce8:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1cea:	bc 14 02    	call      0x14bc <limited_key_3>
    1cec:	00 00 00 
	call	set_T2_from_Speed
    1cee:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    1cf0:	00 00 00 
	call	set_T3_from_Sync
    1cf2:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    1cf4:	00 00 00 
	pop	w5	; /
    1cf6:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_back_X
    1cf8:	f1 ff 37    	bra       0x1cdc <runtime_back_X>

00001cfa <runtime_pause>:
;-----------------------------------------------
runtime_pause:			; runtime PAUSE
	bclr	Flag2,#1	; #1 program Runs 
    1cfa:	de 29 a9    	bclr.b    0x9de, #0x1
	bset	A16,#b_noclk_sch
    1cfc:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1cfe:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_save
    1d00:	af a9 a8    	bset.b    0x9af, #0x5
	bset	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1d02:	e0 a9 a8    	bset.b    0x9e0, #0x5
	bclr	A16,#b_clk_sch
    1d04:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1d06:	ae 69 a8    	bset.b    0x9ae, #0x3

00001d08 <L116>:
1:
	btss	Flag,#1		; #1 handshaking flag for buttons
    1d08:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1d0a:	fe ff 37    	bra       0x1d08 <L116>
	bclr	Flag,#1
    1d0c:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    1d0e:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    1d10:	65 00 e1    	cp.w      w0, #0x5
	ifc
    1d12:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    1d14:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    1d16:	00 60 01    	bra       w0
; ...
	bra	runtime_pause	; pause mode (just ignore)
    1d18:	f0 ff 37    	bra       0x1cfa <runtime_pause>
	bra	pause_exit 	; pause fast (exit from pause)
    1d1a:	0d 00 37    	bra       0x1d36 <pause_exit>
	bra	pause_exit	; pause pause (exit from pause)
    1d1c:	0c 00 37    	bra       0x1d36 <pause_exit>
	bra	runtime_break	; pause break (break pgm execution)
    1d1e:	17 00 37    	bra       0x1d4e <runtime_break>
	bra	pause_exit	; pause run (exit from pause)
    1d20:	0a 00 37    	bra       0x1d36 <pause_exit>
	bra	general_pause_5	; keys 6...18
    1d22:	00 00 37    	bra       0x1d24 <general_pause_5>

00001d24 <general_pause_5>:
;................................
general_pause_5:
; 13 buttons OPCODE 8... DATA IN
	push	w5	; \
    1d24:	85 1f 78    	mov.w     w5, [w15++]
	call	limited_key_3	; can't affect pgm data, only Dim Clock Page
    1d26:	bc 14 02    	call      0x14bc <limited_key_3>
    1d28:	00 00 00 
	call	set_T2_from_Speed
    1d2a:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    1d2c:	00 00 00 
	call	set_T3_from_Sync
    1d2e:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    1d30:	00 00 00 
	pop	w5	; /
    1d32:	cf 02 78    	mov.w     [--w15], w5
	bra	runtime_pause
    1d34:	e2 ff 37    	bra       0x1cfa <runtime_pause>

00001d36 <pause_exit>:
; ------------------------------
pause_exit:
	bset	Flag2,#1	; #1 program Runs 
    1d36:	de 29 a8    	bset.b    0x9de, #0x1
	bclr	A16,#b_save
    1d38:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1d3a:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	bra	runtime_back_X	; continue execution
    1d3c:	cf ff 37    	bra       0x1cdc <runtime_back_X>

00001d3e <Run_StackErr>:
;------------------------------------------------
Run_StackErr:		; Stack Error occured
	bset	BlinkFlag,#6	; 6 set = Stack blinks
    1d3e:	e0 c9 a8    	bset.b    0x9e0, #0x6

00001d40 <L117>:
1:
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    1d40:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  2f
    1d42:	02 00 37    	bra       0x1d48 <L29>
	btss	Flag,#1		; #1 handshaking flag for buttons
    1d44:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	1b
    1d46:	fc ff 37    	bra       0x1d40 <L117>

00001d48 <L29>:
2:
	bclr	Flag,#1
    1d48:	dc 29 a9    	bclr.b    0x9dc, #0x1
	bclr	BlinkFlag,#6	; 6 set = Stack blinks
    1d4a:	e0 c9 a9    	bclr.b    0x9e0, #0x6
	clr	Stack
    1d4c:	2a 29 ef    	clr.w     0x92a

00001d4e <runtime_break>:
runtime_break:			; runtime BREAK
	bclr	Flag2,#5	; #5 Fatal Stack Error
    1d4e:	de a9 a9    	bclr.b    0x9de, #0x5
	bclr	A16,#b_clk_sch
    1d50:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bset	A16,#b_noclk_sch
    1d52:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_key
    1d54:	ae 49 a9    	bclr.b    0x9ae, #0x2
	bset	A16,#b_noclk_sch
    1d56:	ae 69 a8    	bset.b    0x9ae, #0x3
	bclr	A16,#b_clk_sch
    1d58:	ae 09 a9    	bclr.b    0x9ae, #0x0
	bclr	A16,#b_save
    1d5a:	af a9 a9    	bclr.b    0x9af, #0x5
	bclr	BlinkFlag,#5	; 5 set = LED Save (Pause) blinks
    1d5c:	e0 a9 a9    	bclr.b    0x9e0, #0x5
	mov	#0b001110000,w0	; autorpt Opcode, OperX, OperY
    1d5e:	00 07 20    	mov.w     #0x70, w0
	mov	w0,AutorptFlag
    1d60:	60 4d 88    	mov.w     w0, 0x9ac
; clear SFR and spec registers
	bclr	A16,#b_carry
    1d62:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#Rom,w9
    1d64:	09 00 22    	mov.w     #0x2000, w9
	call	read12
    1d66:	fc 29 02    	call      0x29fc <read12>
    1d68:	00 00 00 
;	call	clr_ram
;	clr	Stack
;	clr.b	Page		; default page 0
;	clr.b	Speed		; default Clock max
;	clr.b	Sync		; default Sync max
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    1d6a:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    1d6c:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    1d6e:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    1d70:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    1d72:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    1d74:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    1d76:	88 28 02    	call      0x2888 <rxtx_to_rxtxpos>
    1d78:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    1d7a:	54 28 02    	call      0x2854 <set_U1BRG>
    1d7c:	00 00 00 
; clear Fast parameters
	  bclr	  BlinkFlag,#2		; 2 set = LED Run blinks
    1d7e:	e0 49 a9    	bclr.b    0x9e0, #0x2
	  btss	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1d80:	de 09 ae    	btss.b    0x9de, #0x0
	  bra	  not_running_fast
    1d82:	05 00 37    	bra       0x1d8e <not_running_fast>
	  bclr	  Flag2,#0		; #0 Run Fast toggler (1=fast)
    1d84:	de 09 a9    	bclr.b    0x9de, #0x0
	  call	  set_T2_from_Speed
    1d86:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    1d88:	00 00 00 
	  call	  set_T3_from_Sync
    1d8a:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    1d8c:	00 00 00 

00001d8e <not_running_fast>:
not_running_fast:
	mov	#0,w0		; default speed 0 (max)
    1d8e:	00 00 20    	mov.w     #0x0, w0
	call	set_T2_from_w0
    1d90:	98 26 02    	call      0x2698 <set_T2_from_w0>
    1d92:	00 00 00 
	mov	#0,w0		; default sync 0 (fastest)
    1d94:	00 00 20    	mov.w     #0x0, w0
	call	set_T3_from_w0
    1d96:	ca 26 02    	call      0x26ca <set_T3_from_w0>
    1d98:	00 00 00 
	bra	run_wait_key
    1d9a:	78 fe 37    	bra       0x1a8c <run_wait_key>

00001d9c <run_cont>:

; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;
; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;

run_cont:			; phases (ONLY IF SPEED>0)
wait_phase_1:
	  mov	  #1,w0
    1d9c:	10 00 20    	mov.w     #0x1, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1d9e:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1da0:	8a ff 37    	bra       0x1cb6 <runtime_key>

00001da2 <runtime_back_1>:
runtime_back_1:
	  btss	  IFS0,#7	; test int flag
    1da2:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_1
    1da4:	fb ff 37    	bra       0x1d9c <run_cont> <wait_phase_1>
	  bclr	  IFS0,#7	; clr int flag
    1da6:	88 e0 a9    	bclr.b    0x88, #0x7
;	
	  call	  transfer1	; uses w6 bits to decide flag transfer
    1da8:	40 15 02    	call      0x1540 <transfer1>
    1daa:	00 00 00 

00001dac <wait_phase_2>:
wait_phase_2:
	  mov	  #2,w0
    1dac:	20 00 20    	mov.w     #0x2, w0
	  btsc	  Flag,#1	; #1 handshaking flag for buttons
    1dae:	dc 29 af    	btsc.b    0x9dc, #0x1
	  bra	  runtime_key	; if key pressed in runtime
    1db0:	82 ff 37    	bra       0x1cb6 <runtime_key>

00001db2 <runtime_back_2>:
runtime_back_2:
	  btss	  IFS0,#7	; test int flag
    1db2:	88 e0 ae    	btss.b    0x88, #0x7
	  bra	  wait_phase_2
    1db4:	fb ff 37    	bra       0x1dac <wait_phase_2>
	  bclr	  IFS0,#7	; clr int flag
    1db6:	88 e0 a9    	bclr.b    0x88, #0x7
	  call	  transfer2	; uses w6 bits to decide flag transfer
    1db8:	24 16 02    	call      0x1624 <transfer2>
    1dba:	00 00 00 

00001dbc <ins_part_2>:
; ------
ins_part_2:			; called from SS mode
	incpc			; increment address     * * * * * * * * * * * * * * * * *
    1dbc:	89 84 e8    	inc2.w    w9, w9
    1dbe:	09 e0 a7    	btsc.w    w9, #0xe
    1dc0:	09 00 22    	mov.w     #0x2000, w9
; check if w7 < 8, if so perform special instruction
	cp	w7,#8		; flag for special instructions (if w7 < 8)
    1dc2:	68 38 e1    	cp.w      w7, #0x8
	bra	nc,spec_ins
    1dc4:	14 00 39    	bra       NC, 0x1dee <spec_ins>
	mov.b	w13,[w7]	;  W R I T E   R E S U L T   T O   D E S T I N A T I O N
    1dc6:	8d 4b 78    	mov.b     w13, [w7]
; check if destination was JSR or PCL, if so, then perform CALL or JUMP
	btss	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1dc8:	dc 89 ae    	btss.b    0x9dc, #0x4
	bra	chk_sfr
    1dca:	0a 00 37    	bra       0x1de0 <chk_sfr>
	bclr	Flag,#4		; #4 set if instruction allows CALL and JP (mov, inc, dec)
    1dcc:	dc 89 a9    	bclr.b    0x9dc, #0x4
; check and perform if there is PCM, PCH 12-bit extension
	  mov	  PcmPch,w0
    1dce:	90 4d 80    	mov.w     0x9b2, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    1dd0:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    1dd2:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    1dd4:	dc e9 a9    	bclr.b    0x9dc, #0x7
	mov	#Ram+12,w0	; Ram+12=JSR
    1dd6:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    1dd8:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    1dda:	3c 00 32    	bra       Z, 0x1e54 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    1ddc:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    1dde:	4e 00 32    	bra       Z, 0x1e7c <run_jump>

00001de0 <chk_sfr>:
; check if source or dest was in SFR area, if so perform perpheral service
chk_sfr:
	  btsc	  Flag,#9		; #9 set if instruction is writing to SFR area
    1de0:	dd 29 af    	btsc.b    0x9dd, #0x1
	  call	  perform_SFR_write
    1de2:	1e 27 02    	call      0x271e <perform_SFR_write>
    1de4:	00 00 00 
	  btsc	  Flag,#10		; #10 set if instruction is reading from SFR area
    1de6:	dd 49 af    	btsc.b    0x9dd, #0x2
	  call	  perform_SFR_read
    1de8:	be 27 02    	call      0x27be <perform_SFR_read>
    1dea:	00 00 00 
	return
    1dec:	00 00 06    	return    

00001dee <spec_ins>:
;------------------------
spec_ins:			; <------ executed both from SS and RUN
	bra	w7
    1dee:	07 60 01    	bra       w7
;...
	bra	spec0	; dummy
    1df0:	07 00 37    	bra       0x1e00 <spec0>
	bra	spec1	; JR   N
    1df2:	07 00 37    	bra       0x1e02 <spec1>
	bra	spec2	; DSZ  RY
    1df4:	0f 00 37    	bra       0x1e14 <spec2>
	bra	spec3	; EXR  N
    1df6:	16 00 37    	bra       0x1e24 <spec3>
	bra	spec4	; RET R0,N
    1df8:	18 00 37    	bra       0x1e2a <spec4>
	bra	spec5	; LPC  NN
    1dfa:	1d 00 37    	bra       0x1e36 <spec5>
	bra	spec6	; SKIP F,M
    1dfc:	22 00 37    	bra       0x1e42 <spec6>
	bra	spec7	; reserved
    1dfe:	23 00 37    	bra       0x1e46 <spec7>

00001e00 <spec0>:
; --------------------
spec0:			; flag 00 = dummy instruction
	return
    1e00:	00 00 06    	return    

00001e02 <spec1>:
;		
spec1:			; flag 01 = special instruction: JR NN
	btsc	w5,#8		; displacement is signed 9-bit number
    1e02:	05 80 a7    	btsc.w    w5, #0x8
	sub	#0x200,w5	; if displacement is negative
    1e04:	05 20 b1    	sub.w     #0x200, w5
	add	w9,w5,w9	; new PC value
    1e06:	85 84 44    	add.w     w9, w5, w9

00001e08 <w9range>:
w9range:
	mov	#0x2000,w0
    1e08:	00 00 22    	mov.w     #0x2000, w0
	btsc	w9,#14
    1e0a:	09 e0 a7    	btsc.w    w9, #0xe
	sub	w9,w0,w9	; fit w9 < end of program memory
    1e0c:	80 84 54    	sub.w     w9, w0, w9
	btss	w9,#13
    1e0e:	09 d0 a6    	btss.w    w9, #0xd
	add	w9,w0,w9	; fit w9 > start-1 of program memory
    1e10:	80 84 44    	add.w     w9, w0, w9
	return
    1e12:	00 00 06    	return    

00001e14 <spec2>:
;		
spec2:			; flag 02 = special instruction: DSZ RY
	mov.b	w13,[w5]	; w13 = RY after decrement, w5 = RY address
    1e14:	8d 4a 78    	mov.b     w13, [w5]
	cp0	w13
    1e16:	0d 00 e0    	cp0.w     w13
	ifnz
    1e18:	42 20 ae    	btss.b    0x42, #0x1
	return
    1e1a:	00 00 06    	return    
	inc2	w9,w9		; skip (inrement PC)
    1e1c:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    1e1e:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    1e20:	09 00 22    	mov.w     #0x2000, w9
	return
    1e22:	00 00 06    	return    

00001e24 <spec3>:
;		
spec3:			; flag 03 = special instruction: EXR N
	btg	A16,#b_exr
    1e24:	ae 29 aa    	btg.b     0x9ae, #0x1
	goto	swapper
    1e26:	ec 24 04    	goto      0x24ec <swapper>
    1e28:	00 00 00 

00001e2a <spec4>:
;		
spec4:			; flag 04 = special instruction: RET R0,N
	cp0	Stack
    1e2a:	2a 09 e2    	cp0.w     0x92a
	bra	z,stackerr7	; stack underflow
    1e2c:	0f 00 32    	bra       Z, 0x1e4c <stackerr7>
	mov.b	w12,[w10]	; store #N to R0
    1e2e:	0c 4d 78    	mov.b     w12, [w10]
	mov	w5,w9		; store ret address to PC
    1e30:	85 04 78    	mov.w     w5, w9
	dec	Stack		; new Stack
    1e32:	2a 29 ed    	dec.w     0x92a
	return
    1e34:	00 00 06    	return    

00001e36 <spec5>:
;		
spec5:			; flag 05 = special instruction: MOV PC,NN
	mov.b	w5,[w10+15]	; write hi nibble to PCH (irregular, but possible use of w5)
    1e36:	75 4d 98    	mov.b     w5, [w10+15]
	mov.b	w8,[w10+14]	; write low nibble to PCL (irregular, but possible use of w8)
    1e38:	68 4d 98    	mov.b     w8, [w10+14]
	mov	#Ram+0x0B,w8	; restore w8
    1e3a:	b8 80 20    	mov.w     #0x80b, w8
	btsc.b	WrFlags,#1	; I/O port select
    1e3c:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#Ram+0xFB,w8	; restore w8
    1e3e:	b8 8f 20    	mov.w     #0x8fb, w8
	return
    1e40:	00 00 06    	return    

00001e42 <spec6>:
;		
spec6:			; flag 06 = special instruction: SKIP F,M
	mov	w5,w9		; store new address to PC
    1e42:	85 04 78    	mov.w     w5, w9
	return
    1e44:	00 00 06    	return    

00001e46 <spec7>:
;		
spec7:			; flag 07 is reserved
	return
    1e46:	00 00 06    	return    

00001e48 <stackerr6>:
;------------------------------------------
stackerr6:			; Fatal Error, Stack overflow
	mov	#6,w0		; Stack=6: Overflow (5+1)
    1e48:	60 00 20    	mov.w     #0x6, w0
	bra	skrerr
    1e4a:	01 00 37    	bra       0x1e4e <skrerr>

00001e4c <stackerr7>:
stackerr7:			; Fatal Error, Stack underflow
	mov	#7,w0		; Stack=7: Underflow (0-1)
    1e4c:	70 00 20    	mov.w     #0x7, w0

00001e4e <skrerr>:
skrerr:
	mov	w0,Stack
    1e4e:	50 49 88    	mov.w     w0, 0x92a
	bset	Flag2,#5	; #5 Fatal Stack Error
    1e50:	de a9 a8    	bset.b    0x9de, #0x5
	return
    1e52:	00 00 06    	return    

00001e54 <run_call>:

;#################################################################################
run_call:			; - - - - - - - - - - - - - - - - -  RUN CALL   <----
	mov	Stack,w0
    1e54:	50 49 80    	mov.w     0x92a, w0
	cp	w0,#5
    1e56:	65 00 e1    	cp.w      w0, #0x5
	bra	c,stackerr6	; stack overflow
    1e58:	f7 ff 31    	bra       C, 0x1e48 <stackerr6>
	mul.uu	w0,#3,w0	; w0:w1
    1e5a:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16,w0		; stack starts at Ram+16
    1e5c:	00 01 b0    	add.w     #0x10, w0
	add	w0,w10,w1	; w1 = current stack
    1e5e:	8a 00 40    	add.w     w0, w10, w1
; push ret addr on stack
	mov	#Rom,w0
    1e60:	00 00 22    	mov.w     #0x2000, w0
	sub	w9,w0,w9
    1e62:	80 84 54    	sub.w     w9, w0, w9
	lsr	w9,w9
    1e64:	89 04 d1    	lsr.w     w9, w9
	and	w9,#0x0F,w0
    1e66:	6f 80 64    	and.w     w9, #0xf, w0
	mov.b	w0,[w1++]	; push low ret addr on stack
    1e68:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#4,w0
    1e6a:	44 48 de    	lsr.w     w9, #0x4, w0
	and	w0,#0x0F,w0
    1e6c:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push med ret addr on stack
    1e6e:	80 58 78    	mov.b     w0, [w1++]
	lsr	w9,#8,w0
    1e70:	48 48 de    	lsr.w     w9, #0x8, w0
	and	w0,#0x0F,w0
    1e72:	6f 00 60    	and.w     w0, #0xf, w0
	mov.b	w0,[w1++]	; push hi ret addr on stack
    1e74:	80 58 78    	mov.b     w0, [w1++]
	inc	Stack
    1e76:	2a 29 ec    	inc.w     0x92a
; load new ProgMemAddr from registers RC RE RF
	mov.b	Ram+12,WREG
    1e78:	0c c8 bf    	mov.b     0x80c, WREG
	bra	skr_run
    1e7a:	01 00 37    	bra       0x1e7e <skr_run>

00001e7c <run_jump>:
run_jump:			; - - - - - - - - - - - - - - - - -  RUN JUMP   <----
	mov.b	Ram+13,WREG
    1e7c:	0d c8 bf    	mov.b     0x80d, WREG

00001e7e <skr_run>:
skr_run:
	ze	w0,w1
    1e7e:	80 80 fb    	ze        w0, w1
	mov.b	Ram+15,WREG
    1e80:	0f c8 bf    	mov.b     0x80f, WREG
	sl	w0,#4,w0
    1e82:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Ram+14,WREG
    1e84:	0e 48 b7    	ior.b     0x80e, WREG
	ze	w0,w0
    1e86:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0
    1e88:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w1,w0
    1e8a:	01 40 70    	ior.b     w0, w1, w0
	mov	w0,w9		; correction, as SS farm increments Prog Mem Addr
    1e8c:	80 04 78    	mov.w     w0, w9
	sl	w9,w9		; ×2
    1e8e:	89 04 d0    	sl.w      w9, w9
	mov	#Rom,w0
    1e90:	00 00 22    	mov.w     #0x2000, w0
	add	w9,w0,w9
    1e92:	80 84 44    	add.w     w9, w0, w9
	return
    1e94:	00 00 06    	return    

00001e96 <ind_4_1>:

; ----------------------------------------------------------------------------------- 
; ------------------------     I N S T R U C T I O N S     -------------------------- 
; ----------------------------------------------------------------------------------- 
; Label Name Rules:								      
; IND subroutines: with INDirectly addressed operands (SS and RUN modes)              
; DIR subroutines: with DIRectly addressed operands (ALU mode)                        
; First digit: _4 means 4-bit operand						      
; First digit: _8 means 8-bit operand						      
; Second digit _0..._15 is Opcode (or Opcode extension) digit			      

ind_4_1:   ; ------------------------------------------------------   1   ADD RX,RY (49T)
; IN register service
	mov	PORTB,w0
    1e96:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1e98:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1e9a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1e9c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1e9e:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1ea0:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1ea2:	6a 46 7e    	mov.b     [w10+w12], w12

00001ea4 <dir_4_1>:
dir_4_1:
	mov	w11,Atemp	; pre-load Accu temp
    1ea4:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1ea6:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds		; uses w0
    1ea8:	f0 f8 2f    	mov.w     #0xff8f, w0
    1eaa:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1eac:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1eae:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1eb0:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1eb2:	a2 57 23    	mov.w     #0x357a, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1eb4:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1eb6:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1eb8:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1eba:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1ebc:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1ebe:	14 00 37    	bra       0x1ee8 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1ec0:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1ec2:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1ec4:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1ec6:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1ec8:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1eca:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1ecc:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1ece:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1ed0:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1ed2:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1ed4:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1ed6:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1ed8:	89 84 e8    	inc2.w    w9, w9
    1eda:	09 e0 a7    	btsc.w    w9, #0xe
    1edc:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1ede:	00 40 a6    	btss.w    w0, #0x4
	return
    1ee0:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1ee2:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1ee4:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1ee6:	00 00 06    	return    

00001ee8 <slow3flags1111>:

slow3flags1111:
	mov	#0b1111,w6	; move VZCA
    1ee8:	f6 00 20    	mov.w     #0xf, w6

00001eea <slow3flags_keepw6>:
slow3flags_keepw6:
	bclr	Vflag,#0
    1eea:	30 09 a9    	bclr.b    0x930, #0x0
	bclr	Zflag,#0
    1eec:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    1eee:	2c 09 a9    	bclr.b    0x92c, #0x0
	btsc	w0,#6
    1ef0:	00 60 a7    	btsc.w    w0, #0x6
	bset	Vflag,#0
    1ef2:	30 09 a8    	bset.b    0x930, #0x0
	btsc	w0,#5
    1ef4:	00 50 a7    	btsc.w    w0, #0x5
	bset	Zflag,#0
    1ef6:	2e 09 a8    	bset.b    0x92e, #0x0
	btsc	w0,#4
    1ef8:	00 40 a7    	btsc.w    w0, #0x4
	bset	Cflag,#0
    1efa:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    1efc:	00 00 06    	return    

00001efe <ind_4_2>:

ind_4_2:   ; ------------------------------------------------------   2   ADC RX,RY (52T)
; IN register service
	mov	PORTB,w0
    1efe:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f00:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f02:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f04:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f06:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1f08:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1f0a:	6a 46 7e    	mov.b     [w10+w12], w12

00001f0c <dir_4_2>:
dir_4_2:
	mov	w11,Atemp	; pre-load Accu temp
    1f0c:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f0e:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	bclr	A16,#b_data_inv
    1f10:	ae 89 a9    	bclr.b    0x9ae, #0x4
	bset	A16,#b_cena
    1f12:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1f14:	e0 9a 20    	mov.w     #0x9ae, w0
	btst.c	[w0],#b_carry	; A16,#b_carry ---> C
    1f16:	10 c0 a3    	btst.c    [w0], #0xc
	mov	#b_cin,w3
    1f18:	53 00 20    	mov.w     #0x5, w3
	bsw.c	[w0],w3		; C ---> A16,#b_cin
    1f1a:	10 18 ad    	bsw.c     [w0], w3
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1f1c:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1f1e:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1f20:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1f22:	a2 57 23    	mov.w     #0x357a, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1f24:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1f26:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1f28:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1f2a:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1f2c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1f2e:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1f30:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1f32:	da ff 37    	bra       0x1ee8 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1f34:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1f36:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1f38:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f3a:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f3c:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f3e:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f40:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f42:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f44:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f46:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f48:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1f4a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1f4c:	89 84 e8    	inc2.w    w9, w9
    1f4e:	09 e0 a7    	btsc.w    w9, #0xe
    1f50:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1f52:	00 40 a6    	btss.w    w0, #0x4
	return
    1f54:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1f56:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1f58:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1f5a:	00 00 06    	return    

00001f5c <ind_4_3>:

ind_4_3:   ; ------------------------------------------------------   3   SUB RX,RY (50T)
; IN register service
	mov	PORTB,w0
    1f5c:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1f5e:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1f60:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1f62:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1f64:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1f66:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1f68:	6a 46 7e    	mov.b     [w10+w12], w12

00001f6a <dir_4_3>:
dir_4_3:
	mov	w11,Atemp	; pre-load Accu temp
    1f6a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1f6c:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1f6e:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1f70:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    1f72:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    1f74:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1f76:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1f78:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1f7a:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    1f7c:	c2 57 23    	mov.w     #0x357c, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1f7e:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1f80:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1f82:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1f84:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1f86:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1f88:	af ff 37    	bra       0x1ee8 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1f8a:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1f8c:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1f8e:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1f90:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1f92:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1f94:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1f96:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1f98:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1f9a:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    1f9c:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    1f9e:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    1fa0:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    1fa2:	89 84 e8    	inc2.w    w9, w9
    1fa4:	09 e0 a7    	btsc.w    w9, #0xe
    1fa6:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    1fa8:	00 40 a6    	btss.w    w0, #0x4
	return
    1faa:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    1fac:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    1fae:	af 89 a8    	bset.b    0x9af, #0x4
	return
    1fb0:	00 00 06    	return    

00001fb2 <ind_4_4>:

ind_4_4:   ; ------------------------------------------------------   4   SBB RX,RY (54T)
; IN register service
	mov	PORTB,w0
    1fb2:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    1fb4:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    1fb6:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    1fb8:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    1fba:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    1fbc:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    1fbe:	6a 46 7e    	mov.b     [w10+w12], w12

00001fc0 <dir_4_4>:
dir_4_4:
	mov	w11,Atemp	; pre-load Accu temp
    1fc0:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    1fc2:	0b 07 78    	mov.w     w11, w14
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    1fc4:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    1fc6:	ae 89 a8    	bset.b    0x9ae, #0x4
	bset	A16,#b_cena
    1fc8:	ae c9 a8    	bset.b    0x9ae, #0x6
	mov	#A16,w0
    1fca:	e0 9a 20    	mov.w     #0x9ae, w0
	btst	[w0],#b_carry	; A16,#b_carry ---> C
    1fcc:	10 c8 a3    	btst.z    [w0], #0xc
	ccf
    1fce:	42 00 aa    	btg.b     0x42, #0x0
	mov	#b_cin,w3
    1fd0:	53 00 20    	mov.w     #0x5, w3
	bsw	[w0],w3		; C ---> A16,#b_cin
    1fd2:	10 98 ad    	bsw.z     [w0], w3
	ccf
    1fd4:	42 00 aa    	btg.b     0x42, #0x0
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    1fd6:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    1fd8:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    1fda:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    1fdc:	a2 57 23    	mov.w     #0x357a, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    1fde:	02 00 40    	add.w     w0, w2, w0
	btsc	A16,#b_cin	; Extra bit 16: C IN (schematic) 
    1fe0:	ae a9 af    	btsc.b    0x9ae, #0x5
	inc2	w0,w0		; if Cin set
    1fe2:	00 80 e8    	inc2.w    w0, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    1fe4:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    1fe6:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    1fe8:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    1fea:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    1fec:	7d ff 37    	bra       0x1ee8 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    1fee:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    1ff0:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    1ff2:	30 29 ef    	clr.w     0x930
	clr	Zflag
    1ff4:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    1ff6:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    1ff8:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    1ffa:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    1ffc:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    1ffe:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    2000:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    2002:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    2004:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2006:	89 84 e8    	inc2.w    w9, w9
    2008:	09 e0 a7    	btsc.w    w9, #0xe
    200a:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    200c:	00 40 a6    	btss.w    w0, #0x4
	return
    200e:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    2010:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    2012:	af 89 a8    	bset.b    0x9af, #0x4
	return
    2014:	00 00 06    	return    

00002016 <ind_4_5>:

ind_4_5:   ; ------------------------------------------------------   5   OR RX,RY (T)
; IN register service
	mov	PORTB,w0
    2016:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2018:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    201a:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    201c:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    201e:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    2020:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2022:	6a 46 7e    	mov.b     [w10+w12], w12

00002024 <dir_4_5>:
dir_4_5:
	mov	w11,Atemp	; pre-load Accu temp
    2024:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2026:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2028:	f0 f8 2f    	mov.w     #0xff8f, w0
    202a:	ae 29 b6    	and.w     0x9ae
; exec
	ior	w11,w12,w13	; exec
    202c:	8c 86 75    	ior.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    202e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    2030:	0b 00 37    	bra       0x2048 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2032:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2034:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    2036:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2038:	2e 29 ef    	clr.w     0x92e
	ifz
    203a:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    203c:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    203e:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2040:	89 84 e8    	inc2.w    w9, w9
    2042:	09 e0 a7    	btsc.w    w9, #0xe
    2044:	09 00 22    	mov.w     #0x2000, w9

	return
    2046:	00 00 06    	return    

00002048 <slowZflag0101>:
slowZflag0101:
	mov	#0b0101,w6	; move VZCA
    2048:	56 00 20    	mov.w     #0x5, w6
	bclr	Zflag,#0
    204a:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    204c:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    204e:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    2050:	00 00 06    	return    

00002052 <ind_4_6>:

ind_4_6:   ; ------------------------------------------------------   6   AND RX,RY (T)
; IN register service
	mov	PORTB,w0
    2052:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2054:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2056:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2058:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    205a:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    205c:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    205e:	6a 46 7e    	mov.b     [w10+w12], w12

00002060 <dir_4_6>:
dir_4_6:
	mov	w11,Atemp	; pre-load Accu temp
    2060:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2062:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2064:	f0 f8 2f    	mov.w     #0xff8f, w0
    2066:	ae 29 b6    	and.w     0x9ae
; exec
	and	w11,w12,w13	; exec
    2068:	8c 86 65    	and.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    206a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    206c:	ed ff 37    	bra       0x2048 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    206e:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2070:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    2072:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2074:	2e 29 ef    	clr.w     0x92e
	ifz
    2076:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    2078:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    207a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    207c:	89 84 e8    	inc2.w    w9, w9
    207e:	09 e0 a7    	btsc.w    w9, #0xe
    2080:	09 00 22    	mov.w     #0x2000, w9

	return
    2082:	00 00 06    	return    

00002084 <ind_4_7>:

ind_4_7:   ; ------------------------------------------------------   7   XOR RX,RY (T)
; IN register service
	mov	PORTB,w0
    2084:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2086:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2088:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    208a:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    208c:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    208e:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2090:	6a 46 7e    	mov.b     [w10+w12], w12

00002092 <dir_4_7>:
dir_4_7:
	mov	w11,Atemp	; pre-load Accu temp
    2092:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2094:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2096:	f0 f8 2f    	mov.w     #0xff8f, w0
    2098:	ae 29 b6    	and.w     0x9ae
; exec
	xor	w11,w12,w13	; exec
    209a:	8c 86 6d    	xor.w     w11, w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    209c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0101
    209e:	d4 ff 37    	bra       0x2048 <slowZflag0101>
				; fast simplified Z flag (no bit #1 and #2 shifts)
	mov	w13,Atemp
    20a0:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20a2:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2
    20a4:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    20a6:	2e 29 ef    	clr.w     0x92e
	ifz
    20a8:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag
    20aa:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    20ac:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20ae:	89 84 e8    	inc2.w    w9, w9
    20b0:	09 e0 a7    	btsc.w    w9, #0xe
    20b2:	09 00 22    	mov.w     #0x2000, w9

	return
    20b4:	00 00 06    	return    

000020b6 <ind_4_8>:

ind_4_8:   ; ------------------------------------------------------   8   MOV RX,RY (T)
; IN register service
	mov	PORTB,w0
    20b6:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    20b8:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    20ba:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    20bc:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    20be:	8b 03 45    	add.w     w10, w11, w7
	ze	[w7],w11	; X value
    20c0:	97 85 fb    	ze        [w7], w11
	mov.b	[w10+w12],w12	; Y value
    20c2:	6a 46 7e    	mov.b     [w10+w12], w12

000020c4 <dir_4_8>:
dir_4_8:
	mov	w11,Atemp	; pre-load Accu temp
    20c4:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    20c6:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    20c8:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    20ca:	f0 f8 2f    	mov.w     #0xff8f, w0
    20cc:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    20ce:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    20d0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    20d2:	0c 00 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    20d4:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    20d6:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    20d8:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    20da:	89 84 e8    	inc2.w    w9, w9
    20dc:	09 e0 a7    	btsc.w    w9, #0xe
    20de:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    20e0:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    20e2:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    20e4:	b7 fe 32    	bra       Z, 0x1e54 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    20e6:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    20e8:	c9 fe 32    	bra       Z, 0x1e7c <run_jump>
	return
    20ea:	00 00 06    	return    

000020ec <slowAccu0001>:
slowAccu0001:
	mov	#0b0001,w6	; move VZCA
    20ec:	16 00 20    	mov.w     #0x1, w6
	return
    20ee:	00 00 06    	return    

000020f0 <ind_4_9>:

ind_4_9:   ; ------------------------------------------------------   9   MOV RX,N (T)
; IN register service
	mov	PORTB,w0
    20f0:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    20f2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    20f4:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    20f6:	00 4c 78    	mov.b     w0, [w8]
; get indirect values from registers
	add	w10,w11,w7	; result write address
    20f8:	8b 03 45    	add.w     w10, w11, w7
	mov.b	[w10+w11],w11	; X value
    20fa:	ea c5 7d    	mov.b     [w10+w11], w11
	mov	w11,Atemp	; pre-load Accu temp
    20fc:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    20fe:	0b 07 78    	mov.w     w11, w14
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    2100:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    2102:	f0 f8 2f    	mov.w     #0xff8f, w0
    2104:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13		; exec
    2106:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2108:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    210a:	f0 ff 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    210c:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    210e:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2110:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2112:	89 84 e8    	inc2.w    w9, w9
    2114:	09 e0 a7    	btsc.w    w9, #0xe
    2116:	09 00 22    	mov.w     #0x2000, w9

; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    2118:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    211a:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    211c:	9b fe 32    	bra       Z, 0x1e54 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    211e:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    2120:	ad fe 32    	bra       Z, 0x1e7c <run_jump>
	return
    2122:	00 00 06    	return    

00002124 <ind_4_10>:

ind_4_10:   ; -----------------------------------------------------   10  MOV [XY],R0 (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    2124:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    2126:	6a 46 7e    	mov.b     [w10+w12], w12
	sl	w11,#4,w7	; 16 × X
    2128:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    212a:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    212c:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    212e:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    2130:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    2132:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    2134:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    2136:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    2138:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    213a:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    213c:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    213e:	f0 f8 2f    	mov.w     #0xff8f, w0
    2140:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    2142:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2144:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    2146:	d2 ff 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2148:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    214a:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    214c:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    214e:	89 84 e8    	inc2.w    w9, w9
    2150:	09 e0 a7    	btsc.w    w9, #0xe
    2152:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    2154:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    2156:	00 00 06    	return    
	bra	perform_SFR_write
    2158:	e2 02 37    	bra       0x271e <perform_SFR_write>

0000215a <ind_4_11>:

ind_4_11:   ; -----------------------------------------------------   11  MOV R0,[XY] (T)
; get indirect values from registers
	mov.b	[w10+w11],w11	; X value
    215a:	ea c5 7d    	mov.b     [w10+w11], w11
	mov.b	[w10+w12],w12	; Y value
    215c:	6a 46 7e    	mov.b     [w10+w12], w12
	mov	w10,w7		; dst addr to w7 (just for convention)
    215e:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    2160:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    2162:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    2164:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    2166:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    2168:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    216a:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr1
    216c:	02 00 3a    	bra       NZ, 0x2172 <nosfr1>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    216e:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    2170:	8c 02 78    	mov.w     w12, w5

00002172 <nosfr1>:
nosfr1:
	clr	w11		; clear 1st operand displayed
    2172:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    2174:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    2176:	f0 f8 2f    	mov.w     #0xff8f, w0
    2178:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    217a:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    217c:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    217e:	b6 ff 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    2180:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    2182:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2184:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2186:	89 84 e8    	inc2.w    w9, w9
    2188:	09 e0 a7    	btsc.w    w9, #0xe
    218a:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    218c:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    218e:	00 00 06    	return    
	bra	perform_SFR_read
    2190:	16 03 37    	bra       0x27be <perform_SFR_read>

00002192 <ind_4_12>:

ind_4_12:   ; -----------------------------------------------------   12  MOV [NN],R0 (T)
	sl	w11,#4,w7	; 16 × X
    2192:	c4 5b dd    	sl.w      w11, #0x4, w7
	add	w7,w12,w7	; 16 × X + Y
    2194:	8c 83 43    	add.w     w7, w12, w7
	add	w7,w10,w7	; 16 × X + Y + Ram (result write address)
    2196:	8a 83 43    	add.w     w7, w10, w7

	  cp	  w11,#15
    2198:	6f 58 e1    	cp.w      w11, #0xf
	  ifz
    219a:	42 20 af    	btsc.b    0x42, #0x1
	  bset	  Flag,#9	; #9 set if instruction is writing to SFR area
    219c:	dd 29 a8    	bset.b    0x9dd, #0x1
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    219e:	8c 02 78    	mov.w     w12, w5

	clr	w11		; clear 1st operand displayed
    21a0:	80 05 eb    	clr.w     w11
	ze	[w7],w14	; pre-load Accu out
    21a2:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    21a4:	4e 49 88    	mov.w     w14, 0x928
	ze	[w10],w12	; source (2nd) operand displayed
    21a6:	1a 86 fb    	ze        [w10], w12
; maintain logic diagram
	clr3leds
    21a8:	f0 f8 2f    	mov.w     #0xff8f, w0
    21aa:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    21ac:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    21ae:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    21b0:	9d ff 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    21b2:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    21b4:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    21b6:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    21b8:	89 84 e8    	inc2.w    w9, w9
    21ba:	09 e0 a7    	btsc.w    w9, #0xe
    21bc:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#9		; #9 set if instruction is writing to SFR area
    21be:	dd 29 ae    	btss.b    0x9dd, #0x1
	return
    21c0:	00 00 06    	return    
	bra	perform_SFR_write
    21c2:	ad 02 37    	bra       0x271e <perform_SFR_write>

000021c4 <ind_4_13>:


ind_4_13:   ; -----------------------------------------------------   13  MOV R0,[NN] (T)
	mov	w10,w7		; dst addr to w7 (just for convention)
    21c4:	8a 03 78    	mov.w     w10, w7
	ze	[w7],w14	; pre-load Accu out
    21c6:	17 87 fb    	ze        [w7], w14
	mov	w14,Atemp	; pre-load Accu temp
    21c8:	4e 49 88    	mov.w     w14, 0x928

	sl	w11,#4,w1	; 16 × X
    21ca:	c4 58 dd    	sl.w      w11, #0x4, w1
	add	w1,w12,w1	; 16 × X + Y
    21cc:	8c 80 40    	add.w     w1, w12, w1
	add	w1,w10,w1	; 16 × X + Y + Ram (source address)
    21ce:	8a 80 40    	add.w     w1, w10, w1

	  cp	  w11,#15
    21d0:	6f 58 e1    	cp.w      w11, #0xf
	  bra	  nz,nosfr2
    21d2:	02 00 3a    	bra       NZ, 0x21d8 <nosfr2>
	  bset	  Flag,#10	; #10 set if instruction is reading from SFR area
    21d4:	dd 49 a8    	bset.b    0x9dd, #0x2
	  mov	  w12,w5	; SFR service will need the low nibble of SFR address
    21d6:	8c 02 78    	mov.w     w12, w5

000021d8 <nosfr2>:
nosfr2:
	clr	w11		; clear 1st operand displayed
    21d8:	80 05 eb    	clr.w     w11
	ze	[w1],w12	; source (2nd) operand displayed
    21da:	11 86 fb    	ze        [w1], w12
; maintain logic diagram
	clr3leds
    21dc:	f0 f8 2f    	mov.w     #0xff8f, w0
    21de:	ae 29 b6    	and.w     0x9ae
; exec
	mov	w12,w13
    21e0:	8c 06 78    	mov.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    21e2:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowAccu0001
    21e4:	83 ff 37    	bra       0x20ec <slowAccu0001>
				; fast simplified exit (no flags)
	mov	w13,Atemp
    21e6:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14
    21e8:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    21ea:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    21ec:	89 84 e8    	inc2.w    w9, w9
    21ee:	09 e0 a7    	btsc.w    w9, #0xe
    21f0:	09 00 22    	mov.w     #0x2000, w9

	btss	Flag,#10	; #10 set if instruction is reading from SFR area
    21f2:	dd 49 ae    	btss.b    0x9dd, #0x2
	return
    21f4:	00 00 06    	return    
	bra	perform_SFR_read
    21f6:	e3 02 37    	bra       0x27be <perform_SFR_read>

000021f8 <ind_4_14>:

ind_4_14:   ; -----------------------------------------------------   14  MOV PC,NN (T)
; maintain logic diagram
	clr3leds
    21f8:	f0 f8 2f    	mov.w     #0xff8f, w0
    21fa:	ae 29 b6    	and.w     0x9ae

	mov	w11,w5
    21fc:	8b 02 78    	mov.w     w11, w5
	mov	w12,w8
    21fe:	0c 04 78    	mov.w     w12, w8
	clr	w11		; clear 1st operand displayed
    2200:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    2202:	00 06 eb    	clr.w     w12

	mov	#0x05,w7	; flag "MOV PC,NN" instead of "MOV W13,[W7]"
    2204:	57 00 20    	mov.w     #0x5, w7
	mov	w14,w13
    2206:	8e 06 78    	mov.w     w14, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2208:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    220a:	04 00 37    	bra       0x2214 <phases_0>

	incpc			; w9++
    220c:	89 84 e8    	inc2.w    w9, w9
    220e:	09 e0 a7    	btsc.w    w9, #0xe
    2210:	09 00 22    	mov.w     #0x2000, w9

	bra	spec5
    2212:	11 fe 37    	bra       0x1e36 <spec5>

00002214 <phases_0>:
phases_0:
	mov	#0b0000,w6	; move VZCA
    2214:	06 00 20    	mov.w     #0x0, w6
	return
    2216:	00 00 06    	return    

00002218 <ind_4_15>:

ind_4_15:   ; -----------------------------------------------------   15  JR NN (T)
; maintain logic diagram
	clr3leds
    2218:	f0 f8 2f    	mov.w     #0xff8f, w0
    221a:	ae 29 b6    	and.w     0x9ae
; exec
	sl	w11,#4,w5	; 16 × X
    221c:	c4 5a dd    	sl.w      w11, #0x4, w5
	add	w5,w12,w5	; 16 × X + Y (8-bit displacement addr)
    221e:	8c 82 42    	add.w     w5, w12, w5
	sl	w5,w5		; ×2, now in 9-bit range 0...0x1FE (signed -0x100...0xFF)
    2220:	85 02 d0    	sl.w      w5, w5
	clr	w11		; clear 1st operand displayed
    2222:	80 05 eb    	clr.w     w11
	clr	w12		; clear 2nd operand displayed
    2224:	00 06 eb    	clr.w     w12

	mov	#0x01,w7	; flag "JR NN" instead of "MOV W13,[W7]"
    2226:	17 00 20    	mov.w     #0x1, w7
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2228:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    222a:	f4 ff 37    	bra       0x2214 <phases_0>
				; fast simplified exit (no flags)
	incpc			; w9++
    222c:	89 84 e8    	inc2.w    w9, w9
    222e:	09 e0 a7    	btsc.w    w9, #0xe
    2230:	09 00 22    	mov.w     #0x2000, w9

	bra	spec1
    2232:	e7 fd 37    	bra       0x1e02 <spec1>

00002234 <ind_8_0>:

; ###################################################################################

ind_8_0:   ; -----------------------------------------------------    00  CP R0,N (T)
; IN register service
	mov	PORTB,w0
    2234:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2236:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2238:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    223a:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    223c:	9a 85 fb    	ze        [w10], w11

0000223e <dir_8_0>:
dir_8_0:
	xor	w12,#0x0F,w12	; inv Y value (will be displayed)
    223e:	6f 06 6e    	xor.w     w12, #0xf, w12
; maintain logic diagram
	bset	A16,#b_data_inv
    2240:	ae 89 a8    	bset.b    0x9ae, #0x4
	bclr	A16,#b_cena
    2242:	ae c9 a9    	bclr.b    0x9ae, #0x6
	bset	A16,#b_cin	; subtract = inv (add) with inv (C)
    2244:	ae a9 a8    	bset.b    0x9ae, #0x5
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2246:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2248:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    224a:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder)+2,w2
    224c:	c2 57 23    	mov.w     #0x357c, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    224e:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    2250:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    2252:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; result to Accu IN
    2254:	ef 06 60    	and.w     w0, #0xf, w13
	mov	#Dummy,w7
    2256:	07 9b 20    	mov.w     #0x9b0, w7
; get flags
	mov	#0b1110,w6	; move VZCA
    2258:	e6 00 20    	mov.w     #0xe, w6
	btsc	Flag,#2		; #2 set if Speed>0
    225a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags_keepw6
    225c:	46 fe 37    	bra       0x1eea <slow3flags_keepw6>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	clr	Vflag
    225e:	30 29 ef    	clr.w     0x930
	clr	Zflag
    2260:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2262:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2264:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2266:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    2268:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    226a:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    226c:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    226e:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    2270:	89 84 e8    	inc2.w    w9, w9
    2272:	09 e0 a7    	btsc.w    w9, #0xe
    2274:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    2276:	00 40 a6    	btss.w    w0, #0x4
	return
    2278:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    227a:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    227c:	af 89 a8    	bset.b    0x9af, #0x4
	return
    227e:	00 00 06    	return    

00002280 <ind_8_1>:

ind_8_1:   ; -----------------------------------------------------    01  ADD R0,N (T)
; IN register service
	mov	PORTB,w0
    2280:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2282:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2284:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2286:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2288:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    228a:	8a 03 78    	mov.w     w10, w7

0000228c <dir_8_1>:
dir_8_1:
	mov	w11,Atemp	; pre-load Accu temp
    228c:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    228e:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2290:	f0 f8 2f    	mov.w     #0xff8f, w0
    2292:	ae 29 b6    	and.w     0x9ae
; exec Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2294:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2296:	00 80 75    	ior.w     w11, w0, w0
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    2298:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    229a:	a2 57 23    	mov.w     #0x357a, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    229c:	02 00 40    	add.w     w0, w2, w0
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    229e:	10 00 ba    	tblrdl.w  [w0], w0
	lsr	w0,#4,w0	; 0000 0000 0VZC AAAA
    22a0:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w13	; write result to Accu in
    22a2:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    22a4:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow3flags1111
    22a6:	20 fe 37    	bra       0x1ee8 <slow3flags1111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    22a8:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    22aa:	0d 07 78    	mov.w     w13, w14
	clr	Vflag
    22ac:	30 29 ef    	clr.w     0x930
	clr	Zflag
    22ae:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    22b0:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    22b2:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    22b4:	72 00 20    	mov.w     #0x7, w2
	btsc	w0,#6
    22b6:	00 60 a7    	btsc.w    w0, #0x6
	mov	w2,Vflag	; if V flag set
    22b8:	82 49 88    	mov.w     w2, 0x930
	btsc	w0,#5
    22ba:	00 50 a7    	btsc.w    w0, #0x5
	mov	w2,Zflag	; if Z flag set
    22bc:	72 49 88    	mov.w     w2, 0x92e

	mov.b	w13,[w7]	; write result to destination
    22be:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    22c0:	89 84 e8    	inc2.w    w9, w9
    22c2:	09 e0 a7    	btsc.w    w9, #0xe
    22c4:	09 00 22    	mov.w     #0x2000, w9

	btss	w0,#4
    22c6:	00 40 a6    	btss.w    w0, #0x4
	return
    22c8:	00 00 06    	return    
	mov	w2,Cflag	; if C flag set
    22ca:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    22cc:	af 89 a8    	bset.b    0x9af, #0x4
	return
    22ce:	00 00 06    	return    

000022d0 <ind_8_2>:

ind_8_2:   ; -----------------------------------------------------    02  INC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    22d0:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    22d2:	6a 46 7e    	mov.b     [w10+w12], w12

000022d4 <dir_8_2>:
dir_8_2:
	mov	w12,Atemp	; pre-load Accu temp
    22d4:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    22d6:	0c 07 78    	mov.w     w12, w14
	mov	#1,w11		; "add 1" = "inc" (will be displayed)
    22d8:	1b 00 20    	mov.w     #0x1, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    22da:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    22dc:	f0 f8 2f    	mov.w     #0xff8f, w0
    22de:	ae 29 b6    	and.w     0x9ae
; exec 
	inc	w12,w0		; exec
    22e0:	0c 00 e8    	inc.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    22e2:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    22e4:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    22e6:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 13)
    22e8:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    22ea:	0f 00 3a    	bra       NZ, 0x230a <L43>
	cp0	Mode
    22ec:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    22ee:	0d 00 32    	bra       Z, 0x230a <L43>
; extension to PCM and PCH
	cp0	w13
    22f0:	0d 00 e0    	cp0.w     w13
	bra	nz,4f		; if no overflow from nibble 1
    22f2:	0b 00 3a    	bra       NZ, 0x230a <L43>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    22f4:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    22f6:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    22f8:	90 4d 88    	mov.w     w0, 0x9b2
	  inc.b	  PcmPch+0	; inc PCM
    22fa:	b2 69 ec    	inc.b     0x9b2
	  btss.b  PcmPch+0,#4	; PCM overflow?
    22fc:	b2 89 ae    	btss.b    0x9b2, #0x4
	  bra	  4f		; if no overflow
    22fe:	05 00 37    	bra       0x230a <L43>
	  bclr.b  PcmPch+0,#4	; keep PCM in 4-bit range
    2300:	b2 89 a9    	bclr.b    0x9b2, #0x4
	  cp0.b	  PcmPch+0	; is there overflow from PCM nibble?
    2302:	b2 49 e2    	cp0.b     0x9b2
	  ifz			; if overflow from PCM nibble...
    2304:	42 20 af    	btsc.b    0x42, #0x1
	  inc.b	  PcmPch+1	; ...then inc PCH...
    2306:	b3 69 ec    	inc.b     0x9b3
	  bclr.b  PcmPch+1,#4	; ...and keep it in 4-bit range
    2308:	b3 89 a9    	bclr.b    0x9b3, #0x4

0000230a <L43>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    230a:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow0111
    230c:	19 00 37    	bra       0x2340 <slow0111>

	incpc			; w9++
    230e:	89 84 e8    	inc2.w    w9, w9
    2310:	09 e0 a7    	btsc.w    w9, #0xe
    2312:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2314:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2316:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2318:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    231a:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    231c:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    231e:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    2320:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    2322:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2324:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2326:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2328:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    232a:	0d 00 e0    	cp0.w     w13
	bra	nz,no_write_02
    232c:	03 00 3a    	bra       NZ, 0x2334 <no_write_02>
	mov	w2,Zflag	; if result zero, Z flag set
    232e:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; if overflow, C flag set
    2330:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    2332:	af 89 a8    	bset.b    0x9af, #0x4

00002334 <no_write_02>:
no_write_02:
; check if destination was JSR or PCL, if so perform CALL or JUMP
	mov	#Ram+12,w0	; Ram+12=JSR
    2334:	c0 80 20    	mov.w     #0x80c, w0
	sub	w7,w0,w1	; w7= destination address
    2336:	80 80 53    	sub.w     w7, w0, w1
	bra	z,run_call	; - - - - - - - - - - - - - - - - -  RUN CALL  ---->
    2338:	8d fd 32    	bra       Z, 0x1e54 <run_call>
	dec	w1,w1		; Ram+13=JUMP
    233a:	81 00 e9    	dec.w     w1, w1
	bra	z,run_jump	; - - - - - - - - - - - - - - - - -  RUN JUMP  ---->
    233c:	9f fd 32    	bra       Z, 0x1e7c <run_jump>
	return
    233e:	00 00 06    	return    

00002340 <slow0111>:
slow0111:
	mov	#0b0111,w6	; move VZCA
    2340:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    2342:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    2344:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    2346:	0d 00 e0    	cp0.w     w13
	bra	nz,goback
    2348:	02 00 3a    	bra       NZ, 0x234e <goback>
	bset	Zflag,#0	; if result zero, Z flag set
    234a:	2e 09 a8    	bset.b    0x92e, #0x0
	bset	Cflag,#0	; if overflow, C flag set
    234c:	2c 09 a8    	bset.b    0x92c, #0x0

0000234e <goback>:
goback:
	return
    234e:	00 00 06    	return    

00002350 <ind_8_3>:

ind_8_3:   ; -----------------------------------------------------    03  DEC RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    2350:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    2352:	6a 46 7e    	mov.b     [w10+w12], w12

00002354 <dir_8_3>:
dir_8_3:
	mov	w12,Atemp	; pre-load Accu temp
    2354:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2356:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    2358:	fb 00 20    	mov.w     #0xf, w11
	bset	Flag,#4		; #4 set if instruction covers CALL and JP (mov, inc, dec)
    235a:	dc 89 a8    	bset.b    0x9dc, #0x4
; maintain logic diagram
	clr3leds
    235c:	f0 f8 2f    	mov.w     #0xff8f, w0
    235e:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w0		; exec
    2360:	0c 00 e9    	dec.w     w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2362:	ef 06 60    	and.w     w0, #0xf, w13
	sub	w7,w10,w3
    2364:	8a 81 53    	sub.w     w7, w10, w3
	sub	#12,w3
    2366:	c3 00 b1    	sub.w     #0xc, w3
	and	#0x0FE,w3	; will be 0 only for registers PCL or JSR (12 or 12)
    2368:	e3 0f b2    	and.w     #0xfe, w3
	bra	nz,4f		; if not registers PCL or JSR
    236a:	0e 00 3a    	bra       NZ, 0x2388 <L44>
	cp0	Mode
    236c:	76 09 e2    	cp0.w     0x976
	bra	z,4f		; no extension in ALU mode
    236e:	0c 00 32    	bra       Z, 0x2388 <L44>
; extension to PCM and PCH
	cp0	w12
    2370:	0c 00 e0    	cp0.w     w12
	bra	nz,4f		; if PCL or JSR was not 0 before dec
    2372:	0a 00 3a    	bra       NZ, 0x2388 <L44>
	  bset	  Flag,#7	; #7 set if there is PCM/PCH extension
    2374:	dc e9 a8    	bset.b    0x9dc, #0x7
	  mov	  Ram+14,w0
    2376:	70 40 80    	mov.w     0x80e, w0
	  mov	  w0,PcmPch	; PCM, PCH ---> PcmPch
    2378:	90 4d 88    	mov.w     w0, 0x9b2
	  dec.b	  PcmPch+0	; dec PCM
    237a:	b2 69 ed    	dec.b     0x9b2
	  btss.b  PcmPch+0,#7	; PCM underflow?
    237c:	b2 e9 ae    	btss.b    0x9b2, #0x7
	  bra	  4f		; if no underflow
    237e:	04 00 37    	bra       0x2388 <L44>
	mov	#0x0F,w0
    2380:	f0 00 20    	mov.w     #0xf, w0
	and.b	PcmPch+0	; mask low nibble bits of PCM
    2382:	b2 69 b6    	and.b     0x9b2
	dec.b	PcmPch+1	; dec PCH
    2384:	b3 69 ed    	dec.b     0x9b3
	and.b	PcmPch+1	; mask low nibble bits of PCH
    2386:	b3 69 b6    	and.b     0x9b3

00002388 <L44>:
4:
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    2388:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow03
    238a:	17 00 37    	bra       0x23ba <slow03>

	incpc			; w9++
    238c:	89 84 e8    	inc2.w    w9, w9
    238e:	09 e0 a7    	btsc.w    w9, #0xe
    2390:	09 00 22    	mov.w     #0x2000, w9

; fast simplified ZC flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2392:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2394:	0d 07 78    	mov.w     w13, w14
	mov.b	w13,[w7]	; write result to destination
    2396:	8d 4b 78    	mov.b     w13, [w7]
	  mov	  PcmPch+14,w0
    2398:	00 4e 80    	mov.w     0x9c0, w0
	  btsc	  Flag,#7	; #7 set if there is PCM/PCH extension
    239a:	dc e9 af    	btsc.b    0x9dc, #0x7
	  mov	  w0,Ram+14	; PcmPch ---> PCM, PCH (extension restored)
    239c:	70 40 88    	mov.w     w0, 0x80e
	  bclr	  Flag,#7	; #7 set if there is PCM/PCH extension
    239e:	dc e9 a9    	bclr.b    0x9dc, #0x7
	clr	Zflag
    23a0:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    23a2:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    23a4:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    23a6:	72 00 20    	mov.w     #0x7, w2
	cp0	w13
    23a8:	0d 00 e0    	cp0.w     w13
	ifz
    23aa:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if zero, Z flag set
    23ac:	72 49 88    	mov.w     w2, 0x92e
	cp	w13,#0x0F
    23ae:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    23b0:	42 20 ae    	btss.b    0x42, #0x1
	return
    23b2:	00 00 06    	return    
	mov	w2,Cflag	; if "dec" did not cause result 0x1111
    23b4:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED
    23b6:	af 89 a8    	bset.b    0x9af, #0x4
	return
    23b8:	00 00 06    	return    

000023ba <slow03>:
slow03:
	mov	#0b0111,w6	; move VZCA
    23ba:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    23bc:	2e 09 a9    	bclr.b    0x92e, #0x0
	bclr	Cflag,#0
    23be:	2c 09 a9    	bclr.b    0x92c, #0x0
	cp0	w13
    23c0:	0d 00 e0    	cp0.w     w13
	ifz
    23c2:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0	; if zero, Z flag set
    23c4:	2e 09 a8    	bset.b    0x92e, #0x0
	cp	w13,#0x0F
    23c6:	6f 68 e1    	cp.w      w13, #0xf
	ifnz
    23c8:	42 20 ae    	btss.b    0x42, #0x1
	bset	Cflag,#0	; if "dec" did not cause result 0x1111
    23ca:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    23cc:	00 00 06    	return    

000023ce <ind_8_4>:

ind_8_4:   ; -----------------------------------------------------    04  DSZ RY (T)
; get indirect values from OperY
	add	w10,w12,w7	; result write address
    23ce:	8c 03 45    	add.w     w10, w12, w7
	ze	[w7],w12	; Y value
    23d0:	17 86 fb    	ze        [w7], w12

000023d2 <dir_8_4>:
dir_8_4:
	mov	w12,Atemp	; pre-load Accu temp
    23d2:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    23d4:	0c 07 78    	mov.w     w12, w14
	mov	#0x0F,w11	; "add -1" = "dec" (will be displayed)
    23d6:	fb 00 20    	mov.w     #0xf, w11
; maintain logic diagram
	clr3leds
    23d8:	f0 f8 2f    	mov.w     #0xff8f, w0
    23da:	ae 29 b6    	and.w     0x9ae
; exec 
	dec	w12,w2		; exec
    23dc:	0c 01 e9    	dec.w     w12, w2
	and	w2,#0x0F,w13	; w13 = new Accu value
    23de:	ef 06 61    	and.w     w2, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    23e0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow04
    23e2:	0d 00 37    	bra       0x23fe <slow04>

	incpc			; w9++
    23e4:	89 84 e8    	inc2.w    w9, w9
    23e6:	09 e0 a7    	btsc.w    w9, #0xe
    23e8:	09 00 22    	mov.w     #0x2000, w9
				; fast simplified execution (no flags)
	mov.b	w13,[w7]	; write result to destination
    23ea:	8d 4b 78    	mov.b     w13, [w7]
	mov	w13,w14
    23ec:	0d 07 78    	mov.w     w13, w14
	mov	w13,Atemp
    23ee:	4d 49 88    	mov.w     w13, 0x928
	cp0	w13
    23f0:	0d 00 e0    	cp0.w     w13
	ifnz
    23f2:	42 20 ae    	btss.b    0x42, #0x1
	return
    23f4:	00 00 06    	return    

	incpc			; w9++
    23f6:	89 84 e8    	inc2.w    w9, w9
    23f8:	09 e0 a7    	btsc.w    w9, #0xe
    23fa:	09 00 22    	mov.w     #0x2000, w9

	return
    23fc:	00 00 06    	return    

000023fe <slow04>:
slow04:
	mov	w12,Atemp	; pre-load Accu temp
    23fe:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    2400:	0c 07 78    	mov.w     w12, w14
	mov	w7,w5		; new destination address (not w7)!
    2402:	87 02 78    	mov.w     w7, w5
	mov	#0x02,w7	; flag "DSZ RY" instead of "MOV W13,[W7]"
    2404:	27 00 20    	mov.w     #0x2, w7
	mov	#0b0000,w6	; move VZCA
    2406:	06 00 20    	mov.w     #0x0, w6
	return
    2408:	00 00 06    	return    

0000240a <ind_8_5>:

ind_8_5:   ; -----------------------------------------------------    05  OR R0,N (T)
; IN register service
	mov	PORTB,w0
    240a:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    240c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    240e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2410:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2412:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    2414:	8a 03 78    	mov.w     w10, w7

00002416 <dir_8_5>:
dir_8_5:
	mov	w11,Atemp	; pre-load Accu temp
    2416:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2418:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    241a:	f0 f8 2f    	mov.w     #0xff8f, w0
    241c:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w11,w12,w0
    241e:	0c 80 75    	ior.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    2420:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	setc			; SET C unconditionally
    2422:	42 00 a8    	bset.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    2424:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    2426:	0e 00 37    	bra       0x2444 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2428:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    242a:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    242c:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    242e:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    2430:	0d 00 e0    	cp0.w     w13
	ifz
    2432:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    2434:	72 49 88    	mov.w     w2, 0x92e
	mov	w2,Cflag	; SET C unconditionally
    2436:	62 49 88    	mov.w     w2, 0x92c
	bset	A16,#b_carry	; Carry button LED unconditionally
    2438:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    243a:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    243c:	89 84 e8    	inc2.w    w9, w9
    243e:	09 e0 a7    	btsc.w    w9, #0xe
    2440:	09 00 22    	mov.w     #0x2000, w9

	return
    2442:	00 00 06    	return    

00002444 <slowZCAflag0111>:

slowZCAflag0111:
	mov	#0b0111,w6	; move VZCA
    2444:	76 00 20    	mov.w     #0x7, w6
	bclr	Zflag,#0
    2446:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    2448:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    244a:	2e 09 a8    	bset.b    0x92e, #0x0
	bclr	Cflag,#0
    244c:	2c 09 a9    	bclr.b    0x92c, #0x0
	ifc
    244e:	42 00 af    	btsc.b    0x42, #0x0
	bset	Cflag,#0
    2450:	2c 09 a8    	bset.b    0x92c, #0x0
	return
    2452:	00 00 06    	return    

00002454 <ind_8_6>:

ind_8_6:   ; -----------------------------------------------------    06  AND R0,N (T)
; IN register service
	mov	PORTB,w0
    2454:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2456:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2458:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    245a:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    245c:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    245e:	8a 03 78    	mov.w     w10, w7

00002460 <dir_8_6>:
dir_8_6:
	mov	w11,Atemp	; pre-load Accu temp
    2460:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2462:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    2464:	f0 f8 2f    	mov.w     #0xff8f, w0
    2466:	ae 29 b6    	and.w     0x9ae
; exec 
	and	w11,w12,w0
    2468:	0c 80 65    	and.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    246a:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	clrc			; CLR C unconditionally
    246c:	42 00 a9    	bclr.b    0x42, #0x0
	btsc	Flag,#2		; #2 set if Speed>0
    246e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    2470:	e9 ff 37    	bra       0x2444 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    2472:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2474:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    2476:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2478:	2e 29 ef    	clr.w     0x92e
	cp0	w13
    247a:	0d 00 e0    	cp0.w     w13
	ifz
    247c:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    247e:	72 49 88    	mov.w     w2, 0x92e
	clr	Cflag		; clr C unconditionally
    2480:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED unconditionally
    2482:	af 89 a9    	bclr.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    2484:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2486:	89 84 e8    	inc2.w    w9, w9
    2488:	09 e0 a7    	btsc.w    w9, #0xe
    248a:	09 00 22    	mov.w     #0x2000, w9

	return
    248c:	00 00 06    	return    

0000248e <ind_8_7>:

ind_8_7:   ; -----------------------------------------------------    07  XOR R0,N (T)
; IN register service
	mov	PORTB,w0
    248e:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    2490:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    2492:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2494:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from register R0
	ze	[w10],w11	; X value (R0 is on Ram+0 addr)
    2496:	9a 85 fb    	ze        [w10], w11
	mov	w10,w7		; result write address
    2498:	8a 03 78    	mov.w     w10, w7

0000249a <dir_8_7>:
dir_8_7:
	mov	w11,Atemp	; pre-load Accu temp
    249a:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    249c:	0b 07 78    	mov.w     w11, w14
; maintain logic diagram
	clr3leds
    249e:	f0 f8 2f    	mov.w     #0xff8f, w0
    24a0:	ae 29 b6    	and.w     0x9ae
; exec 
	clrc
    24a2:	42 00 a9    	bclr.b    0x42, #0x0
	btss	A16,#b_carry
    24a4:	af 89 ae    	btss.b    0x9af, #0x4
	setc			; CPL C unconditionally
    24a6:	42 00 a8    	bset.b    0x42, #0x0
	xor	w11,w12,w0
    24a8:	0c 80 6d    	xor.w     w11, w12, w0
	and	w0,#0x0F,w13	; write result to Accu in
    24aa:	ef 06 60    	and.w     w0, #0xf, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    24ac:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    24ae:	ca ff 37    	bra       0x2444 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    24b0:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    24b2:	0d 07 78    	mov.w     w13, w14
	mov	#7,w2		; constant to write to in/temp/out flag
    24b4:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    24b6:	2e 29 ef    	clr.w     0x92e
	bclr	A16,#b_carry	; Carry button LED
    24b8:	af 89 a9    	bclr.b    0x9af, #0x4
	cp0	w13
    24ba:	0d 00 e0    	cp0.w     w13
	ifz
    24bc:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; Z flag
    24be:	72 49 88    	mov.w     w2, 0x92e

	btsc	Cflag,#2
    24c0:	2c 49 af    	btsc.b    0x92c, #0x2
	clr	w2		; w2,#2,1,0 = complement Cflag,#2
    24c2:	00 01 eb    	clr.w     w2
	mov	w2,Cflag	; cpl C unconditionally (bits 2,1,0)
    24c4:	62 49 88    	mov.w     w2, 0x92c
	
	btsc	w2,#0
    24c6:	02 00 a7    	btsc.w    w2, #0x0
	bset	A16,#b_carry	; Carry button LED
    24c8:	af 89 a8    	bset.b    0x9af, #0x4

	mov.b	w13,[w7]	; write result to destination
    24ca:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    24cc:	89 84 e8    	inc2.w    w9, w9
    24ce:	09 e0 a7    	btsc.w    w9, #0xe
    24d0:	09 00 22    	mov.w     #0x2000, w9

	return
    24d2:	00 00 06    	return    

000024d4 <ind_8_8>:

ind_8_8:   ; -----------------------------------------------------    08  EXR N (T)
; IN register service
	mov	PORTB,w0
    24d4:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    24d6:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    24d8:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    24da:	00 4c 78    	mov.b     w0, [w8]

	clr	w11		; 1st operand = 0 (what else?)
    24dc:	80 05 eb    	clr.w     w11
; maintain logic diagram
	clr3leds
    24de:	f0 f8 2f    	mov.w     #0xff8f, w0
    24e0:	ae 29 b6    	and.w     0x9ae
	btsc	Flag,#2		; #2 set if Speed>0
    24e2:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slow08
    24e4:	0f 00 37    	bra       0x2504 <slow08>

	incpc			; w9++
    24e6:	89 84 e8    	inc2.w    w9, w9
    24e8:	09 e0 a7    	btsc.w    w9, #0xe
    24ea:	09 00 22    	mov.w     #0x2000, w9

000024ec <swapper>:
; exec 
swapper:
	mov	w12,w2
    24ec:	0c 01 78    	mov.w     w12, w2
	cp0	w2
    24ee:	02 00 e0    	cp0.w     w2
	ifz
    24f0:	42 20 af    	btsc.b    0x42, #0x1
	mov	#16,w2		; 0 members ---> 16 members
    24f2:	02 01 20    	mov.w     #0x10, w2
	mov	#Ram,w3
    24f4:	03 80 20    	mov.w     #0x800, w3
	mov	#Ram+(14*16),w4	; page 14
    24f6:	04 8e 20    	mov.w     #0x8e0, w4

000024f8 <L210>:
2:
	ze	[w4],w0		; [page 14] ---> w0
    24f8:	14 80 fb    	ze        [w4], w0
	mov.b	[w3],[w4++]	;  [page 0] ---> [page 14]
    24fa:	13 5a 78    	mov.b     [w3], [w4++]
	mov.b	w0,[w3++]	;        w0 ---> [page 0]
    24fc:	80 59 78    	mov.b     w0, [w3++]
	dec	w2,w2
    24fe:	02 01 e9    	dec.w     w2, w2
	bra	nz,2b		; swap loop -------->
    2500:	fb ff 3a    	bra       NZ, 0x24f8 <L210>
	return
    2502:	00 00 06    	return    

00002504 <slow08>:
slow08:
	mov	#0x03,w7	; flag "EXR N" instead of "MOV W13,[W7]"
    2504:	37 00 20    	mov.w     #0x3, w7
	mov	#0b0000,w6	; move VZCA
    2506:	06 00 20    	mov.w     #0x0, w6
	return
    2508:	00 00 06    	return    

0000250a <ind_8_9>:

ind_8_9:   ; -----------------------------------------------------    09  BIT RG,M (T)
; IN register service
	mov	PORTB,w0
    250a:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    250c:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    250e:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    2510:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    2512:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    2514:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2516:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if reading from reg 0, 1, 2
    2518:	03 00 3a    	bra       NZ, 0x2520 <L118>
; if reading from reg 3 (IN port)
	mov	#0x0B,w0	; R0A (IN A)
    251a:	b0 00 20    	mov.w     #0xb, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    251c:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFB,w0	; RFA (IN B)
    251e:	b0 0f 20    	mov.w     #0xfb, w0

00002520 <L118>:
1:
	add	w10,w0,w7	; result write address
    2520:	80 03 45    	add.w     w10, w0, w7

00002522 <dir_8_9>:
dir_8_9:
	ze	[w7],w11	; value of addressed nibble
    2522:	97 85 fb    	ze        [w7], w11
	ze	[w7],w13	; this cancels later writing to [w7] (in routine "phases")
    2524:	97 86 fb    	ze        [w7], w13
	and	w12,#3,w2	; w2 = M isolated
    2526:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2528:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    252a:	02 06 dd    	sl.w      w0, w2, w12
; exec 
	and	w12,w11,w0	; only flag Z is the result
    252c:	0b 00 66    	and.w     w12, w11, w0
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    252e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZflag0100
    2530:	08 00 37    	bra       0x2542 <slowZflag0100>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	#7,w2		; constant to write to in/temp/out flag
    2532:	72 00 20    	mov.w     #0x7, w2
	clr	Zflag
    2534:	2e 29 ef    	clr.w     0x92e
	ifz
    2536:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    2538:	72 49 88    	mov.w     w2, 0x92e

	incpc			; w9++
    253a:	89 84 e8    	inc2.w    w9, w9
    253c:	09 e0 a7    	btsc.w    w9, #0xe
    253e:	09 00 22    	mov.w     #0x2000, w9

	return
    2540:	00 00 06    	return    

00002542 <slowZflag0100>:
slowZflag0100:
	mov	#0b0100,w6	; move VZCA
    2542:	46 00 20    	mov.w     #0x4, w6
	bclr	Zflag,#0
    2544:	2e 09 a9    	bclr.b    0x92e, #0x0
	ifz
    2546:	42 20 af    	btsc.b    0x42, #0x1
	bset	Zflag,#0
    2548:	2e 09 a8    	bset.b    0x92e, #0x0
	return
    254a:	00 00 06    	return    

0000254c <ind_8_10>:

ind_8_10:   ; -----------------------------------------------------    0A  BSET RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    254c:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    254e:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2550:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    2552:	03 00 3a    	bra       NZ, 0x255a <L119>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    2554:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    2556:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    2558:	a0 0f 20    	mov.w     #0xfa, w0

0000255a <L119>:
1:
	add	w10,w0,w7	; result write address
    255a:	80 03 45    	add.w     w10, w0, w7

0000255c <dir_8_10>:
dir_8_10:
	ze	[w7],w11	; value of addressed nibble
    255c:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    255e:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2560:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    2562:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2564:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    2566:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    2568:	f0 f8 2f    	mov.w     #0xff8f, w0
    256a:	ae 29 b6    	and.w     0x9ae
; exec 
	ior	w12,w11,w13	; w11 with bit set to Accu in
    256c:	8b 06 76    	ior.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    256e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2570:	51 fe 37    	bra       0x2214 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    2572:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2574:	89 84 e8    	inc2.w    w9, w9
    2576:	09 e0 a7    	btsc.w    w9, #0xe
    2578:	09 00 22    	mov.w     #0x2000, w9

	return
    257a:	00 00 06    	return    

0000257c <ind_8_11>:

ind_8_11:   ; -----------------------------------------------------    0B  BCLR RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    257c:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    257e:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    2580:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    2582:	03 00 3a    	bra       NZ, 0x258a <L120>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    2584:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    2586:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    2588:	a0 0f 20    	mov.w     #0xfa, w0

0000258a <L120>:
1:
	add	w10,w0,w7	; result write address
    258a:	80 03 45    	add.w     w10, w0, w7

0000258c <dir_8_11>:
dir_8_11:
	ze	[w7],w11	; value of addressed nibble
    258c:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    258e:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    2590:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    2592:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    2594:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    2596:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    2598:	f0 f8 2f    	mov.w     #0xff8f, w0
    259a:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,#0x0F,w0
    259c:	6f 00 6e    	xor.w     w12, #0xf, w0
	and	w0,w11,w13	; w11 with bit reset to Accu in
    259e:	8b 06 60    	and.w     w0, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    25a0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    25a2:	38 fe 37    	bra       0x2214 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    25a4:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    25a6:	89 84 e8    	inc2.w    w9, w9
    25a8:	09 e0 a7    	btsc.w    w9, #0xe
    25aa:	09 00 22    	mov.w     #0x2000, w9

	return
    25ac:	00 00 06    	return    

000025ae <ind_8_12>:

ind_8_12:   ; -----------------------------------------------------    0C  BTG RG,M (T)
; get indirect value from RG (bits 3,2 of OperY)
	and	w12,#0x0C,w0	; bits 3,2 = register
    25ae:	6c 00 66    	and.w     w12, #0xc, w0
	lsr	w0,#2,w0
    25b0:	42 00 de    	lsr.w     w0, #0x2, w0
	cp	w0,#3
    25b2:	63 00 e1    	cp.w      w0, #0x3
	bra	nz,1f		; if writing to reg 0, 1, 2
    25b4:	03 00 3a    	bra       NZ, 0x25bc <L121>
; if writing to reg 3 (OUT port)
	mov	#0x0A,w0	; R0A (OUT A)
    25b6:	a0 00 20    	mov.w     #0xa, w0
	btsc.b	WrFlags,#1	; WRFlags,  InOutPos
    25b8:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov	#0xFA,w0	; RFA (OUT B)
    25ba:	a0 0f 20    	mov.w     #0xfa, w0

000025bc <L121>:
1:
	add	w10,w0,w7	; result write address
    25bc:	80 03 45    	add.w     w10, w0, w7

000025be <dir_8_12>:
dir_8_12:
	ze	[w7],w11	; value of addressed nibble
    25be:	97 85 fb    	ze        [w7], w11
	mov	w11,Atemp	; pre-load Accu temp
    25c0:	4b 49 88    	mov.w     w11, 0x928
	mov	w11,w14		; pre-load Accu out
    25c2:	0b 07 78    	mov.w     w11, w14
	and	w12,#3,w2	; w2 = M isolated
    25c4:	63 01 66    	and.w     w12, #0x3, w2
	mov	#1,w0
    25c6:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w2,w12	; now w12 is with addressed bit set
    25c8:	02 06 dd    	sl.w      w0, w2, w12
; maintain logic diagram
	clr3leds
    25ca:	f0 f8 2f    	mov.w     #0xff8f, w0
    25cc:	ae 29 b6    	and.w     0x9ae
; exec 
	xor	w12,w11,w13	; w11 with bit flipped to Accu in
    25ce:	8b 06 6e    	xor.w     w12, w11, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    25d0:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    25d2:	20 fe 37    	bra       0x2214 <phases_0>
	mov.b	w13,[w7]	; write result to destination
    25d4:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    25d6:	89 84 e8    	inc2.w    w9, w9
    25d8:	09 e0 a7    	btsc.w    w9, #0xe
    25da:	09 00 22    	mov.w     #0x2000, w9

	return
    25dc:	00 00 06    	return    

000025de <ind_8_13>:

ind_8_13:   ; -----------------------------------------------------    0D  RRC RY (T)
; IN register service
	mov	PORTB,w0
    25de:	c0 33 80    	mov.w     0x678, w0
	lsr	w0,#4,w0
    25e0:	44 00 de    	lsr.w     w0, #0x4, w0
	and	#0x0F,w0
    25e2:	f0 00 b2    	and.w     #0xf, w0
	mov.b	w0,[w8]		; #Ram+0x0B or #Ram+0xFF
    25e4:	00 4c 78    	mov.b     w0, [w8]
; get indirect value from OperY
	add	w10,w12,w7	; result write address
    25e6:	8c 03 45    	add.w     w10, w12, w7
	mov.b	[w10+w12],w12	; Y value
    25e8:	6a 46 7e    	mov.b     [w10+w12], w12

000025ea <dir_8_13>:
dir_8_13:
	clr	w11		; clr oper 1 (will be displayed)
    25ea:	80 05 eb    	clr.w     w11
	mov	w12,Atemp	; pre-load Accu temp
    25ec:	4c 49 88    	mov.w     w12, 0x928
	mov	w12,w14		; pre-load Accu out
    25ee:	0c 07 78    	mov.w     w12, w14
; maintain logic diagram
	clr3leds
    25f0:	f0 f8 2f    	mov.w     #0xff8f, w0
    25f2:	ae 29 b6    	and.w     0x9ae
; exec 
	btsc	A16,#b_carry
    25f4:	af 89 af    	btsc.b    0x9af, #0x4
	bset	w12,#4		; Carry flag for 4-bit operand
    25f6:	0c 40 a0    	bset.w    w12, #0x4
	lsr	w12,w13		; write result straight to Accu in
    25f8:	8c 06 d1    	lsr.w     w12, w13
; get flags
	btsc	Flag,#2		; #2 set if Speed>0
    25fa:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	slowZCAflag0111
    25fc:	23 ff 37    	bra       0x2444 <slowZCAflag0111>
				; fast simplified VZCA flags (no bit #1 and #2 shifts)
	mov	w13,Atemp
    25fe:	4d 49 88    	mov.w     w13, 0x928
	mov	w13,w14		; propagate result to all Accumulator steps
    2600:	0d 07 78    	mov.w     w13, w14
	clr	Zflag
    2602:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    2604:	2c 29 ef    	clr.w     0x92c
	bclr	A16,#b_carry	; Carry button LED
    2606:	af 89 a9    	bclr.b    0x9af, #0x4
	mov	#7,w2		; constant to write to in/temp/out flag
    2608:	72 00 20    	mov.w     #0x7, w2
	ifz
    260a:	42 20 af    	btsc.b    0x42, #0x1
	mov	w2,Zflag	; if Z flag set
    260c:	72 49 88    	mov.w     w2, 0x92e
	ifc
    260e:	42 00 af    	btsc.b    0x42, #0x0
	mov	w2,Cflag	; if C flag set
    2610:	62 49 88    	mov.w     w2, 0x92c
	ifc
    2612:	42 00 af    	btsc.b    0x42, #0x0
	bset	A16,#b_carry	; Carry button LED
    2614:	af 89 a8    	bset.b    0x9af, #0x4
	mov.b	w13,[w7]	; write result to destination
    2616:	8d 4b 78    	mov.b     w13, [w7]

	incpc			; w9++
    2618:	89 84 e8    	inc2.w    w9, w9
    261a:	09 e0 a7    	btsc.w    w9, #0xe
    261c:	09 00 22    	mov.w     #0x2000, w9

	return
    261e:	00 00 06    	return    

00002620 <ind_8_14>:

ind_8_14:   ; -----------------------------------------------------    0E  RET R0,N (T)
	clr	w11		; will be displayed
    2620:	80 05 eb    	clr.w     w11
	mov.b	w12,w13		; preset #N to Acc in
    2622:	8c 46 78    	mov.b     w12, w13
	mov.b	[w10],w14	; preset previous R0 to Acc out
    2624:	1a 47 78    	mov.b     [w10], w14
	mov	w14,Atemp	; preset previous R0 to Acc temp
    2626:	4e 49 88    	mov.w     w14, 0x928
	mov	#0x04,w7	; flag "RET R0,N" instead of "MOV W13,[W7]"
    2628:	47 00 20    	mov.w     #0x4, w7
; maintain logic diagram
	clr3leds
    262a:	f0 f8 2f    	mov.w     #0xff8f, w0
    262c:	ae 29 b6    	and.w     0x9ae
; exec
	mov	Stack,w0
    262e:	50 49 80    	mov.w     0x92a, w0
	mul.uu	w0,#3,w0	; w0:w1
    2630:	63 00 b8    	mul.uu    w0, #0x3, w0
	add	#16-1,w0	; stack starts at Ram+16
    2632:	f0 00 b0    	add.w     #0xf, w0
	add	w0,w10,w1	; stack starts at Ram+16
    2634:	8a 00 40    	add.w     w0, w10, w1
	ze	[w1--],w0	; high nibble of ret addr
    2636:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0
    2638:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1--],w0	; medium nibble of ret addr
    263a:	21 40 70    	ior.b     w0, [w1--], w0
	sl	w0,#4,w0
    263c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; low nibble of ret addr
    263e:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,w0		; ×2
    2640:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w5
    2642:	05 00 22    	mov.w     #0x2000, w5
	add	w0,w5,w5	; ret address
    2644:	85 02 40    	add.w     w0, w5, w5
	btss	Flag,#2		; #2 set if Speed>0
    2646:	dc 49 ae    	btss.b    0x9dc, #0x2
	bra	spec4
    2648:	f0 fb 37    	bra       0x1e2a <spec4>
	bra	phases_0
    264a:	e4 fd 37    	bra       0x2214 <phases_0>

0000264c <ind_8_15>:

ind_8_15:   ; -----------------------------------------------------    0F  SKIP F,M (T)
	clr	w11		; will be displayed
    264c:	80 05 eb    	clr.w     w11
	mov	#0x06,w7	; flag "SKIP F,M" instead of "MOV W13,[W7]"
    264e:	67 00 20    	mov.w     #0x6, w7
; maintain logic diagram
	clr3leds
    2650:	f0 f8 2f    	mov.w     #0xff8f, w0
    2652:	ae 29 b6    	and.w     0x9ae
; exec
	and	w12,#3,w0	; w0 skip format
    2654:	63 00 66    	and.w     w12, #0x3, w0
	ifz
    2656:	42 20 af    	btsc.b    0x42, #0x1
	mov	#4,w0		; skip 0 = skip 4
    2658:	40 00 20    	mov.w     #0x4, w0
	sl	w0,w0		; ×2
    265a:	00 00 d0    	sl.w      w0, w0
	lsr	w12,#2,w1	; w1 = condition
    265c:	c2 60 de    	lsr.w     w12, #0x2, w1
	and	#3,w1
    265e:	31 00 b2    	and.w     #0x3, w1
	bra	w1
    2660:	01 60 01    	bra       w1
;.........................
	bra	skip_C
    2662:	03 00 37    	bra       0x266a <skip_C>
	bra	skip_NC
    2664:	06 00 37    	bra       0x2672 <skip_NC>
	bra	skip_Z
    2666:	09 00 37    	bra       0x267a <skip_Z>
	bra	skip_NZ
    2668:	0c 00 37    	bra       0x2682 <skip_NZ>

0000266a <skip_C>:
skip_C:
	mov	w9,w5
    266a:	89 02 78    	mov.w     w9, w5
	btsc	A16,#b_carry	; cc0: C
    266c:	af 89 af    	btsc.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    266e:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    2670:	0b 00 37    	bra       0x2688 <skr_skip>

00002672 <skip_NC>:
skip_NC:
	mov	w9,w5
    2672:	89 02 78    	mov.w     w9, w5
	btss	A16,#b_carry	; cc1: NC
    2674:	af 89 ae    	btss.b    0x9af, #0x4
	add	w5,w0,w5	; skip
    2676:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    2678:	07 00 37    	bra       0x2688 <skr_skip>

0000267a <skip_Z>:
skip_Z:
	mov	w9,w5
    267a:	89 02 78    	mov.w     w9, w5
	btsc	Zflag,#2	; cc2: Z
    267c:	2e 49 af    	btsc.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    267e:	80 82 42    	add.w     w5, w0, w5
	bra	skr_skip
    2680:	03 00 37    	bra       0x2688 <skr_skip>

00002682 <skip_NZ>:
skip_NZ:
	mov	w9,w5
    2682:	89 02 78    	mov.w     w9, w5
	btss	Zflag,#2	; cc3: NZ
    2684:	2e 49 ae    	btss.b    0x92e, #0x2
	add	w5,w0,w5	; skip
    2686:	80 82 42    	add.w     w5, w0, w5

00002688 <skr_skip>:
skr_skip:
	inc2	w5,w5		; because INC2 W5 will not be executed like INC2 W9
    2688:	85 82 e8    	inc2.w    w5, w5
	btsc	w5,#14
    268a:	05 e0 a7    	btsc.w    w5, #0xe
	mov	#Rom,w5		; wrap to start of program memory
    268c:	05 00 22    	mov.w     #0x2000, w5

	btsc	Flag,#2		; #2 set if Speed>0
    268e:	dc 49 af    	btsc.b    0x9dc, #0x2
	bra	phases_0
    2690:	c1 fd 37    	bra       0x2214 <phases_0>

	mov	w5,w9
    2692:	85 04 78    	mov.w     w5, w9
	bra	w9range
    2694:	b9 fb 37    	bra       0x1e08 <w9range>

00002696 <set_T2_from_Speed>:

; ---------------------------------------------------------------------------
set_T2_from_Speed:
	mov.b	Speed,WREG
    2696:	f1 c8 bf    	mov.b     0x8f1, WREG

00002698 <set_T2_from_w0>:
set_T2_from_w0:
	and	#0x0F,w0
    2698:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Speed	; Speed index, bit 3210
    269a:	f1 e8 b7    	mov.b     WREG, 0x8f1
	clr	TBLPAG
    269c:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(clk_table),w1
    269e:	81 32 23    	mov.w     #0x3328, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    26a0:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(clk_table_high),w1
    26a2:	81 36 23    	mov.w     #0x3368, w1
	bclr	T2CON,#TON	; stop Timer 2
    26a4:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	clr	TMR2		; clear timing counter
    26a6:	96 21 ef    	clr.w     0x196
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    26a8:	dc 49 a8    	bset.b    0x9dc, #0x2
	  cp0.b	  w0
    26aa:	00 04 e0    	cp0.b     w0
	  ifz
    26ac:	42 20 af    	btsc.b    0x42, #0x1
	  bclr	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    26ae:	dc 49 a9    	bclr.b    0x9dc, #0x2
	bclr	IFS0,#7		; clr int flag
    26b0:	88 e0 a9    	bclr.b    0x88, #0x7
	sl	w0,#2,w0	; × 4
    26b2:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Speed × 4
    26b4:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    26b6:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR2		; update T2 divider value
    26b8:	e1 0c 88    	mov.w     w1, 0x19c
	tblrdl	[w0++],w0
    26ba:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T2CON	; update prescaler value (low byte only)
    26bc:	a0 e1 b7    	mov.b     WREG, 0x1a0
	  dec2	  Mode,WREG
    26be:	76 89 ed    	dec2.w    0x976, WREG
	  ifnz
    26c0:	42 20 ae    	btss.b    0x42, #0x1
	  bset	  Flag,#2	; #2 set if Speed > 0 or if Mode <> 2
    26c2:	dc 49 a8    	bset.b    0x9dc, #0x2
	bset	T2CON,#TON	; start Timer 2
    26c4:	a1 e1 a8    	bset.b    0x1a1, #0x7
	return
    26c6:	00 00 06    	return    

000026c8 <set_T3_from_Sync>:

; ---------------------------------------------------------------------------
set_T3_from_Sync:
	mov.b	Sync,WREG
    26c8:	f2 c8 bf    	mov.b     0x8f2, WREG

000026ca <set_T3_from_w0>:
set_T3_from_w0:
	and	#0x0F,w0
    26ca:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Sync	; Sync index, bit 3210
    26cc:	f2 e8 b7    	mov.b     WREG, 0x8f2
	clr	TBLPAG
    26ce:	54 20 ef    	clr.w     0x54
	mov	#tbloffset(sync_table),w1
    26d0:	81 3a 23    	mov.w     #0x33a8, w1
	btsc	Flag2,#0	; #0 set if FAST mode
    26d2:	de 09 af    	btsc.b    0x9de, #0x0
	mov	#tbloffset(sync_table_high),w1
    26d4:	81 3e 23    	mov.w     #0x33e8, w1
	bclr	T3CON,#TON	; stop Timer 3
    26d6:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	clr	TMR3		; clear timing counter
    26d8:	9a 21 ef    	clr.w     0x19a
	bclr	IFS0,#8		; clr int flag
    26da:	89 00 a9    	bclr.b    0x89, #0x0
	bclr.b	RdFlags,#0	; clr Sync flag
    26dc:	f4 08 a9    	bclr.b    0x8f4, #0x0
	sl	w0,#2,w0	; × 4
    26de:	42 00 dd    	sl.w      w0, #0x2, w0
	add	w1,w0,w0	; table + Sync × 4
    26e0:	00 80 40    	add.w     w1, w0, w0
	tblrdl	[w0++],w1
    26e2:	b0 00 ba    	tblrdl.w  [w0++], w1
	mov	w1,PR3		; update T3 divider value
    26e4:	f1 0c 88    	mov.w     w1, 0x19e
	tblrdl	[w0++],w0
    26e6:	30 00 ba    	tblrdl.w  [w0++], w0
	mov.b	WREG,T3CON	; update prescaler value (low byte only)
    26e8:	a2 e1 b7    	mov.b     WREG, 0x1a2
	bset	T3CON,#TON	; start Timer 3
    26ea:	a3 e1 a8    	bset.b    0x1a3, #0x7
	return
    26ec:	00 00 06    	return    

000026ee <rnd>:

; ------------------------------------------------------------------------------
rnd:				; RND to w0 bits 3-0
;           not needed       needed1          needed2
; AB * CD = (A*C << 32) + ((B*C + A*D) << 16) + B*D
; A=w5:B=w4 × C=w3=0x41c6:D=w2=4e6d + 0x6073 ---> w4:w5

	mov	Rndhi,w5	; existing hi
    26ee:	35 4e 80    	mov.w     0x9c6, w5
	mov	Rndlo,w4	; existing lo
    26f0:	24 4e 80    	mov.w     0x9c4, w4
	mov	#0x41c6,w3	; hi
    26f2:	63 1c 24    	mov.w     #0x41c6, w3
	mov	#0x4e6d,w2	; lo
    26f4:	d2 e6 24    	mov.w     #0x4e6d, w2

	mul.uu	w4,w3,w0	; B*C ---> w0(:w1)
    26f6:	03 20 b8    	mul.uu    w4, w3, w0
	mov	w0,w6		; ---> w6
    26f8:	00 03 78    	mov.w     w0, w6
	mul.uu	w5,w2,w0	; A*D ---> w0(:w1)
    26fa:	02 28 b8    	mul.uu    w5, w2, w0
	add	w0,w6,w3	; w3 = needed1
    26fc:	86 01 40    	add.w     w0, w6, w3

	mul.uu	w4,w2,w4	; B*D ---> w4:w5 = needed2 (w4 low word)
    26fe:	02 22 b8    	mul.uu    w4, w2, w4
	add	w5,w3,w5	; w5 high word
    2700:	83 82 42    	add.w     w5, w3, w5

	mov	#0x6073,w3
    2702:	33 07 26    	mov.w     #0x6073, w3
	add	w4,w3,w4	; lo + 0x6073 --> lo
    2704:	03 02 42    	add.w     w4, w3, w4
	addc	w5,#0,w5	; hi + Carry ---> hi
    2706:	e0 82 4a    	addc.w    w5, #0x0, w5
    ; w4:w5 ---> rnd seed
	mov	w4,Rndlo	; new lo
    2708:	24 4e 88    	mov.w     w4, 0x9c4
	mov	w5,Rndhi	; new hi
    270a:	35 4e 88    	mov.w     w5, 0x9c6

0000270c <extract4bits>:
extract4bits:
	xor	w4,w5,w0	; [w5] 31-16  XOR  [w4] 15-00  --->  [w0] 15-0
    270c:	05 00 6a    	xor.w     w4, w5, w0
	add.b	_WREG0+1,WREG	; [w0] 15-08   +   [w0] 07-00  --->  [w0] 7-0
    270e:	01 40 b4    	add.b     0x1, WREG
	lsr	w0,#4,w2
    2710:	44 01 de    	lsr.w     w0, #0x4, w2
	xor	w0,w2,w0	; [w2] 07-04  XOR  [w0] 03-00  --->  [w0] 3-0
    2712:	02 00 68    	xor.w     w0, w2, w0
	and	w0,#0x0F,w0	; RND in w0 bits 3-0
    2714:	6f 00 60    	and.w     w0, #0xf, w0
	return
    2716:	00 00 06    	return    

00002718 <getrnd>:

getrnd:
	mov	Rndlo,w4	; existing lo
    2718:	24 4e 80    	mov.w     0x9c4, w4
	mov	Rndhi,w5	; existing hi
    271a:	35 4e 80    	mov.w     0x9c6, w5
	bra	extract4bits
    271c:	f7 ff 37    	bra       0x270c <extract4bits>

0000271e <perform_SFR_write>:

; ------------------------------------------------------------------------------
perform_SFR_write:
	bclr	Flag,#9		; #9 set if instruction is writing to SFR area
    271e:	dd 29 a9    	bclr.b    0x9dd, #0x1
	and	#0x0f,w5
    2720:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    2722:	05 60 01    	bra       w5
;...
	return
    2724:	00 00 06    	return    
	bra	SFR_write_1
    2726:	0e 00 37    	bra       0x2744 <SFR_write_1>
	bra	SFR_write_2
    2728:	10 00 37    	bra       0x274a <SFR_write_2>
	bra	SFR_write_3
    272a:	12 00 37    	bra       0x2750 <SFR_write_3>
	return
    272c:	00 00 06    	return    
	bra	SFR_write_5
    272e:	1d 00 37    	bra       0x276a <SFR_write_5>
	bra	SFR_write_6
    2730:	1e 00 37    	bra       0x276e <SFR_write_6>
	return
    2732:	00 00 06    	return    
	bra	SFR_write_8
    2734:	23 00 37    	bra       0x277c <SFR_write_8>
	bra	SFR_write_9
    2736:	29 00 37    	bra       0x278a <SFR_write_9>
	return
    2738:	00 00 06    	return    
	return
    273a:	00 00 06    	return    
	return
    273c:	00 00 06    	return    
	return
    273e:	00 00 06    	return    
	return
    2740:	00 00 06    	return    
	bra	SFR_write_15
    2742:	26 00 37    	bra       0x2790 <SFR_write_15>

00002744 <SFR_write_1>:
;...
SFR_write_1:		; Speed
	call	set_T2_from_Speed
    2744:	96 26 02    	call      0x2696 <set_T2_from_Speed>
    2746:	00 00 00 
	return
    2748:	00 00 06    	return    

0000274a <SFR_write_2>:
;	
SFR_write_2:		; Sync
	call	set_T3_from_Sync
    274a:	c8 26 02    	call      0x26c8 <set_T3_from_Sync>
    274c:	00 00 00 
	return
    274e:	00 00 06    	return    

00002750 <SFR_write_3>:
;	
SFR_write_3:		; WrFlags (PinPos); in: SerCtrl,#3=0...1,  out: RPINR, RPOR
	mov.b	SerCtrl,WREG
    2750:	f5 c8 bf    	mov.b     0x8f5, WREG

00002752 <sel_pinpos>:
sel_pinpos:
	btss.b	WrFlags,#0	; #0 RxTxPos
    2752:	f3 08 ae    	btss.b    0x8f3, #0x0
	bra	RxTx0
    2754:	05 00 37    	bra       0x2760 <RxTx0>
; RxTxPos=1 (Rx and Tx are on I/O connector)
	btsc	Flag2,#3	; #3 Previous RxTxPos
    2756:	de 69 af    	btsc.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    2758:	07 00 37    	bra       0x2768 <WrFlags_next>
	  call	  rxtx_to_io	; SWITCH RxTx to IO
    275a:	9e 28 02    	call      0x289e <rxtx_to_io>
    275c:	00 00 00 
	bra	WrFlags_next
    275e:	04 00 37    	bra       0x2768 <WrFlags_next>

00002760 <RxTx0>:
RxTx0:
	btss	Flag2,#3	; #3 Previous RxTxPos
    2760:	de 69 ae    	btss.b    0x9de, #0x3
	bra	WrFlags_next	; if nothing new on RxTxPos
    2762:	02 00 37    	bra       0x2768 <WrFlags_next>
	  call	  rxtx_to_sao	; SWITCH RxTx to SAO
    2764:	8c 28 02    	call      0x288c <rxtx_to_sao>
    2766:	00 00 00 

00002768 <WrFlags_next>:
WrFlags_next:
	return
    2768:	00 00 06    	return    

0000276a <SFR_write_5>:
;	
SFR_write_5:		; SerCtrl (SERVICE BaudRate)
	and	w13,#0x07,w0
    276a:	67 80 66    	and.w     w13, #0x7, w0
	bra	set_U1BRG_from_w0
    276c:	75 00 37    	bra       0x2858 <set_U1BRG_from_w0>

0000276e <SFR_write_6>:
;	
SFR_write_6:		; SerLow (TX BYTE)
	mov.b	SerHigh,WREG
    276e:	f7 c8 bf    	mov.b     0x8f7, WREG
	sl	w0,#4,w0
    2770:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerLow,WREG
    2772:	f6 48 b7    	ior.b     0x8f6, WREG

00002774 <waittx_2>:
waittx_2:
	btsc	U1STA,#UTXBF
    2774:	9b 23 af    	btsc.b    0x39b, #0x1
	bra	waittx_2
    2776:	fe ff 37    	bra       0x2774 <waittx_2>
	mov.b	WREG,U1TXREG	; ----> transmit w0
    2778:	9c e3 b7    	mov.b     WREG, 0x39c
	return
    277a:	00 00 06    	return    

0000277c <SFR_write_8>:
;	
SFR_write_8:		; Received
	cp0.b	Received
    277c:	f8 48 e2    	cp0.b     0x8f8
	bra	nz,go_cont_8_2
    277e:	03 00 3a    	bra       NZ, 0x2786 <go_cont_8_2>
	mov	#RX_buf,w0
    2780:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    2782:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    2784:	f0 4d 88    	mov.w     w0, 0x9be

00002786 <go_cont_8_2>:
go_cont_8_2:
	ifnz
    2786:	42 20 ae    	btss.b    0x42, #0x1
	return
    2788:	00 00 06    	return    

0000278a <SFR_write_9>:
;	
SFR_write_9:		; AutoOff
; as the destination is AutoOff, AutoOff_Hi must be preloaded
	mov	#37500,w0
    278a:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    278c:	b0 4d 88    	mov.w     w0, 0x9b6
	return
    278e:	00 00 06    	return    

00002790 <SFR_write_15>:
;	
SFR_write_15:		; RND
	cp.b	w13,#15
    2790:	6f 6c e1    	cp.b      w13, #0xf
	bra	z,seed15
    2792:	09 00 32    	bra       Z, 0x27a6 <seed15>
	sl	w13,#4,w0
    2794:	44 68 dd    	sl.w      w13, #0x4, w0
	ior	w13,w0,w0	; 4 ---> 8 bits
    2796:	00 80 76    	ior.w     w13, w0, w0
	sl	w0,#8,w13
    2798:	c8 06 dd    	sl.w      w0, #0x8, w13
	ior	w13,w0,w0	; 8 ---> 16 bits
    279a:	00 80 76    	ior.w     w13, w0, w0
	mov	w0,Rndhi
    279c:	30 4e 88    	mov.w     w0, 0x9c6
	mov	w0,Rndlo
    279e:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    27a0:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    27a2:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    27a4:	00 00 06    	return    

000027a6 <seed15>:
seed15:			; if seed=15, then total RND
	mov	TMR2,w0
    27a6:	b0 0c 80    	mov.w     0x196, w0
	sl	w0,#4,w0
    27a8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	RowScan,WREG
    27aa:	78 49 b7    	ior.b     0x978, WREG
	sl	w0,#4,w0
    27ac:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	TMR1,WREG
    27ae:	90 41 b7    	ior.b     0x190, WREG
	mov	w0,Rndhi
    27b0:	30 4e 88    	mov.w     w0, 0x9c6
	mov	AutoOff_Hi,w1
    27b2:	b1 4d 80    	mov.w     0x9b6, w1
	xor	w0,w1,w0
    27b4:	01 00 68    	xor.w     w0, w1, w0
	mov	w0,Rndlo
    27b6:	20 4e 88    	mov.w     w0, 0x9c4
	and	#0x0F,w0
    27b8:	f0 00 b2    	and.w     #0xf, w0
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    27ba:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    27bc:	00 00 06    	return    

000027be <perform_SFR_read>:

; ------------------------------------------------------------------------------

perform_SFR_read:
	bclr	Flag,#10	; #10 set if instruction is reading from SFR area
    27be:	dd 49 a9    	bclr.b    0x9dd, #0x2
	and	#0x0f,w5
    27c0:	f5 00 b2    	and.w     #0xf, w5
	bra	w5
    27c2:	05 60 01    	bra       w5
;...
	return
    27c4:	00 00 06    	return    
	return
    27c6:	00 00 06    	return    
	return
    27c8:	00 00 06    	return    
	return
    27ca:	00 00 06    	return    
	bra	SFR_read_4
    27cc:	0b 00 37    	bra       0x27e4 <SFR_read_4>
	bra	SFR_read_5
    27ce:	15 00 37    	bra       0x27fa <SFR_read_5>
	bra	SFR_read_6
    27d0:	16 00 37    	bra       0x27fe <SFR_read_6>
	return
    27d2:	00 00 06    	return    
	return
    27d4:	00 00 06    	return    
	return
    27d6:	00 00 06    	return    
	return	;bra	SFR_read_10
    27d8:	00 00 06    	return    
	return
    27da:	00 00 06    	return    
	bra	SFR_read_12
    27dc:	2d 00 37    	bra       0x2838 <SFR_read_12>
	return
    27de:	00 00 06    	return    
	return
    27e0:	00 00 06    	return    
	bra	SFR_read_15
    27e2:	2f 00 37    	bra       0x2842 <SFR_read_15>

000027e4 <SFR_read_4>:
;...
SFR_read_4:		; RdFlags
	bclr	IEC0,#8		; disable Timer 3 interrupt
    27e4:	99 00 a9    	bclr.b    0x99, #0x0
	mov.b	RdFlags,WREG
    27e6:	f4 c8 bf    	mov.b     0x8f4, WREG
	and.b	Ram+0,WREG
    27e8:	00 48 b6    	and.b     0x800, WREG
	btss	w0,#0
    27ea:	00 00 a6    	btss.w    w0, #0x0
	bra	1f
    27ec:	04 00 37    	bra       0x27f6 <L122>
	mov.b	RdFlags,WREG
    27ee:	f4 c8 bf    	mov.b     0x8f4, WREG
	mov.b	WREG,Ram+0	; write to R0 again, timing is critical!
    27f0:	00 e8 b7    	mov.b     WREG, 0x800
	and	#0b1110,w0	; kill flag UserSync (#0)
    27f2:	e0 00 b2    	and.w     #0xe, w0
	mov.b	WREG,RdFlags
    27f4:	f4 e8 b7    	mov.b     WREG, 0x8f4

000027f6 <L122>:
1:
	bset	IEC0,#8		; enable Timer 3 interrupt
    27f6:	99 00 a8    	bset.b    0x99, #0x0
	return
    27f8:	00 00 06    	return    

000027fa <SFR_read_5>:
;	
SFR_read_5:
	bclr	SerCtrl,#3
    27fa:	f5 68 a9    	bclr.b    0x8f5, #0x3
	return
    27fc:	00 00 06    	return    

000027fe <SFR_read_6>:
;	
SFR_read_6:		; SerLow
	cp0.b	Received
    27fe:	f8 48 e2    	cp0.b     0x8f8
	ifz
    2800:	42 20 af    	btsc.b    0x42, #0x1
	return			; if zero received
    2802:	00 00 06    	return    
	bclr	IEC0,#11   ; \    disable RX1 interrupt
    2804:	99 60 a9    	bclr.b    0x99, #0x3
; move char from SerLow to r0
	mov.b	SerLow,WREG
    2806:	f6 c8 bf    	mov.b     0x8f6, WREG
	mov.b	w0,[w7]
    2808:	80 4b 78    	mov.b     w0, [w7]
	bclr	Flag2,#2	; clr handshaking flag (for FIFO ---> SerHigh:SerLow)
    280a:	de 49 a9    	bclr.b    0x9de, #0x2
; test if there is anything in FIFO...
	mov	RXRD,w0
    280c:	f0 4d 80    	mov.w     0x9be, w0
	cp.b	RXWR
    280e:	bc 49 e3    	cp.b      0x9bc
	bra	z,calc_rcvd	; if FIFO empty
    2810:	08 00 32    	bra       Z, 0x2822 <calc_rcvd>
; ...checked, FIFO > 0, move 1st char from FIFO to ser buf Ser L:H and inc RDPtr
	ze	[w0],w1		; w1 1st byte from FIFO
    2812:	90 80 fb    	ze        [w0], w1
	and	w1,#0x0F,w0	; low nibble
    2814:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    2816:	f6 e8 b7    	mov.b     WREG, 0x8f6
	lsr	w1,#4,w0	; hi nibble
    2818:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    281a:	f7 e8 b7    	mov.b     WREG, 0x8f7
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    281c:	de 49 a8    	bset.b    0x9de, #0x2
	inc.b	RXRD		; inc RD ptr (8-bit inc, to stay inside FIFO)
    281e:	be 69 ec    	inc.b     0x9be
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    2820:	de 49 a8    	bset.b    0x9de, #0x2

00002822 <calc_rcvd>:
calc_rcvd:
; calculate Received
	clr	w0		; to clear high byte
    2822:	00 00 eb    	clr.w     w0
	mov.b	RXWR,WREG
    2824:	bc c9 bf    	mov.b     0x9bc, WREG
	sub.b	RXRD,WREG	; RXRD-RXWR (byte mode, to stay in range 0000-00FF)
    2826:	be 49 b5    	sub.b     0x9be, WREG
	btsc	Flag2,#2	; handshaking flag (for FIFO ---> SerHigh:SerLow)
    2828:	de 49 af    	btsc.b    0x9de, #0x2
	inc	w0,w0		; plus char in Ser H:L (if any)
    282a:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    282c:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    282e:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    2830:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    2832:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	IEC0,#11   ; /    enable RX1 interrupt
    2834:	99 60 a8    	bset.b    0x99, #0x3
	return
    2836:	00 00 06    	return    

00002838 <SFR_read_12>:
;	
;SFR_read_10:		; KeyStatus
;	disi	#4
;	mov.b	KeyStatus,WREG
;	mov.b	WREG,Ram+0	; write to R0
;	bclr	KeyStatus,#0
;	return
;	
SFR_read_12:		; KeyStatus
	disi	#4
    2838:	04 00 fc    	disi      #0x4
	mov.b	KeyStatus,WREG
    283a:	fc c8 bf    	mov.b     0x8fc, WREG
	mov.b	WREG,Ram+0	; write to R0
    283c:	00 e8 b7    	mov.b     WREG, 0x800
	bclr	KeyStatus,#0
    283e:	fc 08 a9    	bclr.b    0x8fc, #0x0
	return
    2840:	00 00 06    	return    

00002842 <SFR_read_15>:
;	
SFR_read_15:		; RND
	call	getrnd
    2842:	18 27 02    	call      0x2718 <getrnd>
    2844:	00 00 00 
	mov.b	WREG,Ram+0	; write to R0
    2846:	00 e8 b7    	mov.b     WREG, 0x800

00002848 <new_rnd>:
new_rnd:
	call	rnd
    2848:	ee 26 02    	call      0x26ee <rnd>
    284a:	00 00 00 
	mov.b	WREG,Ram+0xFF	; write to RND SFR
    284c:	ff e8 b7    	mov.b     WREG, 0x8ff
	return
    284e:	00 00 06    	return    

00002850 <def_U1BRG>:

; ---------------------------------------------------------------------------
def_U1BRG:		; set Baud Rate to 9600
	mov	#3,w0
    2850:	30 00 20    	mov.w     #0x3, w0
	bra	set_U1BRG_from_w0
    2852:	02 00 37    	bra       0x2858 <set_U1BRG_from_w0>

00002854 <set_U1BRG>:
set_U1BRG:		; restore the original Baud Rate
	mov.b	SerCtrl,WREG
    2854:	f5 c8 bf    	mov.b     0x8f5, WREG
	and	#7,w0
    2856:	70 00 b2    	and.w     #0x7, w0

00002858 <set_U1BRG_from_w0>:
set_U1BRG_from_w0:	; in: w0,  out: U1BRG
	bclr	U1MODE,#15		; disable UART 1
    2858:	99 e3 a9    	bclr.b    0x399, #0x7
	clr	TBLPAG
    285a:	54 20 ef    	clr.w     0x54
	sl	w0,w0		; ×2
    285c:	00 00 d0    	sl.w      w0, w0
	mov	#tbloffset(baud_tab),w1
    285e:	81 87 22    	mov.w     #0x2878, w1
	add	w0,w1,w1
    2860:	81 00 40    	add.w     w0, w1, w1
	tblrdl	[w1],w0
    2862:	11 00 ba    	tblrdl.w  [w1], w0
	mov	w0,U1BRG
    2864:	00 1d 88    	mov.w     w0, 0x3a0
	bset	U1MODE,#15		; enable UART 1
    2866:	99 e3 a8    	bset.b    0x399, #0x7
	nop
    2868:	00 00 00    	nop       
	bset	U1STAL,#UTXEN	; enable TX 1 (must be after UART enable)
    286a:	9b 43 a8    	bset.b    0x39b, #0x2
	bset	U1STAL,#URXEN	; enable RX 1 (must be after UART enable)
    286c:	9b 83 a8    	bset.b    0x39b, #0x4
	clr.b	Received
    286e:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    2870:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    2872:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    2874:	f0 4d 88    	mov.w     w0, 0x9be
	return
    2876:	00 00 06    	return    

00002878 <baud_tab>:
    2878:	04 0d 00    	nop       
    287a:	82 06 00    	nop       
    287c:	40 03 00    	nop       
    287e:	a0 01 00    	nop       
    2880:	cf 00 00    	nop       
    2882:	67 00 00    	nop       
    2884:	44 00 00    	nop       
    2886:	22 00 00    	nop       

00002888 <rxtx_to_rxtxpos>:
baud_tab:
	.word	3333-1	;  0.  1200
	.word	1667-1	;  1.  2400
	.word	833-1	;  2.  4800
	.word	417-1	;  3.  9600
	.word	208-1	;  4.  19200
	.word	104-1	;  5.  38400
	.word	69-1	;  6.  57600
	.word	35-1	;  7.  115200
; ---------------------------------------------------
rxtx_to_rxtxpos:
	btsc.b	WrFlags,#0	; WrFlags,#0: RxTxPos
    2888:	f3 08 af    	btsc.b    0x8f3, #0x0
	bra	rxtx_to_io	; if RxTxPos=1
    288a:	09 00 37    	bra       0x289e <rxtx_to_io>

0000288c <rxtx_to_sao>:
rxtx_to_sao:
; B7 input now (GP input)
	bclr	U1MODE,#15		; disable UART 1
    288c:	99 e3 a9    	bclr.b    0x399, #0x7
	bset	TRISB,#7
    288e:	76 e6 a8    	bset.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to SAO connector
	mov	#26,w0		; RP26 PORT  (A0)... (0x3f to disable RX input)
    2890:	a0 01 20    	mov.w     #0x1a, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    2892:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    2894:	30 00 20    	mov.w     #0x3, w0
	mov.b	RPOR13+1	; ...to RP27 (A1)
    2896:	ef e7 bf    	mov.b     0x7ef
; disable old pin for Tx
	clr.b	RPOR3+1		; ...to RP7  (B7) (0x00 to return to default OUT port)
    2898:	db 67 ef    	clr.b     0x7db
	bclr	Flag2,#3	; #3 Previous RxTxPos
    289a:	de 69 a9    	bclr.b    0x9de, #0x3
	bra	skr_rxtx
    289c:	07 00 37    	bra       0x28ac <skr_rxtx>

0000289e <rxtx_to_io>:
;----------------------------------------------------
rxtx_to_io:
; B7 output now (Tx)
	bclr	U1MODE,#15		; disable UART 1
    289e:	99 e3 a9    	bclr.b    0x399, #0x7
	bclr	TRISB,#7
    28a0:	76 e6 a9    	bclr.b    0x676, #0x7
; Peripheral Pin Select <---- Rx and Tx pins to I/O connector
	mov	#6,w0		; RP6  PORT  (B6)...  (0x3f to disable RX input)
    28a2:	60 00 20    	mov.w     #0x6, w0
	mov.b	WREG,RPINR18	; ...to U1_RX
    28a4:	b4 e7 b7    	mov.b     WREG, 0x7b4
	mov	#3,w0		; #3=U1_TX...     (0x00 to return to default OUT port)
    28a6:	30 00 20    	mov.w     #0x3, w0
	mov.b	WREG,RPOR3+1	; ...to RP7  (B7)
    28a8:	db e7 b7    	mov.b     WREG, 0x7db
; disable old pin for Tx
;	clr.b	RPOR13+1	; ...to RP27 (A1) (0x00 to return to default OUT port)
	bset	Flag2,#3	; #3 Previous RxTxPos
    28aa:	de 69 a8    	bset.b    0x9de, #0x3

000028ac <skr_rxtx>:
skr_rxtx:
	bset	U1MODE,#15		; enable UART 1
    28ac:	99 e3 a8    	bset.b    0x399, #0x7
	clr.b	Received
    28ae:	f8 68 ef    	clr.b     0x8f8
	mov	#RX_buf,w0
    28b0:	00 60 24    	mov.w     #0x4600, w0
	mov	w0,RXWR
    28b2:	e0 4d 88    	mov.w     w0, 0x9bc
	mov	w0,RXRD
    28b4:	f0 4d 88    	mov.w     w0, 0x9be
	return
    28b6:	00 00 06    	return    

000028b8 <leave_run_ept>:

; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------
; ---------------------------------------------------------------------------------

leave_run_ept:
; save RUN variables to RUN Temp
	mov	Stack,w0
    28b8:	50 49 80    	mov.w     0x92a, w0
	mov	w0,RunTempStack	; Stack
    28ba:	b0 4a 88    	mov.w     w0, 0x956
	mov	w9,RunTempPMAddr; PC
    28bc:	a9 4a 88    	mov.w     w9, 0x954
	mov.b	Page,WREG
    28be:	f0 c8 bf    	mov.b     0x8f0, WREG
	mov.b	WREG,RunTempPage ; Page
    28c0:	58 e9 b7    	mov.b     WREG, 0x958
; save Run flags
	mov	Vflag,w0
    28c2:	80 49 80    	mov.w     0x930, w0
	mov	w0,RunTempVflag
    28c4:	d0 4a 88    	mov.w     w0, 0x95a
	mov	Zflag,w0
    28c6:	70 49 80    	mov.w     0x92e, w0
	mov	w0,RunTempZflag
    28c8:	e0 4a 88    	mov.w     w0, 0x95c
	mov	Cflag,w0
    28ca:	60 49 80    	mov.w     0x92c, w0
	mov	w0,RunTempCflag
    28cc:	f0 4a 88    	mov.w     w0, 0x95e
	mov	w14,RunTempw14
    28ce:	1e 4b 88    	mov.w     w14, 0x962
	mov	w13,RunTempw13
    28d0:	0d 4b 88    	mov.w     w13, 0x960
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    28d2:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	pgm_ept
    28d4:	01 00 37    	bra       0x28d8 <pgm_ept>
	bra	ss_ept
    28d6:	99 f7 37    	bra       0x180a <ss_ept>

000028d8 <pgm_ept>:

pgm_ept:
	btss	Flag2,#12
    28d8:	df 89 ae    	btss.b    0x9df, #0x4
	call	clr_ram
    28da:	66 11 02    	call      0x1166 <clr_ram>
    28dc:	00 00 00 
	bset	Flag2,#12
    28de:	df 89 a8    	bset.b    0x9df, #0x4
; initialize or reload PGM variables from PGM Temp
	clr	Stack		; Stack
    28e0:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; Page 0
    28e2:	f0 68 ef    	clr.b     0x8f0
	mov	PgmTempPMAddr,w9 ; PC
    28e4:	29 4b 80    	mov.w     0x964, w9
	mov	#0b011101100,w0	; autorpt for Addr-, Addr+, Opcode, OperX, OperY
    28e6:	c0 0e 20    	mov.w     #0xec, w0
	mov	w0,AutorptFlag
    28e8:	60 4d 88    	mov.w     w0, 0x9ac
; PGM initialize
	mov	#3,w0
    28ea:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode		; Mode
    28ec:	b0 4b 88    	mov.w     w0, 0x976
	clr	BlinkFlag
    28ee:	e0 29 ef    	clr.w     0x9e0
	clr	w11
    28f0:	80 05 eb    	clr.w     w11
	clr	w12
    28f2:	00 06 eb    	clr.w     w12
	clr	w13
    28f4:	80 06 eb    	clr.w     w13
	clr	w14
    28f6:	00 07 eb    	clr.w     w14
	clr	Vflag
    28f8:	30 29 ef    	clr.w     0x930
	clr	Zflag
    28fa:	2e 29 ef    	clr.w     0x92e
	clr	Cflag
    28fc:	2c 29 ef    	clr.w     0x92c
	mov	#3,w0			; 3 = PGM
    28fe:	30 00 20    	mov.w     #0x3, w0
	mov	w0,Mode
    2900:	b0 4b 88    	mov.w     w0, 0x976
	bset	Flag,#2		; #2 set if Speed > 0 or if Mode <> 2
    2902:	dc 49 a8    	bset.b    0x9dc, #0x2
	clr	w13		; w13 is Accumulator IN, displayed as ACCU IN
    2904:	80 06 eb    	clr.w     w13
	clr	w14		; w14 is Accumulator OUT, displayed as ACCU OUT
    2906:	00 07 eb    	clr.w     w14
; prepare A16 (set RUN and keep Bin/Sel)
	mov	#0b1000000010000000,w0	; keep BIN and SEL only
    2908:	00 08 28    	mov.w     #0x8080, w0
	and	A16
    290a:	ae 29 b6    	and.w     0x9ae
	mov	#0b0000000100000000,w0	; set RUN
    290c:	00 10 20    	mov.w     #0x100, w0
	ior	A16
    290e:	ae 29 b7    	ior.w     0x9ae

00002910 <pgm_farm>:

pgm_farm:
	call	read12		; read new pgm word
    2910:	fc 29 02    	call      0x29fc <read12>
    2912:	00 00 00 

00002914 <pgm_noread>:
pgm_noread:
	btss	Flag,#1		; #1 handshaking flag for buttons
    2914:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	pgm_noread
    2916:	fe ff 37    	bra       0x2914 <pgm_noread>
	bclr	Flag,#1
    2918:	dc 29 a9    	bclr.b    0x9dc, #0x1
	mov	Just,w0
    291a:	30 4d 80    	mov.w     0x9a6, w0
	cp	w0,#5
    291c:	65 00 e1    	cp.w      w0, #0x5
	ifc
    291e:	42 00 af    	btsc.b    0x42, #0x0
	mov	#5,w0
    2920:	50 00 20    	mov.w     #0x5, w0
	bra	w0
    2922:	00 60 01    	bra       w0
; ...
	bra	leave_pgm_ept
    2924:	74 00 37    	bra       0x2a0e <leave_pgm_ept>
	bra	button_addr_set
    2926:	04 00 37    	bra       0x2930 <button_addr_set>
	bra	button_addr_minus_pgm
    2928:	18 00 37    	bra       0x295a <button_addr_minus_pgm>
	bra	button_addr_plus_pgm
    292a:	1d 00 37    	bra       0x2966 <button_addr_plus_pgm>
	bra	button_dep
    292c:	22 00 37    	bra       0x2972 <button_dep>
	bra	general_pgm_5
    292e:	63 00 37    	bra       0x29f6 <general_pgm_5>

00002930 <button_addr_set>:
;					ept 0: addr_set (in PGM mode)
button_addr_set:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2930:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_addr_set	; if ALT addr set pressed
    2932:	09 00 37    	bra       0x2946 <alt_addr_set>
	mov	Opcode,w0
    2934:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    2936:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    2938:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    293a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    293c:	26 09 b7    	ior.w     0x926, WREG
	sl	w0,w0		; ×2
    293e:	00 00 d0    	sl.w      w0, w0
	mov	#Rom,w1
    2940:	01 00 22    	mov.w     #0x2000, w1
	add	w0,w1,w9	; write new address
    2942:	81 04 40    	add.w     w0, w1, w9
	bra	pgm_farm
    2944:	e5 ff 37    	bra       0x2910 <pgm_farm>

00002946 <alt_addr_set>:
;					ept 0: addr_set (in PGM mode)
alt_addr_set:
	inc2	w9,w2
    2946:	09 81 e8    	inc2.w    w9, w2
	mov	#Rom+0x2000,w1	; end of Program Memory + 2
    2948:	01 00 24    	mov.w     #0x4000, w1

0000294a <train2>:
train2:
	cp	w2,w1		; w9=current program pointer (non-incremented)
    294a:	01 10 e1    	cp.w      w2, w1
	bra	nz,1f
    294c:	02 00 3a    	bra       NZ, 0x2952 <L123>
	clr	[--w2]		; last word in program = 0x000
    294e:	00 21 eb    	clr.w     [--w2]
	bra	adr_plus	; train finished
    2950:	0c 00 37    	bra       0x296a <adr_plus>

00002952 <L123>:
1:
	mov	[w2--],w0	; w0 = contents
    2952:	22 00 78    	mov.w     [w2--], w0
	mov	w0,[w2]
    2954:	00 09 78    	mov.w     w0, [w2]
	add	#4,w2
    2956:	42 00 b0    	add.w     #0x4, w2
	bra	train2
    2958:	f8 ff 37    	bra       0x294a <train2>

0000295a <button_addr_minus_pgm>:
;					ept 1: addr_minus_pgm (in PGM mode)
button_addr_minus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    295a:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_minus_pgm	; if ALT addr minus pressed
    295c:	27 00 37    	bra       0x29ac <alt_minus_pgm>
	dec2	w9,w9		; decrement address
    295e:	89 84 e9    	dec2.w    w9, w9
	btss	w9,#13
    2960:	09 d0 a6    	btss.w    w9, #0xd
	mov	#Rom+0x1FFE,w9	; wrap to end of program memory
    2962:	e9 ff 23    	mov.w     #0x3ffe, w9
	bra	pgm_farm
    2964:	d5 ff 37    	bra       0x2910 <pgm_farm>

00002966 <button_addr_plus_pgm>:
;					ept 2: addr_plus_pgm (in PGM mode)
button_addr_plus_pgm:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2966:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_plus_pgm	; if ALT addr plus pressed
    2968:	1c 00 37    	bra       0x29a2 <alt_plus_pgm>

0000296a <adr_plus>:
adr_plus:
	inc2	w9,w9		; increment address
    296a:	89 84 e8    	inc2.w    w9, w9
	btsc	w9,#14
    296c:	09 e0 a7    	btsc.w    w9, #0xe
	mov	#Rom,w9		; wrap to start of program memory
    296e:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm	; test failed, some other key pressed
    2970:	cf ff 37    	bra       0x2910 <pgm_farm>

00002972 <button_dep>:
;					ept 3: dep (in PGM mode)
button_dep:
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2972:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt_dep		; if ALT DEP pressed
    2974:	03 00 37    	bra       0x297c <alt_dep>
	call	write12		; write new pgm word
    2976:	94 29 02    	call      0x2994 <write12>
    2978:	00 00 00 
	bra	adr_plus
    297a:	f7 ff 37    	bra       0x296a <adr_plus>

0000297c <alt_dep>:
;		
alt_dep:
	mov	[w9],w2		; old value
    297c:	19 01 78    	mov.w     [w9], w2
	call	write12		; *** write new pgm word
    297e:	94 29 02    	call      0x2994 <write12>
    2980:	00 00 00 
	mov	#Rom+0x1FFC,w1	; end of Program Memory - 2
    2982:	c1 ff 23    	mov.w     #0x3ffc, w1

00002984 <train1>:
train1:
	cp	w9,w1		; w9=current program pointer (non-incremented)
    2984:	01 48 e1    	cp.w      w9, w1
	bra	nc,1f
    2986:	02 00 39    	bra       NC, 0x298c <L124>
	mov	w2,[++w1]
    2988:	82 28 78    	mov.w     w2, [++w1]
	bra	adr_plus	; train finished
    298a:	ef ff 37    	bra       0x296a <adr_plus>

0000298c <L124>:
1:
	mov	[w1++],w0	; w0 = contents
    298c:	31 00 78    	mov.w     [w1++], w0
	mov	w0,[w1--]
    298e:	80 10 78    	mov.w     w0, [w1--]
	dec2	w1,w1
    2990:	81 80 e9    	dec2.w    w1, w1
	bra	train1
    2992:	f8 ff 37    	bra       0x2984 <train1>

00002994 <write12>:
;		
write12:
	mov	Opcode,w0
    2994:	10 49 80    	mov.w     0x922, w0
	sl	w0,#4,w0
    2996:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG
    2998:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0
    299a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; data packed in 12 bits
    299c:	26 09 b7    	ior.w     0x926, WREG
	mov	w0,[w9]		; write program word
    299e:	80 0c 78    	mov.w     w0, [w9]
	return
    29a0:	00 00 06    	return    

000029a2 <alt_plus_pgm>:
;		
alt_plus_pgm:
	btss	KeyRotors+4,#0	; it's -ADDR debouncer
    29a2:	82 09 ae    	btss.b    0x982, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    29a4:	08 00 37    	bra       0x29b6 <alt_both_pgm>
	call	find_last
    29a6:	d0 19 02    	call      0x19d0 <find_last>
    29a8:	00 00 00 
	bra	pgm_farm
    29aa:	b2 ff 37    	bra       0x2910 <pgm_farm>

000029ac <alt_minus_pgm>:
;		
alt_minus_pgm:
	btss	KeyRotors+6,#0	; it's ADDR+ debouncer
    29ac:	84 09 ae    	btss.b    0x984, #0x0
	bra	alt_both_pgm	; if alt and both - and + pressed
    29ae:	03 00 37    	bra       0x29b6 <alt_both_pgm>
	clr	Stack
    29b0:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w9
    29b2:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    29b4:	ad ff 37    	bra       0x2910 <pgm_farm>

000029b6 <alt_both_pgm>:
;				; "go addr 0" test	
alt_both_pgm:			; ALT both pressed
	mov	KeyRotors+0,w0
    29b6:	f0 4b 80    	mov.w     0x97e, w0
	and	KeyRotors+2,WREG
    29b8:	80 09 b6    	and.w     0x980, WREG
	mov	#KeyRotors+8,w1
    29ba:	61 98 20    	mov.w     #0x986, w1
	mov	#14,w2
    29bc:	e2 00 20    	mov.w     #0xe, w2

000029be <L125>:
1:
	and	w0,[w1++],w0
    29be:	31 00 60    	and.w     w0, [w1++], w0
	dec	w2,w2
    29c0:	02 01 e9    	dec.w     w2, w2
	bra	nz,1b
    29c2:	fd ff 3a    	bra       NZ, 0x29be <L125>
	btss	w0,#0
    29c4:	00 00 a6    	btss.w    w0, #0x0
	bra	pgm_farm	; some other key is pressed, ignore command
    29c6:	a4 ff 37    	bra       0x2910 <pgm_farm>
; erase all data memory
	call	clr_ram
    29c8:	66 11 02    	call      0x1166 <clr_ram>
    29ca:	00 00 00 
	clr	Stack
    29cc:	2a 29 ef    	clr.w     0x92a
	clr.b	Page		; default page 0
    29ce:	f0 68 ef    	clr.b     0x8f0
	clr.b	Speed		; default Clock max
    29d0:	f1 68 ef    	clr.b     0x8f1
	clr.b	Sync		; default Sync max
    29d2:	f2 68 ef    	clr.b     0x8f2
	clr.b	WrFlags		; Leds on, Matrix on, IOPos 0xA-0xB, RxTxPos on SAO
    29d4:	f3 68 ef    	clr.b     0x8f3
	clr.b	Received	; clear queue
    29d6:	f8 68 ef    	clr.b     0x8f8
	mov	#15,w0
    29d8:	f0 00 20    	mov.w     #0xf, w0
	mov.b	Wreg,Dimmer	; default Dimmer max
    29da:	fe e8 b7    	mov.b     WREG, 0x8fe
	mov	#0b0011,w0
    29dc:	30 00 20    	mov.w     #0x3, w0
	mov.b	Wreg,SerCtrl	; default UART
    29de:	f5 e8 b7    	mov.b     WREG, 0x8f5
	  call	  rxtx_to_rxtxpos ; RxTx restored back to RxTxpos
    29e0:	88 28 02    	call      0x2888 <rxtx_to_rxtxpos>
    29e2:	00 00 00 
	  call	  set_U1BRG	  ; BRG restored to SerCtrl (bits 210)
    29e4:	54 28 02    	call      0x2854 <set_U1BRG>
    29e6:	00 00 00 
; erase all program memory
	clr	Stack
    29e8:	2a 29 ef    	clr.w     0x92a
	mov	#Rom,w0
    29ea:	00 00 22    	mov.w     #0x2000, w0
	repeat	#0x01000-1
    29ec:	ff 0f 09    	repeat    #0xfff
	clr	[w0++]		; clr Rom
    29ee:	00 18 eb    	clr.w     [w0++]
	clr.b	Page
    29f0:	f0 68 ef    	clr.b     0x8f0
	mov	#Rom,w9
    29f2:	09 00 22    	mov.w     #0x2000, w9
	bra	pgm_farm
    29f4:	8d ff 37    	bra       0x2910 <pgm_farm>

000029f6 <general_pgm_5>:

general_pgm_5:	; -----------------------------------------------------------------
; 13 buttons OPCODE 8... DATA IN
	call	general_key_3O
    29f6:	c4 14 02    	call      0x14c4 <general_key_3O>
    29f8:	00 00 00 
	bra	pgm_noread
    29fa:	8c ff 37    	bra       0x2914 <pgm_noread>

000029fc <read12>:
; ------------------------------
read12:
	mov	[w9],w0
    29fc:	19 00 78    	mov.w     [w9], w0
	lsr	w0,#8,w1
    29fe:	c8 00 de    	lsr.w     w0, #0x8, w1
	mov	w1,Opcode
    2a00:	11 49 88    	mov.w     w1, 0x922
	lsr	w0,#4,w2
    2a02:	44 01 de    	lsr.w     w0, #0x4, w2
	and	w2,#0x0F,w2
    2a04:	6f 01 61    	and.w     w2, #0xf, w2
	mov	w2,OperX
    2a06:	22 49 88    	mov.w     w2, 0x924
	and	w0,#0x0F,w0
    2a08:	6f 00 60    	and.w     w0, #0xf, w0
	mov	w0,OperY
    2a0a:	30 49 88    	mov.w     w0, 0x926
	return
    2a0c:	00 00 06    	return    

00002a0e <leave_pgm_ept>:

; -------------------------------------------------------------------------------

leave_pgm_ept:
; save PGM params
	mov	w9,PgmTempPMAddr ; PC
    2a0e:	29 4b 88    	mov.w     w9, 0x964
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    2a10:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	alu_ept
    2a12:	b2 f3 37    	bra       0x1178 <alu_ept>
	bra	run_ept
    2a14:	0f f8 37    	bra       0x1a34 <run_ept>

00002a16 <T1Int>:
;***********************************************************************************
;****************************       T1 INTERRUPT       *****************************
;***********************************************************************************
T1Int:				; TIMER1 int, display & kbd 3.2 KHz
	push.s			; \
    2a16:	00 a0 fe    	push.s    
; OUT port service
	mov.b	Ram+0x0A,WREG	; OUT register if WrFlags,#1 = 0
    2a18:	0a c8 bf    	mov.b     0x80a, WREG
	btsc	WrFlags,#1	; I/O port select
    2a1a:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	Ram+0xFA,WREG	; OUT register if WrFlags,#1 = 1
    2a1c:	fa c8 bf    	mov.b     0x8fa, WREG
	mov.b	WREG,LATB	; OUT port
    2a1e:	7a e6 b7    	mov.b     WREG, 0x67a
; split interrupt Dimmer timing to two timings (to give a total of 514)
	mov.b	Dimmer,WREG
    2a20:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w0
    2a22:	00 80 fb    	ze        w0, w0
	btsc	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    2a24:	dd a9 af    	btsc.b    0x9dd, #0x5
	bra	aux_int		; aux_int only turns off LEDs, for dimming
    2a26:	0e 04 37    	bra       0x3244 <aux_int>
	bset	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    2a28:	dd a9 a8    	bset.b    0x9dd, #0x5
; calculate exponential dimmer step
	mul.uu	w0,w0,w2	; w2 =   0,   1,   4,   9,  16...196, 225
    2a2a:	00 01 b8    	mul.uu    w0, w0, w2
	cp0	w2
    2a2c:	02 00 e0    	cp0.w     w2
	ifnz
    2a2e:	42 20 ae    	btss.b    0x42, #0x1
	add	#5,w2		; w2 =   0,   6,   9,  14,  21...201, 230
    2a30:	52 00 b0    	add.w     #0x5, w2
	add	#5,w2		; w2 =   5,  11,  14,  19,  26...206, 235
    2a32:	52 00 b0    	add.w     #0x5, w2
	sl	w2,w2		; w2 =  10,  22,  28,  38,  52...412, 470
    2a34:	02 01 d0    	sl.w      w2, w2
; mov #300,w2 ;(samo za snimanje 60 fps)
	mov	w2,PR1
    2a36:	92 0c 88    	mov.w     w2, 0x192
	mov	w2,PR1copy
    2a38:	12 4e 88    	mov.w     w2, 0x9c2
; automatic Leds and Matrix off when ALT pressed
	  mov	  #0b0011,w0
    2a3a:	30 00 20    	mov.w     #0x3, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    2a3c:	dc c9 af    	btsc.b    0x9dc, #0x6
	  and.b	  WrFlags
    2a3e:	f3 68 b6    	and.b     0x8f3
; if 10 minutes countdown=0 then go to sleep
	inc	BlinkCount	; +
    2a40:	7c 29 ec    	inc.w     0x97c
	  btsc	  Flag,#14	  ; dim down in progress?
    2a42:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  count625
    2a44:	0e 00 37    	bra       0x2a62 <count625>
	  btsc	  Flag,#15	  ; dim up in progress?
    2a46:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  count625
    2a48:	0c 00 37    	bra       0x2a62 <count625>
	mov	BlinkCount,w0
    2a4a:	e0 4b 80    	mov.w     0x97c, w0
	and	#0x3F,w0	; 4 KHz / 0x03F = 62.5 Hz
    2a4c:	f0 03 b2    	and.w     #0x3f, w0
	  ifz
    2a4e:	42 20 af    	btsc.b    0x42, #0x1
	  dec	  AutoOff_Hi	  ; 62.5 Hz decrement
    2a50:	b6 29 ed    	dec.w     0x9b6
	  bra	  nz,count625
    2a52:	07 00 3a    	bra       NZ, 0x2a62 <count625>
; if AutoOff_Hi started from 37500, then 10 minutes here
	  mov	  #37500,w0
    2a54:	c0 27 29    	mov.w     #0x927c, w0
	  mov	  w0,AutoOff_Hi	  ; new 10 min cycle started
    2a56:	b0 4d 88    	mov.w     w0, 0x9b6
; decrement 10 minutes countdown, if=0 then go to sleep 
	  dec.b	  AutoOff
    2a58:	f9 68 ed    	dec.b     0x8f9
	  bra	  nz,count625
    2a5a:	03 00 3a    	bra       NZ, 0x2a62 <count625>
	  mov.b	  Dimmer,WREG
    2a5c:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    2a5e:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down request (AutoOff patience counter expired)
    2a60:	dd c9 a8    	bset.b    0x9dd, #0x6

00002a62 <count625>:
count625:
; inc main multiplex pointer
	inc	RowScan,WREG	; +
    2a62:	78 09 ec    	inc.w     0x978, WREG
	and	#0x0F,w0
    2a64:	f0 00 b2    	and.w     #0xf, w0
	mov	w0,RowScan	; RowScan = 0000...1111
    2a66:	c0 4b 88    	mov.w     w0, 0x978
; anode off
	clr.b	LATC		; LED anodes off
    2a68:	8e 66 ef    	clr.b     0x68e
	clr.b	LATB+1		; LED anodes off
    2a6a:	7b 66 ef    	clr.b     0x67b
	bclr	LATC,#8		; 17th anode column
    2a6c:	8f 06 a9    	bclr.b    0x68f, #0x0
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2a6e:	dd 89 a9    	bclr.b    0x9dd, #0x4
; decoder service
	sl	w0,#7,w1	; RowScan 3, 2, 1, 0 ---> A10, A9, A8, A7
    2a70:	c7 00 dd    	sl.w      w0, #0x7, w1
	btsc	LATA,#1		; LATA,#1 is output for SAO (if it's not Tx)...
    2a72:	66 26 af    	btsc.b    0x666, #0x1
	bset	w1,#1		; ...restore it
    2a74:	01 10 a0    	bset.w    w1, #0x1
	mov	w1,LATA		; set decoder 74HC138 inputs
    2a76:	31 33 88    	mov.w     w1, 0x666
; A16 History/standard mode select
	  mov	  History_A16,w3
    2a78:	63 48 80    	mov.w     0x90c, w3
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2a7a:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	A16,w3
    2a7c:	73 4d 80    	mov.w     0x9ae, w3
; main branch
	bra	w0		; main branch (w0=0...15)
    2a7e:	00 60 01    	bra       w0
;...
	bra	cathode0
    2a80:	0f 00 37    	bra       0x2aa0 <cathode0>
	bra	cathode1
    2a82:	3e 00 37    	bra       0x2b00 <cathode1>
	bra	cathode2
    2a84:	60 00 37    	bra       0x2b46 <cathode2>
	bra	cathode3
    2a86:	7d 00 37    	bra       0x2b82 <cathode3>
	bra	cathode4
    2a88:	a6 00 37    	bra       0x2bd6 <cathode4>
	bra	cathode5
    2a8a:	ca 00 37    	bra       0x2c20 <cathode5>
	bra	cathode6
    2a8c:	ee 00 37    	bra       0x2c6a <cathode6>
	bra	cathode7
    2a8e:	16 01 37    	bra       0x2cbc <cathode7>
	bra	cathode8
    2a90:	7d 01 37    	bra       0x2d8c <cathode8>
	bra	cathode9
    2a92:	b7 01 37    	bra       0x2e02 <cathode9>
	bra	cathode10
    2a94:	f4 01 37    	bra       0x2e7e <cathode10>
	bra	cathode11
    2a96:	31 02 37    	bra       0x2efa <cathode11>
	bra	cathode12
    2a98:	74 02 37    	bra       0x2f82 <cathode12>
	bra	cathode13
    2a9a:	b1 02 37    	bra       0x2ffe <cathode13>
	bra	cathode14
    2a9c:	ee 02 37    	bra       0x307a <cathode14>
	bra	cathode15
    2a9e:	3e 03 37    	bra       0x311c <cathode15>

00002aa0 <cathode0>:

;------------------------------- MACRO -------------------------------
; Important Note for this Macro: 
; Ports LATA,#A7-#A10 are a,b,c,d inputs to the 4-to-16 decoder (2×74AHC138). These 
; outputs drive LED matrix, and also buttons. Outputs 0-6 are not used for buttons, 
; output 7 is for rightmost keys, output 8 for Mode and Carry, output 9 for Save and 
; Load, and so on. Input ; PORTA,#3 is for keys Mode, save, Clock... and so every 
; second key. Input Porta,#4 ; is for Carry, Load, Opcode8... and so every second 
; key. Keys On-Off and ALT are not in the keyboard matrix. Please see schematics.
.macro	keytest	keynum,AllowRpt1,AllowRpt2
; key connected to PORTA,#3 input
	btsc	BlinkCount,#4
	bra	6f		; if odd then skip
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2
	btsc	PORTA,#3
	bset	KeyRotors+\keynum*2,#0
	inc2	KeyRotors+\keynum*2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum,w0
	mov	w0,Just		; just pressed
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt1
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
6:
; key connected to PORTA,#4 input
; debouncer and "just" condition detector
	sl	KeyRotors+\keynum*2+2
	mov	#0b1111110000000000,w0
	ior	KeyRotors+\keynum*2+2
	btsc	PORTA,#4
	bset	KeyRotors+\keynum*2+2,#0
	inc2	KeyRotors+\keynum*2+2,WREG ; test if keynum = 0bxxxx111111111110
	bra	nz,7f		; if not just pressed
	and	Anypress	; bit 0 will be reset if any key still depressed
	mov	#\keynum+1,w0
	mov	w0,Just		; code of "just pressed" key
	sub	#4,w0		; now key numbers 1...13 for Opcode/OperX/OperY/DataIn...
	ifnc
	mov	#0,w0		; ...and 0 for all other keys
	mov.b	WREG,KeyReg	; SFR code of "just pressed" key
	bset	Flag,#1		; flag "key just pressed"
	bset.b	KeyStatus,#0	; SFR "key just pressed"
	mov	#15,w0		; 15×10 min autooff at keystroke
	mov.b	WREG,AutoOff
	mov	#37500,w0
	mov	w0,AutoOff_Hi
; test if Autorepeat for this key is allowed
	btss	AutorptFlag,#\AllowRpt2
	bra	8f		; if Autorepeat for this key not allowed
; yes, it's allowed
	mov	#autorpt_start,w0
	btsc	AutorptCount,#15 ; don't write to AutorptCount if it's already counting
	mov	w0,AutorptCount	; write only if it's negative
	bra	8f
7:
	and	Anypress	; bit 0 will be reset if any key still depressed
8:
.endm

;------------------------------- OPCODE BAR --------------------------- cathode 0
cathode0:
; spec test if any key pressed (needed for autorepeat)
	btsc	BlinkCount,#4
    2aa0:	7c 89 af    	btsc.b    0x97c, #0x4
	bra	cont_cathode0	; test must be performed in every 2nd pass
    2aa2:	0f 00 37    	bra       0x2ac2 <cont_cathode0>
	btsts	Anypress,#0	; test AND SET bit 0 (will be Z if any key pressed)
    2aa4:	a8 09 ac    	btsts.b   0x9a8, #0x0
	bra	nz,NoAutoRpt	; if no key was pressed
    2aa6:	0c 00 3a    	bra       NZ, 0x2ac0 <NoAutoRpt>
; at least 1 key was pressed
	btsc	AutorptCount,#15
    2aa8:	ab e9 af    	btsc.b    0x9ab, #0x7
	bra	cont_cathode0	; if it's not set for counting (it's negative)
    2aaa:	0b 00 37    	bra       0x2ac2 <cont_cathode0>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2aac:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	cont_cathode0	; if ALT pressed
    2aae:	09 00 37    	bra       0x2ac2 <cont_cathode0>
	dec	AutorptCount
    2ab0:	aa 29 ed    	dec.w     0x9aa
	bra	nz,cont_cathode0 ; if not yet 0x0000
    2ab2:	07 00 3a    	bra       NZ, 0x2ac2 <cont_cathode0>
; AutorptCount just reached 0, reinitialize autorpt process
	mov	#KeyRotors,w0
    2ab4:	e0 97 20    	mov.w     #0x97e, w0
	repeat	#18-1
    2ab6:	11 00 09    	repeat    #0x11
	setm	[w0++]		; reenable "just" condition
    2ab8:	00 98 eb    	setm.w    [w0++]
	mov	#autorpt_next,w0
    2aba:	f0 00 20    	mov.w     #0xf, w0
	mov	w0,AutorptCount	; reinitialize autorpt process
    2abc:	50 4d 88    	mov.w     w0, 0x9aa
	bra	cont_cathode0
    2abe:	01 00 37    	bra       0x2ac2 <cont_cathode0>

00002ac0 <NoAutoRpt>:
NoAutoRpt:
	setm	AutorptCount	; forced -1 (only #autorpt_start allowed for writing)
    2ac0:	aa a9 ef    	setm.w    0x9aa

00002ac2 <cont_cathode0>:
cont_cathode0:
; extra anode 16
	btsc	w3,#b_clk_sch	; Extra bit 16: CLOCK (schematics) 
    2ac2:	03 00 a7    	btsc.w    w3, #0x0
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ac4:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2ac6:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2ac8:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2aca:	02 00 32    	bra       Z, 0x2ad0 <L36>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2acc:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt0		; IF ALT pressed
    2ace:	0e 00 37    	bra       0x2aec <alt0>

00002ad0 <L36>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2ad0:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2ad2:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#8,w1	  ; HISTORY mode
    2ad4:	c8 08 de    	lsr.w     w1, #0x8, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2ad6:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	Opcode,w1	; ***
    2ad8:	11 49 80    	mov.w     0x922, w1
	mov	#0,w0
    2ada:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2adc:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#0	; 0 set = column Opcode blinks
    2ade:	e0 09 ae    	btss.b    0x9e0, #0x0
	mov	#1,w0
    2ae0:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2ae2:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2ae4:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2ae6:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2ae8:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0a
    2aea:	07 00 37    	bra       0x2afa <go_disp0a>

00002aec <alt0>:
alt0:				; IF ALU pressed
	mov.b	Sync,WREG	; if Mode > 0 (SS Run Pgm)
    2aec:	f2 c8 bf    	mov.b     0x8f2, WREG
	    cp0	    Mode
    2aee:	76 09 e2    	cp0.w     0x976
	    ifz
    2af0:	42 20 af    	btsc.b    0x42, #0x1
	    mov.b   Dimmer,WREG	; if Mode = 0 (ALU)
    2af2:	fe c8 bf    	mov.b     0x8fe, WREG
	ze	w0,w1
    2af4:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2af6:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2af8:	01 00 dd    	sl.w      w0, w1, w0

00002afa <go_disp0a>:
go_disp0a:
	btsc	Flag,#3		; #3 self-check mode
    2afa:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column1,w0
    2afc:	40 4e 80    	mov.w     0x9c8, w0
	bra	disp_w0_noblank
    2afe:	98 03 37    	bra       0x3230 <disp_w0_noblank>

00002b00 <cathode1>:
;------------------------------- OPERAND X BAR ------------------------ cathode 1
cathode1:
; extra anode 16
	btsc	w3,#b_exr	; Extra bit 16: EXR (instruction set)
    2b00:	03 10 a7    	btsc.w    w3, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b02:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2b04:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2b06:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2b08:	02 00 32    	bra       Z, 0x2b0e <L37>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2b0a:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt1		; IF ALT pressed
    2b0c:	0f 00 37    	bra       0x2b2c <alt1>

00002b0e <L37>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2b0e:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2b10:	91 00 78    	mov.w     [w1], w1
	  lsr	  w1,#4,w1	  ; HISTORY mode
    2b12:	c4 08 de    	lsr.w     w1, #0x4, w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b14:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperX,w1	; ***
    2b16:	21 49 80    	mov.w     0x924, w1
	and	#0x0F,w1
    2b18:	f1 00 b2    	and.w     #0xf, w1
	mov	#0,w0
    2b1a:	00 00 20    	mov.w     #0x0, w0
	btsc	BlinkCount,#9	; blinking freq
    2b1c:	7d 29 af    	btsc.b    0x97d, #0x1
	btss	BlinkFlag,#1	; 1 set = column Oper X blinks
    2b1e:	e0 29 ae    	btss.b    0x9e0, #0x1
	mov	#1,w0
    2b20:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2b22:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2b24:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2b26:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2b28:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0b
    2b2a:	0a 00 37    	bra       0x2b40 <go_disp0b>

00002b2c <alt1>:
alt1:			; IF ALT pressed
	mov.b	Speed,WREG
    2b2c:	f1 c8 bf    	mov.b     0x8f1, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b2e:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Speed,WREG
    2b30:	14 c9 bf    	mov.b     0x914, WREG
	    cp0	    Mode
    2b32:	76 09 e2    	cp0.w     0x976
	    bra	    nz,1f
    2b34:	02 00 3a    	bra       NZ, 0x2b3a <L126>
	    mov.b   SerCtrl,WREG	; if Mode = 0 (ALU)
    2b36:	f5 c8 bf    	mov.b     0x8f5, WREG
	    bclr.b  w0,#3		; spec case: Buad Rate takes only 3 bits
    2b38:	00 34 a1    	bclr.b    w0, #0x3

00002b3a <L126>:
1:
	ze	w0,w1
    2b3a:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2b3c:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2b3e:	01 00 dd    	sl.w      w0, w1, w0

00002b40 <go_disp0b>:
go_disp0b:
	btsc	Flag,#3		; #3 self-check mode
    2b40:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column2,w0
    2b42:	50 4e 80    	mov.w     0x9ca, w0
	bra	disp_w0
    2b44:	73 03 37    	bra       0x322c <disp_w0>

00002b46 <cathode2>:
;------------------------------- OPERAND Y BAR ------------------------ cathode 2
cathode2:
; extra anode 16
	btsc	w3,#b_clk_key	; Extra bit 16: CLOCK (schematic) 
    2b46:	03 20 a7    	btsc.w    w3, #0x2
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2b48:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	Mode,w1
    2b4a:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2b4c:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2b4e:	02 00 32    	bra       Z, 0x2b54 <L38>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2b50:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	alt2pressed	; IF ALT pressed
    2b52:	0b 00 37    	bra       0x2b6a <alt2pressed>

00002b54 <L38>:
3:
	  mov	  History_w9,w1	  ; HISTORY mode
    2b54:	11 48 80    	mov.w     0x902, w1
	  mov	  [w1],w1	  ; HISTORY mode
    2b56:	91 00 78    	mov.w     [w1], w1
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2b58:	dc a9 ae    	btss.b    0x9dc, #0x5
	mov	OperY,w1
    2b5a:	31 49 80    	mov.w     0x926, w1
	and	#0x0F,w1
    2b5c:	f1 00 b2    	and.w     #0xf, w1
	mov	#1,w0
    2b5e:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2b60:	01 00 dd    	sl.w      w0, w1, w0
	  cp0	  Taskbar
    2b62:	b8 09 e2    	cp0.w     0x9b8
	  ifnz
    2b64:	42 20 ae    	btss.b    0x42, #0x1
	  mov	  Taskbar,w0
    2b66:	c0 4d 80    	mov.w     0x9b8, w0
	bra	go_disp0c
    2b68:	09 00 37    	bra       0x2b7c <go_disp0c>

00002b6a <alt2pressed>:
alt2pressed:		; IF DATA IN pressed
	mov.b	Page,WREG
    2b6a:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2b6c:	dc a9 af    	btsc.b    0x9dc, #0x5
	  mov.b	  History_Page,WREG
    2b6e:	10 c9 bf    	mov.b     0x910, WREG
	    cp0	    Mode
    2b70:	76 09 e2    	cp0.w     0x976
	    ifz
    2b72:	42 20 af    	btsc.b    0x42, #0x1
	    mov	    FlashAddr,w0 ; Alt pressed in ALU mode: get FlashAddr instead of OperY
    2b74:	00 4e 80    	mov.w     0x9c0, w0
	ze	w0,w1
    2b76:	80 80 fb    	ze        w0, w1
	mov	#1,w0
    2b78:	10 00 20    	mov.w     #0x1, w0
	sl	w0,w1,w0	; shift 0000000000000001 for w1 bit positions
    2b7a:	01 00 dd    	sl.w      w0, w1, w0

00002b7c <go_disp0c>:
go_disp0c:
	btsc	Flag,#3		; #3 self-check mode
    2b7c:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Column3,w0
    2b7e:	60 4e 80    	mov.w     0x9cc, w0
	bra	disp_w0
    2b80:	55 03 37    	bra       0x322c <disp_w0>

00002b82 <cathode3>:
;---------------------- SOURCE, PROG MEM ADDR ------------------------ cathode 3
cathode3:
; ALT key debouncer
	sl	KeyRotors+38
    2b82:	a4 29 d4    	sl.w      0x9a4
	btsc	PORTA,#2
    2b84:	64 46 af    	btsc.b    0x664, #0x2
	bset	KeyRotors+38,#0
    2b86:	a4 09 a8    	bset.b    0x9a4, #0x0
	inc.b	KeyRotors+38,WREG ; test if keynum = 0bxxxxxxxx11111111
    2b88:	a4 49 ec    	inc.b     0x9a4, WREG
	ifz
    2b8a:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#6		; #6 set if ALT pressed (debounced)
    2b8c:	dc c9 a9    	bclr.b    0x9dc, #0x6
	ifz
    2b8e:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b90:	fc 68 a9    	bclr.b    0x8fc, #0x3
	cp0.b	KeyRotors+38	; test if keynum = 0bxxxxxxxx00000000
    2b92:	a4 49 e2    	cp0.b     0x9a4
	ifz
    2b94:	42 20 af    	btsc.b    0x42, #0x1
	bset	Flag,#6		; #6 set if ALT pressed (debounced)
    2b96:	dc c9 a8    	bset.b    0x9dc, #0x6
	ifz
    2b98:	42 20 af    	btsc.b    0x42, #0x1
	bclr	KeyStatus,#3
    2b9a:	fc 68 a9    	bclr.b    0x8fc, #0x3
	btsc	Flag,#3		; #3 self-check mode
    2b9c:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in3		; no IN in self-check mode
    2b9e:	07 00 37    	bra       0x2bae <no_in3>
; IN register service
	mov.b	PORTB,WREG
    2ba0:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2ba2:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2ba4:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2ba6:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2ba8:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2baa:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2bac:	fb e8 b7    	mov.b     WREG, 0x8fb

00002bae <no_in3>:
no_in3:
; extra anode 16
	btsc	w3,#b_noclk_sch ; Extra bit 16: INV CLOCK (schematic)
    2bae:	03 30 a7    	btsc.w    w3, #0x3
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2bb0:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Rom,w1
    2bb2:	01 00 22    	mov.w     #0x2000, w1
	  mov	  History_w9,w0	  ; HISTORY mode
    2bb4:	10 48 80    	mov.w     0x902, w0
	  sub	  w0,w1,w0	  ; HISTORY mode
    2bb6:	01 00 50    	sub.w     w0, w1, w0
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    2bb8:	dc c9 af    	btsc.b    0x9dc, #0x6
	  sl	  History_Ptr,WREG ; if ALT in History mode, then History_Ptr displayed
    2bba:	1e 09 d4    	sl.w      0x91e, WREG
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2bbc:	dc a9 ae    	btss.b    0x9dc, #0x5
	sub	w9,w1,w0
    2bbe:	01 80 54    	sub.w     w9, w1, w0
	lsr	w0,w1		; w1 = PC actual value
    2bc0:	80 00 d1    	lsr.w     w0, w1
	  mov	  History_w12,w0  ; HISTORY mode
    2bc2:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#12,w0	  ; HISTORY mode
    2bc4:	4c 00 dd    	sl.w      w0, #0xc, w0
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    2bc6:	dc a9 ae    	btss.b    0x9dc, #0x5
	sl	w12,#12,w0	; w12 = SOURCE (OperY) contents
    2bc8:	4c 60 dd    	sl.w      w12, #0xc, w0
	    mov	    #0x0FFF,w3	    ; * * * * BUG FIX SEPT 21 2022
    2bca:	f3 ff 20    	mov.w     #0xfff, w3
	    and	    w3,w1,w1	    ; * * * * BUG FIX SEPT 21 2022
    2bcc:	81 80 61    	and.w     w3, w1, w1
;	cp0	Mode
;	ifnz			; ProgMemAddr (w9) is not displayed in ALU mode
	ior	w1,w0,w0
    2bce:	00 80 70    	ior.w     w1, w0, w0
	btsc	Flag,#3		; #3 self-check mode
    2bd0:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row3,w0
    2bd2:	70 4e 80    	mov.w     0x9ce, w0
	bra	disp_w0_noblank
    2bd4:	2d 03 37    	bra       0x3230 <disp_w0_noblank>

00002bd6 <cathode4>:
;------------------------------- Vflag, ADDER, DEST ------------------- cathode 4
cathode4:
; extra anode 16
	btsc	w3,#b_data_inv	; Extra bit 16: DATA INVERSE (schematic) 
    2bd6:	03 40 a7    	btsc.w    w3, #0x4
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2bd8:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2bda:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat4	  ; if HISTORY mode
    2bdc:	19 00 37    	bra       0x2c10 <History_cat4>
	mov	Vflag,w0
    2bde:	80 49 80    	mov.w     0x930, w0
	btss	Stack,#2
    2be0:	2a 49 ae    	btss.b    0x92a, #0x2
	bra	1f
    2be2:	03 00 37    	bra       0x2bea <L127>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2be4:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2be6:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2be8:	00 30 a0    	bset.w    w0, #0x3

00002bea <L127>:
1:
	sl	w0,#8,w1	; 0000 SVVV 0000 0000
    2bea:	c8 00 dd    	sl.w      w0, #0x8, w1
; Adder Sum & Carry
	sl	w12,#4,w0	; w0 = source × 16
    2bec:	44 60 dd    	sl.w      w12, #0x4, w0
	ior	w11,w0,w0	; w0 = source × 16 + dest
    2bee:	00 80 75    	ior.w     w11, w0, w0

00002bf0 <skr_cat4>:
skr_cat4:
	sl	w0,#2,w0	; w0 = 4 × (source × 16 + dest)
    2bf0:	42 00 dd    	sl.w      w0, #0x2, w0
	mov	#tbloffset(table_adder),w2
    2bf2:	a2 57 23    	mov.w     #0x357a, w2
	add	w0,w2,w0	; w0 = #table_adder + 4 × (source × 16 + dest)
    2bf4:	02 00 40    	add.w     w0, w2, w0
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2bf6:	03 50 a7    	btsc.w    w3, #0x5
	inc2	w0,w0		; if Cin set
    2bf8:	00 80 e8    	inc2.w    w0, w0
	push	TBLPAG	   ; \\
    2bfa:	54 00 f8    	push      0x54
	clr	TBLPAG
    2bfc:	54 20 ef    	clr.w     0x54
	tblrdl	[w0],w0		; 0000 0VZC AAAA CCCC
    2bfe:	10 00 ba    	tblrdl.w  [w0], w0
	pop	TBLPAG	   ; //
    2c00:	54 00 f9    	pop       0x54
	and	#0x0FF,w0	; 0000 0000 AAAA CCCC
    2c02:	f0 0f b2    	and.w     #0xff, w0
	ior	w0,w1,w0	; 0000 SVVV AAAA CCCC
    2c04:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SVVV AAAA CCCC 0000
    2c06:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w11,w0	; SVVV AAAA CCCC DDDD (w11 = dest contents)
    2c08:	0b 00 70    	ior.w     w0, w11, w0
	btsc	Flag,#3		; #3 self-check mode
    2c0a:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row4,w0
    2c0c:	80 4e 80    	mov.w     0x9d0, w0
	bra	disp_w0
    2c0e:	0e 03 37    	bra       0x322c <disp_w0>

00002c10 <History_cat4>:
History_cat4:			  ; HISTORY mode ............................
	  mov	  History_Vflag,w0
    2c10:	b0 48 80    	mov.w     0x916, w0
	  btsc	  History_Stack,#2
    2c12:	1c 49 af    	btsc.b    0x91c, #0x2
	  bset	  w0,#3		  ; Stack LED bit
    2c14:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#8,w1	  ; 0000 SVVV 0000 0000
    2c16:	c8 00 dd    	sl.w      w0, #0x8, w1
  ; Adder Sum & Carry
	  mov	  History_w12,w0
    2c18:	30 48 80    	mov.w     0x906, w0
	  sl	  w0,#4,w0	  ; w0 = source × 16
    2c1a:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w11,WREG ; w0 = source × 16 + dest
    2c1c:	04 09 b7    	ior.w     0x904, WREG
	  bra	  skr_cat4
    2c1e:	e8 ff 37    	bra       0x2bf0 <skr_cat4>

00002c20 <cathode5>:
;-------------------------------- Zflag, OR, AND, XOR ----------------- cathode 5
cathode5:
; extra anode 16
	btsc	w3,#b_cin	; Extra bit 16: C IN (schematic) 
    2c20:	03 50 a7    	btsc.w    w3, #0x5
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2c22:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2c24:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat5
    2c26:	12 00 37    	bra       0x2c4c <History_cat5>
	mov	Zflag,w0	; 0000 0000 0000 0ZZZ
    2c28:	70 49 80    	mov.w     0x92e, w0
	btss	Stack,#1
    2c2a:	2a 29 ae    	btss.b    0x92a, #0x1
	bra	1f
    2c2c:	03 00 37    	bra       0x2c34 <L128>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2c2e:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2c30:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; 0000 0000 0000 SZZZ
    2c32:	00 30 a0    	bset.w    w0, #0x3

00002c34 <L128>:
1:
	sl	w0,#4,w0	; 0000 0000 SZZZ 0000
    2c34:	44 00 dd    	sl.w      w0, #0x4, w0
; Logic OR, AND and XOR
	ior	w11,w12,w1
    2c36:	8c 80 75    	ior.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 0000 SZZZ OOOO
    2c38:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; 0000 SZZZ OOOO 0000
    2c3a:	44 00 dd    	sl.w      w0, #0x4, w0
	and	w11,w12,w1
    2c3c:	8c 80 65    	and.w     w11, w12, w1
	ior	w0,w1,w0	; 0000 SZZZ OOOO AAAA
    2c3e:	01 00 70    	ior.w     w0, w1, w0
	sl	w0,#4,w0	; SZZZ OOOO AAAA 0000
    2c40:	44 00 dd    	sl.w      w0, #0x4, w0
	xor	w11,w12,w1
    2c42:	8c 80 6d    	xor.w     w11, w12, w1
	ior	w0,w1,w0	; SZZZ OOOO AAAA XXXX
    2c44:	01 00 70    	ior.w     w0, w1, w0
	btsc	Flag,#3		; #3 self-check mode
    2c46:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row5,w0
    2c48:	90 4e 80    	mov.w     0x9d2, w0
	bra	disp_w0
    2c4a:	f0 02 37    	bra       0x322c <disp_w0>

00002c4c <History_cat5>:
History_cat5:			  ; HISTORY mode ............................
	  mov	  History_Zflag,w0 ; 0000 0000 0000 0ZZZ
    2c4c:	c0 48 80    	mov.w     0x918, w0
	  btsc	  History_Stack,#1
    2c4e:	1c 29 af    	btsc.b    0x91c, #0x1
	  bset	  w0,#3		  ; 0000 0000 0000 SZZZ
    2c50:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; 0000 0000 SZZZ 0000
    2c52:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Logic OR, AND and XOR
	  mov	  History_w11,w2
    2c54:	22 48 80    	mov.w     0x904, w2
	  mov	  History_w12,w3
    2c56:	33 48 80    	mov.w     0x906, w3
	  ior	  w2,w3,w1
    2c58:	83 00 71    	ior.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 0000 SZZZ OOOO
    2c5a:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; 0000 SZZZ OOOO 0000
    2c5c:	44 00 dd    	sl.w      w0, #0x4, w0
	  and	  w2,w3,w1
    2c5e:	83 00 61    	and.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; 0000 SZZZ OOOO AAAA
    2c60:	01 00 70    	ior.w     w0, w1, w0
	  sl	  w0,#4,w0	  ; SZZZ OOOO AAAA 0000
    2c62:	44 00 dd    	sl.w      w0, #0x4, w0
	  xor	  w2,w3,w1
    2c64:	83 00 69    	xor.w     w2, w3, w1
	  ior	  w0,w1,w0	  ; SZZZ OOOO AAAA XXXX
    2c66:	01 00 70    	ior.w     w0, w1, w0
	  bra	  disp_w0
    2c68:	e1 02 37    	bra       0x322c <disp_w0>

00002c6a <cathode6>:
;-------------------------------- Cflag, ACCU OUT/TEMP/IN ------------- cathode 6
cathode6:
; test ON-OFF key
	sl	KeyRotors+36
    2c6a:	a2 29 d4    	sl.w      0x9a2
	btsc	PORTC,#9
    2c6c:	8d 26 af    	btsc.b    0x68d, #0x1
	bset	KeyRotors+36,#0
    2c6e:	a2 09 a8    	bset.b    0x9a2, #0x0
	inc2	KeyRotors+36,WREG ; test if keynum = 0bxxxxxxxx11111110
    2c70:	a2 89 ec    	inc2.w    0x9a2, WREG
	bra	nz,1f
    2c72:	07 00 3a    	bra       NZ, 0x2c82 <L129>
; ON-OFF pressed
	  btsc	  Flag,#14	  ; dim down in progress?
    2c74:	dd c9 af    	btsc.b    0x9dd, #0x6
	  bra	  1f
    2c76:	05 00 37    	bra       0x2c82 <L129>
	  btsc	  Flag,#15	  ; dim up in progress?
    2c78:	dd e9 af    	btsc.b    0x9dd, #0x7
	  bra	  1f
    2c7a:	03 00 37    	bra       0x2c82 <L129>
	  mov.b	  Dimmer,WREG
    2c7c:	fe c8 bf    	mov.b     0x8fe, WREG
	  mov.b	  WREG,Temp_Dimmer
    2c7e:	ba e9 b7    	mov.b     WREG, 0x9ba
	  bset	  Flag,#14	; dim down MAIN REQUEST (key ON/OFF pressed)
    2c80:	dd c9 a8    	bset.b    0x9dd, #0x6

00002c82 <L129>:
1:
; extra anode 16
	btsc	w3,#b_cena	; Extra bit 16: C ENABLE (schematic) 
    2c82:	03 60 a7    	btsc.w    w3, #0x6
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2c84:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	  btsc	  Flag,#5	  ; #5 set in HISTORY mode
    2c86:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat6
    2c88:	0f 00 37    	bra       0x2ca8 <History_cat6>
	mov	Cflag,w0
    2c8a:	60 49 80    	mov.w     0x92c, w0
	btss	Stack,#0
    2c8c:	2a 09 ae    	btss.b    0x92a, #0x0
	bra	1f
    2c8e:	03 00 37    	bra       0x2c96 <L130>
	btsc	BlinkFlag,#6	; 6 set = Stack blinks
    2c90:	e0 c9 af    	btsc.b    0x9e0, #0x6
	btss	BlinkCount,#9	; blinking freq
    2c92:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	w0,#3		; Stack LED bit
    2c94:	00 30 a0    	bset.w    w0, #0x3

00002c96 <L130>:
1:
	sl	w0,#4,w0	; xxxx xxxx SCCC 0000
    2c96:	44 00 dd    	sl.w      w0, #0x4, w0
; Accumulator OUT / TEMP / IN
	ior	w0,w14,w0	; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2c98:	0e 00 70    	ior.w     w0, w14, w0
	sl	w0,#4,w0	; xxxx SCCC OOOO 0000
    2c9a:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	Atemp,WREG	; xxxx SCCC OOOO TTTT
    2c9c:	28 09 b7    	ior.w     0x928, WREG
	sl	w0,#4,w0	; SCCC OOOO TTTT 0000
    2c9e:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	w0,w13,w0	; SCCC OOOO TTTT IIII (Accu In is w13)
    2ca0:	0d 00 70    	ior.w     w0, w13, w0
	btsc	Flag,#3		; #3 self-check mode
    2ca2:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row6,w0
    2ca4:	a0 4e 80    	mov.w     0x9d4, w0
	bra	disp_w0
    2ca6:	c2 02 37    	bra       0x322c <disp_w0>

00002ca8 <History_cat6>:
History_cat6:			  ; HISTORY mode ............................
	  mov	  History_Cflag,w0
    2ca8:	d0 48 80    	mov.w     0x91a, w0
	  btsc	  History_Stack,#0
    2caa:	1c 09 af    	btsc.b    0x91c, #0x0
	  bset	  w0,#3		  ; Stack LED bit
    2cac:	00 30 a0    	bset.w    w0, #0x3
	  sl	  w0,#4,w0	  ; xxxx xxxx SCCC 0000
    2cae:	44 00 dd    	sl.w      w0, #0x4, w0
  ; Accumulator OUT / TEMP / IN
	  ior	  History_w14,WREG ; xxxx xxxx SCCC OOOO (Accu Out is w14)
    2cb0:	0a 09 b7    	ior.w     0x90a, WREG
	  sl	  w0,#4,w0	  ; xxxx SCCC OOOO 0000
    2cb2:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_Atemp,WREG ; xxxx SCCC OOOO TTTT
    2cb4:	0e 09 b7    	ior.w     0x90e, WREG
	  sl	  w0,#4,w0	  ; SCCC OOOO TTTT 0000
    2cb6:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior	  History_w13,WREG ; SCCC OOOO TTTT IIII (Accu In is w13)
    2cb8:	08 09 b7    	ior.w     0x908, WREG
	  bra	  disp_w0
    2cba:	b8 02 37    	bra       0x322c <disp_w0>

00002cbc <cathode7>:
;-------------------------------- PAGE, OPCODE, OPERX, OPERY ---------- cathode 7
cathode7:
; test keys 16, 17
	keytest	16,7,8
    2cbc:	7c 89 af    	btsc.b    0x97c, #0x4
    2cbe:	1a 00 37    	bra       0x2cf4 <L66>
    2cc0:	9e 29 d4    	sl.w      0x99e
    2cc2:	00 c0 2f    	mov.w     #0xfc00, w0
    2cc4:	9e 29 b7    	ior.w     0x99e
    2cc6:	64 66 af    	btsc.b    0x664, #0x3
    2cc8:	9e 09 a8    	bset.b    0x99e, #0x0
    2cca:	9e 89 ec    	inc2.w    0x99e, WREG
    2ccc:	2d 00 3a    	bra       NZ, 0x2d28 <L73>
    2cce:	a8 29 b6    	and.w     0x9a8
    2cd0:	00 01 20    	mov.w     #0x10, w0
    2cd2:	30 4d 88    	mov.w     w0, 0x9a6
    2cd4:	40 00 b1    	sub.w     #0x4, w0
    2cd6:	42 00 ae    	btss.b    0x42, #0x0
    2cd8:	00 00 20    	mov.w     #0x0, w0
    2cda:	fd e8 b7    	mov.b     WREG, 0x8fd
    2cdc:	dc 29 a8    	bset.b    0x9dc, #0x1
    2cde:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ce0:	f0 00 20    	mov.w     #0xf, w0
    2ce2:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2ce4:	c0 27 29    	mov.w     #0x927c, w0
    2ce6:	b0 4d 88    	mov.w     w0, 0x9b6
    2ce8:	ac e9 ae    	btss.b    0x9ac, #0x7
    2cea:	1f 00 37    	bra       0x2d2a <L84>
    2cec:	00 05 20    	mov.w     #0x50, w0
    2cee:	ab e9 af    	btsc.b    0x9ab, #0x7
    2cf0:	50 4d 88    	mov.w     w0, 0x9aa
    2cf2:	1b 00 37    	bra       0x2d2a <L84>

00002cf4 <L66>:
    2cf4:	a0 29 d4    	sl.w      0x9a0
    2cf6:	00 c0 2f    	mov.w     #0xfc00, w0
    2cf8:	a0 29 b7    	ior.w     0x9a0
    2cfa:	64 86 af    	btsc.b    0x664, #0x4
    2cfc:	a0 09 a8    	bset.b    0x9a0, #0x0
    2cfe:	a0 89 ec    	inc2.w    0x9a0, WREG
    2d00:	13 00 3a    	bra       NZ, 0x2d28 <L73>
    2d02:	a8 29 b6    	and.w     0x9a8
    2d04:	10 01 20    	mov.w     #0x11, w0
    2d06:	30 4d 88    	mov.w     w0, 0x9a6
    2d08:	40 00 b1    	sub.w     #0x4, w0
    2d0a:	42 00 ae    	btss.b    0x42, #0x0
    2d0c:	00 00 20    	mov.w     #0x0, w0
    2d0e:	fd e8 b7    	mov.b     WREG, 0x8fd
    2d10:	dc 29 a8    	bset.b    0x9dc, #0x1
    2d12:	fc 08 a8    	bset.b    0x8fc, #0x0
    2d14:	f0 00 20    	mov.w     #0xf, w0
    2d16:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2d18:	c0 27 29    	mov.w     #0x927c, w0
    2d1a:	b0 4d 88    	mov.w     w0, 0x9b6
    2d1c:	ad 09 ae    	btss.b    0x9ad, #0x0
    2d1e:	05 00 37    	bra       0x2d2a <L84>
    2d20:	00 05 20    	mov.w     #0x50, w0
    2d22:	ab e9 af    	btsc.b    0x9ab, #0x7
    2d24:	50 4d 88    	mov.w     w0, 0x9aa
    2d26:	01 00 37    	bra       0x2d2a <L84>

00002d28 <L73>:
    2d28:	a8 29 b6    	and.w     0x9a8

00002d2a <L84>:
; extra anode 16
	btsc	w3,#b_sel	; Extra bit 16: SEL (bin/sel leds) 
    2d2a:	03 70 a7    	btsc.w    w3, #0x7
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2d2c:	dd 89 a8    	bset.b    0x9dd, #0x4
	  btsc	  Flag,#5	; #5 set in HISTORY mode
    2d2e:	dc a9 af    	btsc.b    0x9dc, #0x5
	  bra	  History_cat7
    2d30:	1e 00 37    	bra       0x2d6e <History_cat7>
	mov.b	Page,WREG	; xxxx xxxx xxxx PPPP
    2d32:	f0 c8 bf    	mov.b     0x8f0, WREG
	sl	w0,#4,w0	; xxxx xxxx PPPP 0000
    2d34:	44 00 dd    	sl.w      w0, #0x4, w0
	mov	Mode,w1
    2d36:	b1 4b 80    	mov.w     0x976, w1
	cp.b	w1,#3
    2d38:	63 0c e1    	cp.b      w1, #0x3
	bra	z,3f		; *** in PGM mode, no Sync Clock Page
    2d3a:	02 00 32    	bra       Z, 0x2d40 <L39>
	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
    2d3c:	dc c9 af    	btsc.b    0x9dc, #0x6
	bra	Alt7		; IF ALT pressed
    2d3e:	06 00 37    	bra       0x2d4c <Alt7>

00002d40 <L39>:
; anodes 0...15
3:
	ior	Opcode,WREG	; xxxx xxxx PPPP OOOO
    2d40:	22 09 b7    	ior.w     0x922, WREG
	sl	w0,#4,w0	; xxxx PPPP OOOO 0000
    2d42:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperX,WREG	; xxxx PPPP OOOO XXXX
    2d44:	24 09 b7    	ior.w     0x924, WREG
	sl	w0,#4,w0	; PPPP OOOO XXXX 0000
    2d46:	44 00 dd    	sl.w      w0, #0x4, w0
	ior	OperY,WREG	; PPPP OOOO XXXX YYYY
    2d48:	26 09 b7    	ior.w     0x926, WREG
	bra	go_disp0d
    2d4a:	07 00 37    	bra       0x2d5a <go_disp0d>

00002d4c <Alt7>:
Alt7:			; IF ALT pressed (not history) (Sync Clock Page)
	cp0	Mode
    2d4c:	76 09 e2    	cp0.w     0x976
	bra	z,alt7alu
    2d4e:	08 00 32    	bra       Z, 0x2d60 <alt7alu>
	ior.b	Sync,WREG	; xxxx xxxx PPPP SSSS
    2d50:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0	; xxxx PPPP SSSS 0000
    2d52:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG	; xxxx PPPP SSSS SSSS
    2d54:	f1 48 b7    	ior.b     0x8f1, WREG
	sl	w0,#4,w0	; PPPP SSSS SSSS 0000
    2d56:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG	; PPPP SSSS SSSS PPPP
    2d58:	f0 48 b7    	ior.b     0x8f0, WREG

00002d5a <go_disp0d>:
go_disp0d:
	btsc	Flag,#3		; #3 self-check mode
    2d5a:	dc 69 af    	btsc.b    0x9dc, #0x3
	mov	Row7,w0
    2d5c:	b0 4e 80    	mov.w     0x9d6, w0
	bra	disp_w0
    2d5e:	66 02 37    	bra       0x322c <disp_w0>

00002d60 <alt7alu>:
alt7alu:		; if ALT pressed in ALU mode (Dim Baud Flash)
	ior.b	Dimmer,WREG	; xxxx xxxx PPPP DDDD
    2d60:	fe 48 b7    	ior.b     0x8fe, WREG
	sl	w0,#4,w0	; xxxx PPPP DDDD 0000
    2d62:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	SerCtrl,WREG	; xxxx PPPP DDDD EBBB
    2d64:	f5 48 b7    	ior.b     0x8f5, WREG
	  bclr	  w0,#3		; spec case: Buad Rate takes only 3 bits
    2d66:	00 30 a1    	bclr.w    w0, #0x3
	sl	w0,#4,w0	; PPPP DDDD 0BBB 0000
    2d68:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	FlashAddr,WREG	; PPPP DDDD 0BBB FFFF
    2d6a:	c0 49 b7    	ior.b     0x9c0, WREG
	bra	disp_w0
    2d6c:	5f 02 37    	bra       0x322c <disp_w0>

00002d6e <History_cat7>:
History_cat7:			  ; HISTORY mode ............................
	  btsc	  Flag,#6		; #6 set if ALT pressed (debounced)
    2d6e:	dc c9 af    	btsc.b    0x9dc, #0x6
	  bra	  History_PageClockDim	; IF ALT pressed
    2d70:	05 00 37    	bra       0x2d7c <History_PageClockDim>
  ; anodes 0...15
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2d72:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#12,w0		; PPPP 0000 0000 0000
    2d74:	4c 00 dd    	sl.w      w0, #0xc, w0
	  mov	  History_w9,w1		; Program Memory Address
    2d76:	11 48 80    	mov.w     0x902, w1
	  ior	  w0,[w1],w0		; PPPP CCCC XXXX YYYY
    2d78:	11 00 70    	ior.w     w0, [w1], w0
	  bra	  disp_w0
    2d7a:	58 02 37    	bra       0x322c <disp_w0>

00002d7c <History_PageClockDim>:
History_PageClockDim:
	  mov.b	  History_Page,WREG	; xxxx xxxx xxxx PPPP
    2d7c:	10 c9 bf    	mov.b     0x910, WREG
	  sl	  w0,#4,w0		; xxxx xxxx PPPP 0000
    2d7e:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  Dimmer,WREG		; xxxx xxxx PPPP SSSS
    2d80:	fe 48 b7    	ior.b     0x8fe, WREG
	  sl	  w0,#4,w0		; xxxx PPPP SSSS 0000
    2d82:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Speed,WREG	; xxxx PPPP SSSS CCCC
    2d84:	14 49 b7    	ior.b     0x914, WREG
	  sl	  w0,#4,w0		; PPPP SSSS CCCC 0000
    2d86:	44 00 dd    	sl.w      w0, #0x4, w0
	  ior.b	  History_Page,WREG	; PPPP SSSS CCCC PPPP
    2d88:	10 49 b7    	ior.b     0x910, WREG
	  bra	  disp_w0
    2d8a:	50 02 37    	bra       0x322c <disp_w0>

00002d8c <cathode8>:
;-------------------------------- MATRIX 0,1 -------------------------- cathode 8
cathode8:
; test keys 0, 1
	keytest	0,0,1
    2d8c:	7c 89 af    	btsc.b    0x97c, #0x4
    2d8e:	1a 00 37    	bra       0x2dc4 <L67>
    2d90:	7e 29 d4    	sl.w      0x97e
    2d92:	00 c0 2f    	mov.w     #0xfc00, w0
    2d94:	7e 29 b7    	ior.w     0x97e
    2d96:	64 66 af    	btsc.b    0x664, #0x3
    2d98:	7e 09 a8    	bset.b    0x97e, #0x0
    2d9a:	7e 89 ec    	inc2.w    0x97e, WREG
    2d9c:	2d 00 3a    	bra       NZ, 0x2df8 <L74>
    2d9e:	a8 29 b6    	and.w     0x9a8
    2da0:	00 00 20    	mov.w     #0x0, w0
    2da2:	30 4d 88    	mov.w     w0, 0x9a6
    2da4:	40 00 b1    	sub.w     #0x4, w0
    2da6:	42 00 ae    	btss.b    0x42, #0x0
    2da8:	00 00 20    	mov.w     #0x0, w0
    2daa:	fd e8 b7    	mov.b     WREG, 0x8fd
    2dac:	dc 29 a8    	bset.b    0x9dc, #0x1
    2dae:	fc 08 a8    	bset.b    0x8fc, #0x0
    2db0:	f0 00 20    	mov.w     #0xf, w0
    2db2:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2db4:	c0 27 29    	mov.w     #0x927c, w0
    2db6:	b0 4d 88    	mov.w     w0, 0x9b6
    2db8:	ac 09 ae    	btss.b    0x9ac, #0x0
    2dba:	1f 00 37    	bra       0x2dfa <L85>
    2dbc:	00 05 20    	mov.w     #0x50, w0
    2dbe:	ab e9 af    	btsc.b    0x9ab, #0x7
    2dc0:	50 4d 88    	mov.w     w0, 0x9aa
    2dc2:	1b 00 37    	bra       0x2dfa <L85>

00002dc4 <L67>:
    2dc4:	80 29 d4    	sl.w      0x980
    2dc6:	00 c0 2f    	mov.w     #0xfc00, w0
    2dc8:	80 29 b7    	ior.w     0x980
    2dca:	64 86 af    	btsc.b    0x664, #0x4
    2dcc:	80 09 a8    	bset.b    0x980, #0x0
    2dce:	80 89 ec    	inc2.w    0x980, WREG
    2dd0:	13 00 3a    	bra       NZ, 0x2df8 <L74>
    2dd2:	a8 29 b6    	and.w     0x9a8
    2dd4:	10 00 20    	mov.w     #0x1, w0
    2dd6:	30 4d 88    	mov.w     w0, 0x9a6
    2dd8:	40 00 b1    	sub.w     #0x4, w0
    2dda:	42 00 ae    	btss.b    0x42, #0x0
    2ddc:	00 00 20    	mov.w     #0x0, w0
    2dde:	fd e8 b7    	mov.b     WREG, 0x8fd
    2de0:	dc 29 a8    	bset.b    0x9dc, #0x1
    2de2:	fc 08 a8    	bset.b    0x8fc, #0x0
    2de4:	f0 00 20    	mov.w     #0xf, w0
    2de6:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2de8:	c0 27 29    	mov.w     #0x927c, w0
    2dea:	b0 4d 88    	mov.w     w0, 0x9b6
    2dec:	ac 29 ae    	btss.b    0x9ac, #0x1
    2dee:	05 00 37    	bra       0x2dfa <L85>
    2df0:	00 05 20    	mov.w     #0x50, w0
    2df2:	ab e9 af    	btsc.b    0x9ab, #0x7
    2df4:	50 4d 88    	mov.w     w0, 0x9aa
    2df6:	01 00 37    	bra       0x2dfa <L85>

00002df8 <L74>:
    2df8:	a8 29 b6    	and.w     0x9a8

00002dfa <L85>:
; extra anode 16
	btsc	w3,#b_pgm	; Extra bit 16: PGM (led) 
    2dfa:	03 80 a7    	btsc.w    w3, #0x8
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2dfc:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+17,w1
    2dfe:	11 81 20    	mov.w     #0x811, w1
	bra	disp_matrix
    2e00:	d8 01 37    	bra       0x31b2 <disp_matrix>

00002e02 <cathode9>:
;-------------------------------- MATRIX 2,3 -------------------------- cathode 9
cathode9:
; test keys 2, 3
	keytest 2,2,3
    2e02:	7c 89 af    	btsc.b    0x97c, #0x4
    2e04:	1a 00 37    	bra       0x2e3a <L68>
    2e06:	82 29 d4    	sl.w      0x982
    2e08:	00 c0 2f    	mov.w     #0xfc00, w0
    2e0a:	82 29 b7    	ior.w     0x982
    2e0c:	64 66 af    	btsc.b    0x664, #0x3
    2e0e:	82 09 a8    	bset.b    0x982, #0x0
    2e10:	82 89 ec    	inc2.w    0x982, WREG
    2e12:	2d 00 3a    	bra       NZ, 0x2e6e <L75>
    2e14:	a8 29 b6    	and.w     0x9a8
    2e16:	20 00 20    	mov.w     #0x2, w0
    2e18:	30 4d 88    	mov.w     w0, 0x9a6
    2e1a:	40 00 b1    	sub.w     #0x4, w0
    2e1c:	42 00 ae    	btss.b    0x42, #0x0
    2e1e:	00 00 20    	mov.w     #0x0, w0
    2e20:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e22:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e24:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e26:	f0 00 20    	mov.w     #0xf, w0
    2e28:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e2a:	c0 27 29    	mov.w     #0x927c, w0
    2e2c:	b0 4d 88    	mov.w     w0, 0x9b6
    2e2e:	ac 49 ae    	btss.b    0x9ac, #0x2
    2e30:	1f 00 37    	bra       0x2e70 <L86>
    2e32:	00 05 20    	mov.w     #0x50, w0
    2e34:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e36:	50 4d 88    	mov.w     w0, 0x9aa
    2e38:	1b 00 37    	bra       0x2e70 <L86>

00002e3a <L68>:
    2e3a:	84 29 d4    	sl.w      0x984
    2e3c:	00 c0 2f    	mov.w     #0xfc00, w0
    2e3e:	84 29 b7    	ior.w     0x984
    2e40:	64 86 af    	btsc.b    0x664, #0x4
    2e42:	84 09 a8    	bset.b    0x984, #0x0
    2e44:	84 89 ec    	inc2.w    0x984, WREG
    2e46:	13 00 3a    	bra       NZ, 0x2e6e <L75>
    2e48:	a8 29 b6    	and.w     0x9a8
    2e4a:	30 00 20    	mov.w     #0x3, w0
    2e4c:	30 4d 88    	mov.w     w0, 0x9a6
    2e4e:	40 00 b1    	sub.w     #0x4, w0
    2e50:	42 00 ae    	btss.b    0x42, #0x0
    2e52:	00 00 20    	mov.w     #0x0, w0
    2e54:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e56:	dc 29 a8    	bset.b    0x9dc, #0x1
    2e58:	fc 08 a8    	bset.b    0x8fc, #0x0
    2e5a:	f0 00 20    	mov.w     #0xf, w0
    2e5c:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2e5e:	c0 27 29    	mov.w     #0x927c, w0
    2e60:	b0 4d 88    	mov.w     w0, 0x9b6
    2e62:	ac 69 ae    	btss.b    0x9ac, #0x3
    2e64:	05 00 37    	bra       0x2e70 <L86>
    2e66:	00 05 20    	mov.w     #0x50, w0
    2e68:	ab e9 af    	btsc.b    0x9ab, #0x7
    2e6a:	50 4d 88    	mov.w     w0, 0x9aa
    2e6c:	01 00 37    	bra       0x2e70 <L86>

00002e6e <L75>:
    2e6e:	a8 29 b6    	and.w     0x9a8

00002e70 <L86>:
; extra anode 16
	btss	w3,#b_run	; Extra bit 16: RUN (led) 
    2e70:	03 90 a6    	btss.w    w3, #0x9
	bra	1f
    2e72:	03 00 37    	bra       0x2e7a <L131>
	btsc	BlinkFlag,#2	; 2 set = LED Run blinks
    2e74:	e0 49 af    	btsc.b    0x9e0, #0x2
	btss	BlinkCount,#9	; bit pos = blinking freq
    2e76:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2e78:	dd 89 a8    	bset.b    0x9dd, #0x4

00002e7a <L131>:
1:
; anodes 0...15
	mov	#Ram+19,w1
    2e7a:	31 81 20    	mov.w     #0x813, w1
	bra	disp_matrix
    2e7c:	9a 01 37    	bra       0x31b2 <disp_matrix>

00002e7e <cathode10>:
;-------------------------------- MATRIX 4,5 -------------------------- cathode 10
cathode10:
; test keys 4, 5
	keytest 4,4,5
    2e7e:	7c 89 af    	btsc.b    0x97c, #0x4
    2e80:	1a 00 37    	bra       0x2eb6 <L69>
    2e82:	86 29 d4    	sl.w      0x986
    2e84:	00 c0 2f    	mov.w     #0xfc00, w0
    2e86:	86 29 b7    	ior.w     0x986
    2e88:	64 66 af    	btsc.b    0x664, #0x3
    2e8a:	86 09 a8    	bset.b    0x986, #0x0
    2e8c:	86 89 ec    	inc2.w    0x986, WREG
    2e8e:	2d 00 3a    	bra       NZ, 0x2eea <L76>
    2e90:	a8 29 b6    	and.w     0x9a8
    2e92:	40 00 20    	mov.w     #0x4, w0
    2e94:	30 4d 88    	mov.w     w0, 0x9a6
    2e96:	40 00 b1    	sub.w     #0x4, w0
    2e98:	42 00 ae    	btss.b    0x42, #0x0
    2e9a:	00 00 20    	mov.w     #0x0, w0
    2e9c:	fd e8 b7    	mov.b     WREG, 0x8fd
    2e9e:	dc 29 a8    	bset.b    0x9dc, #0x1
    2ea0:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ea2:	f0 00 20    	mov.w     #0xf, w0
    2ea4:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2ea6:	c0 27 29    	mov.w     #0x927c, w0
    2ea8:	b0 4d 88    	mov.w     w0, 0x9b6
    2eaa:	ac 89 ae    	btss.b    0x9ac, #0x4
    2eac:	1f 00 37    	bra       0x2eec <L87>
    2eae:	00 05 20    	mov.w     #0x50, w0
    2eb0:	ab e9 af    	btsc.b    0x9ab, #0x7
    2eb2:	50 4d 88    	mov.w     w0, 0x9aa
    2eb4:	1b 00 37    	bra       0x2eec <L87>

00002eb6 <L69>:
    2eb6:	88 29 d4    	sl.w      0x988
    2eb8:	00 c0 2f    	mov.w     #0xfc00, w0
    2eba:	88 29 b7    	ior.w     0x988
    2ebc:	64 86 af    	btsc.b    0x664, #0x4
    2ebe:	88 09 a8    	bset.b    0x988, #0x0
    2ec0:	88 89 ec    	inc2.w    0x988, WREG
    2ec2:	13 00 3a    	bra       NZ, 0x2eea <L76>
    2ec4:	a8 29 b6    	and.w     0x9a8
    2ec6:	50 00 20    	mov.w     #0x5, w0
    2ec8:	30 4d 88    	mov.w     w0, 0x9a6
    2eca:	40 00 b1    	sub.w     #0x4, w0
    2ecc:	42 00 ae    	btss.b    0x42, #0x0
    2ece:	00 00 20    	mov.w     #0x0, w0
    2ed0:	fd e8 b7    	mov.b     WREG, 0x8fd
    2ed2:	dc 29 a8    	bset.b    0x9dc, #0x1
    2ed4:	fc 08 a8    	bset.b    0x8fc, #0x0
    2ed6:	f0 00 20    	mov.w     #0xf, w0
    2ed8:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2eda:	c0 27 29    	mov.w     #0x927c, w0
    2edc:	b0 4d 88    	mov.w     w0, 0x9b6
    2ede:	ac a9 ae    	btss.b    0x9ac, #0x5
    2ee0:	05 00 37    	bra       0x2eec <L87>
    2ee2:	00 05 20    	mov.w     #0x50, w0
    2ee4:	ab e9 af    	btsc.b    0x9ab, #0x7
    2ee6:	50 4d 88    	mov.w     w0, 0x9aa
    2ee8:	01 00 37    	bra       0x2eec <L87>

00002eea <L76>:
    2eea:	a8 29 b6    	and.w     0x9a8

00002eec <L87>:
; extra anode 16
	btss	w3,#b_ss	; Extra bit 16: SS (led) 
    2eec:	03 a0 a6    	btss.w    w3, #0xa
	bra	1f
    2eee:	03 00 37    	bra       0x2ef6 <L132>
	btsc	BlinkFlag,#3	; 3 set = LED SS blinks
    2ef0:	e0 69 af    	btsc.b    0x9e0, #0x3
	btss	BlinkCount,#9	; blinking freq
    2ef2:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ef4:	dd 89 a8    	bset.b    0x9dd, #0x4

00002ef6 <L132>:
1:
; anodes 0...15
	mov	#Ram+21,w1
    2ef6:	51 81 20    	mov.w     #0x815, w1
	bra	disp_matrix
    2ef8:	5c 01 37    	bra       0x31b2 <disp_matrix>

00002efa <cathode11>:
;-------------------------------- MATRIX 6,7 -------------------------- cathode 11
cathode11:
	btsc	Flag,#3		; #3 self-check mode
    2efa:	dc 69 af    	btsc.b    0x9dc, #0x3
	bra	no_in4		; no IN in self-check mode
    2efc:	07 00 37    	bra       0x2f0c <no_in4>
; IN register service
	mov.b	PORTB,WREG
    2efe:	78 c6 bf    	mov.b     0x678, WREG
	lsr	w0,#4,w0
    2f00:	44 00 de    	lsr.w     w0, #0x4, w0
	and	w0,#0x0F,w0
    2f02:	6f 00 60    	and.w     w0, #0xf, w0
	btss	WrFlags,#1	; I/O port select
    2f04:	f3 28 ae    	btss.b    0x8f3, #0x1
	mov.b	WREG,Ram+0x0B	; IN register
    2f06:	0b e8 b7    	mov.b     WREG, 0x80b
	btsc	WrFlags,#1	; I/O port select
    2f08:	f3 28 af    	btsc.b    0x8f3, #0x1
	mov.b	WREG,Ram+0xFB	; IN register
    2f0a:	fb e8 b7    	mov.b     WREG, 0x8fb

00002f0c <no_in4>:
no_in4:
; test keys 6, 7
	keytest 6,5,5
    2f0c:	7c 89 af    	btsc.b    0x97c, #0x4
    2f0e:	1a 00 37    	bra       0x2f44 <L610>
    2f10:	8a 29 d4    	sl.w      0x98a
    2f12:	00 c0 2f    	mov.w     #0xfc00, w0
    2f14:	8a 29 b7    	ior.w     0x98a
    2f16:	64 66 af    	btsc.b    0x664, #0x3
    2f18:	8a 09 a8    	bset.b    0x98a, #0x0
    2f1a:	8a 89 ec    	inc2.w    0x98a, WREG
    2f1c:	2d 00 3a    	bra       NZ, 0x2f78 <L77>
    2f1e:	a8 29 b6    	and.w     0x9a8
    2f20:	60 00 20    	mov.w     #0x6, w0
    2f22:	30 4d 88    	mov.w     w0, 0x9a6
    2f24:	40 00 b1    	sub.w     #0x4, w0
    2f26:	42 00 ae    	btss.b    0x42, #0x0
    2f28:	00 00 20    	mov.w     #0x0, w0
    2f2a:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f2c:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f2e:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f30:	f0 00 20    	mov.w     #0xf, w0
    2f32:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f34:	c0 27 29    	mov.w     #0x927c, w0
    2f36:	b0 4d 88    	mov.w     w0, 0x9b6
    2f38:	ac a9 ae    	btss.b    0x9ac, #0x5
    2f3a:	1f 00 37    	bra       0x2f7a <L88>
    2f3c:	00 05 20    	mov.w     #0x50, w0
    2f3e:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f40:	50 4d 88    	mov.w     w0, 0x9aa
    2f42:	1b 00 37    	bra       0x2f7a <L88>

00002f44 <L610>:
    2f44:	8c 29 d4    	sl.w      0x98c
    2f46:	00 c0 2f    	mov.w     #0xfc00, w0
    2f48:	8c 29 b7    	ior.w     0x98c
    2f4a:	64 86 af    	btsc.b    0x664, #0x4
    2f4c:	8c 09 a8    	bset.b    0x98c, #0x0
    2f4e:	8c 89 ec    	inc2.w    0x98c, WREG
    2f50:	13 00 3a    	bra       NZ, 0x2f78 <L77>
    2f52:	a8 29 b6    	and.w     0x9a8
    2f54:	70 00 20    	mov.w     #0x7, w0
    2f56:	30 4d 88    	mov.w     w0, 0x9a6
    2f58:	40 00 b1    	sub.w     #0x4, w0
    2f5a:	42 00 ae    	btss.b    0x42, #0x0
    2f5c:	00 00 20    	mov.w     #0x0, w0
    2f5e:	fd e8 b7    	mov.b     WREG, 0x8fd
    2f60:	dc 29 a8    	bset.b    0x9dc, #0x1
    2f62:	fc 08 a8    	bset.b    0x8fc, #0x0
    2f64:	f0 00 20    	mov.w     #0xf, w0
    2f66:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2f68:	c0 27 29    	mov.w     #0x927c, w0
    2f6a:	b0 4d 88    	mov.w     w0, 0x9b6
    2f6c:	ac a9 ae    	btss.b    0x9ac, #0x5
    2f6e:	05 00 37    	bra       0x2f7a <L88>
    2f70:	00 05 20    	mov.w     #0x50, w0
    2f72:	ab e9 af    	btsc.b    0x9ab, #0x7
    2f74:	50 4d 88    	mov.w     w0, 0x9aa
    2f76:	01 00 37    	bra       0x2f7a <L88>

00002f78 <L77>:
    2f78:	a8 29 b6    	and.w     0x9a8

00002f7a <L88>:
; extra anode 16
	btsc	w3,#b_alu	;  Extra bit 16:ALU (led) 
    2f7a:	03 b0 a7    	btsc.w    w3, #0xb
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2f7c:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+23,w1
    2f7e:	71 81 20    	mov.w     #0x817, w1
	bra	disp_matrix
    2f80:	18 01 37    	bra       0x31b2 <disp_matrix>

00002f82 <cathode12>:
;-------------------------------- MATRIX 8,9 -------------------------- cathode 12
cathode12:
; test keys 8, 9
	keytest 8,5,6
    2f82:	7c 89 af    	btsc.b    0x97c, #0x4
    2f84:	1a 00 37    	bra       0x2fba <L611>
    2f86:	8e 29 d4    	sl.w      0x98e
    2f88:	00 c0 2f    	mov.w     #0xfc00, w0
    2f8a:	8e 29 b7    	ior.w     0x98e
    2f8c:	64 66 af    	btsc.b    0x664, #0x3
    2f8e:	8e 09 a8    	bset.b    0x98e, #0x0
    2f90:	8e 89 ec    	inc2.w    0x98e, WREG
    2f92:	2d 00 3a    	bra       NZ, 0x2fee <L78>
    2f94:	a8 29 b6    	and.w     0x9a8
    2f96:	80 00 20    	mov.w     #0x8, w0
    2f98:	30 4d 88    	mov.w     w0, 0x9a6
    2f9a:	40 00 b1    	sub.w     #0x4, w0
    2f9c:	42 00 ae    	btss.b    0x42, #0x0
    2f9e:	00 00 20    	mov.w     #0x0, w0
    2fa0:	fd e8 b7    	mov.b     WREG, 0x8fd
    2fa2:	dc 29 a8    	bset.b    0x9dc, #0x1
    2fa4:	fc 08 a8    	bset.b    0x8fc, #0x0
    2fa6:	f0 00 20    	mov.w     #0xf, w0
    2fa8:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2faa:	c0 27 29    	mov.w     #0x927c, w0
    2fac:	b0 4d 88    	mov.w     w0, 0x9b6
    2fae:	ac a9 ae    	btss.b    0x9ac, #0x5
    2fb0:	1f 00 37    	bra       0x2ff0 <L89>
    2fb2:	00 05 20    	mov.w     #0x50, w0
    2fb4:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fb6:	50 4d 88    	mov.w     w0, 0x9aa
    2fb8:	1b 00 37    	bra       0x2ff0 <L89>

00002fba <L611>:
    2fba:	90 29 d4    	sl.w      0x990
    2fbc:	00 c0 2f    	mov.w     #0xfc00, w0
    2fbe:	90 29 b7    	ior.w     0x990
    2fc0:	64 86 af    	btsc.b    0x664, #0x4
    2fc2:	90 09 a8    	bset.b    0x990, #0x0
    2fc4:	90 89 ec    	inc2.w    0x990, WREG
    2fc6:	13 00 3a    	bra       NZ, 0x2fee <L78>
    2fc8:	a8 29 b6    	and.w     0x9a8
    2fca:	90 00 20    	mov.w     #0x9, w0
    2fcc:	30 4d 88    	mov.w     w0, 0x9a6
    2fce:	40 00 b1    	sub.w     #0x4, w0
    2fd0:	42 00 ae    	btss.b    0x42, #0x0
    2fd2:	00 00 20    	mov.w     #0x0, w0
    2fd4:	fd e8 b7    	mov.b     WREG, 0x8fd
    2fd6:	dc 29 a8    	bset.b    0x9dc, #0x1
    2fd8:	fc 08 a8    	bset.b    0x8fc, #0x0
    2fda:	f0 00 20    	mov.w     #0xf, w0
    2fdc:	f9 e8 b7    	mov.b     WREG, 0x8f9
    2fde:	c0 27 29    	mov.w     #0x927c, w0
    2fe0:	b0 4d 88    	mov.w     w0, 0x9b6
    2fe2:	ac c9 ae    	btss.b    0x9ac, #0x6
    2fe4:	05 00 37    	bra       0x2ff0 <L89>
    2fe6:	00 05 20    	mov.w     #0x50, w0
    2fe8:	ab e9 af    	btsc.b    0x9ab, #0x7
    2fea:	50 4d 88    	mov.w     w0, 0x9aa
    2fec:	01 00 37    	bra       0x2ff0 <L89>

00002fee <L78>:
    2fee:	a8 29 b6    	and.w     0x9a8

00002ff0 <L89>:
; extra anode 16
	btss	w3,#b_carry	; Extra bit 16: CARRY (key)
    2ff0:	03 c0 a6    	btss.w    w3, #0xc
	bra	1f
    2ff2:	03 00 37    	bra       0x2ffa <L133>
	btsc	BlinkFlag,#4	; #4 = CARRY blinks
    2ff4:	e0 89 af    	btsc.b    0x9e0, #0x4
	btss	BlinkCount,#9	; blinking freq
    2ff6:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    2ff8:	dd 89 a8    	bset.b    0x9dd, #0x4

00002ffa <L133>:
1:
; anodes 0...15
	mov	#Ram+25,w1
    2ffa:	91 81 20    	mov.w     #0x819, w1
	bra	disp_matrix
    2ffc:	da 00 37    	bra       0x31b2 <disp_matrix>

00002ffe <cathode13>:
;-------------------------------- MATRIX A,B -------------------------- cathode 13
cathode13:
; test keys 10, 11
	keytest 10,6,6
    2ffe:	7c 89 af    	btsc.b    0x97c, #0x4
    3000:	1a 00 37    	bra       0x3036 <L612>
    3002:	92 29 d4    	sl.w      0x992
    3004:	00 c0 2f    	mov.w     #0xfc00, w0
    3006:	92 29 b7    	ior.w     0x992
    3008:	64 66 af    	btsc.b    0x664, #0x3
    300a:	92 09 a8    	bset.b    0x992, #0x0
    300c:	92 89 ec    	inc2.w    0x992, WREG
    300e:	2d 00 3a    	bra       NZ, 0x306a <L79>
    3010:	a8 29 b6    	and.w     0x9a8
    3012:	a0 00 20    	mov.w     #0xa, w0
    3014:	30 4d 88    	mov.w     w0, 0x9a6
    3016:	40 00 b1    	sub.w     #0x4, w0
    3018:	42 00 ae    	btss.b    0x42, #0x0
    301a:	00 00 20    	mov.w     #0x0, w0
    301c:	fd e8 b7    	mov.b     WREG, 0x8fd
    301e:	dc 29 a8    	bset.b    0x9dc, #0x1
    3020:	fc 08 a8    	bset.b    0x8fc, #0x0
    3022:	f0 00 20    	mov.w     #0xf, w0
    3024:	f9 e8 b7    	mov.b     WREG, 0x8f9
    3026:	c0 27 29    	mov.w     #0x927c, w0
    3028:	b0 4d 88    	mov.w     w0, 0x9b6
    302a:	ac c9 ae    	btss.b    0x9ac, #0x6
    302c:	1f 00 37    	bra       0x306c <L810>
    302e:	00 05 20    	mov.w     #0x50, w0
    3030:	ab e9 af    	btsc.b    0x9ab, #0x7
    3032:	50 4d 88    	mov.w     w0, 0x9aa
    3034:	1b 00 37    	bra       0x306c <L810>

00003036 <L612>:
    3036:	94 29 d4    	sl.w      0x994
    3038:	00 c0 2f    	mov.w     #0xfc00, w0
    303a:	94 29 b7    	ior.w     0x994
    303c:	64 86 af    	btsc.b    0x664, #0x4
    303e:	94 09 a8    	bset.b    0x994, #0x0
    3040:	94 89 ec    	inc2.w    0x994, WREG
    3042:	13 00 3a    	bra       NZ, 0x306a <L79>
    3044:	a8 29 b6    	and.w     0x9a8
    3046:	b0 00 20    	mov.w     #0xb, w0
    3048:	30 4d 88    	mov.w     w0, 0x9a6
    304a:	40 00 b1    	sub.w     #0x4, w0
    304c:	42 00 ae    	btss.b    0x42, #0x0
    304e:	00 00 20    	mov.w     #0x0, w0
    3050:	fd e8 b7    	mov.b     WREG, 0x8fd
    3052:	dc 29 a8    	bset.b    0x9dc, #0x1
    3054:	fc 08 a8    	bset.b    0x8fc, #0x0
    3056:	f0 00 20    	mov.w     #0xf, w0
    3058:	f9 e8 b7    	mov.b     WREG, 0x8f9
    305a:	c0 27 29    	mov.w     #0x927c, w0
    305c:	b0 4d 88    	mov.w     w0, 0x9b6
    305e:	ac c9 ae    	btss.b    0x9ac, #0x6
    3060:	05 00 37    	bra       0x306c <L810>
    3062:	00 05 20    	mov.w     #0x50, w0
    3064:	ab e9 af    	btsc.b    0x9ab, #0x7
    3066:	50 4d 88    	mov.w     w0, 0x9aa
    3068:	01 00 37    	bra       0x306c <L810>

0000306a <L79>:
    306a:	a8 29 b6    	and.w     0x9a8

0000306c <L810>:
; extra anode 16
	btss	w3,#b_save	; Extra bit 16: SAVE (key)
    306c:	03 d0 a6    	btss.w    w3, #0xd
	bra	1f
    306e:	03 00 37    	bra       0x3076 <L134>
	btsc	BlinkFlag,#5	; #5 = SAVE blinks
    3070:	e0 a9 af    	btsc.b    0x9e0, #0x5
	btss	BlinkCount,#9	; blinking freq
    3072:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3074:	dd 89 a8    	bset.b    0x9dd, #0x4

00003076 <L134>:
1:
; anodes 0...15
	mov	#Ram+27,w1
    3076:	b1 81 20    	mov.w     #0x81b, w1
	bra	disp_matrix
    3078:	9c 00 37    	bra       0x31b2 <disp_matrix>

0000307a <cathode14>:
;-------------------------------- MATRIX C,D -------------------------- cathode 14
cathode14:
	mov	BlinkCount,w0
    307a:	e0 4b 80    	mov.w     0x97c, w0
	mov	#0b110000,w1	; dim down/up speed
    307c:	01 03 20    	mov.w     #0x30, w1
	and	w0,w1,w0
    307e:	01 00 60    	and.w     w0, w1, w0
	bra	nz,no_dim_up
    3080:	0f 00 3a    	bra       NZ, 0x30a0 <no_dim_up>
; dim down \\\\\\\\\\\\\\\\\\\\\
	btss	Flag,#14	; #14 set if dim down in progress
    3082:	dd c9 ae    	btss.b    0x9dd, #0x6
	bra	no_dim_down
    3084:	05 00 37    	bra       0x3090 <no_dim_down>
	cp0.b	Dimmer
    3086:	fe 48 e2    	cp0.b     0x8fe
	ifz
    3088:	42 20 af    	btsc.b    0x42, #0x1
	bclr	Flag,#14	; end of dim down
    308a:	dd c9 a9    	bclr.b    0x9dd, #0x6
	bra	z,enter_sleep	; GO SLEEP -------------------------------------->
    308c:	19 01 32    	bra       Z, 0x32c0 <enter_sleep>
	dec.b	Dimmer
    308e:	fe 68 ed    	dec.b     0x8fe

00003090 <no_dim_down>:
no_dim_down:
; dim up ///////////////////////
	btss	Flag,#15	; #15 set if dim up in progress
    3090:	dd e9 ae    	btss.b    0x9dd, #0x7
	bra	no_dim_up
    3092:	06 00 37    	bra       0x30a0 <no_dim_up>
	mov.b	Temp_Dimmer,WREG
    3094:	ba c9 bf    	mov.b     0x9ba, WREG
	cp.b	Dimmer		; Dimmer - Temp_Dimmer
    3096:	fe 48 e3    	cp.b      0x8fe
	ifc
    3098:	42 00 af    	btsc.b    0x42, #0x0
	bclr	Flag,#15	; end of dim up
    309a:	dd e9 a9    	bclr.b    0x9dd, #0x7
	ifnc
    309c:	42 00 ae    	btss.b    0x42, #0x0
	inc.b	Dimmer
    309e:	fe 68 ec    	inc.b     0x8fe

000030a0 <no_dim_up>:
no_dim_up:
; test keys 12, 13
	keytest 12,6,7
    30a0:	7c 89 af    	btsc.b    0x97c, #0x4
    30a2:	1a 00 37    	bra       0x30d8 <L613>
    30a4:	96 29 d4    	sl.w      0x996
    30a6:	00 c0 2f    	mov.w     #0xfc00, w0
    30a8:	96 29 b7    	ior.w     0x996
    30aa:	64 66 af    	btsc.b    0x664, #0x3
    30ac:	96 09 a8    	bset.b    0x996, #0x0
    30ae:	96 89 ec    	inc2.w    0x996, WREG
    30b0:	2d 00 3a    	bra       NZ, 0x310c <L710>
    30b2:	a8 29 b6    	and.w     0x9a8
    30b4:	c0 00 20    	mov.w     #0xc, w0
    30b6:	30 4d 88    	mov.w     w0, 0x9a6
    30b8:	40 00 b1    	sub.w     #0x4, w0
    30ba:	42 00 ae    	btss.b    0x42, #0x0
    30bc:	00 00 20    	mov.w     #0x0, w0
    30be:	fd e8 b7    	mov.b     WREG, 0x8fd
    30c0:	dc 29 a8    	bset.b    0x9dc, #0x1
    30c2:	fc 08 a8    	bset.b    0x8fc, #0x0
    30c4:	f0 00 20    	mov.w     #0xf, w0
    30c6:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30c8:	c0 27 29    	mov.w     #0x927c, w0
    30ca:	b0 4d 88    	mov.w     w0, 0x9b6
    30cc:	ac c9 ae    	btss.b    0x9ac, #0x6
    30ce:	1f 00 37    	bra       0x310e <L811>
    30d0:	00 05 20    	mov.w     #0x50, w0
    30d2:	ab e9 af    	btsc.b    0x9ab, #0x7
    30d4:	50 4d 88    	mov.w     w0, 0x9aa
    30d6:	1b 00 37    	bra       0x310e <L811>

000030d8 <L613>:
    30d8:	98 29 d4    	sl.w      0x998
    30da:	00 c0 2f    	mov.w     #0xfc00, w0
    30dc:	98 29 b7    	ior.w     0x998
    30de:	64 86 af    	btsc.b    0x664, #0x4
    30e0:	98 09 a8    	bset.b    0x998, #0x0
    30e2:	98 89 ec    	inc2.w    0x998, WREG
    30e4:	13 00 3a    	bra       NZ, 0x310c <L710>
    30e6:	a8 29 b6    	and.w     0x9a8
    30e8:	d0 00 20    	mov.w     #0xd, w0
    30ea:	30 4d 88    	mov.w     w0, 0x9a6
    30ec:	40 00 b1    	sub.w     #0x4, w0
    30ee:	42 00 ae    	btss.b    0x42, #0x0
    30f0:	00 00 20    	mov.w     #0x0, w0
    30f2:	fd e8 b7    	mov.b     WREG, 0x8fd
    30f4:	dc 29 a8    	bset.b    0x9dc, #0x1
    30f6:	fc 08 a8    	bset.b    0x8fc, #0x0
    30f8:	f0 00 20    	mov.w     #0xf, w0
    30fa:	f9 e8 b7    	mov.b     WREG, 0x8f9
    30fc:	c0 27 29    	mov.w     #0x927c, w0
    30fe:	b0 4d 88    	mov.w     w0, 0x9b6
    3100:	ac e9 ae    	btss.b    0x9ac, #0x7
    3102:	05 00 37    	bra       0x310e <L811>
    3104:	00 05 20    	mov.w     #0x50, w0
    3106:	ab e9 af    	btsc.b    0x9ab, #0x7
    3108:	50 4d 88    	mov.w     w0, 0x9aa
    310a:	01 00 37    	bra       0x310e <L811>

0000310c <L710>:
    310c:	a8 29 b6    	and.w     0x9a8

0000310e <L811>:
; extra anode 16
	btss	w3,#b_load	; Extra bit 16: LOAD (key) 
    310e:	03 e0 a6    	btss.w    w3, #0xe
	bra	1f
    3110:	03 00 37    	bra       0x3118 <L135>
	btsc	BlinkFlag,#7	; #7 = LOAD blinks
    3112:	e0 e9 af    	btsc.b    0x9e0, #0x7
	btss	BlinkCount,#9	; blinking freq
    3114:	7d 29 ae    	btss.b    0x97d, #0x1
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3116:	dd 89 a8    	bset.b    0x9dd, #0x4

00003118 <L135>:
1:
; anodes 0...15
	mov	#Ram+29,w1
    3118:	d1 81 20    	mov.w     #0x81d, w1
	bra	disp_matrix
    311a:	4b 00 37    	bra       0x31b2 <disp_matrix>

0000311c <cathode15>:
;-------------------------------- MATRIX E,F -------------------------- cathode 15
cathode15:
; test keys 14, 15
	keytest 14,7,7
    311c:	7c 89 af    	btsc.b    0x97c, #0x4
    311e:	1a 00 37    	bra       0x3154 <L614>
    3120:	9a 29 d4    	sl.w      0x99a
    3122:	00 c0 2f    	mov.w     #0xfc00, w0
    3124:	9a 29 b7    	ior.w     0x99a
    3126:	64 66 af    	btsc.b    0x664, #0x3
    3128:	9a 09 a8    	bset.b    0x99a, #0x0
    312a:	9a 89 ec    	inc2.w    0x99a, WREG
    312c:	2d 00 3a    	bra       NZ, 0x3188 <L711>
    312e:	a8 29 b6    	and.w     0x9a8
    3130:	e0 00 20    	mov.w     #0xe, w0
    3132:	30 4d 88    	mov.w     w0, 0x9a6
    3134:	40 00 b1    	sub.w     #0x4, w0
    3136:	42 00 ae    	btss.b    0x42, #0x0
    3138:	00 00 20    	mov.w     #0x0, w0
    313a:	fd e8 b7    	mov.b     WREG, 0x8fd
    313c:	dc 29 a8    	bset.b    0x9dc, #0x1
    313e:	fc 08 a8    	bset.b    0x8fc, #0x0
    3140:	f0 00 20    	mov.w     #0xf, w0
    3142:	f9 e8 b7    	mov.b     WREG, 0x8f9
    3144:	c0 27 29    	mov.w     #0x927c, w0
    3146:	b0 4d 88    	mov.w     w0, 0x9b6
    3148:	ac e9 ae    	btss.b    0x9ac, #0x7
    314a:	1f 00 37    	bra       0x318a <L812>
    314c:	00 05 20    	mov.w     #0x50, w0
    314e:	ab e9 af    	btsc.b    0x9ab, #0x7
    3150:	50 4d 88    	mov.w     w0, 0x9aa
    3152:	1b 00 37    	bra       0x318a <L812>

00003154 <L614>:
    3154:	9c 29 d4    	sl.w      0x99c
    3156:	00 c0 2f    	mov.w     #0xfc00, w0
    3158:	9c 29 b7    	ior.w     0x99c
    315a:	64 86 af    	btsc.b    0x664, #0x4
    315c:	9c 09 a8    	bset.b    0x99c, #0x0
    315e:	9c 89 ec    	inc2.w    0x99c, WREG
    3160:	13 00 3a    	bra       NZ, 0x3188 <L711>
    3162:	a8 29 b6    	and.w     0x9a8
    3164:	f0 00 20    	mov.w     #0xf, w0
    3166:	30 4d 88    	mov.w     w0, 0x9a6
    3168:	40 00 b1    	sub.w     #0x4, w0
    316a:	42 00 ae    	btss.b    0x42, #0x0
    316c:	00 00 20    	mov.w     #0x0, w0
    316e:	fd e8 b7    	mov.b     WREG, 0x8fd
    3170:	dc 29 a8    	bset.b    0x9dc, #0x1
    3172:	fc 08 a8    	bset.b    0x8fc, #0x0
    3174:	f0 00 20    	mov.w     #0xf, w0
    3176:	f9 e8 b7    	mov.b     WREG, 0x8f9
    3178:	c0 27 29    	mov.w     #0x927c, w0
    317a:	b0 4d 88    	mov.w     w0, 0x9b6
    317c:	ac e9 ae    	btss.b    0x9ac, #0x7
    317e:	05 00 37    	bra       0x318a <L812>
    3180:	00 05 20    	mov.w     #0x50, w0
    3182:	ab e9 af    	btsc.b    0x9ab, #0x7
    3184:	50 4d 88    	mov.w     w0, 0x9aa
    3186:	01 00 37    	bra       0x318a <L812>

00003188 <L711>:
    3188:	a8 29 b6    	and.w     0x9a8

0000318a <L812>:
; anykey ---> Flag,#11 test
	btss	BlinkCount,#4
    318a:	7c 89 ae    	btss.b    0x97c, #0x4
	bra	1f		; if odd pass
    318c:	07 00 37    	bra       0x319c <L136>
	bclr	Flag,#11	; #11 flag "any Key Pressed"
    318e:	dd 69 a9    	bclr.b    0x9dd, #0x3
	btss	Anypress,#0	; bit 0 is reset if any key still depressed
    3190:	a8 09 ae    	btss.b    0x9a8, #0x0
	bset	Flag,#11	; #11 flag "any Key Pressed"
    3192:	dd 69 a8    	bset.b    0x9dd, #0x3
;	btsc	Flag,#6		; #6 set if ALT pressed (debounced)
;	bset	Flag,#11	;WrFlags #11 flag "any Key Pressed"
	bclr.b	KeyStatus,#2	; user's flag "any key pressed"
    3194:	fc 48 a9    	bclr.b    0x8fc, #0x2
	btsc	Flag,#11	; #11 flag "any Key Pressed" (will be moved to KeyStatus,#2)
    3196:	dd 69 af    	btsc.b    0x9dd, #0x3
	bset.b	KeyStatus,#2	; user's flag "any key pressed"
    3198:	fc 48 a8    	bset.b    0x8fc, #0x2
	bra	2f
    319a:	08 00 37    	bra       0x31ac <L211>

0000319c <L136>:
1:
; test if last key is still pressed (service KeyStatus,#1)
	bclr.b	KeyStatus,#1	; user's flag "last key pressed"
    319c:	fc 28 a9    	bclr.b    0x8fc, #0x1
	sl.b	KeyReg,WREG	; ×2
    319e:	fd 48 d4    	sl.b      0x8fd, WREG
	and	#0x1F,w0
    31a0:	f0 01 b2    	and.w     #0x1f, w0
	bra	z,2f		; if last key = 0, 1, 2, 3, 4 (illegal keys)
    31a2:	04 00 32    	bra       Z, 0x31ac <L211>
	mov	#KeyRotors+8,w1
    31a4:	61 98 20    	mov.w     #0x986, w1
	add	w0,w1,w0	; debouncer for the last pressed key
    31a6:	01 00 40    	add.w     w0, w1, w0
	btss	[w0],#0
    31a8:	10 00 a6    	btss.w    [w0], #0x0
	bset.b	KeyStatus,#1	; user's flag "last key pressed"
    31aa:	fc 28 a8    	bset.b    0x8fc, #0x1

000031ac <L211>:
2:
; extra anode 16
	btsc	w3,#b_bin	; Extra bit 16: BIN (bin/sel leds) 
    31ac:	03 f0 a7    	btsc.w    w3, #0xf
	bset	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    31ae:	dd 89 a8    	bset.b    0x9dd, #0x4
; anodes 0...15
	mov	#Ram+31,w1
    31b0:	f1 81 20    	mov.w     #0x81f, w1

000031b2 <disp_matrix>:
disp_matrix:
  ; History cathodes 8...15 conditional setup
	  btss	  Flag,#5	  ; #5 set in HISTORY mode
    31b2:	dc a9 ae    	btss.b    0x9dc, #0x5
	  bra	  regular_15
    31b4:	09 00 37    	bra       0x31c8 <regular_15>
  ; get bytes from unpacked history RAM pages
	  mov	  History_Visible,w1
    31b6:	01 48 80    	mov.w     0x900, w1
	  btss	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    31b8:	dc c9 ae    	btss.b    0x9dc, #0x6
	  add	  #16,w1	  ; address for hist RAM page 0 is History_Visible+16
    31ba:	01 01 b0    	add.w     #0x10, w1
	  mov	  RowScan,w0
    31bc:	c0 4b 80    	mov.w     0x978, w0
	  and	  #7,w0		  ; 8...15 ---> 0...7
    31be:	70 00 b2    	and.w     #0x7, w0
	  sl	  w0,w0		  ; ×2
    31c0:	00 00 d0    	sl.w      w0, w0
	  add	  w0,w1,w1
    31c2:	81 00 40    	add.w     w0, w1, w1
	  mov	  [w1],w0	  ; here's unpacked word ready for display ports
    31c4:	11 00 78    	mov.w     [w1], w0
	  bra	  skr_15
    31c6:	28 00 37    	bra       0x3218 <skr_15>

000031c8 <regular_15>:
regular_15:
	mov.b	Page,WREG
    31c8:	f0 c8 bf    	mov.b     0x8f0, WREG
	  btsc	  Flag,#6	  ; #6 set if ALT pressed (debounced)
    31ca:	dc c9 af    	btsc.b    0x9dc, #0x6
	  clr	  w0		  ; if ALT pressed, then page 0
    31cc:	00 00 eb    	clr.w     w0
	ze	w0,w0
    31ce:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; w0 = 16 × Page
    31d0:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w0,w1,w1	; w1 = #Ram + (16×Page) + 31
    31d2:	81 00 40    	add.w     w0, w1, w1
	sub	w1,#16,w2	; w2 = #Ram + (16×Page) + 15
    31d4:	70 81 50    	sub.w     w1, #0x10, w2
; if >15 then wrap to 0
	mov	#Ram+255,w0
    31d6:	f0 8f 20    	mov.w     #0x8ff, w0
	cp	w1,w0
    31d8:	00 08 e1    	cp.w      w1, w0
	ifc
    31da:	42 00 af    	btsc.b    0x42, #0x0
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    31dc:	01 10 b1    	sub.w     #0x100, w1
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    31de:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    31e0:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    31e2:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    31e4:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1],w0	; 0000 AAAA CCCC BBBB
    31e6:	11 40 70    	ior.b     w0, [w1], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    31e8:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2],w0	; AAAA CCCC BBBB DDDD
    31ea:	12 40 70    	ior.b     w0, [w2], w0
; blank matrix in mode 0 and mode 3
	mov	Mode,w2
    31ec:	b2 4b 80    	mov.w     0x976, w2
	cp0	w2
    31ee:	02 00 e0    	cp0.w     w2
	bra	nz,1f		; if Mode not ALU
    31f0:	10 00 3a    	bra       NZ, 0x3212 <L137>
; Mode = Dir
	btsc	Flag2,#8	; #8 set = first button pressed, Ver/Rev deleted
    31f2:	df 09 af    	btsc.b    0x9df, #0x0
	bra	3f
    31f4:	08 00 37    	bra       0x3206 <L310>
; no buttons pressed yet (Ver/Rev mode)
	mov	RowScan,w2
    31f6:	c2 4b 80    	mov.w     0x978, w2
	cp	w2,#13		; here are rows 10 and 11
    31f8:	6d 10 e1    	cp.w      w2, #0xd
	ifz
    31fa:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS1,w0		; if in Ver/Rev mode, show CHS
    31fc:	c0 4e 80    	mov.w     0x9d8, w0
	cp	w2,#15		; here are rows 14 and 15
    31fe:	6f 10 e1    	cp.w      w2, #0xf
	ifz
    3200:	42 20 af    	btsc.b    0x42, #0x1
	mov	CHS2,w0		; if in Ver/Rev mode, show CHS
    3202:	d0 4e 80    	mov.w     0x9da, w0
	bra	skr_15		; if no buttons pressed yet, show Ver/Rev
    3204:	09 00 37    	bra       0x3218 <skr_15>

00003206 <L310>:
3:
	btss	Flag,#6		; #6 set if ALT pressed (debounced)
    3206:	dc c9 ae    	btss.b    0x9dc, #0x6
	bra	2f		; clear matrix data
    3208:	06 00 37    	bra       0x3216 <L212>
; ALT pressed in ALU mode, anodes 7-15 show Files occupancy
	sl	RowScan,WREG
    320a:	78 09 d4    	sl.w      0x978, WREG
	and	#0x0F,w0
    320c:	f0 00 b2    	and.w     #0xf, w0
	mov	#Files,w1
    320e:	61 96 20    	mov.w     #0x966, w1
	mov	[w0+w1],w0
    3210:	60 80 78    	mov.w     [w0+w1], w0

00003212 <L137>:
1:
	cp	w2,#3		; if Mode = 3 (Run)...
    3212:	63 10 e1    	cp.w      w2, #0x3
	ifz
    3214:	42 20 af    	btsc.b    0x42, #0x1

00003216 <L212>:
2:
	mov	#0,w0		; ...then clear matrix data
    3216:	00 00 20    	mov.w     #0x0, w0

00003218 <skr_15>:
; end of blank matrix in mode 0 and mode 3
skr_15:
; Final matrix anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    3218:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    321a:	dd 89 a9    	bclr.b    0x9dd, #0x4
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    321c:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    321e:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    3220:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATC	; LED anodes 0...7 set
    3222:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    3224:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#2	; 2 set = Matrix Off
    3226:	f3 48 ae    	btss.b    0x8f3, #0x2
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    3228:	7b e6 b7    	mov.b     WREG, 0x67b
	bra	t1exit
    322a:	09 00 37    	bra       0x323e <t1exit>

0000322c <disp_w0>:
; ------------------------------------------------------
disp_w0:		; display service for cathodes 0...7
; Final LED anode port write (respects blank request)
	btsc.b	WrFlags,#3	; 3 set = Leds Off
    322c:	f3 68 af    	btsc.b    0x8f3, #0x3
	bclr	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    322e:	dd 89 a9    	bclr.b    0x9dd, #0x4

00003230 <disp_w0_noblank>:
disp_w0_noblank:
	btsc	Flag,#12	; #12 temp LATC,#8 (column 17 anode)
    3230:	dd 89 af    	btsc.b    0x9dd, #0x4
	bset	LATC,#8		; column 17
    3232:	8f 06 a8    	bset.b    0x68f, #0x0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    3234:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATC	; LED anodes 0...7 set
    3236:	8e e6 b7    	mov.b     WREG, 0x68e
	swap	w0
    3238:	00 80 fd    	swap.w    w0
	btss.b	WrFlags,#3	; 3 set = Leds Off
    323a:	f3 68 ae    	btss.b    0x8f3, #0x3
	mov.b	WREG,LATB+1	; LED anodes 8...15 set
    323c:	7b e6 b7    	mov.b     WREG, 0x67b

0000323e <t1exit>:
; ------------------------------------------------------
t1exit:
; final exit from interrupt
	pop.s			; /
    323e:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    3240:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    3242:	00 40 06    	retfie    

00003244 <aux_int>:
; ------------------------------------------------------
aux_int:		; aux_int only turns off LEDs, for dimming
	bclr	Flag,#13	; #13 toggle between int (0) - aux_int (1)
    3244:	dd a9 a9    	bclr.b    0x9dd, #0x5
	clr	LATC		; all LEDS off (here's LATC,#8 also)
    3246:	8e 26 ef    	clr.w     0x68e
	clr.b	LATB+1		; all LEDS off
    3248:	7b 66 ef    	clr.b     0x67b

	mov	PR1copy,w0	; w0 =  10,  22,  28,  38,  52...412, 470
    324a:	10 4e 80    	mov.w     0x9c2, w0
	mov	#475,w2
    324c:	b2 1d 20    	mov.w     #0x1db, w2
	sub	w2,w0,w0
    324e:	00 00 51    	sub.w     w2, w0, w0
; mov #10,w0 ;(samo za snimanje 60 fps)
	mov	w0,PR1
    3250:	90 0c 88    	mov.w     w0, 0x192

	pop.s			; /
    3252:	00 80 fe    	pop.s     
	bclr	IFS0,#3		; clr int flag
    3254:	88 60 a9    	bclr.b    0x88, #0x3
	retfie			; ---------->
    3256:	00 40 06    	retfie    

00003258 <T3Int>:

;***********************************************************************************
;****************************       T3 INTERRUPT       *****************************
;****************************       USER'S SYNC        *****************************
;***********************************************************************************
T3Int:				; TIMER 3 int, user's sync
	bset.b	RdFlags,#0	; #0 user's SYNC
    3258:	f4 08 a8    	bset.b    0x8f4, #0x0
	nop			; * * *   MCU BUG FIX  ???   * * *
    325a:	00 00 00    	nop       
	bclr	IFS0,#8		; clr int flag (skips this line without NOP)
    325c:	89 00 a9    	bclr.b    0x89, #0x0
	retfie
    325e:	00 40 06    	retfie    

00003260 <U1RXInt>:

;***********************************************************************************
;***********************              RX1 INTERRUPT           **********************
;***********************************************************************************

; Character is received in U1RXREG
; read char and clear UART RX flag UXRDA
; if SerH:L is free, put it there and increment Received; finished
; if there is no room in FIFO, ignore all and exit (character is lost)
; else, put it at the end of FIFO (@WRPtr), inc WRPtr, calc Received

U1RXInt:			; RX1 interrupt
	push.s		   ; \
    3260:	00 a0 fe    	push.s    
	mov	U1RXREG,w1	; <---- get received byte (this resets U1STAL,#URXDA)
    3262:	f1 1c 80    	mov.w     0x39e, w1
	btsc	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    3264:	de 49 af    	btsc.b    0x9de, #0x2
	bra	move2fifo
    3266:	0a 00 37    	bra       0x327c <move2fifo>
; move char to SerH:L
	lsr	w1,#4,w0
    3268:	44 08 de    	lsr.w     w1, #0x4, w0
	mov.b	WREG,SerHigh
    326a:	f7 e8 b7    	mov.b     WREG, 0x8f7
	and	w1,#0x0F,w0
    326c:	6f 80 60    	and.w     w1, #0xf, w0
	mov.b	WREG,SerLow
    326e:	f6 e8 b7    	mov.b     WREG, 0x8f6
	mov	#1,w0
    3270:	10 00 20    	mov.w     #0x1, w0
	mov.b	WREG,Received
    3272:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; #2 handshaking flag (for FIFO ---> SerHigh:SerLow)
    3274:	de 49 a8    	bset.b    0x9de, #0x2
	bclr	IFS0,#11	; clr int flag
    3276:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    3278:	00 80 fe    	pop.s     
	retfie
    327a:	00 40 06    	retfie    

0000327c <move2fifo>:
move2fifo:		; move char to fifo
	mov	RXWR,w2
    327c:	e2 4d 80    	mov.w     0x9bc, w2
	inc.b	w2,w0		; pre-inc RXWR (in byte mode, to wrap inside RX buffer)
    327e:	02 40 e8    	inc.b     w2, w0
	cp.b	RXRD
    3280:	be 49 e3    	cp.b      0x9be
	bra	nz,fifo_room	; if there's free place in FIFO, continue, else...
    3282:	02 00 3a    	bra       NZ, 0x3288 <fifo_room>
	bset.b	SerCtrl,#3	; ...set error flag...
    3284:	f5 68 a8    	bset.b    0x8f5, #0x3
	bra	nochar		; ...and quit
    3286:	0b 00 37    	bra       0x329e <nochar>

00003288 <fifo_room>:
fifo_room:
	mov.b	w1,[w2]		; put char to FIFO
    3288:	01 49 78    	mov.b     w1, [w2]
	inc.b	RXWR		; inc write ptr (in byte mode, to wrap inside RX byffer)
    328a:	bc 69 ec    	inc.b     0x9bc
; Calculate Received
	mov	RXRD,WREG
    328c:	be 89 bf    	mov.w     0x9be, WREG
	sub	RXWR,WREG	; RXWR-RXRD (byte mode, to stay in range 0000-00FF)
    328e:	bc 09 b5    	sub.w     0x9bc, WREG
	ze	w0,w0
    3290:	00 80 fb    	ze        w0, w0
	inc	w0,w0		; as SerH:L is surely full
    3292:	00 00 e8    	inc.w     w0, w0
	cp	w0,#15
    3294:	6f 00 e1    	cp.w      w0, #0xf
	ifc
    3296:	42 00 af    	btsc.b    0x42, #0x0
	mov	#15,w0		; clip to 15
    3298:	f0 00 20    	mov.w     #0xf, w0
	mov.b	WREG,Received
    329a:	f8 e8 b7    	mov.b     WREG, 0x8f8
	bset	Flag2,#2	; set handshaking flag (for FIFO ---> SerHigh:SerLow)
    329c:	de 49 a8    	bset.b    0x9de, #0x2

0000329e <nochar>:
nochar:
	bclr	IFS0,#11	; clr int flag
    329e:	89 60 a9    	bclr.b    0x89, #0x3
	pop.s		   ; /
    32a0:	00 80 fe    	pop.s     
	retfie
    32a2:	00 40 06    	retfie    

000032a4 <U1ErrInt>:

;***********************************************************************************
;***********************          RX1 ERROR INTERRUPT       **********************
;***********************************************************************************
U1ErrInt:			; U1EIE interrupt
	bclr	U1STA,#1	; clr err flag
    32a4:	9a 23 a9    	bclr.b    0x39a, #0x1
	bclr	U1STA,#2	; clr err flag
    32a6:	9a 43 a9    	bclr.b    0x39a, #0x2
	bclr	IFS4,#1
    32a8:	90 20 a9    	bclr.b    0x90, #0x1
	retfie
    32aa:	00 40 06    	retfie    

000032ac <U2RXInt>:

;***********************************************************************************
;***********************      CURREENTLY UNUSED INTERRUPTS     **********************
;***********************************************************************************
U2RXInt:			; RX2 interrupt
	bclr	IFS1,#14	; clr int flag
    32ac:	8b c0 a9    	bclr.b    0x8b, #0x6
	retfie
    32ae:	00 40 06    	retfie    

000032b0 <INT2Int>:
;		
INT2Int:			; external INT2 interrupt
	bclr	IFS1,#13	; clr int flag
    32b0:	8b a0 a9    	bclr.b    0x8b, #0x5
	retfie			; ---------->
    32b2:	00 40 06    	retfie    

000032b4 <U2ErrInt>:
;		
U2ErrInt:			; U2EIE interrupt
	bclr	U2STA,#1	; clr err flag
    32b4:	b0 23 a9    	bclr.b    0x3b0, #0x1
	bclr	U2STA,#2	; clr err flag
    32b6:	b0 43 a9    	bclr.b    0x3b0, #0x2
	bclr	IFS4,#2
    32b8:	90 40 a9    	bclr.b    0x90, #0x2
	retfie
    32ba:	00 40 06    	retfie    

000032bc <INT1Int>:

;***********************************************************************************
;***********************         EXTERNAL INT 1 SERVICE       **********************
;***********************************************************************************
INT1Int:		; ON/OFF button interrupt (shouldn't come here as INTCON2,#GIE ...
			; ...and IEC1,#4 are never ON at the same time, but just in case)
	bclr	IFS1,#4
    32bc:	8a 80 a9    	bclr.b    0x8a, #0x4
	retfie
    32be:	00 40 06    	retfie    

000032c0 <enter_sleep>:

;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZ                S L E E P               ZZZZZZZZZZZZZZZZZZZZZZ
;ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

enter_sleep:		; set ports to lowest current consumption
			; be ready to wake up on EXT INT1 and enter sleep mode
			; After wake up, wait for button safely released and dim up
; peripheral and interrupt control bits
	bclr	INTCON2,#GIE	; global int disable
    32c0:	83 e0 a9    	bclr.b    0x83, #0x7
	bclr	T1CON,#TON	; LED multiplex timer off
    32c2:	95 e1 a9    	bclr.b    0x195, #0x7
	bclr	T2CON,#TON	; T2 timer off
    32c4:	a1 e1 a9    	bclr.b    0x1a1, #0x7
	bclr	T3CON,#TON	; T3 timer off
    32c6:	a3 e1 a9    	bclr.b    0x1a3, #0x7
	bclr	IEC0,#T1IE	; disable Timer 1 interrupt
    32c8:	98 60 a9    	bclr.b    0x98, #0x3
	bclr	IEC0,#7		; disable Timer 2 interrupt
    32ca:	98 e0 a9    	bclr.b    0x98, #0x7
	bclr	IEC0,#8		; disable Timer 3 interrupt
    32cc:	99 00 a9    	bclr.b    0x99, #0x0
	bclr	IEC1,#4		; disable external interrupt
    32ce:	9a 80 a9    	bclr.b    0x9a, #0x4
; LEDs off, I/O pins hi-z
	clr.b	LATB+1		; all LEDs off
    32d0:	7b 66 ef    	clr.b     0x67b
	clr	LATC		; all LEDs off
    32d2:	8e 26 ef    	clr.w     0x68e
	setm.b	TRISB+0		; connector ports hi-z
    32d4:	76 e6 ef    	setm.b    0x676
	bset	TRISA,#1	; Tx on SAO also hi-z
    32d6:	62 26 a8    	bset.b    0x662, #0x1
; wait for ON-OFF safely released and final wake initialization
	call	test_no_press	; wait for ON-OFF safely released
    32d8:	14 33 02    	call      0x3314 <test_no_press>
    32da:	00 00 00 
	bclr	IFS1,#4		; clear interrupt flag to avoid self-triggering
    32dc:	8a 80 a9    	bclr.b    0x8a, #0x4
	bset	INTCON2,#INT1EP	; interrupt on negative-going edge
    32de:	82 20 a8    	bset.b    0x82, #0x1
	bset	IEC1,#4		; enable external interrupt
    32e0:	9a 80 a8    	bset.b    0x9a, #0x4
; SLEEP NOW    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	pwrsav	#0		; *  *   SLEEP   *  *  *  *  *  *  *  *  *  *  *  *  *
    32e2:	00 40 fe    	pwrsav    #0x0
; GOOD MORNING    *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 
	mov	#2,w0		; ×10 min autooff at wake-up
    32e4:	20 00 20    	mov.w     #0x2, w0
	mov.b	WREG,AutoOff
    32e6:	f9 e8 b7    	mov.b     WREG, 0x8f9
	mov	#37500,w0
    32e8:	c0 27 29    	mov.w     #0x927c, w0
	mov	w0,AutoOff_Hi
    32ea:	b0 4d 88    	mov.w     w0, 0x9b6
; restore I/O pins
	mov	#0xF0,w0	; bits 7654 = inputs, bits 3210 = outputs
    32ec:	00 0f 20    	mov.w     #0xf0, w0
	mov.b	WREG,TRISB+0	; restore states of connector ports
    32ee:	76 e6 b7    	mov.b     WREG, 0x676
	bclr	TRISA,#1	; Tx on SAO = output
    32f0:	62 26 a9    	bclr.b    0x662, #0x1
	btsc.b	WrFlags,#0	; if UART is redirected to I/O connector, then... 
    32f2:	f3 08 af    	btsc.b    0x8f3, #0x0
	bclr	TRISB,#7	; ...Tx on I/O connector = output
    32f4:	76 e6 a9    	bclr.b    0x676, #0x7
; restore peripheral and interrupt control bits
	bclr	IEC1,#4		; disable external interrupt
    32f6:	9a 80 a9    	bclr.b    0x9a, #0x4
	bset	IEC0,#T1IE	; enable Timer 1 interrupt
    32f8:	98 60 a8    	bset.b    0x98, #0x3
	bset	IEC0,#8		; enable Timer 3 interrupt
    32fa:	99 00 a8    	bset.b    0x99, #0x0
	bset	T1CON,#TON	; LED multiplex timer on
    32fc:	95 e1 a8    	bset.b    0x195, #0x7
	bset	T2CON,#TON	; T2 timer on
    32fe:	a1 e1 a8    	bset.b    0x1a1, #0x7
	bset	T3CON,#TON	; T3 timer on
    3300:	a3 e1 a8    	bset.b    0x1a3, #0x7
	bset	INTCON2,#GIE	; global int enable
    3302:	83 e0 a8    	bset.b    0x83, #0x7
; initialize key rotors and dim up
	mov	#KeyRotors,w1
    3304:	e1 97 20    	mov.w     #0x97e, w1
	push	RCOUNT		; \
    3306:	36 00 f8    	push      0x36
	repeat	#19-1
    3308:	12 00 09    	repeat    #0x12
	clr	[w1++]		; clear key debouncer rotors to ignore pre-pressed keys
    330a:	80 18 eb    	clr.w     [w1++]
	pop	RCOUNT		; /
    330c:	36 00 f9    	pop       0x36
	bset	Flag,#15	; dim up MAIN REQUEST
    330e:	dd e9 a8    	bset.b    0x9dd, #0x7
	goto	t1exit
    3310:	3e 32 04    	goto      0x323e <t1exit>
    3312:	00 00 00 

00003314 <test_no_press>:
; wait for ON-OFF safely released (90 ms debouncer)
test_no_press:
	mov	#900,w0		; w0 × 0.1 ms verify period
    3314:	40 38 20    	mov.w     #0x384, w0

00003316 <L138>:
1:
	push	RCOUNT		; \
    3316:	36 00 f8    	push      0x36
	repeat	#1600-9
    3318:	37 06 09    	repeat    #0x637
	nop
    331a:	00 00 00    	nop       
	pop	RCOUNT		; /
    331c:	36 00 f9    	pop       0x36
	btss	PORTC,#9	; skip if ON-OFF key high
    331e:	8d 26 ae    	btss.b    0x68d, #0x1
	bra	test_no_press	; it's low, re-initialize the counter from the start
    3320:	f9 ff 37    	bra       0x3314 <test_no_press>
	dec	w0,w0
    3322:	00 00 e9    	dec.w     w0, w0
	bra	nz,1b		; 1 loop = 1600 t = 0.1 ms
    3324:	f8 ff 3a    	bra       NZ, 0x3316 <L138>
	return
    3326:	00 00 06    	return    

00003328 <clk_table>:
    3328:	09 00 00    	nop       
    332a:	00 00 00    	nop       
    332c:	4f 00 00    	nop       
    332e:	00 00 00    	nop       
    3330:	0a 01 00    	nop       
    3332:	00 00 00    	nop       
    3334:	1f 03 00    	nop       
    3336:	00 00 00    	nop       
    3338:	6a 0a 00    	nop       
    333a:	00 00 00    	nop       
    333c:	3f 1f 00    	nop       
    333e:	00 00 00    	nop       
    3340:	7f 3e 00    	nop       
    3342:	00 00 00    	nop       
    3344:	3f 9c 00    	nop       
    3346:	00 00 00    	nop       
    3348:	0f 27 00    	nop       
    334a:	10 00 00    	nop       
    334c:	1f 4e 00    	nop       
    334e:	10 00 00    	nop       
    3350:	69 18 00    	nop       
    3352:	20 00 00    	nop       
    3354:	d3 30 00    	nop       
    3356:	20 00 00    	nop       
    3358:	a7 61 00    	nop       
    335a:	20 00 00    	nop       
    335c:	08 3d 00    	nop       
    335e:	30 00 00    	nop       
    3360:	11 7a 00    	nop       
    3362:	30 00 00    	nop       
    3364:	23 f4 00    	nop       
    3366:	30 00 00    	nop       

00003368 <clk_table_high>:
    3368:	09 00 00    	nop       
    336a:	00 00 00    	nop       
    336c:	09 00 00    	nop       
    336e:	00 00 00    	nop       
    3370:	09 00 00    	nop       
    3372:	00 00 00    	nop       
    3374:	4f 00 00    	nop       
    3376:	00 00 00    	nop       
    3378:	09 01 00    	nop       
    337a:	00 00 00    	nop       
    337c:	1f 03 00    	nop       
    337e:	00 00 00    	nop       
    3380:	3f 06 00    	nop       
    3382:	00 00 00    	nop       
    3384:	9f 0f 00    	nop       
    3386:	00 00 00    	nop       
    3388:	3f 1f 00    	nop       
    338a:	00 00 00    	nop       
    338c:	7f 3e 00    	nop       
    338e:	00 00 00    	nop       
    3390:	3f 9c 00    	nop       
    3392:	00 00 00    	nop       
    3394:	0f 27 00    	nop       
    3396:	10 00 00    	nop       
    3398:	1f 4e 00    	nop       
    339a:	10 00 00    	nop       
    339c:	69 18 00    	nop       
    339e:	20 00 00    	nop       
    33a0:	d3 30 00    	nop       
    33a2:	20 00 00    	nop       
    33a4:	a7 61 00    	nop       
    33a6:	20 00 00    	nop       

000033a8 <sync_table>:
    33a8:	7f 3e 00    	nop       
    33aa:	00 00 00    	nop       
    33ac:	2a 68 00    	nop       
    33ae:	00 00 00    	nop       
    33b0:	3f 9c 00    	nop       
    33b2:	00 00 00    	nop       
    33b4:	ff f9 00    	nop       
    33b6:	00 00 00    	nop       
    33b8:	14 34 00    	nop       
    33ba:	10 00 00    	nop       
    33bc:	1f 4e 00    	nop       
    33be:	10 00 00    	nop       
    33c0:	34 82 00    	nop       
    33c2:	10 00 00    	nop       
    33c4:	4f c3 00    	nop       
    33c6:	10 00 00    	nop       
    33c8:	0f 27 00    	nop       
    33ca:	20 00 00    	nop       
    33cc:	1a 41 00    	nop       
    33ce:	20 00 00    	nop       
    33d0:	a7 61 00    	nop       
    33d2:	20 00 00    	nop       
    33d4:	c2 a2 00    	nop       
    33d6:	20 00 00    	nop       
    33d8:	23 f4 00    	nop       
    33da:	20 00 00    	nop       
    33dc:	a7 61 00    	nop       
    33de:	30 00 00    	nop       
    33e0:	c2 a2 00    	nop       
    33e2:	30 00 00    	nop       
    33e4:	23 f4 00    	nop       
    33e6:	30 00 00    	nop       

000033e8 <sync_table_high>:
    33e8:	3f 06 00    	nop       
    33ea:	00 00 00    	nop       
    33ec:	6a 0a 00    	nop       
    33ee:	00 00 00    	nop       
    33f0:	9f 0f 00    	nop       
    33f2:	00 00 00    	nop       
    33f4:	ff 18 00    	nop       
    33f6:	00 00 00    	nop       
    33f8:	34 05 00    	nop       
    33fa:	10 00 00    	nop       
    33fc:	cf 07 00    	nop       
    33fe:	10 00 00    	nop       
    3400:	04 0d 00    	nop       
    3402:	10 00 00    	nop       
    3404:	87 13 00    	nop       
    3406:	10 00 00    	nop       
    3408:	e7 03 00    	nop       
    340a:	20 00 00    	nop       
    340c:	82 06 00    	nop       
    340e:	20 00 00    	nop       
    3410:	c3 09 00    	nop       
    3412:	20 00 00    	nop       
    3414:	46 10 00    	nop       
    3416:	20 00 00    	nop       
    3418:	69 18 00    	nop       
    341a:	20 00 00    	nop       
    341c:	c3 09 00    	nop       
    341e:	30 00 00    	nop       
    3420:	46 10 00    	nop       
    3422:	30 00 00    	nop       
    3424:	69 18 00    	nop       
    3426:	30 00 00    	nop       

00003428 <ss_history>:
; .equ	History,0x0B00	; FIFO buffer, space: 128 × 42 by = 5376 by = 0x1500 by		
;											

ss_history:
	cp0	Insert_Count_0		; if no history inserts...
    3428:	20 09 e2    	cp0.w     0x920
	bra	z,ss_farm		; ...then ignore and return
    342a:	1d f2 32    	bra       Z, 0x1866 <ss_farm>
	bset	BlinkFlag,#3		; #3 set: LED SS blinks
    342c:	e0 69 a8    	bset.b    0x9e0, #0x3
	bset	Flag,#5			; #5 set: in HISTORY mode
    342e:	dc a9 a8    	bset.b    0x9dc, #0x5

00003430 <history_pos_1>:
history_pos_1:
	mov	#1,w0
    3430:	10 00 20    	mov.w     #0x1, w0
	mov	w0,History_Ptr
    3432:	f0 48 88    	mov.w     w0, 0x91e

00003434 <history_farm>:
history_farm:
	cp0	History_Ptr
    3434:	1e 09 e2    	cp0.w     0x91e
	bra	z,history_exit
    3436:	24 00 32    	bra       Z, 0x3480 <history_exit>
	call	unpack_ptr		; unpack from History buffer, pos History_Ptr
    3438:	1a 35 02    	call      0x351a <unpack_ptr>
    343a:	00 00 00 

0000343c <wait_key_hist>:
wait_key_hist:				; <---------------
	btss	Flag,#1
    343c:	dc 29 ae    	btss.b    0x9dc, #0x1
	bra	wait_key_hist
    343e:	fe ff 37    	bra       0x343c <wait_key_hist>
	bclr	Flag,#1
    3440:	dc 29 a9    	bclr.b    0x9dc, #0x1

	mov	Just,w4
    3442:	34 4d 80    	mov.w     0x9a6, w4
	cp	w4,#1
    3444:	61 20 e1    	cp.w      w4, #0x1
	bra	z,history_pos_1		; key History again: go pos 1  ---------------->
    3446:	f4 ff 32    	bra       Z, 0x3430 <history_pos_1>
	cp	w4,#2
    3448:	62 20 e1    	cp.w      w4, #0x2
	bra	nz,not_hist_minus
    344a:	0d 00 3a    	bra       NZ, 0x3466 <not_hist_minus>
;  - ADDR 				
	  inc	  History_Ptr		  ; ++
    344c:	1e 29 ec    	inc.w     0x91e
	  mov	  History_Ptr,w0
    344e:	f0 48 80    	mov.w     0x91e, w0
	  mov	  Insert_Count_0,w2	  ; count of 24by packets inserted in History buffer from reset
    3450:	02 49 80    	mov.w     0x920, w2
	  inc	  w2,w2
    3452:	02 01 e8    	inc.w     w2, w2

	  cp	  w0,w2
    3454:	02 00 e1    	cp.w      w0, w2
	  bra	  nc,1f			  ; if [History_Ptr] >= [Insert_Count_0] then...
    3456:	04 00 39    	bra       NC, 0x3460 <L139>
	  dec	  History_Ptr		  ; ...clip [history ptr] to [Insert_Count_0] max
    3458:	1e 29 ed    	dec.w     0x91e
	  bset	  History_A16,#b_load	  ; ...and also LED ADDR+ ON
    345a:	0d c9 a8    	bset.b    0x90d, #0x6

0000345c <L213>:
2:
	  btss	  KeyRotors+6,#0
    345c:	84 09 ae    	btss.b    0x984, #0x0
	  bra	  2b			  ; loop and wait for key released
    345e:	fe ff 37    	bra       0x345c <L213>

00003460 <L139>:
1:
	  call	  unpack_ptr		  ; UNPACK
    3460:	1a 35 02    	call      0x351a <unpack_ptr>
    3462:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    3464:	e7 ff 37    	bra       0x3434 <history_farm>

00003466 <not_hist_minus>:
not_hist_minus:
	cp	w4,#3
    3466:	63 20 e1    	cp.w      w4, #0x3
	bra	nz,not_hist_plus
    3468:	09 00 3a    	bra       NZ, 0x347c <not_hist_plus>
;  ADDR	+			
	  dec	  History_Ptr		  ; --
    346a:	1e 29 ed    	dec.w     0x91e
	  bra	  nz,1f			  ; if [History_Ptr] = 0 then...
    346c:	04 00 3a    	bra       NZ, 0x3476 <L140>
	  inc	  History_Ptr		  ; ...restore to 1, as history ptr can't reach 0
    346e:	1e 29 ec    	inc.w     0x91e
	  bset	  History_A16,#b_save	  ; ...and also LED ADDR- ON
    3470:	0d a9 a8    	bset.b    0x90d, #0x5

00003472 <L214>:
2:
	  btss	  KeyRotors+4,#0
    3472:	82 09 ae    	btss.b    0x982, #0x0
	  bra	  2b			  ; loop and wait for key released
    3474:	fe ff 37    	bra       0x3472 <L214>

00003476 <L140>:
1:
	  call	  unpack_ptr		  ; UNPACK
    3476:	1a 35 02    	call      0x351a <unpack_ptr>
    3478:	00 00 00 
	  bra	  history_farm		  ; ---------------->
    347a:	dc ff 37    	bra       0x3434 <history_farm>

0000347c <not_hist_plus>:
not_hist_plus:
	cp	w4,#4
    347c:	64 20 e1    	cp.w      w4, #0x4
	bra	nz,wait_key_hist	; no valid key hit, loop  ---------------->
    347e:	de ff 3a    	bra       NZ, 0x343c <wait_key_hist>

00003480 <history_exit>:
history_exit:
	clr	History_Ptr
    3480:	1e 29 ef    	clr.w     0x91e
	bra	ss_farm
    3482:	f1 f1 37    	bra       0x1866 <ss_farm>

00003484 <insert>:

; -----------------------------------------------------------------------------------
; -----------------------------------------------------------------------------------

; --------------------------------------------------  PACK
; shift buffer up, pack and insert new 21 by (DO NOT USE w5...w15)
insert:			; insert Ram current, Ram page 0 and variables to start of History
; shift FIFO up, to make room for one packet (21 by)
	mov	#History+0x14FE-42,w1
    3484:	41 fd 21    	mov.w     #0x1fd4, w1
	mov	#History+0x14FE,w2
    3486:	e2 ff 21    	mov.w     #0x1ffe, w2
	repeat	#2667-1		; 127 × 42 = 5334 bytes = 2667 words to move
    3488:	6a 0a 09    	repeat    #0xa6a
	mov	[w1--],[w2--]	; shift history buffer up
    348a:	21 11 78    	mov.w     [w1--], [w2--]
	inc	Insert_Count_0
    348c:	20 29 ec    	inc.w     0x920
	btsc	Insert_Count_0,#7
    348e:	20 e9 af    	btsc.b    0x920, #0x7
	dec	Insert_Count_0
    3490:	20 29 ed    	dec.w     0x920

00003492 <pack>:
; pack proc variables and visible Ram to start of history buffer 22 bytes
pack:			; pack Ram current, Ram page 0 and variables to start of History
	mov	#History,w3	; w3 = history buffer physical address
    3492:	03 b0 20    	mov.w     #0xb00, w3
; --------------------------------------- 0...15 ----- STEP 1: page 0
	mov	#Ram+1,w2
    3494:	12 80 20    	mov.w     #0x801, w2
	add	w2,#16,w1
    3496:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    3498:	84 00 20    	mov.w     #0x8, w4

0000349a <pack_loop_1>:
pack_loop_1:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    349a:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    349c:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    349e:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    34a0:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    34a2:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    34a4:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    34a6:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    34a8:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    34aa:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    34ac:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    34ae:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_1	; loop
    34b0:	f4 ff 3a    	bra       NZ, 0x349a <pack_loop_1>
; -------------------------------------- 16...31 ----- STEP 2: current page
	mov	#Ram+1,w2
    34b2:	12 80 20    	mov.w     #0x801, w2
	mov.b	Page,WREG
    34b4:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    34b6:	00 80 fb    	ze        w0, w0
	sl	w0,#4,w0	; ×16
    34b8:	44 00 dd    	sl.w      w0, #0x4, w0
	add	w2,w0,w2
    34ba:	00 01 41    	add.w     w2, w0, w2
	add	w2,#16,w1
    34bc:	f0 00 41    	add.w     w2, #0x10, w1
	mov	#8,w4		; loop counter
    34be:	84 00 20    	mov.w     #0x8, w4
; if Page>15 then wrap to 0
	mov.b	Page,WREG
    34c0:	f0 c8 bf    	mov.b     0x8f0, WREG
	ze	w0,w0
    34c2:	00 80 fb    	ze        w0, w0
	cp	w0,#15
    34c4:	6f 00 e1    	cp.w      w0, #0xf
	ifz
    34c6:	42 20 af    	btsc.b    0x42, #0x1
	sub	#256,w1		; if >=Ram+256 then wrap to start of Ram
    34c8:	01 10 b1    	sub.w     #0x100, w1

000034ca <pack_loop_2>:
pack_loop_2:
; get and stack RAM nibbles
	ze	[w1--],w0	; 0000 0000 0000 AAAA
    34ca:	21 80 fb    	ze        [w1--], w0
	sl	w0,#4,w0	; 0000 0000 AAAA 0000
    34cc:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2--],w0	; 0000 0000 AAAA CCCC
    34ce:	22 40 70    	ior.b     w0, [w2--], w0
	sl	w0,#4,w0	; 0000 AAAA CCCC 0000
    34d0:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w1++],w0	; 0000 AAAA CCCC BBBB
    34d2:	31 40 70    	ior.b     w0, [w1++], w0
	sl	w0,#4,w0	; AAAA CCCC BBBB 0000
    34d4:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,[w2++],w0	; AAAA CCCC BBBB DDDD
    34d6:	32 40 70    	ior.b     w0, [w2++], w0

	mov	w0,[w3++]	; store
    34d8:	80 19 78    	mov.w     w0, [w3++]
	inc2	w1,w1
    34da:	81 80 e8    	inc2.w    w1, w1
	inc2	w2,w2
    34dc:	02 81 e8    	inc2.w    w2, w2
	dec.b	w4,w4
    34de:	04 42 e9    	dec.b     w4, w4
	bra	nz,pack_loop_2	; loop
    34e0:	f4 ff 3a    	bra       NZ, 0x34ca <pack_loop_2>
; -------------------------------------- 32...35 ----- STEP 3: A16 and w9 (no pack)
	mov	A16,w0
    34e2:	70 4d 80    	mov.w     0x9ae, w0
	mov	w0,[w3++]	; store
    34e4:	80 19 78    	mov.w     w0, [w3++]
	mov	w9,[w3++]	; store
    34e6:	89 19 78    	mov.w     w9, [w3++]
; ---------------------------------------- 36,37 ----- STEP 4: w11, w12, w13, w14
	mov	w11,w0
    34e8:	0b 00 78    	mov.w     w11, w0
	sl	w0,#4,w0
    34ea:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w12,w0
    34ec:	0c 40 70    	ior.b     w0, w12, w0
	sl	w0,#4,w0
    34ee:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w13,w0
    34f0:	0d 40 70    	ior.b     w0, w13, w0
	sl	w0,#4,w0
    34f2:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	w0,w14,w0
    34f4:	0e 40 70    	ior.b     w0, w14, w0
	mov	w0,[w3++]	; store
    34f6:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 38,39 ----- STEP 5: Atemp,Page,Sync,Speed
	mov	Atemp,w0
    34f8:	40 49 80    	mov.w     0x928, w0
	sl	w0,#4,w0
    34fa:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Page,WREG
    34fc:	f0 48 b7    	ior.b     0x8f0, WREG
	sl	w0,#4,w0
    34fe:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Sync,WREG
    3500:	f2 48 b7    	ior.b     0x8f2, WREG
	sl	w0,#4,w0
    3502:	44 00 dd    	sl.w      w0, #0x4, w0
	ior.b	Speed,WREG
    3504:	f1 48 b7    	ior.b     0x8f1, WREG
	mov	w0,[w3++]	; store
    3506:	80 19 78    	mov.w     w0, [w3++]
; ---------------------------------------- 40,41 ----- STEP 6: V/Z/Cflag, Stack
	mov	Vflag,w0
    3508:	80 49 80    	mov.w     0x930, w0
	sl	w0,#3,w0
    350a:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Zflag,WREG
    350c:	2e 49 b7    	ior.b     0x92e, WREG
	sl	w0,#3,w0
    350e:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Cflag,WREG
    3510:	2c 49 b7    	ior.b     0x92c, WREG
	sl	w0,#3,w0
    3512:	43 00 dd    	sl.w      w0, #0x3, w0
	ior.b	Stack,WREG
    3514:	2a 49 b7    	ior.b     0x92a, WREG
	mov	w0,[w3++]	; store
    3516:	80 19 78    	mov.w     w0, [w3++]
; ----------------------------------------------------
	return
    3518:	00 00 06    	return    

0000351a <unpack_ptr>:
; ----------------------------------------------------  UNPACK
; unpack from History_Ptr
unpack_ptr:		; unpack using History_Ptr as input
	dec	History_Ptr,WREG
    351a:	1e 09 ed    	dec.w     0x91e, WREG
	mov	#42,w1
    351c:	a1 02 20    	mov.w     #0x2a, w1
	mul.uu	w0,w1,w0	; w0 × 42 ---> w0:w1
    351e:	01 00 b8    	mul.uu    w0, w1, w0
	mov	#History,w1
    3520:	01 b0 20    	mov.w     #0xb00, w1
	add	w0,w1,w2	; w2 = #History + 42 × (History_Ptr-1)
    3522:	01 01 40    	add.w     w0, w1, w2

00003524 <unpack>:
; unpack from history buffer [w2] 42 bytes to proc variables (Ram ---> History_Visible)
unpack:			; unpack using w2 as pointer
	mov	w2,History_Visible
    3524:	02 48 88    	mov.w     w2, 0x900
	add	#32,w2		; skip History Ram, only pointer was needed
    3526:	02 02 b0    	add.w     #0x20, w2
	mov	[w2++],w0	; Packet start + 32
    3528:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_A16
    352a:	60 48 88    	mov.w     w0, 0x90c
	mov	[w2++],w0	; Packet start + 34
    352c:	32 00 78    	mov.w     [w2++], w0
	mov	w0,History_w9
    352e:	10 48 88    	mov.w     w0, 0x902
	mov	[w2++],w0	; Packet start + 36
    3530:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    3532:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_w14
    3534:	51 48 88    	mov.w     w1, 0x90a
	lsr	w0,#4,w1
    3536:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    3538:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w13
    353a:	41 48 88    	mov.w     w1, 0x908
	lsr	w0,#8,w1
    353c:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    353e:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w12
    3540:	31 48 88    	mov.w     w1, 0x906
	lsr	w0,#12,w1
    3542:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    3544:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_w11
    3546:	21 48 88    	mov.w     w1, 0x904
	mov	[w2++],w0	; Packet start + 38
    3548:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x0F,w1
    354a:	ef 00 60    	and.w     w0, #0xf, w1
	mov	w1,History_Speed
    354c:	a1 48 88    	mov.w     w1, 0x914
	lsr	w0,#4,w1
    354e:	c4 00 de    	lsr.w     w0, #0x4, w1
	and	w1,#0x0F,w1
    3550:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Sync
    3552:	91 48 88    	mov.w     w1, 0x912
	lsr	w0,#8,w1
    3554:	c8 00 de    	lsr.w     w0, #0x8, w1
	and	w1,#0x0F,w1
    3556:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Page
    3558:	81 48 88    	mov.w     w1, 0x910
	lsr	w0,#12,w1
    355a:	cc 00 de    	lsr.w     w0, #0xc, w1
	and	w1,#0x0F,w1
    355c:	ef 80 60    	and.w     w1, #0xf, w1
	mov	w1,History_Atemp
    355e:	71 48 88    	mov.w     w1, 0x90e
	mov	[w2++],w0	; Packet start + 40
    3560:	32 00 78    	mov.w     [w2++], w0
	and	w0,#0x07,w1
    3562:	e7 00 60    	and.w     w0, #0x7, w1
	mov	w1,History_Stack
    3564:	e1 48 88    	mov.w     w1, 0x91c
	lsr	w0,#3,w1
    3566:	c3 00 de    	lsr.w     w0, #0x3, w1
	and	w1,#0x07,w1
    3568:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Cflag
    356a:	d1 48 88    	mov.w     w1, 0x91a
	lsr	w0,#6,w1
    356c:	c6 00 de    	lsr.w     w0, #0x6, w1
	and	w1,#0x07,w1
    356e:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Zflag
    3570:	c1 48 88    	mov.w     w1, 0x918
	lsr	w0,#9,w1
    3572:	c9 00 de    	lsr.w     w0, #0x9, w1
	and	w1,#0x07,w1
    3574:	e7 80 60    	and.w     w1, #0x7, w1
	mov	w1,History_Vflag
    3576:	b1 48 88    	mov.w     w1, 0x916
	return
    3578:	00 00 06    	return    

0000357a <table_adder>:
    357a:	00 02 00    	nop       
    357c:	10 00 00    	nop       
    357e:	10 00 00    	nop       
    3580:	21 00 00    	nop       
    3582:	20 00 00    	nop       
    3584:	30 00 00    	nop       
    3586:	30 00 00    	nop       
    3588:	43 00 00    	nop       
    358a:	40 00 00    	nop       
    358c:	50 00 00    	nop       
    358e:	50 00 00    	nop       
    3590:	61 00 00    	nop       
    3592:	60 00 00    	nop       
    3594:	70 00 00    	nop       
    3596:	70 00 00    	nop       
    3598:	87 04 00    	nop       
    359a:	80 00 00    	nop       
    359c:	90 00 00    	nop       
    359e:	90 00 00    	nop       
    35a0:	a1 00 00    	nop       
    35a2:	a0 00 00    	nop       
    35a4:	b0 00 00    	nop       
    35a6:	b0 00 00    	nop       
    35a8:	c3 00 00    	nop       
    35aa:	c0 00 00    	nop       
    35ac:	d0 00 00    	nop       
    35ae:	d0 00 00    	nop       
    35b0:	e1 00 00    	nop       
    35b2:	e0 00 00    	nop       
    35b4:	f0 00 00    	nop       
    35b6:	f0 00 00    	nop       
    35b8:	0f 03 00    	nop       
    35ba:	10 00 00    	nop       
    35bc:	21 00 00    	nop       
    35be:	21 00 00    	nop       
    35c0:	31 00 00    	nop       
    35c2:	30 00 00    	nop       
    35c4:	43 00 00    	nop       
    35c6:	43 00 00    	nop       
    35c8:	53 00 00    	nop       
    35ca:	50 00 00    	nop       
    35cc:	61 00 00    	nop       
    35ce:	61 00 00    	nop       
    35d0:	71 00 00    	nop       
    35d2:	70 00 00    	nop       
    35d4:	87 04 00    	nop       
    35d6:	87 04 00    	nop       
    35d8:	97 04 00    	nop       
    35da:	90 00 00    	nop       
    35dc:	a1 00 00    	nop       
    35de:	a1 00 00    	nop       
    35e0:	b1 00 00    	nop       
    35e2:	b0 00 00    	nop       
    35e4:	c3 00 00    	nop       
    35e6:	c3 00 00    	nop       
    35e8:	d3 00 00    	nop       
    35ea:	d0 00 00    	nop       
    35ec:	e1 00 00    	nop       
    35ee:	e1 00 00    	nop       
    35f0:	f1 00 00    	nop       
    35f2:	f0 00 00    	nop       
    35f4:	0f 03 00    	nop       
    35f6:	0f 03 00    	nop       
    35f8:	1f 01 00    	nop       
    35fa:	20 00 00    	nop       
    35fc:	30 00 00    	nop       
    35fe:	30 00 00    	nop       
    3600:	43 00 00    	nop       
    3602:	42 00 00    	nop       
    3604:	52 00 00    	nop       
    3606:	52 00 00    	nop       
    3608:	63 00 00    	nop       
    360a:	60 00 00    	nop       
    360c:	70 00 00    	nop       
    360e:	70 00 00    	nop       
    3610:	87 04 00    	nop       
    3612:	86 04 00    	nop       
    3614:	96 04 00    	nop       
    3616:	96 04 00    	nop       
    3618:	a7 04 00    	nop       
    361a:	a0 00 00    	nop       
    361c:	b0 00 00    	nop       
    361e:	b0 00 00    	nop       
    3620:	c3 00 00    	nop       
    3622:	c2 00 00    	nop       
    3624:	d2 00 00    	nop       
    3626:	d2 00 00    	nop       
    3628:	e3 00 00    	nop       
    362a:	e0 00 00    	nop       
    362c:	f0 00 00    	nop       
    362e:	f0 00 00    	nop       
    3630:	0f 03 00    	nop       
    3632:	0e 03 00    	nop       
    3634:	1e 01 00    	nop       
    3636:	1e 01 00    	nop       
    3638:	2f 01 00    	nop       
    363a:	30 00 00    	nop       
    363c:	43 00 00    	nop       
    363e:	43 00 00    	nop       
    3640:	53 00 00    	nop       
    3642:	52 00 00    	nop       
    3644:	63 00 00    	nop       
    3646:	63 00 00    	nop       
    3648:	73 00 00    	nop       
    364a:	70 00 00    	nop       
    364c:	87 04 00    	nop       
    364e:	87 04 00    	nop       
    3650:	97 04 00    	nop       
    3652:	96 04 00    	nop       
    3654:	a7 04 00    	nop       
    3656:	a7 04 00    	nop       
    3658:	b7 04 00    	nop       
    365a:	b0 00 00    	nop       
    365c:	c3 00 00    	nop       
    365e:	c3 00 00    	nop       
    3660:	d3 00 00    	nop       
    3662:	d2 00 00    	nop       
    3664:	e3 00 00    	nop       
    3666:	e3 00 00    	nop       
    3668:	f3 00 00    	nop       
    366a:	f0 00 00    	nop       
    366c:	0f 03 00    	nop       
    366e:	0f 03 00    	nop       
    3670:	1f 01 00    	nop       
    3672:	1e 01 00    	nop       
    3674:	2f 01 00    	nop       
    3676:	2f 01 00    	nop       
    3678:	3f 01 00    	nop       
    367a:	40 00 00    	nop       
    367c:	50 00 00    	nop       
    367e:	50 00 00    	nop       
    3680:	61 00 00    	nop       
    3682:	60 00 00    	nop       
    3684:	70 00 00    	nop       
    3686:	70 00 00    	nop       
    3688:	87 04 00    	nop       
    368a:	84 04 00    	nop       
    368c:	94 04 00    	nop       
    368e:	94 04 00    	nop       
    3690:	a5 04 00    	nop       
    3692:	a4 04 00    	nop       
    3694:	b4 04 00    	nop       
    3696:	b4 04 00    	nop       
    3698:	c7 04 00    	nop       
    369a:	c0 00 00    	nop       
    369c:	d0 00 00    	nop       
    369e:	d0 00 00    	nop       
    36a0:	e1 00 00    	nop       
    36a2:	e0 00 00    	nop       
    36a4:	f0 00 00    	nop       
    36a6:	f0 00 00    	nop       
    36a8:	0f 03 00    	nop       
    36aa:	0c 03 00    	nop       
    36ac:	1c 01 00    	nop       
    36ae:	1c 01 00    	nop       
    36b0:	2d 01 00    	nop       
    36b2:	2c 01 00    	nop       
    36b4:	3c 01 00    	nop       
    36b6:	3c 01 00    	nop       
    36b8:	4f 01 00    	nop       
    36ba:	50 00 00    	nop       
    36bc:	61 00 00    	nop       
    36be:	61 00 00    	nop       
    36c0:	71 00 00    	nop       
    36c2:	70 00 00    	nop       
    36c4:	87 04 00    	nop       
    36c6:	87 04 00    	nop       
    36c8:	97 04 00    	nop       
    36ca:	94 04 00    	nop       
    36cc:	a5 04 00    	nop       
    36ce:	a5 04 00    	nop       
    36d0:	b5 04 00    	nop       
    36d2:	b4 04 00    	nop       
    36d4:	c7 04 00    	nop       
    36d6:	c7 04 00    	nop       
    36d8:	d7 04 00    	nop       
    36da:	d0 00 00    	nop       
    36dc:	e1 00 00    	nop       
    36de:	e1 00 00    	nop       
    36e0:	f1 00 00    	nop       
    36e2:	f0 00 00    	nop       
    36e4:	0f 03 00    	nop       
    36e6:	0f 03 00    	nop       
    36e8:	1f 01 00    	nop       
    36ea:	1c 01 00    	nop       
    36ec:	2d 01 00    	nop       
    36ee:	2d 01 00    	nop       
    36f0:	3d 01 00    	nop       
    36f2:	3c 01 00    	nop       
    36f4:	4f 01 00    	nop       
    36f6:	4f 01 00    	nop       
    36f8:	5f 01 00    	nop       
    36fa:	60 00 00    	nop       
    36fc:	70 00 00    	nop       
    36fe:	70 00 00    	nop       
    3700:	87 04 00    	nop       
    3702:	86 04 00    	nop       
    3704:	96 04 00    	nop       
    3706:	96 04 00    	nop       
    3708:	a7 04 00    	nop       
    370a:	a4 04 00    	nop       
    370c:	b4 04 00    	nop       
    370e:	b4 04 00    	nop       
    3710:	c7 04 00    	nop       
    3712:	c6 04 00    	nop       
    3714:	d6 04 00    	nop       
    3716:	d6 04 00    	nop       
    3718:	e7 04 00    	nop       
    371a:	e0 00 00    	nop       
    371c:	f0 00 00    	nop       
    371e:	f0 00 00    	nop       
    3720:	0f 03 00    	nop       
    3722:	0e 03 00    	nop       
    3724:	1e 01 00    	nop       
    3726:	1e 01 00    	nop       
    3728:	2f 01 00    	nop       
    372a:	2c 01 00    	nop       
    372c:	3c 01 00    	nop       
    372e:	3c 01 00    	nop       
    3730:	4f 01 00    	nop       
    3732:	4e 01 00    	nop       
    3734:	5e 01 00    	nop       
    3736:	5e 01 00    	nop       
    3738:	6f 01 00    	nop       
    373a:	70 00 00    	nop       
    373c:	87 04 00    	nop       
    373e:	87 04 00    	nop       
    3740:	97 04 00    	nop       
    3742:	96 04 00    	nop       
    3744:	a7 04 00    	nop       
    3746:	a7 04 00    	nop       
    3748:	b7 04 00    	nop       
    374a:	b4 04 00    	nop       
    374c:	c7 04 00    	nop       
    374e:	c7 04 00    	nop       
    3750:	d7 04 00    	nop       
    3752:	d6 04 00    	nop       
    3754:	e7 04 00    	nop       
    3756:	e7 04 00    	nop       
    3758:	f7 04 00    	nop       
    375a:	f0 00 00    	nop       
    375c:	0f 03 00    	nop       
    375e:	0f 03 00    	nop       
    3760:	1f 01 00    	nop       
    3762:	1e 01 00    	nop       
    3764:	2f 01 00    	nop       
    3766:	2f 01 00    	nop       
    3768:	3f 01 00    	nop       
    376a:	3c 01 00    	nop       
    376c:	4f 01 00    	nop       
    376e:	4f 01 00    	nop       
    3770:	5f 01 00    	nop       
    3772:	5e 01 00    	nop       
    3774:	6f 01 00    	nop       
    3776:	6f 01 00    	nop       
    3778:	7f 01 00    	nop       
    377a:	80 00 00    	nop       
    377c:	90 00 00    	nop       
    377e:	90 00 00    	nop       
    3780:	a1 00 00    	nop       
    3782:	a0 00 00    	nop       
    3784:	b0 00 00    	nop       
    3786:	b0 00 00    	nop       
    3788:	c3 00 00    	nop       
    378a:	c0 00 00    	nop       
    378c:	d0 00 00    	nop       
    378e:	d0 00 00    	nop       
    3790:	e1 00 00    	nop       
    3792:	e0 00 00    	nop       
    3794:	f0 00 00    	nop       
    3796:	f0 00 00    	nop       
    3798:	0f 03 00    	nop       
    379a:	08 07 00    	nop       
    379c:	18 05 00    	nop       
    379e:	18 05 00    	nop       
    37a0:	29 05 00    	nop       
    37a2:	28 05 00    	nop       
    37a4:	38 05 00    	nop       
    37a6:	38 05 00    	nop       
    37a8:	4b 05 00    	nop       
    37aa:	48 05 00    	nop       
    37ac:	58 05 00    	nop       
    37ae:	58 05 00    	nop       
    37b0:	69 05 00    	nop       
    37b2:	68 05 00    	nop       
    37b4:	78 05 00    	nop       
    37b6:	78 05 00    	nop       
    37b8:	8f 01 00    	nop       
    37ba:	90 00 00    	nop       
    37bc:	a1 00 00    	nop       
    37be:	a1 00 00    	nop       
    37c0:	b1 00 00    	nop       
    37c2:	b0 00 00    	nop       
    37c4:	c3 00 00    	nop       
    37c6:	c3 00 00    	nop       
    37c8:	d3 00 00    	nop       
    37ca:	d0 00 00    	nop       
    37cc:	e1 00 00    	nop       
    37ce:	e1 00 00    	nop       
    37d0:	f1 00 00    	nop       
    37d2:	f0 00 00    	nop       
    37d4:	0f 03 00    	nop       
    37d6:	0f 03 00    	nop       
    37d8:	1f 01 00    	nop       
    37da:	18 05 00    	nop       
    37dc:	29 05 00    	nop       
    37de:	29 05 00    	nop       
    37e0:	39 05 00    	nop       
    37e2:	38 05 00    	nop       
    37e4:	4b 05 00    	nop       
    37e6:	4b 05 00    	nop       
    37e8:	5b 05 00    	nop       
    37ea:	58 05 00    	nop       
    37ec:	69 05 00    	nop       
    37ee:	69 05 00    	nop       
    37f0:	79 05 00    	nop       
    37f2:	78 05 00    	nop       
    37f4:	8f 01 00    	nop       
    37f6:	8f 01 00    	nop       
    37f8:	9f 01 00    	nop       
    37fa:	a0 00 00    	nop       
    37fc:	b0 00 00    	nop       
    37fe:	b0 00 00    	nop       
    3800:	c3 00 00    	nop       
    3802:	c2 00 00    	nop       
    3804:	d2 00 00    	nop       
    3806:	d2 00 00    	nop       
    3808:	e3 00 00    	nop       
    380a:	e0 00 00    	nop       
    380c:	f0 00 00    	nop       
    380e:	f0 00 00    	nop       
    3810:	0f 03 00    	nop       
    3812:	0e 03 00    	nop       
    3814:	1e 01 00    	nop       
    3816:	1e 01 00    	nop       
    3818:	2f 01 00    	nop       
    381a:	28 05 00    	nop       
    381c:	38 05 00    	nop       
    381e:	38 05 00    	nop       
    3820:	4b 05 00    	nop       
    3822:	4a 05 00    	nop       
    3824:	5a 05 00    	nop       
    3826:	5a 05 00    	nop       
    3828:	6b 05 00    	nop       
    382a:	68 05 00    	nop       
    382c:	78 05 00    	nop       
    382e:	78 05 00    	nop       
    3830:	8f 01 00    	nop       
    3832:	8e 01 00    	nop       
    3834:	9e 01 00    	nop       
    3836:	9e 01 00    	nop       
    3838:	af 01 00    	nop       
    383a:	b0 00 00    	nop       
    383c:	c3 00 00    	nop       
    383e:	c3 00 00    	nop       
    3840:	d3 00 00    	nop       
    3842:	d2 00 00    	nop       
    3844:	e3 00 00    	nop       
    3846:	e3 00 00    	nop       
    3848:	f3 00 00    	nop       
    384a:	f0 00 00    	nop       
    384c:	0f 03 00    	nop       
    384e:	0f 03 00    	nop       
    3850:	1f 01 00    	nop       
    3852:	1e 01 00    	nop       
    3854:	2f 01 00    	nop       
    3856:	2f 01 00    	nop       
    3858:	3f 01 00    	nop       
    385a:	38 05 00    	nop       
    385c:	4b 05 00    	nop       
    385e:	4b 05 00    	nop       
    3860:	5b 05 00    	nop       
    3862:	5a 05 00    	nop       
    3864:	6b 05 00    	nop       
    3866:	6b 05 00    	nop       
    3868:	7b 05 00    	nop       
    386a:	78 05 00    	nop       
    386c:	8f 01 00    	nop       
    386e:	8f 01 00    	nop       
    3870:	9f 01 00    	nop       
    3872:	9e 01 00    	nop       
    3874:	af 01 00    	nop       
    3876:	af 01 00    	nop       
    3878:	bf 01 00    	nop       
    387a:	c0 00 00    	nop       
    387c:	d0 00 00    	nop       
    387e:	d0 00 00    	nop       
    3880:	e1 00 00    	nop       
    3882:	e0 00 00    	nop       
    3884:	f0 00 00    	nop       
    3886:	f0 00 00    	nop       
    3888:	0f 03 00    	nop       
    388a:	0c 03 00    	nop       
    388c:	1c 01 00    	nop       
    388e:	1c 01 00    	nop       
    3890:	2d 01 00    	nop       
    3892:	2c 01 00    	nop       
    3894:	3c 01 00    	nop       
    3896:	3c 01 00    	nop       
    3898:	4f 01 00    	nop       
    389a:	48 05 00    	nop       
    389c:	58 05 00    	nop       
    389e:	58 05 00    	nop       
    38a0:	69 05 00    	nop       
    38a2:	68 05 00    	nop       
    38a4:	78 05 00    	nop       
    38a6:	78 05 00    	nop       
    38a8:	8f 01 00    	nop       
    38aa:	8c 01 00    	nop       
    38ac:	9c 01 00    	nop       
    38ae:	9c 01 00    	nop       
    38b0:	ad 01 00    	nop       
    38b2:	ac 01 00    	nop       
    38b4:	bc 01 00    	nop       
    38b6:	bc 01 00    	nop       
    38b8:	cf 01 00    	nop       
    38ba:	d0 00 00    	nop       
    38bc:	e1 00 00    	nop       
    38be:	e1 00 00    	nop       
    38c0:	f1 00 00    	nop       
    38c2:	f0 00 00    	nop       
    38c4:	0f 03 00    	nop       
    38c6:	0f 03 00    	nop       
    38c8:	1f 01 00    	nop       
    38ca:	1c 01 00    	nop       
    38cc:	2d 01 00    	nop       
    38ce:	2d 01 00    	nop       
    38d0:	3d 01 00    	nop       
    38d2:	3c 01 00    	nop       
    38d4:	4f 01 00    	nop       
    38d6:	4f 01 00    	nop       
    38d8:	5f 01 00    	nop       
    38da:	58 05 00    	nop       
    38dc:	69 05 00    	nop       
    38de:	69 05 00    	nop       
    38e0:	79 05 00    	nop       
    38e2:	78 05 00    	nop       
    38e4:	8f 01 00    	nop       
    38e6:	8f 01 00    	nop       
    38e8:	9f 01 00    	nop       
    38ea:	9c 01 00    	nop       
    38ec:	ad 01 00    	nop       
    38ee:	ad 01 00    	nop       
    38f0:	bd 01 00    	nop       
    38f2:	bc 01 00    	nop       
    38f4:	cf 01 00    	nop       
    38f6:	cf 01 00    	nop       
    38f8:	df 01 00    	nop       
    38fa:	e0 00 00    	nop       
    38fc:	f0 00 00    	nop       
    38fe:	f0 00 00    	nop       
    3900:	0f 03 00    	nop       
    3902:	0e 03 00    	nop       
    3904:	1e 01 00    	nop       
    3906:	1e 01 00    	nop       
    3908:	2f 01 00    	nop       
    390a:	2c 01 00    	nop       
    390c:	3c 01 00    	nop       
    390e:	3c 01 00    	nop       
    3910:	4f 01 00    	nop       
    3912:	4e 01 00    	nop       
    3914:	5e 01 00    	nop       
    3916:	5e 01 00    	nop       
    3918:	6f 01 00    	nop       
    391a:	68 05 00    	nop       
    391c:	78 05 00    	nop       
    391e:	78 05 00    	nop       
    3920:	8f 01 00    	nop       
    3922:	8e 01 00    	nop       
    3924:	9e 01 00    	nop       
    3926:	9e 01 00    	nop       
    3928:	af 01 00    	nop       
    392a:	ac 01 00    	nop       
    392c:	bc 01 00    	nop       
    392e:	bc 01 00    	nop       
    3930:	cf 01 00    	nop       
    3932:	ce 01 00    	nop       
    3934:	de 01 00    	nop       
    3936:	de 01 00    	nop       
    3938:	ef 01 00    	nop       
    393a:	f0 00 00    	nop       
    393c:	0f 03 00    	nop       
    393e:	0f 03 00    	nop       
    3940:	1f 01 00    	nop       
    3942:	1e 01 00    	nop       
    3944:	2f 01 00    	nop       
    3946:	2f 01 00    	nop       
    3948:	3f 01 00    	nop       
    394a:	3c 01 00    	nop       
    394c:	4f 01 00    	nop       
    394e:	4f 01 00    	nop       
    3950:	5f 01 00    	nop       
    3952:	5e 01 00    	nop       
    3954:	6f 01 00    	nop       
    3956:	6f 01 00    	nop       
    3958:	7f 01 00    	nop       
    395a:	78 05 00    	nop       
    395c:	8f 01 00    	nop       
    395e:	8f 01 00    	nop       
    3960:	9f 01 00    	nop       
    3962:	9e 01 00    	nop       
    3964:	af 01 00    	nop       
    3966:	af 01 00    	nop       
    3968:	bf 01 00    	nop       
    396a:	bc 01 00    	nop       
    396c:	cf 01 00    	nop       
    396e:	cf 01 00    	nop       
    3970:	df 01 00    	nop       
    3972:	de 01 00    	nop       
    3974:	ef 01 00    	nop       
    3976:	ef 01 00    	nop       
    3978:	ff 01 00    	nop       

0000397a <serial_disp>:
    397a:	03 09 00    	nop       
    397c:	f5 0c 00    	nop       
    397e:	0a 09 00    	nop       
    3980:	f2 0c 00    	nop       
    3982:	04 09 00    	nop       
    3984:	f0 0c 00    	nop       
    3986:	01 09 00    	nop       
    3988:	f3 0c 00    	nop       
	...
    3992:	10 09 00    	nop       
    3994:	22 09 00    	nop       
    3996:	f8 0d 00    	nop       
    3998:	00 00 00    	nop       
    399a:	fd 00 00    	nop       
    399c:	05 0f 00    	nop       
    399e:	f7 0d 00    	nop       
    39a0:	67 00 00    	nop       
    39a2:	20 08 00    	nop       
    39a4:	f6 0d 00    	nop       
    39a6:	10 08 00    	nop       
    39a8:	02 08 00    	nop       
    39aa:	02 00 00    	nop       
    39ac:	f6 00 00    	nop       
    39ae:	32 00 00    	nop       
    39b0:	32 00 00    	nop       
    39b2:	00 00 00    	nop       
    39b4:	11 01 00    	nop       
    39b6:	22 02 00    	nop       
    39b8:	61 08 00    	nop       
    39ba:	72 08 00    	nop       
    39bc:	80 09 00    	nop       
    39be:	66 01 00    	nop       
    39c0:	77 02 00    	nop       
    39c2:	88 02 00    	nop       
    39c4:	66 01 00    	nop       
    39c6:	77 02 00    	nop       
    39c8:	88 02 00    	nop       
    39ca:	61 01 00    	nop       
    39cc:	72 02 00    	nop       
    39ce:	8f 02 00    	nop       
    39d0:	28 00 00    	nop       
    39d2:	95 09 00    	nop       
    39d4:	03 0e 00    	nop       
    39d6:	c8 09 00    	nop       
    39d8:	49 00 00    	nop       
    39da:	fc 0f 00    	nop       
    39dc:	60 09 00    	nop       
    39de:	70 09 00    	nop       
    39e0:	81 09 00    	nop       
    39e2:	03 0e 00    	nop       
    39e4:	c8 09 00    	nop       
    39e6:	00 0e 00    	nop       
    39e8:	dc 09 00    	nop       
    39ea:	f4 0d 00    	nop       
    39ec:	61 00 00    	nop       
    39ee:	fd 00 00    	nop       
    39f0:	fc 0f 00    	nop       
    39f2:	f8 08 00    	nop       
    39f4:	e7 08 00    	nop       
    39f6:	c6 08 00    	nop       
    39f8:	2f 0c 00    	nop       
    39fa:	2c 00 00    	nop       
    39fc:	3f 0c 00    	nop       
    39fe:	02 09 00    	nop       
    3a00:	60 01 00    	nop       
    3a02:	ff 00 00    	nop       
    3a04:	27 00 00    	nop       
    3a06:	fd 00 00    	nop       
    3a08:	28 00 00    	nop       
    3a0a:	8a 00 00    	nop       
    3a0c:	6e 09 00    	nop       
    3a0e:	7f 09 00    	nop       
    3a10:	14 09 00    	nop       
    3a12:	25 09 00    	nop       
    3a14:	8f 09 00    	nop       
    3a16:	16 0b 00    	nop       
    3a18:	17 0a 00    	nop       
    3a1a:	26 0b 00    	nop       
    3a1c:	27 0a 00    	nop       
    3a1e:	36 00 00    	nop       
    3a20:	37 00 00    	nop       
    3a22:	48 00 00    	nop       
    3a24:	f8 0f 00    	nop       
    3a26:	8a 00 00    	nop       
    3a28:	2f 0d 00    	nop       
    3a2a:	40 0c 00    	nop       
    3a2c:	3f 0d 00    	nop       
    3a2e:	50 0c 00    	nop       
    3a30:	e0 00 00    	nop       
    3a32:	00 80 00    	nop       

00003a34 <display>:
    3a34:	0a 09 00    	nop       
    3a36:	f2 0c 00    	nop       
    3a38:	04 09 00    	nop       
    3a3a:	f0 0c 00    	nop       
    3a3c:	30 09 00    	nop       
    3a3e:	40 09 00    	nop       
    3a40:	55 09 00    	nop       
    3a42:	f5 08 00    	nop       
    3a44:	e4 08 00    	nop       
    3a46:	c3 08 00    	nop       
    3a48:	10 08 00    	nop       
    3a4a:	2c 00 00    	nop       
    3a4c:	20 08 00    	nop       
    3a4e:	01 06 00    	nop       
    3a50:	20 00 00    	nop       
    3a52:	00 0e 00    	nop       
    3a54:	fd 00 00    	nop       
    3a56:	d4 09 00    	nop       
    3a58:	32 00 00    	nop       
    3a5a:	32 00 00    	nop       
    3a5c:	11 01 00    	nop       
    3a5e:	22 02 00    	nop       
    3a60:	61 08 00    	nop       
    3a62:	72 08 00    	nop       
    3a64:	80 09 00    	nop       
    3a66:	66 01 00    	nop       
    3a68:	77 02 00    	nop       
    3a6a:	88 02 00    	nop       
    3a6c:	66 01 00    	nop       
    3a6e:	77 02 00    	nop       
    3a70:	88 02 00    	nop       
    3a72:	61 01 00    	nop       
    3a74:	72 02 00    	nop       
    3a76:	8f 02 00    	nop       
    3a78:	01 09 00    	nop       
    3a7a:	80 01 00    	nop       
    3a7c:	95 09 00    	nop       
    3a7e:	03 0e 00    	nop       
    3a80:	c6 09 00    	nop       
    3a82:	49 00 00    	nop       
    3a84:	fc 0f 00    	nop       
    3a86:	60 09 00    	nop       
    3a88:	70 09 00    	nop       
    3a8a:	81 09 00    	nop       
    3a8c:	03 0e 00    	nop       
    3a8e:	c6 09 00    	nop       
    3a90:	23 00 00    	nop       
    3a92:	23 00 00    	nop       
    3a94:	ff 00 00    	nop       
    3a96:	24 00 00    	nop       
    3a98:	fd 00 00    	nop       
    3a9a:	25 00 00    	nop       
    3a9c:	00 0e 00    	nop       
    3a9e:	d7 09 00    	nop       
    3aa0:	f4 0d 00    	nop       
    3aa2:	61 00 00    	nop       
    3aa4:	fd 00 00    	nop       
    3aa6:	fc 0f 00    	nop       
    3aa8:	f8 08 00    	nop       
    3aaa:	e7 08 00    	nop       
    3aac:	c6 08 00    	nop       
    3aae:	2f 0c 00    	nop       
    3ab0:	2c 00 00    	nop       
    3ab2:	3f 0c 00    	nop       
    3ab4:	02 09 00    	nop       
    3ab6:	60 01 00    	nop       
    3ab8:	ff 00 00    	nop       
    3aba:	27 00 00    	nop       
    3abc:	fd 00 00    	nop       
    3abe:	28 00 00    	nop       
    3ac0:	80 00 00    	nop       
    3ac2:	6e 09 00    	nop       
    3ac4:	7f 09 00    	nop       
    3ac6:	14 09 00    	nop       
    3ac8:	25 09 00    	nop       
    3aca:	8f 09 00    	nop       
    3acc:	16 0b 00    	nop       
    3ace:	17 0a 00    	nop       
    3ad0:	26 0b 00    	nop       
    3ad2:	27 0a 00    	nop       
    3ad4:	36 00 00    	nop       
    3ad6:	37 00 00    	nop       
    3ad8:	48 00 00    	nop       
    3ada:	f8 0f 00    	nop       
    3adc:	80 00 00    	nop       
    3ade:	2f 0d 00    	nop       
    3ae0:	40 0c 00    	nop       
    3ae2:	3f 0d 00    	nop       
    3ae4:	50 0c 00    	nop       
    3ae6:	e0 00 00    	nop       
    3ae8:	00 80 00    	nop       

00003aea <chargen>:
    3aea:	e0 00 00    	nop       
    3aec:	e0 00 00    	nop       
    3aee:	e0 00 00    	nop       
    3af0:	e0 00 00    	nop       
    3af2:	e0 00 00    	nop       
    3af4:	e0 00 00    	nop       
    3af6:	e0 00 00    	nop       
    3af8:	e0 00 00    	nop       
    3afa:	e0 00 00    	nop       
    3afc:	e0 00 00    	nop       
    3afe:	e0 00 00    	nop       
    3b00:	e0 00 00    	nop       
    3b02:	e0 00 00    	nop       
    3b04:	e0 00 00    	nop       
    3b06:	ea 00 00    	nop       
    3b08:	ef 00 00    	nop       
    3b0a:	e0 00 00    	nop       
    3b0c:	e0 00 00    	nop       
    3b0e:	e0 00 00    	nop       
    3b10:	e0 00 00    	nop       
    3b12:	e0 00 00    	nop       
    3b14:	e0 00 00    	nop       
    3b16:	e0 00 00    	nop       
    3b18:	ec 00 00    	nop       
    3b1a:	e0 00 00    	nop       
    3b1c:	e0 00 00    	nop       
    3b1e:	e0 00 00    	nop       
    3b20:	ec 00 00    	nop       
    3b22:	e0 00 00    	nop       
    3b24:	e0 00 00    	nop       
    3b26:	e8 00 00    	nop       
    3b28:	e2 00 00    	nop       
    3b2a:	ee 00 00    	nop       
    3b2c:	ef 00 00    	nop       
    3b2e:	e8 00 00    	nop       
    3b30:	e2 00 00    	nop       
    3b32:	ee 00 00    	nop       
    3b34:	ef 00 00    	nop       
    3b36:	e8 00 00    	nop       
    3b38:	e2 00 00    	nop       
    3b3a:	e4 00 00    	nop       
    3b3c:	e2 00 00    	nop       
    3b3e:	e4 00 00    	nop       
    3b40:	e5 00 00    	nop       
    3b42:	ee 00 00    	nop       
    3b44:	ef 00 00    	nop       
    3b46:	e4 00 00    	nop       
    3b48:	e5 00 00    	nop       
    3b4a:	e8 00 00    	nop       
    3b4c:	e4 00 00    	nop       
    3b4e:	e6 00 00    	nop       
    3b50:	e4 00 00    	nop       
    3b52:	e6 00 00    	nop       
    3b54:	e2 00 00    	nop       
    3b56:	e0 00 00    	nop       
    3b58:	e1 00 00    	nop       
    3b5a:	e8 00 00    	nop       
    3b5c:	ec 00 00    	nop       
    3b5e:	e4 00 00    	nop       
    3b60:	ec 00 00    	nop       
    3b62:	ec 00 00    	nop       
    3b64:	e6 00 00    	nop       
    3b66:	e2 00 00    	nop       
    3b68:	e9 00 00    	nop       
    3b6a:	ea 00 00    	nop       
    3b6c:	e6 00 00    	nop       
    3b6e:	ec 00 00    	nop       
    3b70:	e0 00 00    	nop       
    3b72:	e2 00 00    	nop       
    3b74:	e1 00 00    	nop       
    3b76:	e0 00 00    	nop       
    3b78:	e0 00 00    	nop       
    3b7a:	e0 00 00    	nop       
    3b7c:	e1 00 00    	nop       
    3b7e:	e0 00 00    	nop       
    3b80:	e6 00 00    	nop       
    3b82:	e0 00 00    	nop       
    3b84:	e0 00 00    	nop       
    3b86:	e0 00 00    	nop       
    3b88:	e0 00 00    	nop       
    3b8a:	e0 00 00    	nop       
    3b8c:	e0 00 00    	nop       
    3b8e:	e8 00 00    	nop       
    3b90:	e3 00 00    	nop       
    3b92:	e4 00 00    	nop       
    3b94:	e4 00 00    	nop       
    3b96:	e2 00 00    	nop       
    3b98:	e8 00 00    	nop       
    3b9a:	e0 00 00    	nop       
    3b9c:	e0 00 00    	nop       
    3b9e:	e0 00 00    	nop       
    3ba0:	e0 00 00    	nop       
    3ba2:	e2 00 00    	nop       
    3ba4:	e8 00 00    	nop       
    3ba6:	e4 00 00    	nop       
    3ba8:	e4 00 00    	nop       
    3baa:	e8 00 00    	nop       
    3bac:	e3 00 00    	nop       
    3bae:	e0 00 00    	nop       
    3bb0:	e0 00 00    	nop       
    3bb2:	e4 00 00    	nop       
    3bb4:	e4 00 00    	nop       
    3bb6:	e8 00 00    	nop       
    3bb8:	e2 00 00    	nop       
    3bba:	ee 00 00    	nop       
    3bbc:	ef 00 00    	nop       
    3bbe:	e8 00 00    	nop       
    3bc0:	e2 00 00    	nop       
    3bc2:	e4 00 00    	nop       
    3bc4:	e4 00 00    	nop       
    3bc6:	e0 00 00    	nop       
    3bc8:	e1 00 00    	nop       
    3bca:	e0 00 00    	nop       
    3bcc:	e1 00 00    	nop       
    3bce:	ec 00 00    	nop       
    3bd0:	e7 00 00    	nop       
    3bd2:	e0 00 00    	nop       
    3bd4:	e1 00 00    	nop       
    3bd6:	e0 00 00    	nop       
    3bd8:	e1 00 00    	nop       
    3bda:	e0 00 00    	nop       
    3bdc:	e0 00 00    	nop       
    3bde:	e1 00 00    	nop       
    3be0:	e0 00 00    	nop       
    3be2:	e6 00 00    	nop       
    3be4:	e0 00 00    	nop       
    3be6:	e0 00 00    	nop       
    3be8:	e0 00 00    	nop       
    3bea:	e0 00 00    	nop       
    3bec:	e0 00 00    	nop       
    3bee:	e0 00 00    	nop       
    3bf0:	e1 00 00    	nop       
    3bf2:	e0 00 00    	nop       
    3bf4:	e1 00 00    	nop       
    3bf6:	e0 00 00    	nop       
    3bf8:	e1 00 00    	nop       
    3bfa:	e0 00 00    	nop       
    3bfc:	e1 00 00    	nop       
    3bfe:	e0 00 00    	nop       
    3c00:	e1 00 00    	nop       
    3c02:	e0 00 00    	nop       
    3c04:	e0 00 00    	nop       
    3c06:	e0 00 00    	nop       
    3c08:	e0 00 00    	nop       
    3c0a:	e6 00 00    	nop       
    3c0c:	e0 00 00    	nop       
    3c0e:	e0 00 00    	nop       
    3c10:	e0 00 00    	nop       
    3c12:	e0 00 00    	nop       
    3c14:	e0 00 00    	nop       
    3c16:	e0 00 00    	nop       
    3c18:	e4 00 00    	nop       
    3c1a:	e0 00 00    	nop       
    3c1c:	e2 00 00    	nop       
    3c1e:	e0 00 00    	nop       
    3c20:	e1 00 00    	nop       
    3c22:	e8 00 00    	nop       
    3c24:	e0 00 00    	nop       
    3c26:	e4 00 00    	nop       
    3c28:	e0 00 00    	nop       
    3c2a:	ec 00 00    	nop       
    3c2c:	e7 00 00    	nop       
    3c2e:	ea 00 00    	nop       
    3c30:	e8 00 00    	nop       
    3c32:	e2 00 00    	nop       
    3c34:	e9 00 00    	nop       
    3c36:	e2 00 00    	nop       
    3c38:	ea 00 00    	nop       
    3c3a:	ec 00 00    	nop       
    3c3c:	e7 00 00    	nop       
    3c3e:	e0 00 00    	nop       
    3c40:	e0 00 00    	nop       
    3c42:	e2 00 00    	nop       
    3c44:	e4 00 00    	nop       
    3c46:	ee 00 00    	nop       
    3c48:	ef 00 00    	nop       
    3c4a:	e2 00 00    	nop       
    3c4c:	e0 00 00    	nop       
    3c4e:	e0 00 00    	nop       
    3c50:	e0 00 00    	nop       
    3c52:	e2 00 00    	nop       
    3c54:	e4 00 00    	nop       
    3c56:	e6 00 00    	nop       
    3c58:	e8 00 00    	nop       
    3c5a:	ea 00 00    	nop       
    3c5c:	e8 00 00    	nop       
    3c5e:	e2 00 00    	nop       
    3c60:	e9 00 00    	nop       
    3c62:	e2 00 00    	nop       
    3c64:	e6 00 00    	nop       
    3c66:	e4 00 00    	nop       
    3c68:	e4 00 00    	nop       
    3c6a:	e2 00 00    	nop       
    3c6c:	e8 00 00    	nop       
    3c6e:	e2 00 00    	nop       
    3c70:	e9 00 00    	nop       
    3c72:	e2 00 00    	nop       
    3c74:	e9 00 00    	nop       
    3c76:	ec 00 00    	nop       
    3c78:	e6 00 00    	nop       
    3c7a:	e8 00 00    	nop       
    3c7c:	e3 00 00    	nop       
    3c7e:	e8 00 00    	nop       
    3c80:	e4 00 00    	nop       
    3c82:	e8 00 00    	nop       
    3c84:	e8 00 00    	nop       
    3c86:	ee 00 00    	nop       
    3c88:	e1 00 00    	nop       
    3c8a:	e8 00 00    	nop       
    3c8c:	e0 00 00    	nop       
    3c8e:	e2 00 00    	nop       
    3c90:	ef 00 00    	nop       
    3c92:	e2 00 00    	nop       
    3c94:	e9 00 00    	nop       
    3c96:	e2 00 00    	nop       
    3c98:	e9 00 00    	nop       
    3c9a:	e2 00 00    	nop       
    3c9c:	e9 00 00    	nop       
    3c9e:	ec 00 00    	nop       
    3ca0:	e8 00 00    	nop       
    3ca2:	ec 00 00    	nop       
    3ca4:	e3 00 00    	nop       
    3ca6:	e2 00 00    	nop       
    3ca8:	e5 00 00    	nop       
    3caa:	e2 00 00    	nop       
    3cac:	e9 00 00    	nop       
    3cae:	e2 00 00    	nop       
    3cb0:	e9 00 00    	nop       
    3cb2:	ec 00 00    	nop       
    3cb4:	e0 00 00    	nop       
    3cb6:	e6 00 00    	nop       
    3cb8:	e8 00 00    	nop       
    3cba:	e8 00 00    	nop       
    3cbc:	e8 00 00    	nop       
    3cbe:	e0 00 00    	nop       
    3cc0:	e9 00 00    	nop       
    3cc2:	e0 00 00    	nop       
    3cc4:	ea 00 00    	nop       
    3cc6:	e0 00 00    	nop       
    3cc8:	ec 00 00    	nop       
    3cca:	ec 00 00    	nop       
    3ccc:	e6 00 00    	nop       
    3cce:	e2 00 00    	nop       
    3cd0:	e9 00 00    	nop       
    3cd2:	e2 00 00    	nop       
    3cd4:	e9 00 00    	nop       
    3cd6:	e2 00 00    	nop       
    3cd8:	e9 00 00    	nop       
    3cda:	ec 00 00    	nop       
    3cdc:	e6 00 00    	nop       
    3cde:	e0 00 00    	nop       
    3ce0:	e6 00 00    	nop       
    3ce2:	e2 00 00    	nop       
    3ce4:	e9 00 00    	nop       
    3ce6:	e2 00 00    	nop       
    3ce8:	e9 00 00    	nop       
    3cea:	e4 00 00    	nop       
    3cec:	e9 00 00    	nop       
    3cee:	e8 00 00    	nop       
    3cf0:	e7 00 00    	nop       
    3cf2:	e0 00 00    	nop       
    3cf4:	e0 00 00    	nop       
    3cf6:	e0 00 00    	nop       
    3cf8:	e0 00 00    	nop       
    3cfa:	e6 00 00    	nop       
    3cfc:	e6 00 00    	nop       
    3cfe:	e0 00 00    	nop       
    3d00:	e0 00 00    	nop       
    3d02:	e0 00 00    	nop       
    3d04:	e0 00 00    	nop       
    3d06:	e0 00 00    	nop       
    3d08:	e0 00 00    	nop       
    3d0a:	e1 00 00    	nop       
    3d0c:	e0 00 00    	nop       
    3d0e:	e6 00 00    	nop       
    3d10:	e6 00 00    	nop       
    3d12:	e0 00 00    	nop       
    3d14:	e0 00 00    	nop       
    3d16:	e0 00 00    	nop       
    3d18:	e0 00 00    	nop       
    3d1a:	e0 00 00    	nop       
    3d1c:	e1 00 00    	nop       
    3d1e:	e8 00 00    	nop       
    3d20:	e2 00 00    	nop       
    3d22:	e4 00 00    	nop       
    3d24:	e4 00 00    	nop       
    3d26:	e2 00 00    	nop       
    3d28:	e8 00 00    	nop       
    3d2a:	e0 00 00    	nop       
    3d2c:	e0 00 00    	nop       
    3d2e:	e8 00 00    	nop       
    3d30:	e2 00 00    	nop       
    3d32:	e8 00 00    	nop       
    3d34:	e2 00 00    	nop       
    3d36:	e8 00 00    	nop       
    3d38:	e2 00 00    	nop       
    3d3a:	e8 00 00    	nop       
    3d3c:	e2 00 00    	nop       
    3d3e:	e8 00 00    	nop       
    3d40:	e2 00 00    	nop       
    3d42:	e0 00 00    	nop       
    3d44:	e0 00 00    	nop       
    3d46:	e2 00 00    	nop       
    3d48:	e8 00 00    	nop       
    3d4a:	e4 00 00    	nop       
    3d4c:	e4 00 00    	nop       
    3d4e:	e8 00 00    	nop       
    3d50:	e2 00 00    	nop       
    3d52:	e0 00 00    	nop       
    3d54:	e1 00 00    	nop       
    3d56:	e0 00 00    	nop       
    3d58:	e4 00 00    	nop       
    3d5a:	e0 00 00    	nop       
    3d5c:	e8 00 00    	nop       
    3d5e:	ea 00 00    	nop       
    3d60:	e8 00 00    	nop       
    3d62:	e0 00 00    	nop       
    3d64:	e9 00 00    	nop       
    3d66:	e0 00 00    	nop       
    3d68:	e6 00 00    	nop       
    3d6a:	ec 00 00    	nop       
    3d6c:	e7 00 00    	nop       
    3d6e:	e2 00 00    	nop       
    3d70:	e9 00 00    	nop       
    3d72:	ea 00 00    	nop       
    3d74:	ea 00 00    	nop       
    3d76:	ea 00 00    	nop       
    3d78:	ea 00 00    	nop       
    3d7a:	e2 00 00    	nop       
    3d7c:	e7 00 00    	nop       
    3d7e:	ee 00 00    	nop       
    3d80:	e3 00 00    	nop       
    3d82:	e8 00 00    	nop       
    3d84:	e4 00 00    	nop       
    3d86:	e8 00 00    	nop       
    3d88:	e8 00 00    	nop       
    3d8a:	e8 00 00    	nop       
    3d8c:	e4 00 00    	nop       
    3d8e:	ee 00 00    	nop       
    3d90:	e3 00 00    	nop       
    3d92:	ee 00 00    	nop       
    3d94:	ef 00 00    	nop       
    3d96:	e2 00 00    	nop       
    3d98:	e9 00 00    	nop       
    3d9a:	e2 00 00    	nop       
    3d9c:	e9 00 00    	nop       
    3d9e:	e2 00 00    	nop       
    3da0:	e9 00 00    	nop       
    3da2:	ec 00 00    	nop       
    3da4:	e6 00 00    	nop       
    3da6:	ec 00 00    	nop       
    3da8:	e7 00 00    	nop       
    3daa:	e2 00 00    	nop       
    3dac:	e8 00 00    	nop       
    3dae:	e2 00 00    	nop       
    3db0:	e8 00 00    	nop       
    3db2:	e2 00 00    	nop       
    3db4:	e8 00 00    	nop       
    3db6:	e4 00 00    	nop       
    3db8:	e4 00 00    	nop       
    3dba:	ee 00 00    	nop       
    3dbc:	ef 00 00    	nop       
    3dbe:	e2 00 00    	nop       
    3dc0:	e8 00 00    	nop       
    3dc2:	e2 00 00    	nop       
    3dc4:	e8 00 00    	nop       
    3dc6:	e4 00 00    	nop       
    3dc8:	e4 00 00    	nop       
    3dca:	e8 00 00    	nop       
    3dcc:	e3 00 00    	nop       
    3dce:	ee 00 00    	nop       
    3dd0:	ef 00 00    	nop       
    3dd2:	e2 00 00    	nop       
    3dd4:	e9 00 00    	nop       
    3dd6:	e2 00 00    	nop       
    3dd8:	e9 00 00    	nop       
    3dda:	e2 00 00    	nop       
    3ddc:	e9 00 00    	nop       
    3dde:	e2 00 00    	nop       
    3de0:	e8 00 00    	nop       
    3de2:	ef 00 00    	nop       
    3de4:	ef 00 00    	nop       
    3de6:	e0 00 00    	nop       
    3de8:	e9 00 00    	nop       
    3dea:	e0 00 00    	nop       
    3dec:	e9 00 00    	nop       
    3dee:	e0 00 00    	nop       
    3df0:	e9 00 00    	nop       
    3df2:	e0 00 00    	nop       
    3df4:	e8 00 00    	nop       
    3df6:	ec 00 00    	nop       
    3df8:	e7 00 00    	nop       
    3dfa:	e2 00 00    	nop       
    3dfc:	e8 00 00    	nop       
    3dfe:	e2 00 00    	nop       
    3e00:	e9 00 00    	nop       
    3e02:	e2 00 00    	nop       
    3e04:	e9 00 00    	nop       
    3e06:	ee 00 00    	nop       
    3e08:	e9 00 00    	nop       
    3e0a:	ee 00 00    	nop       
    3e0c:	ef 00 00    	nop       
    3e0e:	e0 00 00    	nop       
    3e10:	e1 00 00    	nop       
    3e12:	e0 00 00    	nop       
    3e14:	e1 00 00    	nop       
    3e16:	e0 00 00    	nop       
    3e18:	e1 00 00    	nop       
    3e1a:	ee 00 00    	nop       
    3e1c:	ef 00 00    	nop       
    3e1e:	e0 00 00    	nop       
    3e20:	e0 00 00    	nop       
    3e22:	e2 00 00    	nop       
    3e24:	e8 00 00    	nop       
    3e26:	ee 00 00    	nop       
    3e28:	ef 00 00    	nop       
    3e2a:	e2 00 00    	nop       
    3e2c:	e8 00 00    	nop       
    3e2e:	e0 00 00    	nop       
    3e30:	e0 00 00    	nop       
    3e32:	e4 00 00    	nop       
    3e34:	e8 00 00    	nop       
    3e36:	e2 00 00    	nop       
    3e38:	e8 00 00    	nop       
    3e3a:	e2 00 00    	nop       
    3e3c:	e8 00 00    	nop       
    3e3e:	e2 00 00    	nop       
    3e40:	e8 00 00    	nop       
    3e42:	ec 00 00    	nop       
    3e44:	ef 00 00    	nop       
    3e46:	ee 00 00    	nop       
    3e48:	ef 00 00    	nop       
    3e4a:	e0 00 00    	nop       
    3e4c:	e1 00 00    	nop       
    3e4e:	e8 00 00    	nop       
    3e50:	e2 00 00    	nop       
    3e52:	e4 00 00    	nop       
    3e54:	e4 00 00    	nop       
    3e56:	e2 00 00    	nop       
    3e58:	e8 00 00    	nop       
    3e5a:	ee 00 00    	nop       
    3e5c:	ef 00 00    	nop       
    3e5e:	e2 00 00    	nop       
    3e60:	e0 00 00    	nop       
    3e62:	e2 00 00    	nop       
    3e64:	e0 00 00    	nop       
    3e66:	e2 00 00    	nop       
    3e68:	e0 00 00    	nop       
    3e6a:	e2 00 00    	nop       
    3e6c:	e0 00 00    	nop       
    3e6e:	ee 00 00    	nop       
    3e70:	ef 00 00    	nop       
    3e72:	e0 00 00    	nop       
    3e74:	e4 00 00    	nop       
    3e76:	e0 00 00    	nop       
    3e78:	e2 00 00    	nop       
    3e7a:	e0 00 00    	nop       
    3e7c:	e4 00 00    	nop       
    3e7e:	ee 00 00    	nop       
    3e80:	ef 00 00    	nop       
    3e82:	ee 00 00    	nop       
    3e84:	ef 00 00    	nop       
    3e86:	e0 00 00    	nop       
    3e88:	e1 00 00    	nop       
    3e8a:	e8 00 00    	nop       
    3e8c:	e0 00 00    	nop       
    3e8e:	e4 00 00    	nop       
    3e90:	e0 00 00    	nop       
    3e92:	ee 00 00    	nop       
    3e94:	ef 00 00    	nop       
    3e96:	ec 00 00    	nop       
    3e98:	e7 00 00    	nop       
    3e9a:	e2 00 00    	nop       
    3e9c:	e8 00 00    	nop       
    3e9e:	e2 00 00    	nop       
    3ea0:	e8 00 00    	nop       
    3ea2:	e2 00 00    	nop       
    3ea4:	e8 00 00    	nop       
    3ea6:	ec 00 00    	nop       
    3ea8:	e7 00 00    	nop       
    3eaa:	ee 00 00    	nop       
    3eac:	ef 00 00    	nop       
    3eae:	e0 00 00    	nop       
    3eb0:	e9 00 00    	nop       
    3eb2:	e0 00 00    	nop       
    3eb4:	e9 00 00    	nop       
    3eb6:	e0 00 00    	nop       
    3eb8:	e9 00 00    	nop       
    3eba:	e0 00 00    	nop       
    3ebc:	e6 00 00    	nop       
    3ebe:	ec 00 00    	nop       
    3ec0:	e7 00 00    	nop       
    3ec2:	e2 00 00    	nop       
    3ec4:	e8 00 00    	nop       
    3ec6:	ea 00 00    	nop       
    3ec8:	e8 00 00    	nop       
    3eca:	e4 00 00    	nop       
    3ecc:	e8 00 00    	nop       
    3ece:	ea 00 00    	nop       
    3ed0:	e7 00 00    	nop       
    3ed2:	ee 00 00    	nop       
    3ed4:	ef 00 00    	nop       
    3ed6:	e0 00 00    	nop       
    3ed8:	e9 00 00    	nop       
    3eda:	e8 00 00    	nop       
    3edc:	e9 00 00    	nop       
    3ede:	e4 00 00    	nop       
    3ee0:	e9 00 00    	nop       
    3ee2:	e2 00 00    	nop       
    3ee4:	e6 00 00    	nop       
    3ee6:	e4 00 00    	nop       
    3ee8:	e6 00 00    	nop       
    3eea:	e2 00 00    	nop       
    3eec:	e9 00 00    	nop       
    3eee:	e2 00 00    	nop       
    3ef0:	e9 00 00    	nop       
    3ef2:	e2 00 00    	nop       
    3ef4:	e9 00 00    	nop       
    3ef6:	ec 00 00    	nop       
    3ef8:	e4 00 00    	nop       
    3efa:	e0 00 00    	nop       
    3efc:	e8 00 00    	nop       
    3efe:	e0 00 00    	nop       
    3f00:	e8 00 00    	nop       
    3f02:	ee 00 00    	nop       
    3f04:	ef 00 00    	nop       
    3f06:	e0 00 00    	nop       
    3f08:	e8 00 00    	nop       
    3f0a:	e0 00 00    	nop       
    3f0c:	e8 00 00    	nop       
    3f0e:	ec 00 00    	nop       
    3f10:	ef 00 00    	nop       
    3f12:	e2 00 00    	nop       
    3f14:	e0 00 00    	nop       
    3f16:	e2 00 00    	nop       
    3f18:	e0 00 00    	nop       
    3f1a:	e2 00 00    	nop       
    3f1c:	e0 00 00    	nop       
    3f1e:	ec 00 00    	nop       
    3f20:	ef 00 00    	nop       
    3f22:	e8 00 00    	nop       
    3f24:	ef 00 00    	nop       
    3f26:	e4 00 00    	nop       
    3f28:	e0 00 00    	nop       
    3f2a:	e2 00 00    	nop       
    3f2c:	e0 00 00    	nop       
    3f2e:	e4 00 00    	nop       
    3f30:	e0 00 00    	nop       
    3f32:	e8 00 00    	nop       
    3f34:	ef 00 00    	nop       
    3f36:	ee 00 00    	nop       
    3f38:	ef 00 00    	nop       
    3f3a:	e4 00 00    	nop       
    3f3c:	e0 00 00    	nop       
    3f3e:	e8 00 00    	nop       
    3f40:	e0 00 00    	nop       
    3f42:	e4 00 00    	nop       
    3f44:	e0 00 00    	nop       
    3f46:	ee 00 00    	nop       
    3f48:	ef 00 00    	nop       
    3f4a:	e6 00 00    	nop       
    3f4c:	ec 00 00    	nop       
    3f4e:	e8 00 00    	nop       
    3f50:	e2 00 00    	nop       
    3f52:	e0 00 00    	nop       
    3f54:	e1 00 00    	nop       
    3f56:	e8 00 00    	nop       
    3f58:	e2 00 00    	nop       
    3f5a:	e6 00 00    	nop       
    3f5c:	ec 00 00    	nop       
    3f5e:	e0 00 00    	nop       
    3f60:	ee 00 00    	nop       
    3f62:	e0 00 00    	nop       
    3f64:	e1 00 00    	nop       
    3f66:	ee 00 00    	nop       
    3f68:	e0 00 00    	nop       
    3f6a:	e0 00 00    	nop       
    3f6c:	e1 00 00    	nop       
    3f6e:	e0 00 00    	nop       
    3f70:	ee 00 00    	nop       
    3f72:	e6 00 00    	nop       
    3f74:	e8 00 00    	nop       
    3f76:	ea 00 00    	nop       
    3f78:	e8 00 00    	nop       
    3f7a:	e2 00 00    	nop       
    3f7c:	e9 00 00    	nop       
    3f7e:	e2 00 00    	nop       
    3f80:	ea 00 00    	nop       
    3f82:	e2 00 00    	nop       
    3f84:	ec 00 00    	nop       
    3f86:	e0 00 00    	nop       
    3f88:	e0 00 00    	nop       
    3f8a:	e2 00 00    	nop       
    3f8c:	e8 00 00    	nop       
    3f8e:	ee 00 00    	nop       
    3f90:	ef 00 00    	nop       
    3f92:	e0 00 00    	nop       
    3f94:	e0 00 00    	nop       
    3f96:	e0 00 00    	nop       
    3f98:	e0 00 00    	nop       
    3f9a:	e0 00 00    	nop       
    3f9c:	e4 00 00    	nop       
    3f9e:	e0 00 00    	nop       
    3fa0:	e2 00 00    	nop       
    3fa2:	e0 00 00    	nop       
    3fa4:	e1 00 00    	nop       
    3fa6:	e8 00 00    	nop       
    3fa8:	e0 00 00    	nop       
    3faa:	e4 00 00    	nop       
    3fac:	e0 00 00    	nop       
    3fae:	e0 00 00    	nop       
    3fb0:	e0 00 00    	nop       
    3fb2:	e0 00 00    	nop       
    3fb4:	e0 00 00    	nop       
    3fb6:	ee 00 00    	nop       
    3fb8:	ef 00 00    	nop       
    3fba:	e2 00 00    	nop       
    3fbc:	e8 00 00    	nop       
    3fbe:	e0 00 00    	nop       
    3fc0:	e0 00 00    	nop       
    3fc2:	e0 00 00    	nop       
    3fc4:	e2 00 00    	nop       
    3fc6:	e0 00 00    	nop       
    3fc8:	e4 00 00    	nop       
    3fca:	e0 00 00    	nop       
    3fcc:	e8 00 00    	nop       
    3fce:	e0 00 00    	nop       
    3fd0:	e4 00 00    	nop       
    3fd2:	e0 00 00    	nop       
    3fd4:	e2 00 00    	nop       
    3fd6:	e1 00 00    	nop       
    3fd8:	e0 00 00    	nop       
    3fda:	e1 00 00    	nop       
    3fdc:	e0 00 00    	nop       
    3fde:	e1 00 00    	nop       
    3fe0:	e0 00 00    	nop       
    3fe2:	e1 00 00    	nop       
    3fe4:	e0 00 00    	nop       
    3fe6:	e1 00 00    	nop       
    3fe8:	e0 00 00    	nop       
    3fea:	e0 00 00    	nop       
    3fec:	e0 00 00    	nop       
    3fee:	e0 00 00    	nop       
    3ff0:	e8 00 00    	nop       
    3ff2:	e0 00 00    	nop       
    3ff4:	e4 00 00    	nop       
    3ff6:	e0 00 00    	nop       
    3ff8:	e2 00 00    	nop       
    3ffa:	e0 00 00    	nop       
    3ffc:	e0 00 00    	nop       
    3ffe:	e4 00 00    	nop       
    4000:	e0 00 00    	nop       
    4002:	ea 00 00    	nop       
    4004:	e2 00 00    	nop       
    4006:	ea 00 00    	nop       
    4008:	e2 00 00    	nop       
    400a:	ea 00 00    	nop       
    400c:	e2 00 00    	nop       
    400e:	ee 00 00    	nop       
    4010:	e1 00 00    	nop       
    4012:	ee 00 00    	nop       
    4014:	ef 00 00    	nop       
    4016:	e2 00 00    	nop       
    4018:	e1 00 00    	nop       
    401a:	e2 00 00    	nop       
    401c:	e2 00 00    	nop       
    401e:	e2 00 00    	nop       
    4020:	e2 00 00    	nop       
    4022:	ec 00 00    	nop       
    4024:	e1 00 00    	nop       
    4026:	ec 00 00    	nop       
    4028:	e1 00 00    	nop       
    402a:	e2 00 00    	nop       
    402c:	e2 00 00    	nop       
    402e:	e2 00 00    	nop       
    4030:	e2 00 00    	nop       
    4032:	e2 00 00    	nop       
    4034:	e2 00 00    	nop       
    4036:	e2 00 00    	nop       
    4038:	e2 00 00    	nop       
    403a:	ec 00 00    	nop       
    403c:	e1 00 00    	nop       
    403e:	e2 00 00    	nop       
    4040:	e2 00 00    	nop       
    4042:	e2 00 00    	nop       
    4044:	e2 00 00    	nop       
    4046:	e2 00 00    	nop       
    4048:	e1 00 00    	nop       
    404a:	ee 00 00    	nop       
    404c:	ef 00 00    	nop       
    404e:	ec 00 00    	nop       
    4050:	e1 00 00    	nop       
    4052:	ea 00 00    	nop       
    4054:	e2 00 00    	nop       
    4056:	ea 00 00    	nop       
    4058:	e2 00 00    	nop       
    405a:	ea 00 00    	nop       
    405c:	e2 00 00    	nop       
    405e:	e8 00 00    	nop       
    4060:	e1 00 00    	nop       
    4062:	e0 00 00    	nop       
    4064:	e0 00 00    	nop       
    4066:	e8 00 00    	nop       
    4068:	e0 00 00    	nop       
    406a:	ef 00 00    	nop       
    406c:	e7 00 00    	nop       
    406e:	e8 00 00    	nop       
    4070:	e8 00 00    	nop       
    4072:	e0 00 00    	nop       
    4074:	e4 00 00    	nop       
    4076:	e8 00 00    	nop       
    4078:	e1 00 00    	nop       
    407a:	e5 00 00    	nop       
    407c:	e2 00 00    	nop       
    407e:	e5 00 00    	nop       
    4080:	e2 00 00    	nop       
    4082:	e5 00 00    	nop       
    4084:	e2 00 00    	nop       
    4086:	ee 00 00    	nop       
    4088:	e1 00 00    	nop       
    408a:	ee 00 00    	nop       
    408c:	ef 00 00    	nop       
    408e:	e0 00 00    	nop       
    4090:	e1 00 00    	nop       
    4092:	e0 00 00    	nop       
    4094:	e2 00 00    	nop       
    4096:	e0 00 00    	nop       
    4098:	e2 00 00    	nop       
    409a:	ee 00 00    	nop       
    409c:	e1 00 00    	nop       
    409e:	e0 00 00    	nop       
    40a0:	e0 00 00    	nop       
    40a2:	e2 00 00    	nop       
    40a4:	e2 00 00    	nop       
    40a6:	ee 00 00    	nop       
    40a8:	eb 00 00    	nop       
    40aa:	e2 00 00    	nop       
    40ac:	e0 00 00    	nop       
    40ae:	e0 00 00    	nop       
    40b0:	e0 00 00    	nop       
    40b2:	e0 00 00    	nop       
    40b4:	e0 00 00    	nop       
    40b6:	e1 00 00    	nop       
    40b8:	e0 00 00    	nop       
    40ba:	e1 00 00    	nop       
    40bc:	e0 00 00    	nop       
    40be:	ee 00 00    	nop       
    40c0:	eb 00 00    	nop       
    40c2:	e0 00 00    	nop       
    40c4:	e0 00 00    	nop       
    40c6:	e0 00 00    	nop       
    40c8:	e0 00 00    	nop       
    40ca:	ee 00 00    	nop       
    40cc:	ef 00 00    	nop       
    40ce:	e8 00 00    	nop       
    40d0:	e0 00 00    	nop       
    40d2:	e4 00 00    	nop       
    40d4:	e1 00 00    	nop       
    40d6:	e2 00 00    	nop       
    40d8:	e2 00 00    	nop       
    40da:	e0 00 00    	nop       
    40dc:	e0 00 00    	nop       
    40de:	e2 00 00    	nop       
    40e0:	e8 00 00    	nop       
    40e2:	ee 00 00    	nop       
    40e4:	ef 00 00    	nop       
    40e6:	e2 00 00    	nop       
    40e8:	e0 00 00    	nop       
    40ea:	e0 00 00    	nop       
    40ec:	e0 00 00    	nop       
    40ee:	ee 00 00    	nop       
    40f0:	e3 00 00    	nop       
    40f2:	e0 00 00    	nop       
    40f4:	e2 00 00    	nop       
    40f6:	ee 00 00    	nop       
    40f8:	e1 00 00    	nop       
    40fa:	e0 00 00    	nop       
    40fc:	e2 00 00    	nop       
    40fe:	ee 00 00    	nop       
    4100:	e1 00 00    	nop       
    4102:	ee 00 00    	nop       
    4104:	e3 00 00    	nop       
    4106:	e0 00 00    	nop       
    4108:	e1 00 00    	nop       
    410a:	e0 00 00    	nop       
    410c:	e2 00 00    	nop       
    410e:	e0 00 00    	nop       
    4110:	e2 00 00    	nop       
    4112:	ee 00 00    	nop       
    4114:	e1 00 00    	nop       
    4116:	ec 00 00    	nop       
    4118:	e1 00 00    	nop       
    411a:	e2 00 00    	nop       
    411c:	e2 00 00    	nop       
    411e:	e2 00 00    	nop       
    4120:	e2 00 00    	nop       
    4122:	e2 00 00    	nop       
    4124:	e2 00 00    	nop       
    4126:	ec 00 00    	nop       
    4128:	e1 00 00    	nop       
    412a:	ef 00 00    	nop       
    412c:	e3 00 00    	nop       
    412e:	e4 00 00    	nop       
    4130:	e2 00 00    	nop       
    4132:	e4 00 00    	nop       
    4134:	e2 00 00    	nop       
    4136:	e4 00 00    	nop       
    4138:	e2 00 00    	nop       
    413a:	e8 00 00    	nop       
    413c:	e1 00 00    	nop       
    413e:	e8 00 00    	nop       
    4140:	e1 00 00    	nop       
    4142:	e4 00 00    	nop       
    4144:	e2 00 00    	nop       
    4146:	e4 00 00    	nop       
    4148:	e2 00 00    	nop       
    414a:	e4 00 00    	nop       
    414c:	e2 00 00    	nop       
    414e:	ef 00 00    	nop       
    4150:	e3 00 00    	nop       
    4152:	ee 00 00    	nop       
    4154:	e3 00 00    	nop       
    4156:	e0 00 00    	nop       
    4158:	e1 00 00    	nop       
    415a:	e0 00 00    	nop       
    415c:	e2 00 00    	nop       
    415e:	e0 00 00    	nop       
    4160:	e2 00 00    	nop       
    4162:	e0 00 00    	nop       
    4164:	e1 00 00    	nop       
    4166:	e2 00 00    	nop       
    4168:	e1 00 00    	nop       
    416a:	ea 00 00    	nop       
    416c:	e2 00 00    	nop       
    416e:	ea 00 00    	nop       
    4170:	e2 00 00    	nop       
    4172:	ea 00 00    	nop       
    4174:	e2 00 00    	nop       
    4176:	e4 00 00    	nop       
    4178:	e2 00 00    	nop       
    417a:	e0 00 00    	nop       
    417c:	e2 00 00    	nop       
    417e:	ec 00 00    	nop       
    4180:	ef 00 00    	nop       
    4182:	e2 00 00    	nop       
    4184:	e2 00 00    	nop       
    4186:	e2 00 00    	nop       
    4188:	e0 00 00    	nop       
    418a:	e4 00 00    	nop       
    418c:	e0 00 00    	nop       
    418e:	ec 00 00    	nop       
    4190:	e3 00 00    	nop       
    4192:	e2 00 00    	nop       
    4194:	e0 00 00    	nop       
    4196:	e2 00 00    	nop       
    4198:	e0 00 00    	nop       
    419a:	e4 00 00    	nop       
    419c:	e0 00 00    	nop       
    419e:	ee 00 00    	nop       
    41a0:	e3 00 00    	nop       
    41a2:	e8 00 00    	nop       
    41a4:	e3 00 00    	nop       
    41a6:	e4 00 00    	nop       
    41a8:	e0 00 00    	nop       
    41aa:	e2 00 00    	nop       
    41ac:	e0 00 00    	nop       
    41ae:	e4 00 00    	nop       
    41b0:	e0 00 00    	nop       
    41b2:	e8 00 00    	nop       
    41b4:	e3 00 00    	nop       
    41b6:	ee 00 00    	nop       
    41b8:	e3 00 00    	nop       
    41ba:	e4 00 00    	nop       
    41bc:	e0 00 00    	nop       
    41be:	e8 00 00    	nop       
    41c0:	e0 00 00    	nop       
    41c2:	e4 00 00    	nop       
    41c4:	e0 00 00    	nop       
    41c6:	ee 00 00    	nop       
    41c8:	e3 00 00    	nop       
    41ca:	e2 00 00    	nop       
    41cc:	e2 00 00    	nop       
    41ce:	e4 00 00    	nop       
    41d0:	e1 00 00    	nop       
    41d2:	e8 00 00    	nop       
    41d4:	e0 00 00    	nop       
    41d6:	e4 00 00    	nop       
    41d8:	e1 00 00    	nop       
    41da:	e2 00 00    	nop       
    41dc:	e2 00 00    	nop       
    41de:	e1 00 00    	nop       
    41e0:	e3 00 00    	nop       
    41e2:	e9 00 00    	nop       
    41e4:	e0 00 00    	nop       
    41e6:	e6 00 00    	nop       
    41e8:	e0 00 00    	nop       
    41ea:	e4 00 00    	nop       
    41ec:	e0 00 00    	nop       
    41ee:	e8 00 00    	nop       
    41f0:	e3 00 00    	nop       
    41f2:	e2 00 00    	nop       
    41f4:	e2 00 00    	nop       
    41f6:	e6 00 00    	nop       
    41f8:	e2 00 00    	nop       
    41fa:	ea 00 00    	nop       
    41fc:	e2 00 00    	nop       
    41fe:	e2 00 00    	nop       
    4200:	e3 00 00    	nop       
    4202:	e2 00 00    	nop       
    4204:	e2 00 00    	nop       
    4206:	e0 00 00    	nop       
    4208:	e0 00 00    	nop       
    420a:	e0 00 00    	nop       
    420c:	e1 00 00    	nop       
    420e:	ec 00 00    	nop       
    4210:	e6 00 00    	nop       
    4212:	e2 00 00    	nop       
    4214:	e8 00 00    	nop       
    4216:	e0 00 00    	nop       
    4218:	e0 00 00    	nop       
    421a:	e0 00 00    	nop       
    421c:	e0 00 00    	nop       
    421e:	e0 00 00    	nop       
    4220:	e0 00 00    	nop       
    4222:	ee 00 00    	nop       
    4224:	ef 00 00    	nop       
    4226:	e0 00 00    	nop       
    4228:	e0 00 00    	nop       
    422a:	e0 00 00    	nop       
    422c:	e0 00 00    	nop       
    422e:	e0 00 00    	nop       
    4230:	e0 00 00    	nop       
    4232:	e2 00 00    	nop       
    4234:	e8 00 00    	nop       
    4236:	ec 00 00    	nop       
    4238:	e6 00 00    	nop       
    423a:	e0 00 00    	nop       
    423c:	e1 00 00    	nop       
    423e:	e0 00 00    	nop       
    4240:	e0 00 00    	nop       
    4242:	e0 00 00    	nop       
    4244:	e4 00 00    	nop       
    4246:	e0 00 00    	nop       
    4248:	e8 00 00    	nop       
    424a:	e0 00 00    	nop       
    424c:	e4 00 00    	nop       
    424e:	e0 00 00    	nop       
    4250:	e2 00 00    	nop       
    4252:	e0 00 00    	nop       
    4254:	e4 00 00    	nop       
    4256:	e0 00 00    	nop       
    4258:	e0 00 00    	nop       
    425a:	e0 00 00    	nop       
    425c:	e0 00 00    	nop       
    425e:	e0 00 00    	nop       
    4260:	e0 00 00    	nop       
    4262:	e0 00 00    	nop       
    4264:	e0 00 00    	nop       
    4266:	e0 00 00    	nop       
    4268:	e0 00 00    	nop       
    426a:	00 80 00    	nop       

0000426c <disptext>:
    426c:	48 65 00    	nop       
    426e:	6c 6c 00    	nop       
    4270:	6f 2c 00    	nop       
    4272:	77 6f 00    	nop       
    4274:	72 6c 00    	nop       
    4276:	64 21 00    	nop       
    4278:	20 48 00    	nop       
    427a:	69 2c 00    	nop       
    427c:	6a 65 00    	nop       
    427e:	78 21 00    	nop       
    4280:	3e 3e 00    	nop       
    4282:	3e ff 00    	nop       
    4284:	ff 00 00    	nop       
Disassembly of section .dinit:

00004286 <.dinit>:
    4286:	00 08 00    	nop       
    4288:	e2 01 00    	nop       
    428a:	80 00 00    	nop       
    428c:	00 00 00    	nop       
